var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod3) => function __require2() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target, all2) => {
  for (var name10 in all2)
    __defProp(target, name10, { get: all2[name10], enumerable: true });
};
var __copyProps = (to, from7, except, desc) => {
  if (from7 && typeof from7 === "object" || typeof from7 === "function") {
    for (let key of __getOwnPropNames(from7))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from7[key], enumerable: !(desc = __getOwnPropDesc(from7, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));
var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);

// node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code10.length; i < len; ++i) {
      lookup[i] = code10[i];
      revLookup[code10.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num2) {
      return lookup[num2 >> 18 & 63] + lookup[num2 >> 12 & 63] + lookup[num2 >> 6 & 63] + lookup[num2 & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports2) {
    init_buffer_polyfill();
    exports2.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer2[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer2, value2, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
      value2 = Math.abs(value2);
      if (isNaN(value2) || value2 === Infinity) {
        m = isNaN(value2) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value2) / Math.LN2);
        if (value2 * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value2 += rt / c;
        } else {
          value2 += rt * Math.pow(2, 1 - eBias);
        }
        if (value2 * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value2 * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer2[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var base644 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer5;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer5.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer5.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer5.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer5.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer5.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer5.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length6) {
      if (length6 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length6 + '" is invalid for option "size"');
      }
      const buf2 = new Uint8Array(length6);
      Object.setPrototypeOf(buf2, Buffer5.prototype);
      return buf2;
    }
    function Buffer5(arg, encodingOrOffset, length6) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe3(arg);
      }
      return from7(arg, encodingOrOffset, length6);
    }
    Buffer5.poolSize = 8192;
    function from7(value2, encodingOrOffset, length6) {
      if (typeof value2 === "string") {
        return fromString8(value2, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value2)) {
        return fromArrayView(value2);
      }
      if (value2 == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
        );
      }
      if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value2, encodingOrOffset, length6);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value2, encodingOrOffset, length6);
      }
      if (typeof value2 === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value2.valueOf && value2.valueOf();
      if (valueOf != null && valueOf !== value2) {
        return Buffer5.from(valueOf, encodingOrOffset, length6);
      }
      const b = fromObject(value2);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
        return Buffer5.from(value2[Symbol.toPrimitive]("string"), encodingOrOffset, length6);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
      );
    }
    Buffer5.from = function(value2, encodingOrOffset, length6) {
      return from7(value2, encodingOrOffset, length6);
    };
    Object.setPrototypeOf(Buffer5.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer5, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc2(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer5.alloc = function(size, fill, encoding) {
      return alloc2(size, fill, encoding);
    };
    function allocUnsafe3(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer5.allocUnsafe = function(size) {
      return allocUnsafe3(size);
    };
    Buffer5.allocUnsafeSlow = function(size) {
      return allocUnsafe3(size);
    };
    function fromString8(string5, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer5.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length6 = byteLength(string5, encoding) | 0;
      let buf2 = createBuffer(length6);
      const actual = buf2.write(string5, encoding);
      if (actual !== length6) {
        buf2 = buf2.slice(0, actual);
      }
      return buf2;
    }
    function fromArrayLike(array2) {
      const length6 = array2.length < 0 ? 0 : checked(array2.length) | 0;
      const buf2 = createBuffer(length6);
      for (let i = 0; i < length6; i += 1) {
        buf2[i] = array2[i] & 255;
      }
      return buf2;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array2, byteOffset, length6) {
      if (byteOffset < 0 || array2.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array2.byteLength < byteOffset + (length6 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf2;
      if (byteOffset === void 0 && length6 === void 0) {
        buf2 = new Uint8Array(array2);
      } else if (length6 === void 0) {
        buf2 = new Uint8Array(array2, byteOffset);
      } else {
        buf2 = new Uint8Array(array2, byteOffset, length6);
      }
      Object.setPrototypeOf(buf2, Buffer5.prototype);
      return buf2;
    }
    function fromObject(obj) {
      if (Buffer5.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf2 = createBuffer(len);
        if (buf2.length === 0) {
          return buf2;
        }
        obj.copy(buf2, 0, 0, len);
        return buf2;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length6) {
      if (length6 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length6 | 0;
    }
    function SlowBuffer(length6) {
      if (+length6 != length6) {
        length6 = 0;
      }
      return Buffer5.alloc(+length6);
    }
    Buffer5.isBuffer = function isBuffer3(b) {
      return b != null && b._isBuffer === true && b !== Buffer5.prototype;
    };
    Buffer5.compare = function compare4(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer5.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer5.from(b, b.offset, b.byteLength);
      if (!Buffer5.isBuffer(a) || !Buffer5.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer5.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer5.concat = function concat6(list, length6) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer5.alloc(0);
      }
      let i;
      if (length6 === void 0) {
        length6 = 0;
        for (i = 0; i < list.length; ++i) {
          length6 += list[i].length;
        }
      }
      const buffer2 = Buffer5.allocUnsafe(length6);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf2 = list[i];
        if (isInstance(buf2, Uint8Array)) {
          if (pos + buf2.length > buffer2.length) {
            if (!Buffer5.isBuffer(buf2)) buf2 = Buffer5.from(buf2);
            buf2.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf2,
              pos
            );
          }
        } else if (!Buffer5.isBuffer(buf2)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf2.copy(buffer2, pos);
        }
        pos += buf2.length;
      }
      return buffer2;
    };
    function byteLength(string5, encoding) {
      if (Buffer5.isBuffer(string5)) {
        return string5.length;
      }
      if (ArrayBuffer.isView(string5) || isInstance(string5, ArrayBuffer)) {
        return string5.byteLength;
      }
      if (typeof string5 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string5
        );
      }
      const len = string5.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes3(string5).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string5).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes3(string5).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer5.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice2(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer5.prototype._isBuffer = true;
    function swap(b, n2, m) {
      const i = b[n2];
      b[n2] = b[m];
      b[m] = i;
    }
    Buffer5.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer5.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer5.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer5.prototype.toString = function toString8() {
      const length6 = this.length;
      if (length6 === 0) return "";
      if (arguments.length === 0) return utf8Slice2(this, 0, length6);
      return slowToString.apply(this, arguments);
    };
    Buffer5.prototype.toLocaleString = Buffer5.prototype.toString;
    Buffer5.prototype.equals = function equals9(b) {
      if (!Buffer5.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer5.compare(this, b) === 0;
    };
    Buffer5.prototype.inspect = function inspect4() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer5.prototype[customInspectSymbol] = Buffer5.prototype.inspect;
    }
    Buffer5.prototype.compare = function compare4(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer5.from(target, target.offset, target.byteLength);
      }
      if (!Buffer5.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer5.from(val, encoding);
      }
      if (Buffer5.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read4(buf2, i2) {
        if (indexSize === 1) {
          return buf2[i2];
        } else {
          return buf2.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read4(arr, i) === read4(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read4(arr, i + j) !== read4(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer5.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer5.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer5.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf2, string5, offset, length6) {
      offset = Number(offset) || 0;
      const remaining = buf2.length - offset;
      if (!length6) {
        length6 = remaining;
      } else {
        length6 = Number(length6);
        if (length6 > remaining) {
          length6 = remaining;
        }
      }
      const strLen = string5.length;
      if (length6 > strLen / 2) {
        length6 = strLen / 2;
      }
      let i;
      for (i = 0; i < length6; ++i) {
        const parsed = parseInt(string5.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf2[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf2, string5, offset, length6) {
      return blitBuffer(utf8ToBytes3(string5, buf2.length - offset), buf2, offset, length6);
    }
    function asciiWrite(buf2, string5, offset, length6) {
      return blitBuffer(asciiToBytes2(string5), buf2, offset, length6);
    }
    function base64Write(buf2, string5, offset, length6) {
      return blitBuffer(base64ToBytes(string5), buf2, offset, length6);
    }
    function ucs2Write(buf2, string5, offset, length6) {
      return blitBuffer(utf16leToBytes(string5, buf2.length - offset), buf2, offset, length6);
    }
    Buffer5.prototype.write = function write(string5, offset, length6, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length6 = this.length;
        offset = 0;
      } else if (length6 === void 0 && typeof offset === "string") {
        encoding = offset;
        length6 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length6)) {
          length6 = length6 >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length6;
          length6 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length6 === void 0 || length6 > remaining) length6 = remaining;
      if (string5.length > 0 && (length6 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string5, offset, length6);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string5, offset, length6);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string5, offset, length6);
          case "base64":
            return base64Write(this, string5, offset, length6);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string5, offset, length6);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer5.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf2, start, end) {
      if (start === 0 && end === buf2.length) {
        return base644.fromByteArray(buf2);
      } else {
        return base644.fromByteArray(buf2.slice(start, end));
      }
    }
    function utf8Slice2(buf2, start, end) {
      end = Math.min(buf2.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf2[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf2[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              fourthByte = buf2[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray2(res);
    }
    var MAX_ARGUMENTS_LENGTH2 = 4096;
    function decodeCodePointsArray2(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH2) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2)
        );
      }
      return res;
    }
    function asciiSlice(buf2, start, end) {
      let ret = "";
      end = Math.min(buf2.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf2[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf2, start, end) {
      let ret = "";
      end = Math.min(buf2.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf2[i]);
      }
      return ret;
    }
    function hexSlice(buf2, start, end) {
      const len = buf2.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf2[i]];
      }
      return out;
    }
    function utf16leSlice(buf2, start, end) {
      const bytes = buf2.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer5.prototype.slice = function slice2(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer5.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length6) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length6) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer5.prototype.readUintLE = Buffer5.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer5.prototype.readUintBE = Buffer5.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer5.prototype.readUint8 = Buffer5.prototype.readUInt8 = function readUInt82(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer5.prototype.readUint16LE = Buffer5.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer5.prototype.readUint16BE = Buffer5.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer5.prototype.readUint32LE = Buffer5.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer5.prototype.readUint32BE = Buffer5.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer5.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer5.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first2 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer5.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer5.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer5.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer5.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer5.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer5.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer5.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer5.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer5.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first2 << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
    });
    Buffer5.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer5.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer5.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer5.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf2, value2, offset, ext, max, min) {
      if (!Buffer5.isBuffer(buf2)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value2 > max || value2 < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf2.length) throw new RangeError("Index out of range");
    }
    Buffer5.prototype.writeUintLE = Buffer5.prototype.writeUIntLE = function writeUIntLE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value2, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value2 & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value2 / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer5.prototype.writeUintBE = Buffer5.prototype.writeUIntBE = function writeUIntBE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value2, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value2 & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value2 / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer5.prototype.writeUint8 = Buffer5.prototype.writeUInt8 = function writeUInt83(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 1, 255, 0);
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer5.prototype.writeUint16LE = Buffer5.prototype.writeUInt16LE = function writeUInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer5.prototype.writeUint16BE = Buffer5.prototype.writeUInt16BE = function writeUInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer5.prototype.writeUint32LE = Buffer5.prototype.writeUInt32LE = function writeUInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset + 3] = value2 >>> 24;
      this[offset + 2] = value2 >>> 16;
      this[offset + 1] = value2 >>> 8;
      this[offset] = value2 & 255;
      return offset + 4;
    };
    Buffer5.prototype.writeUint32BE = Buffer5.prototype.writeUInt32BE = function writeUInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf2, value2, offset, min, max) {
      checkIntBI(value2, min, max, buf2, offset, 7);
      let lo = Number(value2 & BigInt(4294967295));
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf2, value2, offset, min, max) {
      checkIntBI(value2, min, max, buf2, offset, 7);
      let lo = Number(value2 & BigInt(4294967295));
      buf2[offset + 7] = lo;
      lo = lo >> 8;
      buf2[offset + 6] = lo;
      lo = lo >> 8;
      buf2[offset + 5] = lo;
      lo = lo >> 8;
      buf2[offset + 4] = lo;
      let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
      buf2[offset + 3] = hi;
      hi = hi >> 8;
      buf2[offset + 2] = hi;
      hi = hi >> 8;
      buf2[offset + 1] = hi;
      hi = hi >> 8;
      buf2[offset] = hi;
      return offset + 8;
    }
    Buffer5.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value2, offset = 0) {
      return wrtBigUInt64LE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer5.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value2, offset = 0) {
      return wrtBigUInt64BE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer5.prototype.writeIntLE = function writeIntLE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value2 & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value2 / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer5.prototype.writeIntBE = function writeIntBE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value2 & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value2 / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer5.prototype.writeInt8 = function writeInt8(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 1, 127, -128);
      if (value2 < 0) value2 = 255 + value2 + 1;
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer5.prototype.writeInt16LE = function writeInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer5.prototype.writeInt16BE = function writeInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer5.prototype.writeInt32LE = function writeInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      this[offset + 2] = value2 >>> 16;
      this[offset + 3] = value2 >>> 24;
      return offset + 4;
    };
    Buffer5.prototype.writeInt32BE = function writeInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      if (value2 < 0) value2 = 4294967295 + value2 + 1;
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    Buffer5.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value2, offset = 0) {
      return wrtBigUInt64LE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer5.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value2, offset = 0) {
      return wrtBigUInt64BE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf2, value2, offset, ext, max, min) {
      if (offset + ext > buf2.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf2, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value2, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf2, value2, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer5.prototype.writeFloatLE = function writeFloatLE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, true, noAssert);
    };
    Buffer5.prototype.writeFloatBE = function writeFloatBE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, false, noAssert);
    };
    function writeDouble(buf2, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value2, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf2, value2, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer5.prototype.writeDoubleLE = function writeDoubleLE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, true, noAssert);
    };
    Buffer5.prototype.writeDoubleBE = function writeDoubleBE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, false, noAssert);
    };
    Buffer5.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer5.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer5.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer5.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code10 = val.charCodeAt(0);
          if (encoding === "utf8" && code10 < 128 || encoding === "latin1") {
            val = code10;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer5.isBuffer(val) ? val : Buffer5.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value2) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value: value2,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name10) {
        if (name10) {
          return `${name10} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name10, actual) {
        return `The "${name10}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range4, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range4}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf2, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf2[offset] === void 0 || buf2[offset + byteLength2] === void 0) {
        boundsError(offset, buf2.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value2, min, max, buf2, offset, byteLength2) {
      if (value2 > max || value2 < min) {
        const n2 = typeof min === "bigint" ? "n" : "";
        let range4;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range4 = `>= 0${n2} and < 2${n2} ** ${(byteLength2 + 1) * 8}${n2}`;
          } else {
            range4 = `>= -(2${n2} ** ${(byteLength2 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n2}`;
          }
        } else {
          range4 = `>= ${min}${n2} and <= ${max}${n2}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range4, value2);
      }
      checkBounds(buf2, offset, byteLength2);
    }
    function validateNumber(value2, name10) {
      if (typeof value2 !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name10, "number", value2);
      }
    }
    function boundsError(value2, length6, type) {
      if (Math.floor(value2) !== value2) {
        validateNumber(value2, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value2);
      }
      if (length6 < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length6}`,
        value2
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes3(string5, units) {
      units = units || Infinity;
      let codePoint;
      const length6 = string5.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length6; ++i) {
        codePoint = string5.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length6) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes2(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base644.toByteArray(base64clean(str));
    }
    function blitBuffer(src4, dst, offset, length6) {
      let i;
      for (i = 0; i < length6; ++i) {
        if (i + offset >= dst.length || i >= src4.length) break;
        dst[i + offset] = src4[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = (function() {
      const alphabet5 = "0123456789abcdef";
      const table2 = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table2[i16 + j] = alphabet5[i] + alphabet5[j];
        }
      }
      return table2;
    })();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js"(exports2, module2) {
    init_buffer_polyfill();
    var process3 = module2.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process3.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array2) {
      this.fun = fun;
      this.array = array2;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process3.title = "browser";
    process3.browser = true;
    process3.env = {};
    process3.argv = [];
    process3.version = "";
    process3.versions = {};
    function noop() {
    }
    process3.on = noop;
    process3.addListener = noop;
    process3.once = noop;
    process3.off = noop;
    process3.removeListener = noop;
    process3.removeAllListeners = noop;
    process3.emit = noop;
    process3.prependListener = noop;
    process3.prependOnceListener = noop;
    process3.listeners = function(name10) {
      return [];
    };
    process3.binding = function(name10) {
      throw new Error("process.binding is not supported");
    };
    process3.cwd = function() {
      return "/";
    };
    process3.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process3.umask = function() {
      return 0;
    };
  }
});

// buffer-polyfill.js
var import_buffer, import_process;
var init_buffer_polyfill = __esm({
  "buffer-polyfill.js"() {
    "use strict";
    import_buffer = __toESM(require_buffer());
    import_process = __toESM(require_browser());
    console.log("Buffer polyfill loaded");
    if (typeof window !== "undefined") {
      window.Buffer = import_buffer.Buffer;
      window.process = import_process.default;
    }
    if (typeof globalThis !== "undefined") {
      globalThis.Buffer = import_buffer.Buffer;
      globalThis.process = import_process.default;
    }
  }
});

// node_modules/.pnpm/bech32@2.0.0/node_modules/bech32/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/bech32@2.0.0/node_modules/bech32/dist/index.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bech32m = exports2.bech32 = void 0;
    var ALPHABET2 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (let z = 0; z < ALPHABET2.length; z++) {
      const x = ALPHABET2.charAt(z);
      ALPHABET_MAP[x] = z;
    }
    function polymodStep(pre) {
      const b = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      let chk = 1;
      for (let i = 0; i < prefix.length; ++i) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c >> 5;
      }
      chk = polymodStep(chk);
      for (let i = 0; i < prefix.length; ++i) {
        const v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 31;
      }
      return chk;
    }
    function convert(data, inBits, outBits, pad) {
      let value2 = 0;
      let bits = 0;
      const maxV = (1 << outBits) - 1;
      const result = [];
      for (let i = 0; i < data.length; ++i) {
        value2 = value2 << inBits | data[i];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value2 >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result.push(value2 << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value2 << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWords(bytes) {
      return convert(bytes, 8, 5, true);
    }
    function fromWordsUnsafe(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function getLibraryFromEncoding(encoding) {
      let ENCODING_CONST;
      if (encoding === "bech32") {
        ENCODING_CONST = 1;
      } else {
        ENCODING_CONST = 734539939;
      }
      function encode42(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
          throw new TypeError("Exceeds length limit");
        prefix = prefix.toLowerCase();
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          throw new Error(chk);
        let result = prefix + "1";
        for (let i = 0; i < words.length; ++i) {
          const x = words[i];
          if (x >> 5 !== 0)
            throw new Error("Non 5-bit word");
          chk = polymodStep(chk) ^ x;
          result += ALPHABET2.charAt(x);
        }
        for (let i = 0; i < 6; ++i) {
          chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i = 0; i < 6; ++i) {
          const v = chk >> (5 - i) * 5 & 31;
          result += ALPHABET2.charAt(v);
        }
        return result;
      }
      function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
          return str + " too short";
        if (str.length > LIMIT)
          return "Exceeds length limit";
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
          return "Mixed-case string " + str;
        str = lowered;
        const split2 = str.lastIndexOf("1");
        if (split2 === -1)
          return "No separator character for " + str;
        if (split2 === 0)
          return "Missing prefix for " + str;
        const prefix = str.slice(0, split2);
        const wordChars = str.slice(split2 + 1);
        if (wordChars.length < 6)
          return "Data too short";
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          return chk;
        const words = [];
        for (let i = 0; i < wordChars.length; ++i) {
          const c = wordChars.charAt(i);
          const v = ALPHABET_MAP[c];
          if (v === void 0)
            return "Unknown character " + c;
          chk = polymodStep(chk) ^ v;
          if (i + 6 >= wordChars.length)
            continue;
          words.push(v);
        }
        if (chk !== ENCODING_CONST)
          return "Invalid checksum for " + str;
        return { prefix, words };
      }
      function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
      }
      function decode44(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
        throw new Error(res);
      }
      return {
        decodeUnsafe,
        decode: decode44,
        encode: encode42,
        toWords,
        fromWordsUnsafe,
        fromWords
      };
    }
    exports2.bech32 = getLibraryFromEncoding("bech32");
    exports2.bech32m = getLibraryFromEncoding("bech32m");
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/package.json"(exports2, module2) {
    module2.exports = {
      name: "elliptic",
      version: "6.6.1",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/.pnpm/bn.js@4.12.2/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/.pnpm/bn.js@4.12.2/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    init_buffer_polyfill();
    (function(module3, exports3) {
      "use strict";
      function assert3(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number3, base5, endian) {
        if (BN2.isBN(number3)) {
          return number3;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number3 !== null) {
          if (base5 === "le" || base5 === "be") {
            endian = base5;
            base5 = 10;
          }
          this._init(number3 || 0, base5 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN2;
      } else {
        exports3.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer5;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer5 = window.Buffer;
        } else {
          Buffer5 = require_buffer().Buffer;
        }
      } catch (e) {
      }
      BN2.isBN = function isBN(num2) {
        if (num2 instanceof BN2) {
          return true;
        }
        return num2 !== null && typeof num2 === "object" && num2.constructor.wordSize === BN2.wordSize && Array.isArray(num2.words);
      };
      BN2.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN2.prototype._init = function init(number3, base5, endian) {
        if (typeof number3 === "number") {
          return this._initNumber(number3, base5, endian);
        }
        if (typeof number3 === "object") {
          return this._initArray(number3, base5, endian);
        }
        if (base5 === "hex") {
          base5 = 16;
        }
        assert3(base5 === (base5 | 0) && base5 >= 2 && base5 <= 36);
        number3 = number3.toString().replace(/\s+/g, "");
        var start = 0;
        if (number3[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number3.length) {
          if (base5 === 16) {
            this._parseHex(number3, start, endian);
          } else {
            this._parseBase(number3, base5, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base5, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number3, base5, endian) {
        if (number3 < 0) {
          this.negative = 1;
          number3 = -number3;
        }
        if (number3 < 67108864) {
          this.words = [number3 & 67108863];
          this.length = 1;
        } else if (number3 < 4503599627370496) {
          this.words = [
            number3 & 67108863,
            number3 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number3 < 9007199254740992);
          this.words = [
            number3 & 67108863,
            number3 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base5, endian);
      };
      BN2.prototype._initArray = function _initArray(number3, base5, endian) {
        assert3(typeof number3.length === "number");
        if (number3.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number3.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number3.length - 1, j = 0; i >= 0; i -= 3) {
            w = number3[i] | number3[i - 1] << 8 | number3[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number3.length; i += 3) {
            w = number3[i] | number3[i + 1] << 8 | number3[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string5, index) {
        var c = string5.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string5, lowerBound, index) {
        var r = parseHex4Bits(string5, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string5, index - 1) << 4;
        }
        return r;
      }
      BN2.prototype._parseHex = function _parseHex(number3, start, endian) {
        this.length = Math.ceil((number3.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number3.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number3, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number3.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number3.length; i += 2) {
            w = parseHexByte(number3, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN2.prototype._parseBase = function _parseBase(number3, base5, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base5) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base5 | 0;
        var total = number3.length - start;
        var mod3 = total % limbLen;
        var end = Math.min(total, total - mod3) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number3, i, i + limbLen, base5);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod3 !== 0) {
          var pow = 1;
          word = parseBase(number3, i, number3.length, base5);
          for (i = 0; i < mod3; i++) {
            pow *= base5;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r = new BN2(null);
        this.copy(r);
        return r;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString8(base5, padding) {
        base5 = base5 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base5 === 16 || base5 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base5 === (base5 | 0) && base5 >= 2 && base5 <= 36) {
          var groupSize = groupSizes[base5];
          var groupBase = groupBases[base5];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base5);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length6) {
        assert3(typeof Buffer5 !== "undefined");
        return this.toArrayLike(Buffer5, endian, length6);
      };
      BN2.prototype.toArray = function toArray(endian, length6) {
        return this.toArrayLike(Array, endian, length6);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length6) {
        var byteLength = this.byteLength();
        var reqLength = length6 || Math.max(1, byteLength);
        assert3(byteLength <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num2) {
        var w = new Array(num2.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num2.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num2) {
        while (this.length < num2.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num2.length; i++) {
          this.words[i] = this.words[i] | num2.words[i];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num2) {
        assert3((this.negative | num2.negative) === 0);
        return this.iuor(num2);
      };
      BN2.prototype.or = function or4(num2) {
        if (this.length > num2.length) return this.clone().ior(num2);
        return num2.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num2) {
        if (this.length > num2.length) return this.clone().iuor(num2);
        return num2.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num2) {
        var b;
        if (this.length > num2.length) {
          b = num2;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num2.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num2) {
        assert3((this.negative | num2.negative) === 0);
        return this.iuand(num2);
      };
      BN2.prototype.and = function and(num2) {
        if (this.length > num2.length) return this.clone().iand(num2);
        return num2.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num2) {
        if (this.length > num2.length) return this.clone().iuand(num2);
        return num2.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num2) {
        var a;
        var b;
        if (this.length > num2.length) {
          a = this;
          b = num2;
        } else {
          a = num2;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num2) {
        assert3((this.negative | num2.negative) === 0);
        return this.iuxor(num2);
      };
      BN2.prototype.xor = function xor(num2) {
        if (this.length > num2.length) return this.clone().ixor(num2);
        return num2.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num2) {
        if (this.length > num2.length) return this.clone().iuxor(num2);
        return num2.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num2) {
        var r;
        if (this.negative !== 0 && num2.negative === 0) {
          this.negative = 0;
          r = this.isub(num2);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num2.negative !== 0) {
          num2.negative = 0;
          r = this.isub(num2);
          num2.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num2.length) {
          a = this;
          b = num2;
        } else {
          a = num2;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN2.prototype.add = function add2(num2) {
        var res;
        if (num2.negative !== 0 && this.negative === 0) {
          num2.negative = 0;
          res = this.sub(num2);
          num2.negative ^= 1;
          return res;
        } else if (num2.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num2.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num2.length) return this.clone().iadd(num2);
        return num2.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num2) {
        if (num2.negative !== 0) {
          num2.negative = 0;
          var r = this.iadd(num2);
          num2.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num2);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num2);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num2;
        } else {
          a = num2;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num2) {
        return this.clone().isub(num2);
      };
      function smallMulTo(self2, num2, out) {
        out.negative = num2.negative ^ self2.negative;
        var len = self2.length + num2.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num2.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num2.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num2.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num2, out) {
        var a = self2.words;
        var b = num2.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num2.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num2, out) {
        out.negative = num2.negative ^ self2.negative;
        out.length = self2.length + num2.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num2.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num2.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num2, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num2, out);
      }
      BN2.prototype.mulTo = function mulTo(num2, out) {
        var res;
        var len = this.length + num2.length;
        if (this.length === 10 && num2.length === 10) {
          res = comb10MulTo(this, num2, out);
        } else if (len < 63) {
          res = smallMulTo(this, num2, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num2, out);
        } else {
          res = jumboMulTo(this, num2, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN2.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m) {
        var N = Math.max(m, n2) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num2) {
        var out = new BN2(null);
        out.words = new Array(this.length + num2.length);
        return this.mulTo(num2, out);
      };
      BN2.prototype.mulf = function mulf(num2) {
        var out = new BN2(null);
        out.words = new Array(this.length + num2.length);
        return jumboMulTo(this, num2, out);
      };
      BN2.prototype.imul = function imul(num2) {
        return this.clone().mulTo(num2, this);
      };
      BN2.prototype.imuln = function imuln(num2) {
        assert3(typeof num2 === "number");
        assert3(num2 < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num2;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        this.length = num2 === 0 ? 1 : this.length;
        return this;
      };
      BN2.prototype.muln = function muln(num2) {
        return this.clone().imuln(num2);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num2) {
        var w = toBitArray(num2);
        if (w.length === 0) return new BN2(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h3;
        if (hint) {
          h3 = (hint - hint % 26) / 26;
        } else {
          h3 = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h3 -= s;
        h3 = Math.max(0, h3);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h3); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num2) {
        assert3(typeof num2 === "number");
        assert3(num2 < 67108864);
        if (num2 < 0) return this.isubn(-num2);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num2) {
            this.words[0] = num2 - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num2);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num2);
      };
      BN2.prototype._iaddn = function _iaddn(num2) {
        this.words[0] += num2;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num2) {
        assert3(typeof num2 === "number");
        assert3(num2 < 67108864);
        if (num2 < 0) return this.iaddn(-num2);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num2);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num2;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num2) {
        return this.clone().iaddn(num2);
      };
      BN2.prototype.subn = function subn(num2) {
        return this.clone().isubn(num2);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num2, mul, shift) {
        var len = num2.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num2.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num2.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0) return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num2, mode) {
        var shift = this.length - num2.length;
        var a = this.clone();
        var b = num2;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN2(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN2.prototype.divmod = function divmod(num2, mode, positive2) {
        assert3(!num2.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod3, res;
        if (this.negative !== 0 && num2.negative === 0) {
          res = this.neg().divmod(num2, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod3 = res.mod.neg();
            if (positive2 && mod3.negative !== 0) {
              mod3.iadd(num2);
            }
          }
          return {
            div,
            mod: mod3
          };
        }
        if (this.negative === 0 && num2.negative !== 0) {
          res = this.divmod(num2.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num2.negative) !== 0) {
          res = this.neg().divmod(num2.neg(), mode);
          if (mode !== "div") {
            mod3 = res.mod.neg();
            if (positive2 && mod3.negative !== 0) {
              mod3.isub(num2);
            }
          }
          return {
            div: res.div,
            mod: mod3
          };
        }
        if (num2.length > this.length || this.cmp(num2) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num2.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num2.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num2.words[0]))
            };
          }
          return {
            div: this.divn(num2.words[0]),
            mod: new BN2(this.modn(num2.words[0]))
          };
        }
        return this._wordDiv(num2, mode);
      };
      BN2.prototype.div = function div(num2) {
        return this.divmod(num2, "div", false).div;
      };
      BN2.prototype.mod = function mod3(num2) {
        return this.divmod(num2, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num2) {
        return this.divmod(num2, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num2) {
        var dm = this.divmod(num2);
        if (dm.mod.isZero()) return dm.div;
        var mod3 = dm.div.negative !== 0 ? dm.mod.isub(num2) : dm.mod;
        var half = num2.ushrn(1);
        var r2 = num2.andln(1);
        var cmp = mod3.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num2) {
        assert3(num2 <= 67108863);
        var p = (1 << 26) % num2;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num2;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num2) {
        assert3(num2 <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num2 | 0;
          carry = w % num2;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num2) {
        return this.clone().idivn(num2);
      };
      BN2.prototype.egcd = function egcd(p) {
        assert3(p.negative === 0);
        assert3(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN2(1);
        var B = new BN2(0);
        var C = new BN2(0);
        var D = new BN2(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN2.prototype._invmp = function _invmp(p) {
        assert3(p.negative === 0);
        assert3(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num2) {
        if (this.isZero()) return num2.abs();
        if (num2.isZero()) return this.abs();
        var a = this.clone();
        var b = num2.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN2.prototype.invm = function invm(num2) {
        return this.egcd(num2).a.umod(num2);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num2) {
        return this.words[0] & num2;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num2) {
        var negative = num2 < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num2 = -num2;
          }
          assert3(num2 <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num2 ? 0 : w < num2 ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num2) {
        if (this.negative !== 0 && num2.negative === 0) return -1;
        if (this.negative === 0 && num2.negative !== 0) return 1;
        var res = this.ucmp(num2);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num2) {
        if (this.length > num2.length) return 1;
        if (this.length < num2.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num2.words[i] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num2) {
        return this.cmpn(num2) === 1;
      };
      BN2.prototype.gt = function gt(num2) {
        return this.cmp(num2) === 1;
      };
      BN2.prototype.gten = function gten(num2) {
        return this.cmpn(num2) >= 0;
      };
      BN2.prototype.gte = function gte(num2) {
        return this.cmp(num2) >= 0;
      };
      BN2.prototype.ltn = function ltn(num2) {
        return this.cmpn(num2) === -1;
      };
      BN2.prototype.lt = function lt(num2) {
        return this.cmp(num2) === -1;
      };
      BN2.prototype.lten = function lten(num2) {
        return this.cmpn(num2) <= 0;
      };
      BN2.prototype.lte = function lte(num2) {
        return this.cmp(num2) <= 0;
      };
      BN2.prototype.eqn = function eqn(num2) {
        return this.cmpn(num2) === 0;
      };
      BN2.prototype.eq = function eq(num2) {
        return this.cmp(num2) === 0;
      };
      BN2.red = function red(num2) {
        return new Red(num2);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num2) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num2);
      };
      BN2.prototype.redIAdd = function redIAdd(num2) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num2);
      };
      BN2.prototype.redSub = function redSub(num2) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num2);
      };
      BN2.prototype.redISub = function redISub(num2) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num2);
      };
      BN2.prototype.redShl = function redShl(num2) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num2);
      };
      BN2.prototype.redMul = function redMul(num2) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num2);
        return this.red.mul(this, num2);
      };
      BN2.prototype.redIMul = function redIMul(num2) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num2);
        return this.red.imul(this, num2);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num2) {
        assert3(this.red && !num2.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num2);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name10, p) {
        this.name = name10;
        this.p = new BN2(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num2) {
        var r = num2;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num2) {
        return num2.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split2(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num2) {
        num2.words[num2.length] = 0;
        num2.words[num2.length + 1] = 0;
        num2.length += 2;
        var lo = 0;
        for (var i = 0; i < num2.length; i++) {
          var w = num2.words[i] | 0;
          lo += w * 977;
          num2.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num2.words[num2.length - 1] === 0) {
          num2.length--;
          if (num2.words[num2.length - 1] === 0) {
            num2.length--;
          }
        }
        return num2;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num2) {
        var carry = 0;
        for (var i = 0; i < num2.length; i++) {
          var hi = (num2.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num2.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num2.words[num2.length++] = carry;
        }
        return num2;
      };
      BN2._prime = function prime(name10) {
        if (primes[name10]) return primes[name10];
        var prime2;
        if (name10 === "k256") {
          prime2 = new K256();
        } else if (name10 === "p224") {
          prime2 = new P224();
        } else if (name10 === "p192") {
          prime2 = new P192();
        } else if (name10 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name10);
        }
        primes[name10] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN2._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert3(a.negative === 0, "red works only with positives");
        assert3(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert3((a.negative | b.negative) === 0, "red works only with positives");
        assert3(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add2(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num2) {
        this._verify1(a);
        return this.imod(a.ushln(num2));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert3(!q.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN2(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert3(i < m);
          var b = this.pow(c, new BN2(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num2) {
        if (num2.isZero()) return new BN2(1).toRed(this);
        if (num2.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num2.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num2.length - 1; i >= 0; i--) {
          var word = num2.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num2) {
        var r = num2.umod(this.m);
        return r === num2 ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num2) {
        var res = num2.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num2) {
        return new Mont(num2);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num2) {
        return this.imod(num2.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num2) {
        var r = this.imod(num2.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN2(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js"(exports2, module2) {
    init_buffer_polyfill();
    module2.exports = assert3;
    function assert3(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert3.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  }
});

// node_modules/.pnpm/minimalistic-crypto-utils@1.0.1/node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/minimalistic-crypto-utils@1.0.1/node_modules/minimalistic-crypto-utils/lib/utils.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var utils = exports2;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      } else {
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          var hi = c >> 8;
          var lo = c & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex3(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    utils.toHex = toHex3;
    utils.encode = function encode42(arr, enc) {
      if (enc === "hex")
        return toHex3(arr);
      else
        return arr;
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var utils = exports2;
    var BN2 = require_bn();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num2, w, bits) {
      var naf = new Array(Math.max(num2.bitLength(), bits) + 1);
      var i;
      for (i = 0; i < naf.length; i += 1) {
        naf[i] = 0;
      }
      var ws = 1 << w + 1;
      var k = num2.clone();
      for (i = 0; i < naf.length; i++) {
        var z;
        var mod3 = k.andln(ws - 1);
        if (k.isOdd()) {
          if (mod3 > (ws >> 1) - 1)
            z = (ws >> 1) - mod3;
          else
            z = mod3;
          k.isubn(z);
        } else {
          z = 0;
        }
        naf[i] = z;
        k.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name10, computer) {
      var key = "_" + name10;
      obj.prototype[name10] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN2(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js"(exports2, module2) {
    init_buffer_polyfill();
    var buffer2 = require_buffer();
    var Buffer5 = buffer2.Buffer;
    function copyProps(src4, dst) {
      for (var key in src4) {
        dst[key] = src4[key];
      }
    }
    if (Buffer5.from && Buffer5.alloc && Buffer5.allocUnsafe && Buffer5.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length6) {
      return Buffer5(arg, encodingOrOffset, length6);
    }
    SafeBuffer.prototype = Object.create(Buffer5.prototype);
    copyProps(Buffer5, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length6) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer5(arg, encodingOrOffset, length6);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf2 = Buffer5(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf2.fill(fill, encoding);
        } else {
          buf2.fill(fill);
        }
      } else {
        buf2.fill(0);
      }
      return buf2;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer5(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  }
});

// node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/browser.js
var require_browser2 = __commonJS({
  "node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/browser.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer5 = require_safe_buffer().Buffer;
    var crypto2 = globalThis.crypto || globalThis.msCrypto;
    if (crypto2 && crypto2.getRandomValues) {
      module2.exports = randomBytes2;
    } else {
      module2.exports = oldBrowser;
    }
    function randomBytes2(size, cb) {
      if (size > MAX_UINT32) throw new RangeError("requested too many random bytes");
      var bytes = Buffer5.allocUnsafe(size);
      if (size > 0) {
        if (size > MAX_BYTES) {
          for (var generated = 0; generated < size; generated += MAX_BYTES) {
            crypto2.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto2.getRandomValues(bytes);
        }
      }
      if (typeof cb === "function") {
        return import_process.default.nextTick(function() {
          cb(null, bytes);
        });
      }
      return bytes;
    }
  }
});

// node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports2, module2) {
    init_buffer_polyfill();
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/.pnpm/isarray@2.0.5/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/.pnpm/isarray@2.0.5/node_modules/isarray/index.js"(exports2, module2) {
    init_buffer_polyfill();
    var toString8 = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString8.call(arr) == "[object Array]";
    };
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = TypeError;
  }
});

// node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Object;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Error;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = EvalError;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = RangeError;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = ReferenceError;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = SyntaxError;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = URIError;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Math.abs;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Math.floor;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Math.max;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Math.min;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Math.pow;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Math.round;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var $isNaN = require_isNaN();
    module2.exports = function sign2(number3) {
      if ($isNaN(number3) || number3 === 0) {
        return number3;
      }
      return number3 < 0 ? -1 : 1;
    };
  }
});

// node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = /* @__PURE__ */ Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof /* @__PURE__ */ Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Function.prototype.call;
  }
});

// node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Function.prototype.apply;
  }
});

// node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value2) {
        return $getPrototypeOf(value2 == null ? value2 : $Object(value2));
      }
    ) : false;
  }
});

// node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign2 = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? (function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    })() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign2,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name10) {
      var value2;
      if (name10 === "%AsyncFunction%") {
        value2 = getEvalledConstructor("async function () {}");
      } else if (name10 === "%GeneratorFunction%") {
        value2 = getEvalledConstructor("function* () {}");
      } else if (name10 === "%AsyncGeneratorFunction%") {
        value2 = getEvalledConstructor("async function* () {}");
      } else if (name10 === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value2 = fn.prototype;
        }
      } else if (name10 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value2 = getProto(gen.prototype);
        }
      }
      INTRINSICS[name10] = value2;
      return value2;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string5) {
      var first2 = $strSlice(string5, 0, 1);
      var last2 = $strSlice(string5, -1);
      if (first2 === "%" && last2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last2 === "%" && first2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string5, rePropName, function(match, number3, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number3 || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name10, allowMissing) {
      var intrinsicName = name10;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value2 = INTRINSICS[intrinsicName];
        if (value2 === needsEval) {
          value2 = doEval(intrinsicName);
        }
        if (typeof value2 === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name10 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value: value2
        };
      }
      throw new $SyntaxError("intrinsic " + name10 + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name10, allowMissing) {
      if (typeof name10 !== "string" || name10.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name10) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name10);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value2 = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first2 = $strSlice(part, 0, 1);
        var last2 = $strSlice(part, -1);
        if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value2 = INTRINSICS[intrinsicRealName];
        } else if (value2 != null) {
          if (!(part in value2)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name10 + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value2, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value2 = desc.get;
            } else {
              value2 = value2[part];
            }
          } else {
            isOwn = hasOwn(value2, part);
            value2 = value2[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value2;
          }
        }
      }
      return value2;
    };
  }
});

// node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module2.exports = function callBoundIntrinsic(name10, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name10, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name10, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    };
  }
});

// node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value2) {
      try {
        var fnStr = fnToStr.call(value2);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value2) {
      try {
        if (isES6ClassFn(value2)) {
          return false;
        }
        fnToStr.call(value2);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all2 = document.all;
      if (toStr.call(all2) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value2) {
          if ((isIE68 || !value2) && (typeof value2 === "undefined" || typeof value2 === "object")) {
            try {
              var str = toStr.call(value2);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value2("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all2;
    module2.exports = reflectApply ? function isCallable(value2) {
      if (isDDA(value2)) {
        return true;
      }
      if (!value2) {
        return false;
      }
      if (typeof value2 !== "function" && typeof value2 !== "object") {
        return false;
      }
      try {
        reflectApply(value2, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value2) && tryFunctionObject(value2);
    } : function isCallable(value2) {
      if (isDDA(value2)) {
        return true;
      }
      if (!value2) {
        return false;
      }
      if (typeof value2 !== "function" && typeof value2 !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value2);
      }
      if (isES6ClassFn(value2)) {
        return false;
      }
      var strClass = toStr.call(value2);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value2);
    };
  }
});

// node_modules/.pnpm/for-each@0.3.5/node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/.pnpm/for-each@0.3.5/node_modules/for-each/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array2, iterator, receiver) {
      for (var i = 0, len = array2.length; i < len; i++) {
        if (hasOwnProperty.call(array2, i)) {
          if (receiver == null) {
            iterator(array2[i], i, array2);
          } else {
            iterator.call(receiver, array2[i], i, array2);
          }
        }
      }
    };
    var forEachString = function forEachString2(string5, iterator, receiver) {
      for (var i = 0, len = string5.length; i < len; i++) {
        if (receiver == null) {
          iterator(string5.charAt(i), i, string5);
        } else {
          iterator.call(receiver, string5.charAt(i), i, string5);
        }
      }
    };
    var forEachObject = function forEachObject2(object3, iterator, receiver) {
      for (var k in object3) {
        if (hasOwnProperty.call(object3, k)) {
          if (receiver == null) {
            iterator(object3[k], k, object3);
          } else {
            iterator.call(receiver, object3[k], k, object3);
          }
        }
      }
    };
    function isArray(x) {
      return toStr.call(x) === "[object Array]";
    }
    module2.exports = function forEach2(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (isArray(list)) {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
  }
});

// node_modules/.pnpm/possible-typed-array-names@1.1.0/node_modules/possible-typed-array-names/index.js
var require_possible_typed_array_names = __commonJS({
  "node_modules/.pnpm/possible-typed-array-names@1.1.0/node_modules/possible-typed-array-names/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = [
      "Float16Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var possibleNames = require_possible_typed_array_names();
    var g = typeof globalThis === "undefined" ? globalThis : globalThis;
    module2.exports = function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
  }
});

// node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property, value2) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value: value2,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value2;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var GetIntrinsic = require_get_intrinsic();
    var define = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module2.exports = function setFunctionLength(fn, length6) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length6 !== "number" || length6 < 0 || length6 > 4294967295 || $floor(length6) !== length6) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length6,
            true,
            true
          );
        } else {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length6
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js
var require_applyBind = __commonJS({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var actualApply = require_actualApply();
    module2.exports = function applyBind() {
      return actualApply(bind, $apply, arguments);
    };
  }
});

// node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var setFunctionLength = require_set_function_length();
    var $defineProperty = require_es_define_property();
    var callBindBasic = require_call_bind_apply_helpers();
    var applyBind = require_applyBind();
    module2.exports = function callBind(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/.pnpm/which-typed-array@1.1.20/node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/.pnpm/which-typed-array@1.1.20/node_modules/which-typed-array/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var forEach2 = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBind = require_call_bind();
    var callBound = require_call_bound();
    var gOPD = require_gopd();
    var getProto = require_get_proto();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? globalThis : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf2(array2, value2) {
      for (var i = 0; i < array2.length; i += 1) {
        if (array2[i] === value2) {
          return i;
        }
      }
      return -1;
    };
    var cache4 = { __proto__: null };
    if (hasToStringTag && gOPD && getProto) {
      forEach2(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr && getProto) {
          var proto = getProto(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor && proto) {
            var superProto = getProto(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          if (descriptor && descriptor.get) {
            var bound = callBind(descriptor.get);
            cache4[
              /** @type {`$${import('.').TypedArrayName}`} */
              "$" + typedArray
            ] = bound;
          }
        }
      });
    } else {
      forEach2(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
          var bound = (
            /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
            // @ts-expect-error TODO FIXME
            callBind(fn)
          );
          cache4[
            /** @type {`$${import('.').TypedArrayName}`} */
            "$" + typedArray
          ] = bound;
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value2) {
      var found = false;
      forEach2(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache4,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, typedArray) {
          if (!found) {
            try {
              if ("$" + getter(value2) === typedArray) {
                found = /** @type {import('.').TypedArrayName} */
                $slice(typedArray, 1);
              }
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    var trySlices = function tryAllSlices(value2) {
      var found = false;
      forEach2(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache4,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, name10) {
          if (!found) {
            try {
              getter(value2);
              found = /** @type {import('.').TypedArrayName} */
              $slice(name10, 1);
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    module2.exports = function whichTypedArray(value2) {
      if (!value2 || typeof value2 !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value2), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value2);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value2);
    };
  }
});

// node_modules/.pnpm/is-typed-array@1.1.15/node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/.pnpm/is-typed-array@1.1.15/node_modules/is-typed-array/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var whichTypedArray = require_which_typed_array();
    module2.exports = function isTypedArray(value2) {
      return !!whichTypedArray(value2);
    };
  }
});

// node_modules/.pnpm/typed-array-buffer@1.0.3/node_modules/typed-array-buffer/index.js
var require_typed_array_buffer = __commonJS({
  "node_modules/.pnpm/typed-array-buffer@1.0.3/node_modules/typed-array-buffer/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var $TypeError = require_type();
    var callBound = require_call_bound();
    var $typedArrayBuffer = callBound("TypedArray.prototype.buffer", true);
    var isTypedArray = require_is_typed_array();
    module2.exports = $typedArrayBuffer || function typedArrayBuffer(x) {
      if (!isTypedArray(x)) {
        throw new $TypeError("Not a Typed Array");
      }
      return x.buffer;
    };
  }
});

// node_modules/.pnpm/to-buffer@1.2.2/node_modules/to-buffer/index.js
var require_to_buffer = __commonJS({
  "node_modules/.pnpm/to-buffer@1.2.2/node_modules/to-buffer/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    var isArray = require_isarray();
    var typedArrayBuffer = require_typed_array_buffer();
    var isView = ArrayBuffer.isView || function isView2(obj) {
      try {
        typedArrayBuffer(obj);
        return true;
      } catch (e) {
        return false;
      }
    };
    var useUint8Array = typeof Uint8Array !== "undefined";
    var useArrayBuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
    var useFromArrayBuffer = useArrayBuffer && (Buffer5.prototype instanceof Uint8Array || Buffer5.TYPED_ARRAY_SUPPORT);
    module2.exports = function toBuffer(data, encoding) {
      if (Buffer5.isBuffer(data)) {
        if (data.constructor && !("isBuffer" in data)) {
          return Buffer5.from(data);
        }
        return data;
      }
      if (typeof data === "string") {
        return Buffer5.from(data, encoding);
      }
      if (useArrayBuffer && isView(data)) {
        if (data.byteLength === 0) {
          return Buffer5.alloc(0);
        }
        if (useFromArrayBuffer) {
          var res = Buffer5.from(data.buffer, data.byteOffset, data.byteLength);
          if (res.byteLength === data.byteLength) {
            return res;
          }
        }
        var uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        var result = Buffer5.from(uint8);
        if (result.length === data.byteLength) {
          return result;
        }
      }
      if (useUint8Array && data instanceof Uint8Array) {
        return Buffer5.from(data);
      }
      var isArr = isArray(data);
      if (isArr) {
        for (var i = 0; i < data.length; i += 1) {
          var x = data[i];
          if (typeof x !== "number" || x < 0 || x > 255 || ~~x !== x) {
            throw new RangeError("Array items must be numbers in the range 0-255.");
          }
        }
      }
      if (isArr || Buffer5.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === "function" && data.constructor.isBuffer(data)) {
        return Buffer5.from(data);
      }
      throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
    };
  }
});

// node_modules/.pnpm/hash-base@3.1.2/node_modules/hash-base/to-buffer.js
var require_to_buffer2 = __commonJS({
  "node_modules/.pnpm/hash-base@3.1.2/node_modules/hash-base/to-buffer.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    var toBuffer = require_to_buffer();
    var useUint8Array = typeof Uint8Array !== "undefined";
    var useArrayBuffer = useUint8Array && typeof ArrayBuffer !== "undefined";
    var isView = useArrayBuffer && ArrayBuffer.isView;
    module2.exports = function(thing, encoding) {
      if (typeof thing === "string" || Buffer5.isBuffer(thing) || useUint8Array && thing instanceof Uint8Array || isView && isView(thing)) {
        return toBuffer(thing, encoding);
      }
      throw new TypeError('The "data" argument must be a string, a Buffer, a Uint8Array, or a DataView');
    };
  }
});

// node_modules/.pnpm/process-nextick-args@2.0.1/node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/.pnpm/process-nextick-args@2.0.1/node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    if (typeof import_process.default === "undefined" || !import_process.default.version || import_process.default.version.indexOf("v0.") === 0 || import_process.default.version.indexOf("v1.") === 0 && import_process.default.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = import_process.default;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return import_process.default.nextTick(fn);
        case 2:
          return import_process.default.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return import_process.default.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return import_process.default.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return import_process.default.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/.pnpm/isarray@1.0.0/node_modules/isarray/index.js
var require_isarray2 = __commonJS({
  "node_modules/.pnpm/isarray@1.0.0/node_modules/isarray/index.js"(exports2, module2) {
    init_buffer_polyfill();
    var toString8 = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString8.call(arr) == "[object Array]";
    };
  }
});

// node_modules/.pnpm/events@3.3.0/node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/.pnpm/events@3.3.0/node_modules/events/events.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value2) {
      return value2 !== value2;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module2.exports = EventEmitter;
    module2.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
      if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
      }
      this._maxListeners = n2;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n2) {
      var copy = new Array(n2);
      for (var i = 0; i < n2; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name10) {
      return new Promise(function(resolve2, reject) {
        function errorListener(err) {
          emitter.removeListener(name10, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve2([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name10, resolver, { once: true });
        if (name10 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name10, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name10, listener);
        } else {
          emitter.on(name10, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name10, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name10, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports2, module2) {
    init_buffer_polyfill();
    module2.exports = require_events().EventEmitter;
  }
});

// node_modules/.pnpm/safe-buffer@5.1.2/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "node_modules/.pnpm/safe-buffer@5.1.2/node_modules/safe-buffer/index.js"(exports2, module2) {
    init_buffer_polyfill();
    var buffer2 = require_buffer();
    var Buffer5 = buffer2.Buffer;
    function copyProps(src4, dst) {
      for (var key in src4) {
        dst[key] = src4[key];
      }
    }
    if (Buffer5.from && Buffer5.alloc && Buffer5.allocUnsafe && Buffer5.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length6) {
      return Buffer5(arg, encodingOrOffset, length6);
    }
    copyProps(Buffer5, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length6) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer5(arg, encodingOrOffset, length6);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf2 = Buffer5(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf2.fill(fill, encoding);
        } else {
          buf2.fill(fill);
        }
      } else {
        buf2.fill(0);
      }
      return buf2;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer5(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  }
});

// node_modules/.pnpm/core-util-is@1.0.3/node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/.pnpm/core-util-is@1.0.3/node_modules/core-util-is/lib/util.js"(exports2) {
    init_buffer_polyfill();
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = require_buffer().Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/.pnpm/is-arguments@1.2.0/node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/.pnpm/is-arguments@1.2.0/node_modules/is-arguments/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var hasToStringTag = require_shams2()();
    var callBound = require_call_bound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value2) {
      if (hasToStringTag && value2 && typeof value2 === "object" && Symbol.toStringTag in value2) {
        return false;
      }
      return $toString(value2) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value2) {
      if (isStandardArguments(value2)) {
        return true;
      }
      return value2 !== null && typeof value2 === "object" && "length" in value2 && typeof value2.length === "number" && value2.length >= 0 && $toString(value2) !== "[object Array]" && "callee" in value2 && $toString(value2.callee) === "[object Function]";
    };
    var supportsStandardArguments = (function() {
      return isStandardArguments(arguments);
    })();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js
var require_is_regex = __commonJS({
  "node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var callBound = require_call_bound();
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var gOPD = require_gopd();
    var fn;
    if (hasToStringTag) {
      $exec = callBound("RegExp.prototype.exec");
      isRegexMarker = {};
      throwRegexMarker = function() {
        throw isRegexMarker;
      };
      badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
      };
      if (typeof Symbol.toPrimitive === "symbol") {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
      }
      fn = function isRegex(value2) {
        if (!value2 || typeof value2 !== "object") {
          return false;
        }
        var descriptor = (
          /** @type {NonNullable<typeof gOPD>} */
          gOPD(
            /** @type {{ lastIndex?: unknown }} */
            value2,
            "lastIndex"
          )
        );
        var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
        if (!hasLastIndexDataProperty) {
          return false;
        }
        try {
          $exec(
            value2,
            /** @type {string} */
            /** @type {unknown} */
            badStringifier
          );
        } catch (e) {
          return e === isRegexMarker;
        }
      };
    } else {
      $toString = callBound("Object.prototype.toString");
      regexClass = "[object RegExp]";
      fn = function isRegex(value2) {
        if (!value2 || typeof value2 !== "object" && typeof value2 !== "function") {
          return false;
        }
        return $toString(value2) === regexClass;
      };
    }
    var $exec;
    var isRegexMarker;
    var throwRegexMarker;
    var badStringifier;
    var $toString;
    var regexClass;
    module2.exports = fn;
  }
});

// node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js
var require_safe_regex_test = __commonJS({
  "node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var callBound = require_call_bound();
    var isRegex = require_is_regex();
    var $exec = callBound("RegExp.prototype.exec");
    var $TypeError = require_type();
    module2.exports = function regexTester(regex3) {
      if (!isRegex(regex3)) {
        throw new $TypeError("`regex` must be a RegExp");
      }
      return function test(s) {
        return $exec(regex3, s) !== null;
      };
    };
  }
});

// node_modules/.pnpm/generator-function@2.0.1/node_modules/generator-function/index.js
var require_generator_function = __commonJS({
  "node_modules/.pnpm/generator-function@2.0.1/node_modules/generator-function/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var cached = (
      /** @type {GeneratorFunctionConstructor} */
      function* () {
      }.constructor
    );
    module2.exports = () => cached;
  }
});

// node_modules/.pnpm/is-generator-function@1.1.2/node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "node_modules/.pnpm/is-generator-function@1.1.2/node_modules/is-generator-function/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var callBound = require_call_bound();
    var safeRegexTest = require_safe_regex_test();
    var isFnRegex = safeRegexTest(/^\s*(?:function)?\*/);
    var hasToStringTag = require_shams2()();
    var getProto = require_get_proto();
    var toStr = callBound("Object.prototype.toString");
    var fnToStr = callBound("Function.prototype.toString");
    var getGeneratorFunction = require_generator_function();
    module2.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex(fnToStr(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      var GeneratorFunction = getGeneratorFunction();
      return GeneratorFunction && getProto(fn) === GeneratorFunction.prototype;
    };
  }
});

// node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var isArgumentsObject = require_is_arguments();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray = require_is_typed_array();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    var bigIntValue;
    if (SymbolSupported) {
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    var symbolValue;
    function checkBoxedPrimitive(value2, prototypeValueOf) {
      if (typeof value2 !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value2);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports2.isArgumentsObject = isArgumentsObject;
    exports2.isGeneratorFunction = isGeneratorFunction;
    exports2.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports2.isPromise = isPromise;
    function isArrayBufferView(value2) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value2);
      }
      return isTypedArray(value2) || isDataView(value2);
    }
    exports2.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value2) {
      return whichTypedArray(value2) === "Uint8Array";
    }
    exports2.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value2) {
      return whichTypedArray(value2) === "Uint8ClampedArray";
    }
    exports2.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value2) {
      return whichTypedArray(value2) === "Uint16Array";
    }
    exports2.isUint16Array = isUint16Array;
    function isUint32Array(value2) {
      return whichTypedArray(value2) === "Uint32Array";
    }
    exports2.isUint32Array = isUint32Array;
    function isInt8Array(value2) {
      return whichTypedArray(value2) === "Int8Array";
    }
    exports2.isInt8Array = isInt8Array;
    function isInt16Array(value2) {
      return whichTypedArray(value2) === "Int16Array";
    }
    exports2.isInt16Array = isInt16Array;
    function isInt32Array(value2) {
      return whichTypedArray(value2) === "Int32Array";
    }
    exports2.isInt32Array = isInt32Array;
    function isFloat32Array(value2) {
      return whichTypedArray(value2) === "Float32Array";
    }
    exports2.isFloat32Array = isFloat32Array;
    function isFloat64Array(value2) {
      return whichTypedArray(value2) === "Float64Array";
    }
    exports2.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value2) {
      return whichTypedArray(value2) === "BigInt64Array";
    }
    exports2.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value2) {
      return whichTypedArray(value2) === "BigUint64Array";
    }
    exports2.isBigUint64Array = isBigUint64Array;
    function isMapToString(value2) {
      return ObjectToString(value2) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value2) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value2) : value2 instanceof Map;
    }
    exports2.isMap = isMap;
    function isSetToString(value2) {
      return ObjectToString(value2) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value2) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value2) : value2 instanceof Set;
    }
    exports2.isSet = isSet;
    function isWeakMapToString(value2) {
      return ObjectToString(value2) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value2) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value2) : value2 instanceof WeakMap;
    }
    exports2.isWeakMap = isWeakMap;
    function isWeakSetToString(value2) {
      return ObjectToString(value2) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value2) {
      return isWeakSetToString(value2);
    }
    exports2.isWeakSet = isWeakSet;
    function isArrayBufferToString(value2) {
      return ObjectToString(value2) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value2) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value2) : value2 instanceof ArrayBuffer;
    }
    exports2.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value2) {
      return ObjectToString(value2) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value2) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value2) : value2 instanceof DataView;
    }
    exports2.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value2) {
      return ObjectToString(value2) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value2) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value2) : value2 instanceof SharedArrayBufferCopy;
    }
    exports2.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value2) {
      return ObjectToString(value2) === "[object AsyncFunction]";
    }
    exports2.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value2) {
      return ObjectToString(value2) === "[object Map Iterator]";
    }
    exports2.isMapIterator = isMapIterator;
    function isSetIterator(value2) {
      return ObjectToString(value2) === "[object Set Iterator]";
    }
    exports2.isSetIterator = isSetIterator;
    function isGeneratorObject(value2) {
      return ObjectToString(value2) === "[object Generator]";
    }
    exports2.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value2) {
      return ObjectToString(value2) === "[object WebAssembly.Module]";
    }
    exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value2) {
      return checkBoxedPrimitive(value2, numberValue);
    }
    exports2.isNumberObject = isNumberObject;
    function isStringObject(value2) {
      return checkBoxedPrimitive(value2, stringValue);
    }
    exports2.isStringObject = isStringObject;
    function isBooleanObject(value2) {
      return checkBoxedPrimitive(value2, booleanValue);
    }
    exports2.isBooleanObject = isBooleanObject;
    function isBigIntObject(value2) {
      return BigIntSupported && checkBoxedPrimitive(value2, bigIntValue);
    }
    exports2.isBigIntObject = isBigIntObject;
    function isSymbolObject(value2) {
      return SymbolSupported && checkBoxedPrimitive(value2, symbolValue);
    }
    exports2.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value2) {
      return isNumberObject(value2) || isStringObject(value2) || isBooleanObject(value2) || isBigIntObject(value2) || isSymbolObject(value2);
    }
    exports2.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value2) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value2) || isSharedArrayBuffer(value2));
    }
    exports2.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports2, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  }
});

// node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js"(exports2, module2) {
    init_buffer_polyfill();
    module2.exports = function isBuffer3(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// node_modules/.pnpm/util@0.12.5/node_modules/util/util.js
var require_util2 = __commonJS({
  "node_modules/.pnpm/util@0.12.5/node_modules/util/util.js"(exports2) {
    init_buffer_polyfill();
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys.length; i++) {
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports2.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect4(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%") return "%";
        if (i >= len) return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect4(x);
        }
      }
      return str;
    };
    exports2.deprecate = function(fn, msg) {
      if (typeof import_process.default !== "undefined" && import_process.default.noDeprecation === true) {
        return fn;
      }
      if (typeof import_process.default === "undefined") {
        return function() {
          return exports2.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (import_process.default.throwDeprecation) {
            throw new Error(msg);
          } else if (import_process.default.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (import_process.default.env.NODE_DEBUG) {
      debugEnv = import_process.default.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    var debugEnv;
    exports2.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = import_process.default.pid;
          debugs[set] = function() {
            var msg = exports2.format.apply(exports2, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect4(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports2._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports2.inspect = inspect4;
    inspect4.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect4.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect4.styles[styleType];
      if (style) {
        return "\x1B[" + inspect4.colors[style][0] + "m" + str + "\x1B[" + inspect4.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array2) {
      var hash = {};
      array2.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value2, recurseTimes) {
      if (ctx.customInspect && value2 && isFunction(value2.inspect) && // Filter out the util module, it's inspect function is special
      value2.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
      !(value2.constructor && value2.constructor.prototype === value2)) {
        var ret = value2.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value2);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value2);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value2);
      }
      if (isError(value2) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value2);
      }
      if (keys.length === 0) {
        if (isFunction(value2)) {
          var name10 = value2.name ? ": " + value2.name : "";
          return ctx.stylize("[Function" + name10 + "]", "special");
        }
        if (isRegExp(value2)) {
          return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
        }
        if (isDate(value2)) {
          return ctx.stylize(Date.prototype.toString.call(value2), "date");
        }
        if (isError(value2)) {
          return formatError(value2);
        }
      }
      var base5 = "", array2 = false, braces = ["{", "}"];
      if (isArray(value2)) {
        array2 = true;
        braces = ["[", "]"];
      }
      if (isFunction(value2)) {
        var n2 = value2.name ? ": " + value2.name : "";
        base5 = " [Function" + n2 + "]";
      }
      if (isRegExp(value2)) {
        base5 = " " + RegExp.prototype.toString.call(value2);
      }
      if (isDate(value2)) {
        base5 = " " + Date.prototype.toUTCString.call(value2);
      }
      if (isError(value2)) {
        base5 = " " + formatError(value2);
      }
      if (keys.length === 0 && (!array2 || value2.length == 0)) {
        return braces[0] + base5 + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value2)) {
          return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value2);
      var output;
      if (array2) {
        output = formatArray(ctx, value2, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array2);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base5, braces);
    }
    function formatPrimitive(ctx, value2) {
      if (isUndefined(value2))
        return ctx.stylize("undefined", "undefined");
      if (isString(value2)) {
        var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value2))
        return ctx.stylize("" + value2, "number");
      if (isBoolean(value2))
        return ctx.stylize("" + value2, "boolean");
      if (isNull(value2))
        return ctx.stylize("null", "null");
    }
    function formatError(value2) {
      return "[" + Error.prototype.toString.call(value2) + "]";
    }
    function formatArray(ctx, value2, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value2.length; i < l; ++i) {
        if (hasOwnProperty(value2, String(i))) {
          output.push(formatProperty(
            ctx,
            value2,
            recurseTimes,
            visibleKeys,
            String(i),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value2,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array2) {
      var name10, str, desc;
      desc = Object.getOwnPropertyDescriptor(value2, key) || { value: value2[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name10 = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array2) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name10)) {
        if (array2 && key.match(/^\d+$/)) {
          return str;
        }
        name10 = JSON.stringify("" + key);
        if (name10.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name10 = name10.slice(1, -1);
          name10 = ctx.stylize(name10, "name");
        } else {
          name10 = name10.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name10 = ctx.stylize(name10, "string");
        }
      }
      return name10 + ": " + str;
    }
    function reduceToSingleString(output, base5, braces) {
      var numLinesEst = 0;
      var length6 = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length6 > 60) {
        return braces[0] + (base5 === "" ? "" : base5 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base5 + " " + output.join(", ") + " " + braces[1];
    }
    exports2.types = require_types();
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    exports2.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    exports2.types.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports2.isError = isError;
    exports2.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = require_isBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n2) {
      return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = /* @__PURE__ */ new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports2.log = function() {
      console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
    };
    exports2.inherits = require_inherits_browser();
    exports2._extend = function(origin, add2) {
      if (!add2 || !isObject(add2)) return origin;
      var keys = Object.keys(add2);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add2[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop2) {
      return Object.prototype.hasOwnProperty.call(obj, prop2);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? /* @__PURE__ */ Symbol("util.promisify.custom") : void 0;
    exports2.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve2, reject) {
          promiseResolve = resolve2;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value2) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value2);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports2.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            import_process.default.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            import_process.default.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports2.callbackify = callbackify;
  }
});

// node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    function _classCallCheck(instance3, Constructor) {
      if (!(instance3 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer5 = require_safe_buffer2().Buffer;
    var util = require_util2();
    function copyBuffer(src4, target, offset) {
      src4.copy(target, offset);
    }
    module2.exports = (function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat6(n2) {
        if (this.length === 0) return Buffer5.alloc(0);
        var ret = Buffer5.allocUnsafe(n2 >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    })();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js
var require_browser3 = __commonJS({
  "node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js"(exports2, module2) {
    init_buffer_polyfill();
    module2.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name10) {
      try {
        if (!globalThis.localStorage) return false;
      } catch (_) {
        return false;
      }
      var val = globalThis.localStorage[name10];
      if (null == val) return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = false ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits_browser();
    var internalUtil = {
      deprecate: require_browser3()
    };
    var Stream = require_stream_browser();
    var Buffer5 = require_safe_buffer2().Buffer;
    var OurUint8Array = (typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer5.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer5.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0) this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
      else this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object3) {
          if (realHasInstance.call(this, object3)) return true;
          if (this !== Writable) return false;
          return object3 && object3._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object3) {
        return object3 instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer5.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ended) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer5.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last2 = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last2) {
          last2.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer2 = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) pna.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value2) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value2;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits_browser();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false) this.readable = false;
      if (options && options.writable === false) this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended) return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value2) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value2;
        this._writableState.destroyed = value2;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/.pnpm/string_decoder@1.1.1/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/.pnpm/string_decoder@1.1.1/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer2().Buffer;
    var isEncoding = Buffer5.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer5.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer5.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf2) {
      if (buf2.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf2);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf2.length) return r ? r + this.text(buf2, i) : this.text(buf2, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf2) {
      if (this.lastNeed <= buf2.length) {
        buf2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf2.length);
      this.lastNeed -= buf2.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf2, i) {
      var j = buf2.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf2[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf2[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf2[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf2, p) {
      if ((buf2[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf2.length > 1) {
        if ((buf2[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf2.length > 2) {
          if ((buf2[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf2) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf2, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf2.length) {
        buf2.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf2.copy(this.lastChar, p, 0, buf2.length);
      this.lastNeed -= buf2.length;
    }
    function utf8Text(buf2, i) {
      var total = utf8CheckIncomplete(this, buf2, i);
      if (!this.lastNeed) return buf2.toString("utf8", i);
      this.lastTotal = total;
      var end = buf2.length - (total - this.lastNeed);
      buf2.copy(this.lastChar, 0, end);
      return buf2.toString("utf8", i, end);
    }
    function utf8End(buf2) {
      var r = buf2 && buf2.length ? this.write(buf2) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf2, i) {
      if ((buf2.length - i) % 2 === 0) {
        var r = buf2.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf2[buf2.length - 2];
            this.lastChar[1] = buf2[buf2.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf2[buf2.length - 1];
      return buf2.toString("utf16le", i, buf2.length - 1);
    }
    function utf16End(buf2) {
      var r = buf2 && buf2.length ? this.write(buf2) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf2, i) {
      var n2 = (buf2.length - i) % 3;
      if (n2 === 0) return buf2.toString("base64", i);
      this.lastNeed = 3 - n2;
      this.lastTotal = 3;
      if (n2 === 1) {
        this.lastChar[0] = buf2[buf2.length - 1];
      } else {
        this.lastChar[0] = buf2[buf2.length - 2];
        this.lastChar[1] = buf2[buf2.length - 1];
      }
      return buf2.toString("base64", i, buf2.length - n2);
    }
    function base64End(buf2) {
      var r = buf2 && buf2.length ? this.write(buf2) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf2) {
      return buf2.toString(this.encoding);
    }
    function simpleEnd(buf2) {
      return buf2 && buf2.length ? this.write(buf2) : "";
    }
  }
});

// node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray2();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer5 = require_safe_buffer2().Buffer;
    var OurUint8Array = (typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer5.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer5.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits_browser();
    var debugUtil = require_util2();
    var debug2 = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug2 = debugUtil.debuglog("stream");
    } else {
      debug2 = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0) this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
      else this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value2) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value2;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer5.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer5.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) stream.emit("error", new Error("stream.unshift() after end event"));
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n2) {
      if (n2 >= MAX_HWM) {
        n2 = MAX_HWM;
      } else {
        n2--;
        n2 |= n2 >>> 1;
        n2 |= n2 >>> 2;
        n2 |= n2 >>> 4;
        n2 |= n2 >>> 8;
        n2 |= n2 >>> 16;
        n2++;
      }
      return n2;
    }
    function howMuchToRead(n2, state) {
      if (n2 <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n2 !== n2) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n2 > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n2);
      if (n2 <= state.length) return n2;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n2) {
      debug2("read", n2);
      n2 = parseInt(n2, 10);
      var state = this._readableState;
      var nOrig = n2;
      if (n2 !== 0) state.emittedReadable = false;
      if (n2 === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug2("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n2 = howMuchToRead(n2, state);
      if (n2 === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug2("need readable", doRead);
      if (state.length === 0 || state.length - n2 < state.highWaterMark) {
        doRead = true;
        debug2("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug2("reading or ended", doRead);
      } else if (doRead) {
        debug2("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n2 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n2 > 0) ret = fromList(n2, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = true;
        n2 = 0;
      } else {
        state.length -= n2;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n2 && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug2("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync) pna.nextTick(emitReadable_, stream);
        else emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug2("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug2("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n2) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src4 = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) pna.nextTick(endFn);
      else src4.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug2("onunpipe");
        if (readable === src4) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug2("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src4);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug2("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src4.removeListener("end", onend);
        src4.removeListener("end", unpipe);
        src4.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      var increasedAwaitDrain = false;
      src4.on("data", ondata);
      function ondata(chunk) {
        debug2("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp) {
            debug2("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src4.pause();
        }
      }
      function onerror(er) {
        debug2("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug2("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug2("unpipe");
        src4.unpipe(dest);
      }
      dest.emit("pipe", src4);
      if (!state.flowing) {
        debug2("pipe resume");
        src4.resume();
      }
      return dest;
    };
    function pipeOnDrain(src4) {
      return function() {
        var state = src4._readableState;
        debug2("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src4, "data")) {
          state.flowing = true;
          flow(src4);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf2(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false) this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug2("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug2("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug2("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug2("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug2("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug2("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug2("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug2("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ (function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          })(i);
        }
      }
      for (var n2 = 0; n2 < kProxyEvents.length; n2++) {
        stream.on(kProxyEvents[n2], this.emit.bind(this, kProxyEvents[n2]));
      }
      this._read = function(n3) {
        debug2("wrapped _read", n3);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n2, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n2 || n2 >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.head.data;
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n2, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n2, list, hasStrings) {
      var ret;
      if (n2 < list.head.data.length) {
        ret = list.head.data.slice(0, n2);
        list.head.data = list.head.data.slice(n2);
      } else if (n2 === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n2, list) : copyFromBuffer(n2, list);
      }
      return ret;
    }
    function copyFromBufferString(n2, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n2 -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n2 > str.length ? str.length : n2;
        if (nb === str.length) ret += str;
        else ret += str.slice(0, n2);
        n2 -= nb;
        if (n2 === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) list.head = p.next;
            else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n2, list) {
      var ret = Buffer5.allocUnsafe(n2);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n2 -= p.data.length;
      while (p = p.next) {
        var buf2 = p.data;
        var nb = n2 > buf2.length ? buf2.length : n2;
        buf2.copy(ret, ret.length - n2, 0, nb);
        n2 -= nb;
        if (n2 === 0) {
          if (nb === buf2.length) {
            ++c;
            if (p.next) list.head = p.next;
            else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf2.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf2(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util());
    util.inherits = require_inherits_browser();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n2) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = Object.create(require_util());
    util.inherits = require_inherits_browser();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/readable-browser.js"(exports2, module2) {
    init_buffer_polyfill();
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
  }
});

// node_modules/.pnpm/hash-base@3.1.2/node_modules/hash-base/index.js
var require_hash_base = __commonJS({
  "node_modules/.pnpm/hash-base@3.1.2/node_modules/hash-base/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    var toBuffer = require_to_buffer2();
    var Transform = require_readable_browser().Transform;
    var inherits = require_inherits_browser();
    function HashBase(blockSize) {
      Transform.call(this);
      this._block = Buffer5.allocUnsafe(blockSize);
      this._blockSize = blockSize;
      this._blockOffset = 0;
      this._length = [0, 0, 0, 0];
      this._finalized = false;
    }
    inherits(HashBase, Transform);
    HashBase.prototype._transform = function(chunk, encoding, callback) {
      var error = null;
      try {
        this.update(chunk, encoding);
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype._flush = function(callback) {
      var error = null;
      try {
        this.push(this.digest());
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype.update = function(data, encoding) {
      if (this._finalized) {
        throw new Error("Digest already called");
      }
      var dataBuffer = toBuffer(data, encoding);
      var block = this._block;
      var offset = 0;
      while (this._blockOffset + dataBuffer.length - offset >= this._blockSize) {
        for (var i = this._blockOffset; i < this._blockSize; ) {
          block[i] = dataBuffer[offset];
          i += 1;
          offset += 1;
        }
        this._update();
        this._blockOffset = 0;
      }
      while (offset < dataBuffer.length) {
        block[this._blockOffset] = dataBuffer[offset];
        this._blockOffset += 1;
        offset += 1;
      }
      for (var j = 0, carry = dataBuffer.length * 8; carry > 0; ++j) {
        this._length[j] += carry;
        carry = this._length[j] / 4294967296 | 0;
        if (carry > 0) {
          this._length[j] -= 4294967296 * carry;
        }
      }
      return this;
    };
    HashBase.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    HashBase.prototype.digest = function(encoding) {
      if (this._finalized) {
        throw new Error("Digest already called");
      }
      this._finalized = true;
      var digest4 = this._digest();
      if (encoding !== void 0) {
        digest4 = digest4.toString(encoding);
      }
      this._block.fill(0);
      this._blockOffset = 0;
      for (var i = 0; i < 4; ++i) {
        this._length[i] = 0;
      }
      return digest4;
    };
    HashBase.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    module2.exports = HashBase;
  }
});

// node_modules/.pnpm/md5.js@1.3.5/node_modules/md5.js/index.js
var require_md5 = __commonJS({
  "node_modules/.pnpm/md5.js@1.3.5/node_modules/md5.js/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var inherits = require_inherits_browser();
    var HashBase = require_hash_base();
    var Buffer5 = require_safe_buffer().Buffer;
    var ARRAY16 = new Array(16);
    function MD5() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
    }
    inherits(MD5, HashBase);
    MD5.prototype._update = function() {
      var M = ARRAY16;
      for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);
      var a = this._a;
      var b = this._b;
      var c = this._c;
      var d = this._d;
      a = fnF(a, b, c, d, M[0], 3614090360, 7);
      d = fnF(d, a, b, c, M[1], 3905402710, 12);
      c = fnF(c, d, a, b, M[2], 606105819, 17);
      b = fnF(b, c, d, a, M[3], 3250441966, 22);
      a = fnF(a, b, c, d, M[4], 4118548399, 7);
      d = fnF(d, a, b, c, M[5], 1200080426, 12);
      c = fnF(c, d, a, b, M[6], 2821735955, 17);
      b = fnF(b, c, d, a, M[7], 4249261313, 22);
      a = fnF(a, b, c, d, M[8], 1770035416, 7);
      d = fnF(d, a, b, c, M[9], 2336552879, 12);
      c = fnF(c, d, a, b, M[10], 4294925233, 17);
      b = fnF(b, c, d, a, M[11], 2304563134, 22);
      a = fnF(a, b, c, d, M[12], 1804603682, 7);
      d = fnF(d, a, b, c, M[13], 4254626195, 12);
      c = fnF(c, d, a, b, M[14], 2792965006, 17);
      b = fnF(b, c, d, a, M[15], 1236535329, 22);
      a = fnG(a, b, c, d, M[1], 4129170786, 5);
      d = fnG(d, a, b, c, M[6], 3225465664, 9);
      c = fnG(c, d, a, b, M[11], 643717713, 14);
      b = fnG(b, c, d, a, M[0], 3921069994, 20);
      a = fnG(a, b, c, d, M[5], 3593408605, 5);
      d = fnG(d, a, b, c, M[10], 38016083, 9);
      c = fnG(c, d, a, b, M[15], 3634488961, 14);
      b = fnG(b, c, d, a, M[4], 3889429448, 20);
      a = fnG(a, b, c, d, M[9], 568446438, 5);
      d = fnG(d, a, b, c, M[14], 3275163606, 9);
      c = fnG(c, d, a, b, M[3], 4107603335, 14);
      b = fnG(b, c, d, a, M[8], 1163531501, 20);
      a = fnG(a, b, c, d, M[13], 2850285829, 5);
      d = fnG(d, a, b, c, M[2], 4243563512, 9);
      c = fnG(c, d, a, b, M[7], 1735328473, 14);
      b = fnG(b, c, d, a, M[12], 2368359562, 20);
      a = fnH(a, b, c, d, M[5], 4294588738, 4);
      d = fnH(d, a, b, c, M[8], 2272392833, 11);
      c = fnH(c, d, a, b, M[11], 1839030562, 16);
      b = fnH(b, c, d, a, M[14], 4259657740, 23);
      a = fnH(a, b, c, d, M[1], 2763975236, 4);
      d = fnH(d, a, b, c, M[4], 1272893353, 11);
      c = fnH(c, d, a, b, M[7], 4139469664, 16);
      b = fnH(b, c, d, a, M[10], 3200236656, 23);
      a = fnH(a, b, c, d, M[13], 681279174, 4);
      d = fnH(d, a, b, c, M[0], 3936430074, 11);
      c = fnH(c, d, a, b, M[3], 3572445317, 16);
      b = fnH(b, c, d, a, M[6], 76029189, 23);
      a = fnH(a, b, c, d, M[9], 3654602809, 4);
      d = fnH(d, a, b, c, M[12], 3873151461, 11);
      c = fnH(c, d, a, b, M[15], 530742520, 16);
      b = fnH(b, c, d, a, M[2], 3299628645, 23);
      a = fnI(a, b, c, d, M[0], 4096336452, 6);
      d = fnI(d, a, b, c, M[7], 1126891415, 10);
      c = fnI(c, d, a, b, M[14], 2878612391, 15);
      b = fnI(b, c, d, a, M[5], 4237533241, 21);
      a = fnI(a, b, c, d, M[12], 1700485571, 6);
      d = fnI(d, a, b, c, M[3], 2399980690, 10);
      c = fnI(c, d, a, b, M[10], 4293915773, 15);
      b = fnI(b, c, d, a, M[1], 2240044497, 21);
      a = fnI(a, b, c, d, M[8], 1873313359, 6);
      d = fnI(d, a, b, c, M[15], 4264355552, 10);
      c = fnI(c, d, a, b, M[6], 2734768916, 15);
      b = fnI(b, c, d, a, M[13], 1309151649, 21);
      a = fnI(a, b, c, d, M[4], 4149444226, 6);
      d = fnI(d, a, b, c, M[11], 3174756917, 10);
      c = fnI(c, d, a, b, M[2], 718787259, 15);
      b = fnI(b, c, d, a, M[9], 3951481745, 21);
      this._a = this._a + a | 0;
      this._b = this._b + b | 0;
      this._c = this._c + c | 0;
      this._d = this._d + d | 0;
    };
    MD5.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer2 = Buffer5.allocUnsafe(16);
      buffer2.writeInt32LE(this._a, 0);
      buffer2.writeInt32LE(this._b, 4);
      buffer2.writeInt32LE(this._c, 8);
      buffer2.writeInt32LE(this._d, 12);
      return buffer2;
    };
    function rotl2(x, n2) {
      return x << n2 | x >>> 32 - n2;
    }
    function fnF(a, b, c, d, m, k, s) {
      return rotl2(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
    }
    function fnG(a, b, c, d, m, k, s) {
      return rotl2(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
    }
    function fnH(a, b, c, d, m, k, s) {
      return rotl2(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
    }
    function fnI(a, b, c, d, m, k, s) {
      return rotl2(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
    }
    module2.exports = MD5;
  }
});

// node_modules/.pnpm/ripemd160@2.0.3/node_modules/ripemd160/index.js
var require_ripemd160 = __commonJS({
  "node_modules/.pnpm/ripemd160@2.0.3/node_modules/ripemd160/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var Buffer5 = require_buffer().Buffer;
    var inherits = require_inherits_browser();
    var HashBase = require_hash_base();
    var ARRAY16 = new Array(16);
    var zl = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var zr = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var sl = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sr = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
    var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
    var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function rotl2(x, n2) {
      return x << n2 | x >>> 32 - n2;
    }
    function fn1(a, b, c, d, e, m, k, s) {
      return rotl2(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
    }
    function fn2(a, b, c, d, e, m, k, s) {
      return rotl2(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
    }
    function fn3(a, b, c, d, e, m, k, s) {
      return rotl2(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
    }
    function fn4(a, b, c, d, e, m, k, s) {
      return rotl2(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
    }
    function fn5(a, b, c, d, e, m, k, s) {
      return rotl2(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
    }
    function RIPEMD1602() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
    }
    inherits(RIPEMD1602, HashBase);
    RIPEMD1602.prototype._update = function() {
      var words = ARRAY16;
      for (var j = 0; j < 16; ++j) {
        words[j] = this._block.readInt32LE(j * 4);
      }
      var al = this._a | 0;
      var bl = this._b | 0;
      var cl = this._c | 0;
      var dl = this._d | 0;
      var el = this._e | 0;
      var ar = this._a | 0;
      var br = this._b | 0;
      var cr = this._c | 0;
      var dr = this._d | 0;
      var er = this._e | 0;
      for (var i = 0; i < 80; i += 1) {
        var tl;
        var tr;
        if (i < 16) {
          tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
          tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
        } else if (i < 32) {
          tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
          tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
        } else if (i < 48) {
          tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
          tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
        } else if (i < 64) {
          tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
          tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
        } else {
          tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
          tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
        }
        al = el;
        el = dl;
        dl = rotl2(cl, 10);
        cl = bl;
        bl = tl;
        ar = er;
        er = dr;
        dr = rotl2(cr, 10);
        cr = br;
        br = tr;
      }
      var t = this._b + cl + dr | 0;
      this._b = this._c + dl + er | 0;
      this._c = this._d + el + ar | 0;
      this._d = this._e + al + br | 0;
      this._e = this._a + bl + cr | 0;
      this._a = t;
    };
    RIPEMD1602.prototype._digest = function() {
      this._block[this._blockOffset] = 128;
      this._blockOffset += 1;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer2 = Buffer5.alloc ? Buffer5.alloc(20) : new Buffer5(20);
      buffer2.writeInt32LE(this._a, 0);
      buffer2.writeInt32LE(this._b, 4);
      buffer2.writeInt32LE(this._c, 8);
      buffer2.writeInt32LE(this._d, 12);
      buffer2.writeInt32LE(this._e, 16);
      return buffer2;
    };
    module2.exports = RIPEMD1602;
  }
});

// node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/hash.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    var toBuffer = require_to_buffer();
    function Hash2(blockSize, finalSize) {
      this._block = Buffer5.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash2.prototype.update = function(data, enc) {
      data = toBuffer(data, enc || "utf8");
      var block = this._block;
      var blockSize = this._blockSize;
      var length6 = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length6; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length6 - offset, blockSize - assigned);
        for (var i = 0; i < remainder; i++) {
          block[assigned + i] = data[offset + i];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length6;
      return this;
    };
    Hash2.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash = this._hash();
      return enc ? hash.toString(enc) : hash;
    };
    Hash2.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module2.exports = Hash2;
  }
});

// node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/sha.js
var require_sha = __commonJS({
  "node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/sha.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var inherits = require_inherits_browser();
    var Hash2 = require_hash();
    var Buffer5 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    inherits(Sha, Hash2);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num2) {
      return num2 << 5 | num2 >>> 27;
    }
    function rotl30(num2) {
      return num2 << 30 | num2 >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) {
        return b & c | ~b & d;
      }
      if (s === 2) {
        return b & c | b & d | c & d;
      }
      return b ^ c ^ d;
    }
    Sha.prototype._update = function(M) {
      var w = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) {
        w[i] = M.readInt32BE(i * 4);
      }
      for (; i < 80; ++i) {
        w[i] = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
      }
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H = Buffer5.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha;
  }
});

// node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/sha1.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var inherits = require_inherits_browser();
    var Hash2 = require_hash();
    var Buffer5 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    inherits(Sha1, Hash2);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num2) {
      return num2 << 1 | num2 >>> 31;
    }
    function rotl5(num2) {
      return num2 << 5 | num2 >>> 27;
    }
    function rotl30(num2) {
      return num2 << 30 | num2 >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) {
        return b & c | ~b & d;
      }
      if (s === 2) {
        return b & c | b & d | c & d;
      }
      return b ^ c ^ d;
    }
    Sha1.prototype._update = function(M) {
      var w = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) {
        w[i] = M.readInt32BE(i * 4);
      }
      for (; i < 80; ++i) {
        w[i] = rotl1(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
      }
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H = Buffer5.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha1;
  }
});

// node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/sha256.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var inherits = require_inherits_browser();
    var Hash2 = require_hash();
    var Buffer5 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W = new Array(64);
    function Sha256() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    inherits(Sha256, Hash2);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
    }
    function sigma1(x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
    }
    function gamma0(x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
    }
    function gamma1(x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
    }
    Sha256.prototype._update = function(M) {
      var w = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h3 = this._h | 0;
      for (var i = 0; i < 16; ++i) {
        w[i] = M.readInt32BE(i * 4);
      }
      for (; i < 64; ++i) {
        w[i] = gamma1(w[i - 2]) + w[i - 7] + gamma0(w[i - 15]) + w[i - 16] | 0;
      }
      for (var j = 0; j < 64; ++j) {
        var T1 = h3 + sigma1(e) + ch(e, f, g) + K[j] + w[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;
        h3 = g;
        g = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
      this._f = f + this._f | 0;
      this._g = g + this._g | 0;
      this._h = h3 + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H = Buffer5.allocUnsafe(32);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);
      return H;
    };
    module2.exports = Sha256;
  }
});

// node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/sha224.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var inherits = require_inherits_browser();
    var Sha256 = require_sha256();
    var Hash2 = require_hash();
    var Buffer5 = require_safe_buffer().Buffer;
    var W = new Array(64);
    function Sha224() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    inherits(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H = Buffer5.allocUnsafe(28);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      return H;
    };
    module2.exports = Sha224;
  }
});

// node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/sha512.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var inherits = require_inherits_browser();
    var Hash2 = require_hash();
    var Buffer5 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W = new Array(160);
    function Sha512() {
      this.init();
      this._w = W;
      Hash2.call(this, 128, 112);
    }
    inherits(Sha512, Hash2);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
    }
    function sigma1(x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
    }
    function Gamma0(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
    }
    function Gamma0l(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
    }
    function Gamma1(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
    }
    function Gamma1l(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
    }
    function getCarry(a, b) {
      return a >>> 0 < b >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M) {
      var w = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i = 0; i < 32; i += 2) {
        w[i] = M.readInt32BE(i * 4);
        w[i + 1] = M.readInt32BE(i * 4 + 4);
      }
      for (; i < 160; i += 2) {
        var xh = w[i - 15 * 2];
        var xl = w[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = w[i - 2 * 2];
        xl = w[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = w[i - 7 * 2];
        var Wi7l = w[i - 7 * 2 + 1];
        var Wi16h = w[i - 16 * 2];
        var Wi16l = w[i - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        w[i] = Wih;
        w[i + 1] = Wil;
      }
      for (var j = 0; j < 160; j += 2) {
        Wih = w[j];
        Wil = w[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H = Buffer5.allocUnsafe(64);
      function writeInt64BE(h3, l, offset) {
        H.writeInt32BE(h3, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H;
    };
    module2.exports = Sha512;
  }
});

// node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/sha384.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var inherits = require_inherits_browser();
    var SHA5122 = require_sha512();
    var Hash2 = require_hash();
    var Buffer5 = require_safe_buffer().Buffer;
    var W = new Array(160);
    function Sha384() {
      this.init();
      this._w = W;
      Hash2.call(this, 128, 112);
    }
    inherits(Sha384, SHA5122);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H = Buffer5.allocUnsafe(48);
      function writeInt64BE(h3, l, offset) {
        H.writeInt32BE(h3, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H;
    };
    module2.exports = Sha384;
  }
});

// node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/index.js
var require_sha2 = __commonJS({
  "node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = function SHA(algorithm) {
      var alg = algorithm.toLowerCase();
      var Algorithm = module2.exports[alg];
      if (!Algorithm) {
        throw new Error(alg + " is not supported (we accept pull requests)");
      }
      return new Algorithm();
    };
    module2.exports.sha = require_sha();
    module2.exports.sha1 = require_sha1();
    module2.exports.sha224 = require_sha224();
    module2.exports.sha256 = require_sha256();
    module2.exports.sha384 = require_sha384();
    module2.exports.sha512 = require_sha512();
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser2 = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports2, module2) {
    init_buffer_polyfill();
    module2.exports = require_events().EventEmitter;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    function ownKeys(object3, enumerableOnly) {
      var keys = Object.keys(object3);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object3);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value2) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value2;
      }
      return obj;
    }
    function _classCallCheck(instance3, Constructor) {
      if (!(instance3 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require_buffer();
    var Buffer5 = _require.Buffer;
    var _require2 = require_util2();
    var inspect4 = _require2.inspect;
    var custom2 = inspect4 && inspect4.custom || "inspect";
    function copyBuffer(src4, target, offset) {
      Buffer5.prototype.copy.call(src4, target, offset);
    }
    module2.exports = /* @__PURE__ */ (function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join2(s) {
          if (this.length === 0) return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat6(n2) {
          if (this.length === 0) return Buffer5.alloc(0);
          var ret = Buffer5.allocUnsafe(n2 >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n2, hasStrings) {
          var ret;
          if (n2 < this.head.data.length) {
            ret = this.head.data.slice(0, n2);
            this.head.data = this.head.data.slice(n2);
          } else if (n2 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n2) : this._getBuffer(n2);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first2() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n2) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n2 -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n2 > str.length ? str.length : n2;
            if (nb === str.length) ret += str;
            else ret += str.slice(0, n2);
            n2 -= nb;
            if (n2 === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n2) {
          var ret = Buffer5.allocUnsafe(n2);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n2 -= p.data.length;
          while (p = p.next) {
            var buf2 = p.data;
            var nb = n2 > buf2.length ? buf2.length : n2;
            buf2.copy(ret, ret.length - n2, 0, nb);
            n2 -= nb;
            if (n2 === 0) {
              if (nb === buf2.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf2.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom2,
        value: function value2(_, options) {
          return inspect4(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    })();
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            import_process.default.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            import_process.default.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            import_process.default.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          import_process.default.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          import_process.default.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose) return;
      if (self2._readableState && !self2._readableState.emitClose) return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
      else stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes2 = {};
    function createErrorType(code10, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ (function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      })(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code10;
      codes2[code10] = NodeError;
    }
    function oneOf(expected14, thing) {
      if (Array.isArray(expected14)) {
        var len = expected14.length;
        expected14 = expected14.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected14.slice(0, len - 1).join(", "), ", or ") + expected14[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected14[0], " or ").concat(expected14[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected14[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected14));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name10, value2) {
      return 'The value "' + value2 + '" is invalid for option "' + name10 + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name10, expected14, actual) {
      var determiner;
      if (typeof expected14 === "string" && startsWith(expected14, "not ")) {
        determiner = "must not be";
        expected14 = expected14.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name10, " argument")) {
        msg = "The ".concat(name10, " ").concat(determiner, " ").concat(oneOf(expected14, "type"));
      } else {
        var type = includes(name10, ".") ? "property" : "argument";
        msg = 'The "'.concat(name10, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected14, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name10) {
      return "The " + name10 + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name10) {
      return "Cannot call " + name10 + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes2;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name10 = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name10, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable2 = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser3()
    };
    var Stream = require_stream_browser2();
    var Buffer5 = require_buffer().Buffer;
    var OurUint8Array = (typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer5.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer5.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy2();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value2(object3) {
          if (realHasInstance.call(this, object3)) return true;
          if (this !== Writable) return false;
          return object3 && object3._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object3) {
        return object3 instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex2();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      import_process.default.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        import_process.default.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer5.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ending) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer5.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last2 = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last2) {
          last2.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        import_process.default.nextTick(cb, er);
        import_process.default.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          import_process.default.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer2 = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          import_process.default.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) import_process.default.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value2) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value2;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex2 = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable2();
    var Writable = require_stream_writable2();
    require_inherits_browser()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended) return;
      import_process.default.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value2) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value2;
        this._writableState.destroyed = value2;
      }
    });
  }
});

// node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder2 = __commonJS({
  "node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    var isEncoding = Buffer5.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer5.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer5.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf2) {
      if (buf2.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf2);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf2.length) return r ? r + this.text(buf2, i) : this.text(buf2, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf2) {
      if (this.lastNeed <= buf2.length) {
        buf2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf2.length);
      this.lastNeed -= buf2.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf2, i) {
      var j = buf2.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf2[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf2[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf2[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf2, p) {
      if ((buf2[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf2.length > 1) {
        if ((buf2[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf2.length > 2) {
          if ((buf2[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf2) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf2, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf2.length) {
        buf2.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf2.copy(this.lastChar, p, 0, buf2.length);
      this.lastNeed -= buf2.length;
    }
    function utf8Text(buf2, i) {
      var total = utf8CheckIncomplete(this, buf2, i);
      if (!this.lastNeed) return buf2.toString("utf8", i);
      this.lastTotal = total;
      var end = buf2.length - (total - this.lastNeed);
      buf2.copy(this.lastChar, 0, end);
      return buf2.toString("utf8", i, end);
    }
    function utf8End(buf2) {
      var r = buf2 && buf2.length ? this.write(buf2) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf2, i) {
      if ((buf2.length - i) % 2 === 0) {
        var r = buf2.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf2[buf2.length - 2];
            this.lastChar[1] = buf2[buf2.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf2[buf2.length - 1];
      return buf2.toString("utf16le", i, buf2.length - 1);
    }
    function utf16End(buf2) {
      var r = buf2 && buf2.length ? this.write(buf2) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf2, i) {
      var n2 = (buf2.length - i) % 3;
      if (n2 === 0) return buf2.toString("base64", i);
      this.lastNeed = 3 - n2;
      this.lastTotal = 3;
      if (n2 === 1) {
        this.lastChar[0] = buf2[buf2.length - 1];
      } else {
        this.lastChar[0] = buf2[buf2.length - 2];
        this.lastChar[1] = buf2[buf2.length - 1];
      }
      return buf2.toString("base64", i, buf2.length - n2);
    }
    function base64End(buf2) {
      var r = buf2 && buf2.length ? this.write(buf2) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf2) {
      return buf2.toString(this.encoding);
    }
    function simpleEnd(buf2) {
      return buf2 && buf2.length ? this.write(buf2) : "";
    }
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable) onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value2) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value2;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = /* @__PURE__ */ Symbol("lastResolve");
    var kLastReject = /* @__PURE__ */ Symbol("lastReject");
    var kError = /* @__PURE__ */ Symbol("error");
    var kEnded = /* @__PURE__ */ Symbol("ended");
    var kLastPromise = /* @__PURE__ */ Symbol("lastPromise");
    var kHandlePromise = /* @__PURE__ */ Symbol("handlePromise");
    var kStream = /* @__PURE__ */ Symbol("stream");
    function createIterResult(value2, done) {
      return {
        value: value2,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve2 = iter[kLastResolve];
      if (resolve2 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve2(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      import_process.default.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve2, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve2(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve2, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve2, reject) {
            import_process.default.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve2(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve2, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve2(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value2(resolve2, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve2;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve2 = iterator[kLastResolve];
        if (resolve2 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve2(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports2, module2) {
    init_buffer_polyfill();
    module2.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable2 = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser2();
    var Buffer5 = require_buffer().Buffer;
    var OurUint8Array = (typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer5.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer5.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util2();
    var debug2;
    if (debugUtil && debugUtil.debuglog) {
      debug2 = debugUtil.debuglog("stream");
    } else {
      debug2 = function debug3() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy2();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from7;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder2().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex2();
      if (!(this instanceof Readable)) return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value2) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value2;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer5.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug2("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer5.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder2().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "") this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n2) {
      if (n2 >= MAX_HWM) {
        n2 = MAX_HWM;
      } else {
        n2--;
        n2 |= n2 >>> 1;
        n2 |= n2 >>> 2;
        n2 |= n2 >>> 4;
        n2 |= n2 >>> 8;
        n2 |= n2 >>> 16;
        n2++;
      }
      return n2;
    }
    function howMuchToRead(n2, state) {
      if (n2 <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n2 !== n2) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n2 > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n2);
      if (n2 <= state.length) return n2;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n2) {
      debug2("read", n2);
      n2 = parseInt(n2, 10);
      var state = this._readableState;
      var nOrig = n2;
      if (n2 !== 0) state.emittedReadable = false;
      if (n2 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug2("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n2 = howMuchToRead(n2, state);
      if (n2 === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug2("need readable", doRead);
      if (state.length === 0 || state.length - n2 < state.highWaterMark) {
        doRead = true;
        debug2("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug2("reading or ended", doRead);
      } else if (doRead) {
        debug2("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n2 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n2 > 0) ret = fromList(n2, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n2 = 0;
      } else {
        state.length -= n2;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n2 && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug2("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug2("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug2("emitReadable", state.flowing);
        state.emittedReadable = true;
        import_process.default.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug2("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        import_process.default.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug2("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n2) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src4 = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) import_process.default.nextTick(endFn);
      else src4.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug2("onunpipe");
        if (readable === src4) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug2("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src4);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug2("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src4.removeListener("end", onend);
        src4.removeListener("end", unpipe);
        src4.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      src4.on("data", ondata);
      function ondata(chunk) {
        debug2("ondata");
        var ret = dest.write(chunk);
        debug2("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp) {
            debug2("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src4.pause();
        }
      }
      function onerror(er) {
        debug2("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug2("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug2("unpipe");
        src4.unpipe(dest);
      }
      dest.emit("pipe", src4);
      if (!state.flowing) {
        debug2("pipe resume");
        src4.resume();
      }
      return dest;
    };
    function pipeOnDrain(src4) {
      return function pipeOnDrainFunctionResult() {
        var state = src4._readableState;
        debug2("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src4, "data")) {
          state.flowing = true;
          flow(src4);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
        return this;
      }
      var index = indexOf2(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug2("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            import_process.default.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        import_process.default.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        import_process.default.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug2("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug2("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        import_process.default.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug2("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug2("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug2("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug2("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug2("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug2("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ (function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          })(i);
        }
      }
      for (var n2 = 0; n2 < kProxyEvents.length; n2++) {
        stream.on(kProxyEvents[n2], this.emit.bind(this, kProxyEvents[n2]));
      }
      this._read = function(n3) {
        debug2("wrapped _read", n3);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n2, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n2 || n2 >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n2, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug2("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        import_process.default.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug2("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from7 === void 0) {
          from7 = require_from_browser();
        }
        return from7(Readable, iterable, opts);
      };
    }
    function indexOf2(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform2 = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex2();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n2) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough2 = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = PassThrough;
    var Transform = require_stream_transform2();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err) throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0) eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe3(from7, to) {
      return from7.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length) return noop;
      if (typeof streams[streams.length - 1] !== "function") return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe3);
    }
    module2.exports = pipeline;
  }
});

// node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js
var require_stream_browserify = __commonJS({
  "node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js"(exports2, module2) {
    init_buffer_polyfill();
    module2.exports = Stream;
    var EE = require_events().EventEmitter;
    var inherits = require_inherits_browser();
    inherits(Stream, EE);
    Stream.Readable = require_stream_readable2();
    Stream.Writable = require_stream_writable2();
    Stream.Duplex = require_stream_duplex2();
    Stream.Transform = require_stream_transform2();
    Stream.PassThrough = require_stream_passthrough2();
    Stream.finished = require_end_of_stream();
    Stream.pipeline = require_pipeline();
    Stream.Stream = Stream;
    function Stream() {
      EE.call(this);
    }
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node_modules/.pnpm/cipher-base@1.0.7/node_modules/cipher-base/index.js
var require_cipher_base = __commonJS({
  "node_modules/.pnpm/cipher-base@1.0.7/node_modules/cipher-base/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    var Transform = require_stream_browserify().Transform;
    var StringDecoder = require_string_decoder2().StringDecoder;
    var inherits = require_inherits_browser();
    var toBuffer = require_to_buffer();
    function CipherBase(hashMode) {
      Transform.call(this);
      this.hashMode = typeof hashMode === "string";
      if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
      } else {
        this["final"] = this._finalOrDigest;
      }
      if (this._final) {
        this.__final = this._final;
        this._final = null;
      }
      this._decoder = null;
      this._encoding = null;
    }
    inherits(CipherBase, Transform);
    CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
      var bufferData = toBuffer(data, inputEnc);
      var outData = this._update(bufferData);
      if (this.hashMode) {
        return this;
      }
      if (outputEnc) {
        outData = this._toString(outData, outputEnc);
      }
      return outData;
    };
    CipherBase.prototype.setAutoPadding = function() {
    };
    CipherBase.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    CipherBase.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    CipherBase.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    CipherBase.prototype._transform = function(data, _, next) {
      var err;
      try {
        if (this.hashMode) {
          this._update(data);
        } else {
          this.push(this._update(data));
        }
      } catch (e) {
        err = e;
      } finally {
        next(err);
      }
    };
    CipherBase.prototype._flush = function(done) {
      var err;
      try {
        this.push(this.__final());
      } catch (e) {
        err = e;
      }
      done(err);
    };
    CipherBase.prototype._finalOrDigest = function(outputEnc) {
      var outData = this.__final() || Buffer5.alloc(0);
      if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
      }
      return outData;
    };
    CipherBase.prototype._toString = function(value2, enc, fin) {
      if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
      }
      if (this._encoding !== enc) {
        throw new Error("can\u2019t switch encodings");
      }
      var out = this._decoder.write(value2);
      if (fin) {
        out += this._decoder.end();
      }
      return out;
    };
    module2.exports = CipherBase;
  }
});

// node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/browser.js
var require_browser4 = __commonJS({
  "node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/browser.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var inherits = require_inherits_browser();
    var MD5 = require_md5();
    var RIPEMD1602 = require_ripemd160();
    var sha4 = require_sha2();
    var Base = require_cipher_base();
    function Hash2(hash) {
      Base.call(this, "digest");
      this._hash = hash;
    }
    inherits(Hash2, Base);
    Hash2.prototype._update = function(data) {
      this._hash.update(data);
    };
    Hash2.prototype._final = function() {
      return this._hash.digest();
    };
    module2.exports = function createHash(alg) {
      alg = alg.toLowerCase();
      if (alg === "md5") return new MD5();
      if (alg === "rmd160" || alg === "ripemd160") return new RIPEMD1602();
      return new Hash2(sha4(alg));
    };
  }
});

// node_modules/.pnpm/create-hmac@1.1.7/node_modules/create-hmac/legacy.js
var require_legacy = __commonJS({
  "node_modules/.pnpm/create-hmac@1.1.7/node_modules/create-hmac/legacy.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var inherits = require_inherits_browser();
    var Buffer5 = require_safe_buffer().Buffer;
    var Base = require_cipher_base();
    var ZEROS = Buffer5.alloc(128);
    var blocksize = 64;
    function Hmac(alg, key) {
      Base.call(this, "digest");
      if (typeof key === "string") {
        key = Buffer5.from(key);
      }
      this._alg = alg;
      this._key = key;
      if (key.length > blocksize) {
        key = alg(key);
      } else if (key.length < blocksize) {
        key = Buffer5.concat([key, ZEROS], blocksize);
      }
      var ipad = this._ipad = Buffer5.allocUnsafe(blocksize);
      var opad = this._opad = Buffer5.allocUnsafe(blocksize);
      for (var i = 0; i < blocksize; i++) {
        ipad[i] = key[i] ^ 54;
        opad[i] = key[i] ^ 92;
      }
      this._hash = [ipad];
    }
    inherits(Hmac, Base);
    Hmac.prototype._update = function(data) {
      this._hash.push(data);
    };
    Hmac.prototype._final = function() {
      var h3 = this._alg(Buffer5.concat(this._hash));
      return this._alg(Buffer5.concat([this._opad, h3]));
    };
    module2.exports = Hmac;
  }
});

// node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/md5.js
var require_md52 = __commonJS({
  "node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/md5.js"(exports2, module2) {
    init_buffer_polyfill();
    var MD5 = require_md5();
    module2.exports = function(buffer2) {
      return new MD5().update(buffer2).digest();
    };
  }
});

// node_modules/.pnpm/create-hmac@1.1.7/node_modules/create-hmac/browser.js
var require_browser5 = __commonJS({
  "node_modules/.pnpm/create-hmac@1.1.7/node_modules/create-hmac/browser.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var inherits = require_inherits_browser();
    var Legacy = require_legacy();
    var Base = require_cipher_base();
    var Buffer5 = require_safe_buffer().Buffer;
    var md5 = require_md52();
    var RIPEMD1602 = require_ripemd160();
    var sha4 = require_sha2();
    var ZEROS = Buffer5.alloc(128);
    function Hmac(alg, key) {
      Base.call(this, "digest");
      if (typeof key === "string") {
        key = Buffer5.from(key);
      }
      var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
      this._alg = alg;
      this._key = key;
      if (key.length > blocksize) {
        var hash = alg === "rmd160" ? new RIPEMD1602() : sha4(alg);
        key = hash.update(key).digest();
      } else if (key.length < blocksize) {
        key = Buffer5.concat([key, ZEROS], blocksize);
      }
      var ipad = this._ipad = Buffer5.allocUnsafe(blocksize);
      var opad = this._opad = Buffer5.allocUnsafe(blocksize);
      for (var i = 0; i < blocksize; i++) {
        ipad[i] = key[i] ^ 54;
        opad[i] = key[i] ^ 92;
      }
      this._hash = alg === "rmd160" ? new RIPEMD1602() : sha4(alg);
      this._hash.update(ipad);
    }
    inherits(Hmac, Base);
    Hmac.prototype._update = function(data) {
      this._hash.update(data);
    };
    Hmac.prototype._final = function() {
      var h3 = this._hash.digest();
      var hash = this._alg === "rmd160" ? new RIPEMD1602() : sha4(this._alg);
      return hash.update(this._opad).update(h3).digest();
    };
    module2.exports = function createHmac(alg, key) {
      alg = alg.toLowerCase();
      if (alg === "rmd160" || alg === "ripemd160") {
        return new Hmac("rmd160", key);
      }
      if (alg === "md5") {
        return new Legacy(md5, key);
      }
      return new Hmac(alg, key);
    };
  }
});

// node_modules/.pnpm/browserify-sign@4.2.5/node_modules/browserify-sign/browser/algorithms.json
var require_algorithms = __commonJS({
  "node_modules/.pnpm/browserify-sign@4.2.5/node_modules/browserify-sign/browser/algorithms.json"(exports2, module2) {
    module2.exports = {
      sha224WithRSAEncryption: {
        sign: "rsa",
        hash: "sha224",
        id: "302d300d06096086480165030402040500041c"
      },
      "RSA-SHA224": {
        sign: "ecdsa/rsa",
        hash: "sha224",
        id: "302d300d06096086480165030402040500041c"
      },
      sha256WithRSAEncryption: {
        sign: "rsa",
        hash: "sha256",
        id: "3031300d060960864801650304020105000420"
      },
      "RSA-SHA256": {
        sign: "ecdsa/rsa",
        hash: "sha256",
        id: "3031300d060960864801650304020105000420"
      },
      sha384WithRSAEncryption: {
        sign: "rsa",
        hash: "sha384",
        id: "3041300d060960864801650304020205000430"
      },
      "RSA-SHA384": {
        sign: "ecdsa/rsa",
        hash: "sha384",
        id: "3041300d060960864801650304020205000430"
      },
      sha512WithRSAEncryption: {
        sign: "rsa",
        hash: "sha512",
        id: "3051300d060960864801650304020305000440"
      },
      "RSA-SHA512": {
        sign: "ecdsa/rsa",
        hash: "sha512",
        id: "3051300d060960864801650304020305000440"
      },
      "RSA-SHA1": {
        sign: "rsa",
        hash: "sha1",
        id: "3021300906052b0e03021a05000414"
      },
      "ecdsa-with-SHA1": {
        sign: "ecdsa",
        hash: "sha1",
        id: ""
      },
      sha256: {
        sign: "ecdsa",
        hash: "sha256",
        id: ""
      },
      sha224: {
        sign: "ecdsa",
        hash: "sha224",
        id: ""
      },
      sha384: {
        sign: "ecdsa",
        hash: "sha384",
        id: ""
      },
      sha512: {
        sign: "ecdsa",
        hash: "sha512",
        id: ""
      },
      "DSA-SHA": {
        sign: "dsa",
        hash: "sha1",
        id: ""
      },
      "DSA-SHA1": {
        sign: "dsa",
        hash: "sha1",
        id: ""
      },
      DSA: {
        sign: "dsa",
        hash: "sha1",
        id: ""
      },
      "DSA-WITH-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
      },
      "DSA-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
      },
      "DSA-WITH-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
      },
      "DSA-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
      },
      "DSA-WITH-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
      },
      "DSA-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
      },
      "DSA-WITH-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
      },
      "DSA-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
      },
      "DSA-RIPEMD160": {
        sign: "dsa",
        hash: "rmd160",
        id: ""
      },
      ripemd160WithRSA: {
        sign: "rsa",
        hash: "rmd160",
        id: "3021300906052b2403020105000414"
      },
      "RSA-RIPEMD160": {
        sign: "rsa",
        hash: "rmd160",
        id: "3021300906052b2403020105000414"
      },
      md5WithRSAEncryption: {
        sign: "rsa",
        hash: "md5",
        id: "3020300c06082a864886f70d020505000410"
      },
      "RSA-MD5": {
        sign: "rsa",
        hash: "md5",
        id: "3020300c06082a864886f70d020505000410"
      }
    };
  }
});

// node_modules/.pnpm/browserify-sign@4.2.5/node_modules/browserify-sign/algos.js
var require_algos = __commonJS({
  "node_modules/.pnpm/browserify-sign@4.2.5/node_modules/browserify-sign/algos.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = require_algorithms();
  }
});

// node_modules/.pnpm/pbkdf2@3.1.5/node_modules/pbkdf2/lib/precondition.js
var require_precondition = __commonJS({
  "node_modules/.pnpm/pbkdf2@3.1.5/node_modules/pbkdf2/lib/precondition.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var $isFinite = isFinite;
    var MAX_ALLOC = Math.pow(2, 30) - 1;
    module2.exports = function(iterations, keylen) {
      if (typeof iterations !== "number") {
        throw new TypeError("Iterations not a number");
      }
      if (iterations < 0 || !$isFinite(iterations)) {
        throw new TypeError("Bad iterations");
      }
      if (typeof keylen !== "number") {
        throw new TypeError("Key length not a number");
      }
      if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
        throw new TypeError("Bad key length");
      }
    };
  }
});

// node_modules/.pnpm/pbkdf2@3.1.5/node_modules/pbkdf2/lib/default-encoding.js
var require_default_encoding = __commonJS({
  "node_modules/.pnpm/pbkdf2@3.1.5/node_modules/pbkdf2/lib/default-encoding.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var defaultEncoding;
    if (globalThis.process && globalThis.process.browser) {
      defaultEncoding = "utf-8";
    } else if (globalThis.process && globalThis.process.version) {
      pVersionMajor = parseInt(import_process.default.version.split(".")[0].slice(1), 10);
      defaultEncoding = pVersionMajor >= 6 ? "utf-8" : "binary";
    } else {
      defaultEncoding = "utf-8";
    }
    var pVersionMajor;
    module2.exports = defaultEncoding;
  }
});

// node_modules/.pnpm/pbkdf2@3.1.5/node_modules/pbkdf2/lib/to-buffer.js
var require_to_buffer3 = __commonJS({
  "node_modules/.pnpm/pbkdf2@3.1.5/node_modules/pbkdf2/lib/to-buffer.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    var toBuffer = require_to_buffer();
    var useUint8Array = typeof Uint8Array !== "undefined";
    var useArrayBuffer = useUint8Array && typeof ArrayBuffer !== "undefined";
    var isView = useArrayBuffer && ArrayBuffer.isView;
    module2.exports = function(thing, encoding, name10) {
      if (typeof thing === "string" || Buffer5.isBuffer(thing) || useUint8Array && thing instanceof Uint8Array || isView && isView(thing)) {
        return toBuffer(thing, encoding);
      }
      throw new TypeError(name10 + " must be a string, a Buffer, a Uint8Array, or a DataView");
    };
  }
});

// node_modules/.pnpm/pbkdf2@3.1.5/node_modules/pbkdf2/lib/sync-browser.js
var require_sync_browser = __commonJS({
  "node_modules/.pnpm/pbkdf2@3.1.5/node_modules/pbkdf2/lib/sync-browser.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var md5 = require_md52();
    var RIPEMD1602 = require_ripemd160();
    var sha4 = require_sha2();
    var Buffer5 = require_safe_buffer().Buffer;
    var checkParameters = require_precondition();
    var defaultEncoding = require_default_encoding();
    var toBuffer = require_to_buffer3();
    var ZEROS = Buffer5.alloc(128);
    var sizes = {
      __proto__: null,
      md5: 16,
      sha1: 20,
      sha224: 28,
      sha256: 32,
      sha384: 48,
      sha512: 64,
      "sha512-256": 32,
      ripemd160: 20,
      rmd160: 20
    };
    var mapping = {
      __proto__: null,
      "sha-1": "sha1",
      "sha-224": "sha224",
      "sha-256": "sha256",
      "sha-384": "sha384",
      "sha-512": "sha512",
      "ripemd-160": "ripemd160"
    };
    function rmd160Func(data) {
      return new RIPEMD1602().update(data).digest();
    }
    function getDigest(alg) {
      function shaFunc(data) {
        return sha4(alg).update(data).digest();
      }
      if (alg === "rmd160" || alg === "ripemd160") {
        return rmd160Func;
      }
      if (alg === "md5") {
        return md5;
      }
      return shaFunc;
    }
    function Hmac(alg, key, saltLen) {
      var hash = getDigest(alg);
      var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
      if (key.length > blocksize) {
        key = hash(key);
      } else if (key.length < blocksize) {
        key = Buffer5.concat([key, ZEROS], blocksize);
      }
      var ipad = Buffer5.allocUnsafe(blocksize + sizes[alg]);
      var opad = Buffer5.allocUnsafe(blocksize + sizes[alg]);
      for (var i = 0; i < blocksize; i++) {
        ipad[i] = key[i] ^ 54;
        opad[i] = key[i] ^ 92;
      }
      var ipad1 = Buffer5.allocUnsafe(blocksize + saltLen + 4);
      ipad.copy(ipad1, 0, 0, blocksize);
      this.ipad1 = ipad1;
      this.ipad2 = ipad;
      this.opad = opad;
      this.alg = alg;
      this.blocksize = blocksize;
      this.hash = hash;
      this.size = sizes[alg];
    }
    Hmac.prototype.run = function(data, ipad) {
      data.copy(ipad, this.blocksize);
      var h3 = this.hash(ipad);
      h3.copy(this.opad, this.blocksize);
      return this.hash(this.opad);
    };
    function pbkdf2(password, salt, iterations, keylen, digest4) {
      checkParameters(iterations, keylen);
      password = toBuffer(password, defaultEncoding, "Password");
      salt = toBuffer(salt, defaultEncoding, "Salt");
      var lowerDigest = (digest4 || "sha1").toLowerCase();
      var mappedDigest = mapping[lowerDigest] || lowerDigest;
      var size = sizes[mappedDigest];
      if (typeof size !== "number" || !size) {
        throw new TypeError("Digest algorithm not supported: " + digest4);
      }
      var hmac3 = new Hmac(mappedDigest, password, salt.length);
      var DK = Buffer5.allocUnsafe(keylen);
      var block1 = Buffer5.allocUnsafe(salt.length + 4);
      salt.copy(block1, 0, 0, salt.length);
      var destPos = 0;
      var hLen = size;
      var l = Math.ceil(keylen / hLen);
      for (var i = 1; i <= l; i++) {
        block1.writeUInt32BE(i, salt.length);
        var T = hmac3.run(block1, hmac3.ipad1);
        var U = T;
        for (var j = 1; j < iterations; j++) {
          U = hmac3.run(U, hmac3.ipad2);
          for (var k = 0; k < hLen; k++) {
            T[k] ^= U[k];
          }
        }
        T.copy(DK, destPos);
        destPos += hLen;
      }
      return DK;
    }
    module2.exports = pbkdf2;
  }
});

// node_modules/.pnpm/pbkdf2@3.1.5/node_modules/pbkdf2/lib/async.js
var require_async = __commonJS({
  "node_modules/.pnpm/pbkdf2@3.1.5/node_modules/pbkdf2/lib/async.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    var checkParameters = require_precondition();
    var defaultEncoding = require_default_encoding();
    var sync = require_sync_browser();
    var toBuffer = require_to_buffer3();
    var ZERO_BUF;
    var subtle = globalThis.crypto && globalThis.crypto.subtle;
    var toBrowser = {
      sha: "SHA-1",
      "sha-1": "SHA-1",
      sha1: "SHA-1",
      sha256: "SHA-256",
      "sha-256": "SHA-256",
      sha384: "SHA-384",
      "sha-384": "SHA-384",
      "sha-512": "SHA-512",
      sha512: "SHA-512"
    };
    var checks = [];
    var nextTick;
    function getNextTick() {
      if (nextTick) {
        return nextTick;
      }
      if (globalThis.process && globalThis.process.nextTick) {
        nextTick = globalThis.process.nextTick;
      } else if (globalThis.queueMicrotask) {
        nextTick = globalThis.queueMicrotask;
      } else if (globalThis.setImmediate) {
        nextTick = globalThis.setImmediate;
      } else {
        nextTick = globalThis.setTimeout;
      }
      return nextTick;
    }
    function browserPbkdf2(password, salt, iterations, length6, algo) {
      return subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(key) {
        return subtle.deriveBits({
          name: "PBKDF2",
          salt,
          iterations,
          hash: {
            name: algo
          }
        }, key, length6 << 3);
      }).then(function(res) {
        return Buffer5.from(res);
      });
    }
    function checkNative(algo) {
      if (globalThis.process && !globalThis.process.browser) {
        return Promise.resolve(false);
      }
      if (!subtle || !subtle.importKey || !subtle.deriveBits) {
        return Promise.resolve(false);
      }
      if (checks[algo] !== void 0) {
        return checks[algo];
      }
      ZERO_BUF = ZERO_BUF || Buffer5.alloc(8);
      var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(
        function() {
          return true;
        },
        function() {
          return false;
        }
      );
      checks[algo] = prom;
      return prom;
    }
    function resolvePromise(promise, callback) {
      promise.then(function(out) {
        getNextTick()(function() {
          callback(null, out);
        });
      }, function(e) {
        getNextTick()(function() {
          callback(e);
        });
      });
    }
    module2.exports = function(password, salt, iterations, keylen, digest4, callback) {
      if (typeof digest4 === "function") {
        callback = digest4;
        digest4 = void 0;
      }
      checkParameters(iterations, keylen);
      password = toBuffer(password, defaultEncoding, "Password");
      salt = toBuffer(salt, defaultEncoding, "Salt");
      if (typeof callback !== "function") {
        throw new Error("No callback provided to pbkdf2");
      }
      digest4 = digest4 || "sha1";
      var algo = toBrowser[digest4.toLowerCase()];
      if (!algo || typeof globalThis.Promise !== "function") {
        getNextTick()(function() {
          var out;
          try {
            out = sync(password, salt, iterations, keylen, digest4);
          } catch (e) {
            callback(e);
            return;
          }
          callback(null, out);
        });
        return;
      }
      resolvePromise(checkNative(algo).then(function(resp) {
        if (resp) {
          return browserPbkdf2(password, salt, iterations, keylen, algo);
        }
        return sync(password, salt, iterations, keylen, digest4);
      }), callback);
    };
  }
});

// node_modules/.pnpm/pbkdf2@3.1.5/node_modules/pbkdf2/browser.js
var require_browser6 = __commonJS({
  "node_modules/.pnpm/pbkdf2@3.1.5/node_modules/pbkdf2/browser.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    exports2.pbkdf2 = require_async();
    exports2.pbkdf2Sync = require_sync_browser();
  }
});

// node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/utils.js
var require_utils3 = __commonJS({
  "node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/utils.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    exports2.readUInt32BE = function readUInt32BE(bytes, off) {
      var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
      return res >>> 0;
    };
    exports2.writeUInt32BE = function writeUInt32BE(bytes, value2, off) {
      bytes[0 + off] = value2 >>> 24;
      bytes[1 + off] = value2 >>> 16 & 255;
      bytes[2 + off] = value2 >>> 8 & 255;
      bytes[3 + off] = value2 & 255;
    };
    exports2.ip = function ip(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      for (var i = 6; i >= 0; i -= 2) {
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inR >>> j + i & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inL >>> j + i & 1;
        }
      }
      for (var i = 6; i >= 0; i -= 2) {
        for (var j = 1; j <= 25; j += 8) {
          outR <<= 1;
          outR |= inR >>> j + i & 1;
        }
        for (var j = 1; j <= 25; j += 8) {
          outR <<= 1;
          outR |= inL >>> j + i & 1;
        }
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    exports2.rip = function rip(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      for (var i = 0; i < 4; i++) {
        for (var j = 24; j >= 0; j -= 8) {
          outL <<= 1;
          outL |= inR >>> j + i & 1;
          outL <<= 1;
          outL |= inL >>> j + i & 1;
        }
      }
      for (var i = 4; i < 8; i++) {
        for (var j = 24; j >= 0; j -= 8) {
          outR <<= 1;
          outR |= inR >>> j + i & 1;
          outR <<= 1;
          outR |= inL >>> j + i & 1;
        }
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    exports2.pc1 = function pc1(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      for (var i = 7; i >= 5; i--) {
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inR >> j + i & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inL >> j + i & 1;
        }
      }
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inR >> j + i & 1;
      }
      for (var i = 1; i <= 3; i++) {
        for (var j = 0; j <= 24; j += 8) {
          outR <<= 1;
          outR |= inR >> j + i & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outR <<= 1;
          outR |= inL >> j + i & 1;
        }
      }
      for (var j = 0; j <= 24; j += 8) {
        outR <<= 1;
        outR |= inL >> j + i & 1;
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    exports2.r28shl = function r28shl(num2, shift) {
      return num2 << shift & 268435455 | num2 >>> 28 - shift;
    };
    var pc2table = [
      // inL => outL
      14,
      11,
      17,
      4,
      27,
      23,
      25,
      0,
      13,
      22,
      7,
      18,
      5,
      9,
      16,
      24,
      2,
      20,
      12,
      21,
      1,
      8,
      15,
      26,
      // inR => outR
      15,
      4,
      25,
      19,
      9,
      1,
      26,
      16,
      5,
      11,
      23,
      8,
      12,
      7,
      17,
      0,
      22,
      3,
      10,
      14,
      6,
      20,
      27,
      24
    ];
    exports2.pc2 = function pc2(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      var len = pc2table.length >>> 1;
      for (var i = 0; i < len; i++) {
        outL <<= 1;
        outL |= inL >>> pc2table[i] & 1;
      }
      for (var i = len; i < pc2table.length; i++) {
        outR <<= 1;
        outR |= inR >>> pc2table[i] & 1;
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    exports2.expand = function expand(r, out, off) {
      var outL = 0;
      var outR = 0;
      outL = (r & 1) << 5 | r >>> 27;
      for (var i = 23; i >= 15; i -= 4) {
        outL <<= 6;
        outL |= r >>> i & 63;
      }
      for (var i = 11; i >= 3; i -= 4) {
        outR |= r >>> i & 63;
        outR <<= 6;
      }
      outR |= (r & 31) << 1 | r >>> 31;
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    var sTable = [
      14,
      0,
      4,
      15,
      13,
      7,
      1,
      4,
      2,
      14,
      15,
      2,
      11,
      13,
      8,
      1,
      3,
      10,
      10,
      6,
      6,
      12,
      12,
      11,
      5,
      9,
      9,
      5,
      0,
      3,
      7,
      8,
      4,
      15,
      1,
      12,
      14,
      8,
      8,
      2,
      13,
      4,
      6,
      9,
      2,
      1,
      11,
      7,
      15,
      5,
      12,
      11,
      9,
      3,
      7,
      14,
      3,
      10,
      10,
      0,
      5,
      6,
      0,
      13,
      15,
      3,
      1,
      13,
      8,
      4,
      14,
      7,
      6,
      15,
      11,
      2,
      3,
      8,
      4,
      14,
      9,
      12,
      7,
      0,
      2,
      1,
      13,
      10,
      12,
      6,
      0,
      9,
      5,
      11,
      10,
      5,
      0,
      13,
      14,
      8,
      7,
      10,
      11,
      1,
      10,
      3,
      4,
      15,
      13,
      4,
      1,
      2,
      5,
      11,
      8,
      6,
      12,
      7,
      6,
      12,
      9,
      0,
      3,
      5,
      2,
      14,
      15,
      9,
      10,
      13,
      0,
      7,
      9,
      0,
      14,
      9,
      6,
      3,
      3,
      4,
      15,
      6,
      5,
      10,
      1,
      2,
      13,
      8,
      12,
      5,
      7,
      14,
      11,
      12,
      4,
      11,
      2,
      15,
      8,
      1,
      13,
      1,
      6,
      10,
      4,
      13,
      9,
      0,
      8,
      6,
      15,
      9,
      3,
      8,
      0,
      7,
      11,
      4,
      1,
      15,
      2,
      14,
      12,
      3,
      5,
      11,
      10,
      5,
      14,
      2,
      7,
      12,
      7,
      13,
      13,
      8,
      14,
      11,
      3,
      5,
      0,
      6,
      6,
      15,
      9,
      0,
      10,
      3,
      1,
      4,
      2,
      7,
      8,
      2,
      5,
      12,
      11,
      1,
      12,
      10,
      4,
      14,
      15,
      9,
      10,
      3,
      6,
      15,
      9,
      0,
      0,
      6,
      12,
      10,
      11,
      1,
      7,
      13,
      13,
      8,
      15,
      9,
      1,
      4,
      3,
      5,
      14,
      11,
      5,
      12,
      2,
      7,
      8,
      2,
      4,
      14,
      2,
      14,
      12,
      11,
      4,
      2,
      1,
      12,
      7,
      4,
      10,
      7,
      11,
      13,
      6,
      1,
      8,
      5,
      5,
      0,
      3,
      15,
      15,
      10,
      13,
      3,
      0,
      9,
      14,
      8,
      9,
      6,
      4,
      11,
      2,
      8,
      1,
      12,
      11,
      7,
      10,
      1,
      13,
      14,
      7,
      2,
      8,
      13,
      15,
      6,
      9,
      15,
      12,
      0,
      5,
      9,
      6,
      10,
      3,
      4,
      0,
      5,
      14,
      3,
      12,
      10,
      1,
      15,
      10,
      4,
      15,
      2,
      9,
      7,
      2,
      12,
      6,
      9,
      8,
      5,
      0,
      6,
      13,
      1,
      3,
      13,
      4,
      14,
      14,
      0,
      7,
      11,
      5,
      3,
      11,
      8,
      9,
      4,
      14,
      3,
      15,
      2,
      5,
      12,
      2,
      9,
      8,
      5,
      12,
      15,
      3,
      10,
      7,
      11,
      0,
      14,
      4,
      1,
      10,
      7,
      1,
      6,
      13,
      0,
      11,
      8,
      6,
      13,
      4,
      13,
      11,
      0,
      2,
      11,
      14,
      7,
      15,
      4,
      0,
      9,
      8,
      1,
      13,
      10,
      3,
      14,
      12,
      3,
      9,
      5,
      7,
      12,
      5,
      2,
      10,
      15,
      6,
      8,
      1,
      6,
      1,
      6,
      4,
      11,
      11,
      13,
      13,
      8,
      12,
      1,
      3,
      4,
      7,
      10,
      14,
      7,
      10,
      9,
      15,
      5,
      6,
      0,
      8,
      15,
      0,
      14,
      5,
      2,
      9,
      3,
      2,
      12,
      13,
      1,
      2,
      15,
      8,
      13,
      4,
      8,
      6,
      10,
      15,
      3,
      11,
      7,
      1,
      4,
      10,
      12,
      9,
      5,
      3,
      6,
      14,
      11,
      5,
      0,
      0,
      14,
      12,
      9,
      7,
      2,
      7,
      2,
      11,
      1,
      4,
      14,
      1,
      7,
      9,
      4,
      12,
      10,
      14,
      8,
      2,
      13,
      0,
      15,
      6,
      12,
      10,
      9,
      13,
      0,
      15,
      3,
      3,
      5,
      5,
      6,
      8,
      11
    ];
    exports2.substitute = function substitute(inL, inR) {
      var out = 0;
      for (var i = 0; i < 4; i++) {
        var b = inL >>> 18 - i * 6 & 63;
        var sb = sTable[i * 64 + b];
        out <<= 4;
        out |= sb;
      }
      for (var i = 0; i < 4; i++) {
        var b = inR >>> 18 - i * 6 & 63;
        var sb = sTable[4 * 64 + i * 64 + b];
        out <<= 4;
        out |= sb;
      }
      return out >>> 0;
    };
    var permuteTable = [
      16,
      25,
      12,
      11,
      3,
      20,
      4,
      15,
      31,
      17,
      9,
      6,
      27,
      14,
      1,
      22,
      30,
      24,
      8,
      18,
      0,
      5,
      29,
      23,
      13,
      19,
      2,
      26,
      10,
      21,
      28,
      7
    ];
    exports2.permute = function permute(num2) {
      var out = 0;
      for (var i = 0; i < permuteTable.length; i++) {
        out <<= 1;
        out |= num2 >>> permuteTable[i] & 1;
      }
      return out >>> 0;
    };
    exports2.padSplit = function padSplit(num2, size, group) {
      var str = num2.toString(2);
      while (str.length < size)
        str = "0" + str;
      var out = [];
      for (var i = 0; i < size; i += group)
        out.push(str.slice(i, i + group));
      return out.join(" ");
    };
  }
});

// node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/cipher.js
var require_cipher = __commonJS({
  "node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/cipher.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var assert3 = require_minimalistic_assert();
    function Cipher(options) {
      this.options = options;
      this.type = this.options.type;
      this.blockSize = 8;
      this._init();
      this.buffer = new Array(this.blockSize);
      this.bufferOff = 0;
      this.padding = options.padding !== false;
    }
    module2.exports = Cipher;
    Cipher.prototype._init = function _init() {
    };
    Cipher.prototype.update = function update(data) {
      if (data.length === 0)
        return [];
      if (this.type === "decrypt")
        return this._updateDecrypt(data);
      else
        return this._updateEncrypt(data);
    };
    Cipher.prototype._buffer = function _buffer(data, off) {
      var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
      for (var i = 0; i < min; i++)
        this.buffer[this.bufferOff + i] = data[off + i];
      this.bufferOff += min;
      return min;
    };
    Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
      this._update(this.buffer, 0, out, off);
      this.bufferOff = 0;
      return this.blockSize;
    };
    Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count = (this.bufferOff + data.length) / this.blockSize | 0;
      var out = new Array(count * this.blockSize);
      if (this.bufferOff !== 0) {
        inputOff += this._buffer(data, inputOff);
        if (this.bufferOff === this.buffer.length)
          outputOff += this._flushBuffer(out, outputOff);
      }
      var max = data.length - (data.length - inputOff) % this.blockSize;
      for (; inputOff < max; inputOff += this.blockSize) {
        this._update(data, inputOff, out, outputOff);
        outputOff += this.blockSize;
      }
      for (; inputOff < data.length; inputOff++, this.bufferOff++)
        this.buffer[this.bufferOff] = data[inputOff];
      return out;
    };
    Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
      var out = new Array(count * this.blockSize);
      for (; count > 0; count--) {
        inputOff += this._buffer(data, inputOff);
        outputOff += this._flushBuffer(out, outputOff);
      }
      inputOff += this._buffer(data, inputOff);
      return out;
    };
    Cipher.prototype.final = function final(buffer2) {
      var first2;
      if (buffer2)
        first2 = this.update(buffer2);
      var last2;
      if (this.type === "encrypt")
        last2 = this._finalEncrypt();
      else
        last2 = this._finalDecrypt();
      if (first2)
        return first2.concat(last2);
      else
        return last2;
    };
    Cipher.prototype._pad = function _pad(buffer2, off) {
      if (off === 0)
        return false;
      while (off < buffer2.length)
        buffer2[off++] = 0;
      return true;
    };
    Cipher.prototype._finalEncrypt = function _finalEncrypt() {
      if (!this._pad(this.buffer, this.bufferOff))
        return [];
      var out = new Array(this.blockSize);
      this._update(this.buffer, 0, out, 0);
      return out;
    };
    Cipher.prototype._unpad = function _unpad(buffer2) {
      return buffer2;
    };
    Cipher.prototype._finalDecrypt = function _finalDecrypt() {
      assert3.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
      var out = new Array(this.blockSize);
      this._flushBuffer(out, 0);
      return this._unpad(out);
    };
  }
});

// node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/des.js
var require_des = __commonJS({
  "node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/des.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var assert3 = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    var utils = require_utils3();
    var Cipher = require_cipher();
    function DESState() {
      this.tmp = new Array(2);
      this.keys = null;
    }
    function DES(options) {
      Cipher.call(this, options);
      var state = new DESState();
      this._desState = state;
      this.deriveKeys(state, options.key);
    }
    inherits(DES, Cipher);
    module2.exports = DES;
    DES.create = function create5(options) {
      return new DES(options);
    };
    var shiftTable = [
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      1
    ];
    DES.prototype.deriveKeys = function deriveKeys(state, key) {
      state.keys = new Array(16 * 2);
      assert3.equal(key.length, this.blockSize, "Invalid key length");
      var kL = utils.readUInt32BE(key, 0);
      var kR = utils.readUInt32BE(key, 4);
      utils.pc1(kL, kR, state.tmp, 0);
      kL = state.tmp[0];
      kR = state.tmp[1];
      for (var i = 0; i < state.keys.length; i += 2) {
        var shift = shiftTable[i >>> 1];
        kL = utils.r28shl(kL, shift);
        kR = utils.r28shl(kR, shift);
        utils.pc2(kL, kR, state.keys, i);
      }
    };
    DES.prototype._update = function _update(inp, inOff, out, outOff) {
      var state = this._desState;
      var l = utils.readUInt32BE(inp, inOff);
      var r = utils.readUInt32BE(inp, inOff + 4);
      utils.ip(l, r, state.tmp, 0);
      l = state.tmp[0];
      r = state.tmp[1];
      if (this.type === "encrypt")
        this._encrypt(state, l, r, state.tmp, 0);
      else
        this._decrypt(state, l, r, state.tmp, 0);
      l = state.tmp[0];
      r = state.tmp[1];
      utils.writeUInt32BE(out, l, outOff);
      utils.writeUInt32BE(out, r, outOff + 4);
    };
    DES.prototype._pad = function _pad(buffer2, off) {
      if (this.padding === false) {
        return false;
      }
      var value2 = buffer2.length - off;
      for (var i = off; i < buffer2.length; i++)
        buffer2[i] = value2;
      return true;
    };
    DES.prototype._unpad = function _unpad(buffer2) {
      if (this.padding === false) {
        return buffer2;
      }
      var pad = buffer2[buffer2.length - 1];
      for (var i = buffer2.length - pad; i < buffer2.length; i++)
        assert3.equal(buffer2[i], pad);
      return buffer2.slice(0, buffer2.length - pad);
    };
    DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
      var l = lStart;
      var r = rStart;
      for (var i = 0; i < state.keys.length; i += 2) {
        var keyL = state.keys[i];
        var keyR = state.keys[i + 1];
        utils.expand(r, state.tmp, 0);
        keyL ^= state.tmp[0];
        keyR ^= state.tmp[1];
        var s = utils.substitute(keyL, keyR);
        var f = utils.permute(s);
        var t = r;
        r = (l ^ f) >>> 0;
        l = t;
      }
      utils.rip(r, l, out, off);
    };
    DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
      var l = rStart;
      var r = lStart;
      for (var i = state.keys.length - 2; i >= 0; i -= 2) {
        var keyL = state.keys[i];
        var keyR = state.keys[i + 1];
        utils.expand(l, state.tmp, 0);
        keyL ^= state.tmp[0];
        keyR ^= state.tmp[1];
        var s = utils.substitute(keyL, keyR);
        var f = utils.permute(s);
        var t = l;
        l = (r ^ f) >>> 0;
        r = t;
      }
      utils.rip(l, r, out, off);
    };
  }
});

// node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/cbc.js
var require_cbc = __commonJS({
  "node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/cbc.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var assert3 = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    var proto = {};
    function CBCState(iv) {
      assert3.equal(iv.length, 8, "Invalid IV length");
      this.iv = new Array(8);
      for (var i = 0; i < this.iv.length; i++)
        this.iv[i] = iv[i];
    }
    function instantiate(Base) {
      function CBC(options) {
        Base.call(this, options);
        this._cbcInit();
      }
      inherits(CBC, Base);
      var keys = Object.keys(proto);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        CBC.prototype[key] = proto[key];
      }
      CBC.create = function create5(options) {
        return new CBC(options);
      };
      return CBC;
    }
    exports2.instantiate = instantiate;
    proto._cbcInit = function _cbcInit() {
      var state = new CBCState(this.options.iv);
      this._cbcState = state;
    };
    proto._update = function _update(inp, inOff, out, outOff) {
      var state = this._cbcState;
      var superProto = this.constructor.super_.prototype;
      var iv = state.iv;
      if (this.type === "encrypt") {
        for (var i = 0; i < this.blockSize; i++)
          iv[i] ^= inp[inOff + i];
        superProto._update.call(this, iv, 0, out, outOff);
        for (var i = 0; i < this.blockSize; i++)
          iv[i] = out[outOff + i];
      } else {
        superProto._update.call(this, inp, inOff, out, outOff);
        for (var i = 0; i < this.blockSize; i++)
          out[outOff + i] ^= iv[i];
        for (var i = 0; i < this.blockSize; i++)
          iv[i] = inp[inOff + i];
      }
    };
  }
});

// node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/ede.js
var require_ede = __commonJS({
  "node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des/ede.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var assert3 = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    var Cipher = require_cipher();
    var DES = require_des();
    function EDEState(type, key) {
      assert3.equal(key.length, 24, "Invalid key length");
      var k1 = key.slice(0, 8);
      var k2 = key.slice(8, 16);
      var k3 = key.slice(16, 24);
      if (type === "encrypt") {
        this.ciphers = [
          DES.create({ type: "encrypt", key: k1 }),
          DES.create({ type: "decrypt", key: k2 }),
          DES.create({ type: "encrypt", key: k3 })
        ];
      } else {
        this.ciphers = [
          DES.create({ type: "decrypt", key: k3 }),
          DES.create({ type: "encrypt", key: k2 }),
          DES.create({ type: "decrypt", key: k1 })
        ];
      }
    }
    function EDE(options) {
      Cipher.call(this, options);
      var state = new EDEState(this.type, this.options.key);
      this._edeState = state;
    }
    inherits(EDE, Cipher);
    module2.exports = EDE;
    EDE.create = function create5(options) {
      return new EDE(options);
    };
    EDE.prototype._update = function _update(inp, inOff, out, outOff) {
      var state = this._edeState;
      state.ciphers[0]._update(inp, inOff, out, outOff);
      state.ciphers[1]._update(out, outOff, out, outOff);
      state.ciphers[2]._update(out, outOff, out, outOff);
    };
    EDE.prototype._pad = DES.prototype._pad;
    EDE.prototype._unpad = DES.prototype._unpad;
  }
});

// node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des.js
var require_des2 = __commonJS({
  "node_modules/.pnpm/des.js@1.1.0/node_modules/des.js/lib/des.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    exports2.utils = require_utils3();
    exports2.Cipher = require_cipher();
    exports2.DES = require_des();
    exports2.CBC = require_cbc();
    exports2.EDE = require_ede();
  }
});

// node_modules/.pnpm/browserify-des@1.0.2/node_modules/browserify-des/index.js
var require_browserify_des = __commonJS({
  "node_modules/.pnpm/browserify-des@1.0.2/node_modules/browserify-des/index.js"(exports2, module2) {
    init_buffer_polyfill();
    var CipherBase = require_cipher_base();
    var des = require_des2();
    var inherits = require_inherits_browser();
    var Buffer5 = require_safe_buffer().Buffer;
    var modes = {
      "des-ede3-cbc": des.CBC.instantiate(des.EDE),
      "des-ede3": des.EDE,
      "des-ede-cbc": des.CBC.instantiate(des.EDE),
      "des-ede": des.EDE,
      "des-cbc": des.CBC.instantiate(des.DES),
      "des-ecb": des.DES
    };
    modes.des = modes["des-cbc"];
    modes.des3 = modes["des-ede3-cbc"];
    module2.exports = DES;
    inherits(DES, CipherBase);
    function DES(opts) {
      CipherBase.call(this);
      var modeName = opts.mode.toLowerCase();
      var mode = modes[modeName];
      var type;
      if (opts.decrypt) {
        type = "decrypt";
      } else {
        type = "encrypt";
      }
      var key = opts.key;
      if (!Buffer5.isBuffer(key)) {
        key = Buffer5.from(key);
      }
      if (modeName === "des-ede" || modeName === "des-ede-cbc") {
        key = Buffer5.concat([key, key.slice(0, 8)]);
      }
      var iv = opts.iv;
      if (!Buffer5.isBuffer(iv)) {
        iv = Buffer5.from(iv);
      }
      this._des = mode.create({
        key,
        iv,
        type
      });
    }
    DES.prototype._update = function(data) {
      return Buffer5.from(this._des.update(data));
    };
    DES.prototype._final = function() {
      return Buffer5.from(this._des.final());
    };
  }
});

// node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/ecb.js
var require_ecb = __commonJS({
  "node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/ecb.js"(exports2) {
    init_buffer_polyfill();
    exports2.encrypt = function(self2, block) {
      return self2._cipher.encryptBlock(block);
    };
    exports2.decrypt = function(self2, block) {
      return self2._cipher.decryptBlock(block);
    };
  }
});

// node_modules/.pnpm/buffer-xor@1.0.3/node_modules/buffer-xor/index.js
var require_buffer_xor = __commonJS({
  "node_modules/.pnpm/buffer-xor@1.0.3/node_modules/buffer-xor/index.js"(exports2, module2) {
    init_buffer_polyfill();
    module2.exports = function xor(a, b) {
      var length6 = Math.min(a.length, b.length);
      var buffer2 = new import_buffer.Buffer(length6);
      for (var i = 0; i < length6; ++i) {
        buffer2[i] = a[i] ^ b[i];
      }
      return buffer2;
    };
  }
});

// node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cbc.js
var require_cbc2 = __commonJS({
  "node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cbc.js"(exports2) {
    init_buffer_polyfill();
    var xor = require_buffer_xor();
    exports2.encrypt = function(self2, block) {
      var data = xor(block, self2._prev);
      self2._prev = self2._cipher.encryptBlock(data);
      return self2._prev;
    };
    exports2.decrypt = function(self2, block) {
      var pad = self2._prev;
      self2._prev = block;
      var out = self2._cipher.decryptBlock(block);
      return xor(out, pad);
    };
  }
});

// node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cfb.js
var require_cfb = __commonJS({
  "node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cfb.js"(exports2) {
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    var xor = require_buffer_xor();
    function encryptStart(self2, data, decrypt) {
      var len = data.length;
      var out = xor(data, self2._cache);
      self2._cache = self2._cache.slice(len);
      self2._prev = Buffer5.concat([self2._prev, decrypt ? data : out]);
      return out;
    }
    exports2.encrypt = function(self2, data, decrypt) {
      var out = Buffer5.allocUnsafe(0);
      var len;
      while (data.length) {
        if (self2._cache.length === 0) {
          self2._cache = self2._cipher.encryptBlock(self2._prev);
          self2._prev = Buffer5.allocUnsafe(0);
        }
        if (self2._cache.length <= data.length) {
          len = self2._cache.length;
          out = Buffer5.concat([out, encryptStart(self2, data.slice(0, len), decrypt)]);
          data = data.slice(len);
        } else {
          out = Buffer5.concat([out, encryptStart(self2, data, decrypt)]);
          break;
        }
      }
      return out;
    };
  }
});

// node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cfb8.js
var require_cfb8 = __commonJS({
  "node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cfb8.js"(exports2) {
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    function encryptByte(self2, byteParam, decrypt) {
      var pad = self2._cipher.encryptBlock(self2._prev);
      var out = pad[0] ^ byteParam;
      self2._prev = Buffer5.concat([
        self2._prev.slice(1),
        Buffer5.from([decrypt ? byteParam : out])
      ]);
      return out;
    }
    exports2.encrypt = function(self2, chunk, decrypt) {
      var len = chunk.length;
      var out = Buffer5.allocUnsafe(len);
      var i = -1;
      while (++i < len) {
        out[i] = encryptByte(self2, chunk[i], decrypt);
      }
      return out;
    };
  }
});

// node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cfb1.js
var require_cfb1 = __commonJS({
  "node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/cfb1.js"(exports2) {
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    function encryptByte(self2, byteParam, decrypt) {
      var pad;
      var i = -1;
      var len = 8;
      var out = 0;
      var bit, value2;
      while (++i < len) {
        pad = self2._cipher.encryptBlock(self2._prev);
        bit = byteParam & 1 << 7 - i ? 128 : 0;
        value2 = pad[0] ^ bit;
        out += (value2 & 128) >> i % 8;
        self2._prev = shiftIn(self2._prev, decrypt ? bit : value2);
      }
      return out;
    }
    function shiftIn(buffer2, value2) {
      var len = buffer2.length;
      var i = -1;
      var out = Buffer5.allocUnsafe(buffer2.length);
      buffer2 = Buffer5.concat([buffer2, Buffer5.from([value2])]);
      while (++i < len) {
        out[i] = buffer2[i] << 1 | buffer2[i + 1] >> 7;
      }
      return out;
    }
    exports2.encrypt = function(self2, chunk, decrypt) {
      var len = chunk.length;
      var out = Buffer5.allocUnsafe(len);
      var i = -1;
      while (++i < len) {
        out[i] = encryptByte(self2, chunk[i], decrypt);
      }
      return out;
    };
  }
});

// node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/ofb.js
var require_ofb = __commonJS({
  "node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/ofb.js"(exports2) {
    init_buffer_polyfill();
    var xor = require_buffer_xor();
    function getBlock(self2) {
      self2._prev = self2._cipher.encryptBlock(self2._prev);
      return self2._prev;
    }
    exports2.encrypt = function(self2, chunk) {
      while (self2._cache.length < chunk.length) {
        self2._cache = import_buffer.Buffer.concat([self2._cache, getBlock(self2)]);
      }
      var pad = self2._cache.slice(0, chunk.length);
      self2._cache = self2._cache.slice(chunk.length);
      return xor(chunk, pad);
    };
  }
});

// node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/incr32.js
var require_incr32 = __commonJS({
  "node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/incr32.js"(exports2, module2) {
    init_buffer_polyfill();
    function incr32(iv) {
      var len = iv.length;
      var item;
      while (len--) {
        item = iv.readUInt8(len);
        if (item === 255) {
          iv.writeUInt8(0, len);
        } else {
          item++;
          iv.writeUInt8(item, len);
          break;
        }
      }
    }
    module2.exports = incr32;
  }
});

// node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/ctr.js
var require_ctr = __commonJS({
  "node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/ctr.js"(exports2) {
    init_buffer_polyfill();
    var xor = require_buffer_xor();
    var Buffer5 = require_safe_buffer().Buffer;
    var incr32 = require_incr32();
    function getBlock(self2) {
      var out = self2._cipher.encryptBlockRaw(self2._prev);
      incr32(self2._prev);
      return out;
    }
    var blockSize = 16;
    exports2.encrypt = function(self2, chunk) {
      var chunkNum = Math.ceil(chunk.length / blockSize);
      var start = self2._cache.length;
      self2._cache = Buffer5.concat([
        self2._cache,
        Buffer5.allocUnsafe(chunkNum * blockSize)
      ]);
      for (var i = 0; i < chunkNum; i++) {
        var out = getBlock(self2);
        var offset = start + i * blockSize;
        self2._cache.writeUInt32BE(out[0], offset + 0);
        self2._cache.writeUInt32BE(out[1], offset + 4);
        self2._cache.writeUInt32BE(out[2], offset + 8);
        self2._cache.writeUInt32BE(out[3], offset + 12);
      }
      var pad = self2._cache.slice(0, chunk.length);
      self2._cache = self2._cache.slice(chunk.length);
      return xor(chunk, pad);
    };
  }
});

// node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/list.json
var require_list = __commonJS({
  "node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/list.json"(exports2, module2) {
    module2.exports = {
      "aes-128-ecb": {
        cipher: "AES",
        key: 128,
        iv: 0,
        mode: "ECB",
        type: "block"
      },
      "aes-192-ecb": {
        cipher: "AES",
        key: 192,
        iv: 0,
        mode: "ECB",
        type: "block"
      },
      "aes-256-ecb": {
        cipher: "AES",
        key: 256,
        iv: 0,
        mode: "ECB",
        type: "block"
      },
      "aes-128-cbc": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      "aes-192-cbc": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      "aes-256-cbc": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      aes128: {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      aes192: {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      aes256: {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      "aes-128-cfb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB",
        type: "stream"
      },
      "aes-192-cfb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB",
        type: "stream"
      },
      "aes-256-cfb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB",
        type: "stream"
      },
      "aes-128-cfb8": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB8",
        type: "stream"
      },
      "aes-192-cfb8": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB8",
        type: "stream"
      },
      "aes-256-cfb8": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB8",
        type: "stream"
      },
      "aes-128-cfb1": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB1",
        type: "stream"
      },
      "aes-192-cfb1": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB1",
        type: "stream"
      },
      "aes-256-cfb1": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB1",
        type: "stream"
      },
      "aes-128-ofb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "OFB",
        type: "stream"
      },
      "aes-192-ofb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "OFB",
        type: "stream"
      },
      "aes-256-ofb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "OFB",
        type: "stream"
      },
      "aes-128-ctr": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CTR",
        type: "stream"
      },
      "aes-192-ctr": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CTR",
        type: "stream"
      },
      "aes-256-ctr": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CTR",
        type: "stream"
      },
      "aes-128-gcm": {
        cipher: "AES",
        key: 128,
        iv: 12,
        mode: "GCM",
        type: "auth"
      },
      "aes-192-gcm": {
        cipher: "AES",
        key: 192,
        iv: 12,
        mode: "GCM",
        type: "auth"
      },
      "aes-256-gcm": {
        cipher: "AES",
        key: 256,
        iv: 12,
        mode: "GCM",
        type: "auth"
      }
    };
  }
});

// node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/index.js
var require_modes = __commonJS({
  "node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/modes/index.js"(exports2, module2) {
    init_buffer_polyfill();
    var modeModules = {
      ECB: require_ecb(),
      CBC: require_cbc2(),
      CFB: require_cfb(),
      CFB8: require_cfb8(),
      CFB1: require_cfb1(),
      OFB: require_ofb(),
      CTR: require_ctr(),
      GCM: require_ctr()
    };
    var modes = require_list();
    for (key in modes) {
      modes[key].module = modeModules[modes[key].mode];
    }
    var key;
    module2.exports = modes;
  }
});

// node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/aes.js
var require_aes = __commonJS({
  "node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/aes.js"(exports2, module2) {
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    function asUInt32Array(buf2) {
      if (!Buffer5.isBuffer(buf2)) buf2 = Buffer5.from(buf2);
      var len = buf2.length / 4 | 0;
      var out = new Array(len);
      for (var i = 0; i < len; i++) {
        out[i] = buf2.readUInt32BE(i * 4);
      }
      return out;
    }
    function scrubVec(v) {
      for (var i = 0; i < v.length; v++) {
        v[i] = 0;
      }
    }
    function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
      var SUB_MIX0 = SUB_MIX[0];
      var SUB_MIX1 = SUB_MIX[1];
      var SUB_MIX2 = SUB_MIX[2];
      var SUB_MIX3 = SUB_MIX[3];
      var s0 = M[0] ^ keySchedule[0];
      var s1 = M[1] ^ keySchedule[1];
      var s2 = M[2] ^ keySchedule[2];
      var s3 = M[3] ^ keySchedule[3];
      var t0, t1, t2, t3;
      var ksRow = 4;
      for (var round = 1; round < nRounds; round++) {
        t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++];
        t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++];
        t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++];
        t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
      }
      t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
      t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
      t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
      t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
      t0 = t0 >>> 0;
      t1 = t1 >>> 0;
      t2 = t2 >>> 0;
      t3 = t3 >>> 0;
      return [t0, t1, t2, t3];
    }
    var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
    var G2 = (function() {
      var d = new Array(256);
      for (var j = 0; j < 256; j++) {
        if (j < 128) {
          d[j] = j << 1;
        } else {
          d[j] = j << 1 ^ 283;
        }
      }
      var SBOX = [];
      var INV_SBOX = [];
      var SUB_MIX = [[], [], [], []];
      var INV_SUB_MIX = [[], [], [], []];
      var x = 0;
      var xi = 0;
      for (var i = 0; i < 256; ++i) {
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 255 ^ 99;
        SBOX[x] = sx;
        INV_SBOX[sx] = x;
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];
        var t = d[sx] * 257 ^ sx * 16843008;
        SUB_MIX[0][x] = t << 24 | t >>> 8;
        SUB_MIX[1][x] = t << 16 | t >>> 16;
        SUB_MIX[2][x] = t << 8 | t >>> 24;
        SUB_MIX[3][x] = t;
        t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
        INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
        INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
        INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
        INV_SUB_MIX[3][sx] = t;
        if (x === 0) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
      return {
        SBOX,
        INV_SBOX,
        SUB_MIX,
        INV_SUB_MIX
      };
    })();
    function AES(key) {
      this._key = asUInt32Array(key);
      this._reset();
    }
    AES.blockSize = 4 * 4;
    AES.keySize = 256 / 8;
    AES.prototype.blockSize = AES.blockSize;
    AES.prototype.keySize = AES.keySize;
    AES.prototype._reset = function() {
      var keyWords = this._key;
      var keySize = keyWords.length;
      var nRounds = keySize + 6;
      var ksRows = (nRounds + 1) * 4;
      var keySchedule = [];
      for (var k = 0; k < keySize; k++) {
        keySchedule[k] = keyWords[k];
      }
      for (k = keySize; k < ksRows; k++) {
        var t = keySchedule[k - 1];
        if (k % keySize === 0) {
          t = t << 8 | t >>> 24;
          t = G2.SBOX[t >>> 24] << 24 | G2.SBOX[t >>> 16 & 255] << 16 | G2.SBOX[t >>> 8 & 255] << 8 | G2.SBOX[t & 255];
          t ^= RCON[k / keySize | 0] << 24;
        } else if (keySize > 6 && k % keySize === 4) {
          t = G2.SBOX[t >>> 24] << 24 | G2.SBOX[t >>> 16 & 255] << 16 | G2.SBOX[t >>> 8 & 255] << 8 | G2.SBOX[t & 255];
        }
        keySchedule[k] = keySchedule[k - keySize] ^ t;
      }
      var invKeySchedule = [];
      for (var ik = 0; ik < ksRows; ik++) {
        var ksR = ksRows - ik;
        var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
        if (ik < 4 || ksR <= 4) {
          invKeySchedule[ik] = tt;
        } else {
          invKeySchedule[ik] = G2.INV_SUB_MIX[0][G2.SBOX[tt >>> 24]] ^ G2.INV_SUB_MIX[1][G2.SBOX[tt >>> 16 & 255]] ^ G2.INV_SUB_MIX[2][G2.SBOX[tt >>> 8 & 255]] ^ G2.INV_SUB_MIX[3][G2.SBOX[tt & 255]];
        }
      }
      this._nRounds = nRounds;
      this._keySchedule = keySchedule;
      this._invKeySchedule = invKeySchedule;
    };
    AES.prototype.encryptBlockRaw = function(M) {
      M = asUInt32Array(M);
      return cryptBlock(M, this._keySchedule, G2.SUB_MIX, G2.SBOX, this._nRounds);
    };
    AES.prototype.encryptBlock = function(M) {
      var out = this.encryptBlockRaw(M);
      var buf2 = Buffer5.allocUnsafe(16);
      buf2.writeUInt32BE(out[0], 0);
      buf2.writeUInt32BE(out[1], 4);
      buf2.writeUInt32BE(out[2], 8);
      buf2.writeUInt32BE(out[3], 12);
      return buf2;
    };
    AES.prototype.decryptBlock = function(M) {
      M = asUInt32Array(M);
      var m1 = M[1];
      M[1] = M[3];
      M[3] = m1;
      var out = cryptBlock(M, this._invKeySchedule, G2.INV_SUB_MIX, G2.INV_SBOX, this._nRounds);
      var buf2 = Buffer5.allocUnsafe(16);
      buf2.writeUInt32BE(out[0], 0);
      buf2.writeUInt32BE(out[3], 4);
      buf2.writeUInt32BE(out[2], 8);
      buf2.writeUInt32BE(out[1], 12);
      return buf2;
    };
    AES.prototype.scrub = function() {
      scrubVec(this._keySchedule);
      scrubVec(this._invKeySchedule);
      scrubVec(this._key);
    };
    module2.exports.AES = AES;
  }
});

// node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/ghash.js
var require_ghash = __commonJS({
  "node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/ghash.js"(exports2, module2) {
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    var ZEROES = Buffer5.alloc(16, 0);
    function toArray(buf2) {
      return [
        buf2.readUInt32BE(0),
        buf2.readUInt32BE(4),
        buf2.readUInt32BE(8),
        buf2.readUInt32BE(12)
      ];
    }
    function fromArray2(out) {
      var buf2 = Buffer5.allocUnsafe(16);
      buf2.writeUInt32BE(out[0] >>> 0, 0);
      buf2.writeUInt32BE(out[1] >>> 0, 4);
      buf2.writeUInt32BE(out[2] >>> 0, 8);
      buf2.writeUInt32BE(out[3] >>> 0, 12);
      return buf2;
    }
    function GHASH(key) {
      this.h = key;
      this.state = Buffer5.alloc(16, 0);
      this.cache = Buffer5.allocUnsafe(0);
    }
    GHASH.prototype.ghash = function(block) {
      var i = -1;
      while (++i < block.length) {
        this.state[i] ^= block[i];
      }
      this._multiply();
    };
    GHASH.prototype._multiply = function() {
      var Vi = toArray(this.h);
      var Zi = [0, 0, 0, 0];
      var j, xi, lsbVi;
      var i = -1;
      while (++i < 128) {
        xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
        if (xi) {
          Zi[0] ^= Vi[0];
          Zi[1] ^= Vi[1];
          Zi[2] ^= Vi[2];
          Zi[3] ^= Vi[3];
        }
        lsbVi = (Vi[3] & 1) !== 0;
        for (j = 3; j > 0; j--) {
          Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
        }
        Vi[0] = Vi[0] >>> 1;
        if (lsbVi) {
          Vi[0] = Vi[0] ^ 225 << 24;
        }
      }
      this.state = fromArray2(Zi);
    };
    GHASH.prototype.update = function(buf2) {
      this.cache = Buffer5.concat([this.cache, buf2]);
      var chunk;
      while (this.cache.length >= 16) {
        chunk = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        this.ghash(chunk);
      }
    };
    GHASH.prototype.final = function(abl, bl) {
      if (this.cache.length) {
        this.ghash(Buffer5.concat([this.cache, ZEROES], 16));
      }
      this.ghash(fromArray2([0, abl, 0, bl]));
      return this.state;
    };
    module2.exports = GHASH;
  }
});

// node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/authCipher.js
var require_authCipher = __commonJS({
  "node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/authCipher.js"(exports2, module2) {
    init_buffer_polyfill();
    var aes = require_aes();
    var Buffer5 = require_safe_buffer().Buffer;
    var Transform = require_cipher_base();
    var inherits = require_inherits_browser();
    var GHASH = require_ghash();
    var xor = require_buffer_xor();
    var incr32 = require_incr32();
    function xorTest(a, b) {
      var out = 0;
      if (a.length !== b.length) out++;
      var len = Math.min(a.length, b.length);
      for (var i = 0; i < len; ++i) {
        out += a[i] ^ b[i];
      }
      return out;
    }
    function calcIv(self2, iv, ck) {
      if (iv.length === 12) {
        self2._finID = Buffer5.concat([iv, Buffer5.from([0, 0, 0, 1])]);
        return Buffer5.concat([iv, Buffer5.from([0, 0, 0, 2])]);
      }
      var ghash = new GHASH(ck);
      var len = iv.length;
      var toPad = len % 16;
      ghash.update(iv);
      if (toPad) {
        toPad = 16 - toPad;
        ghash.update(Buffer5.alloc(toPad, 0));
      }
      ghash.update(Buffer5.alloc(8, 0));
      var ivBits = len * 8;
      var tail = Buffer5.alloc(8);
      tail.writeUIntBE(ivBits, 0, 8);
      ghash.update(tail);
      self2._finID = ghash.state;
      var out = Buffer5.from(self2._finID);
      incr32(out);
      return out;
    }
    function StreamCipher(mode, key, iv, decrypt) {
      Transform.call(this);
      var h3 = Buffer5.alloc(4, 0);
      this._cipher = new aes.AES(key);
      var ck = this._cipher.encryptBlock(h3);
      this._ghash = new GHASH(ck);
      iv = calcIv(this, iv, ck);
      this._prev = Buffer5.from(iv);
      this._cache = Buffer5.allocUnsafe(0);
      this._secCache = Buffer5.allocUnsafe(0);
      this._decrypt = decrypt;
      this._alen = 0;
      this._len = 0;
      this._mode = mode;
      this._authTag = null;
      this._called = false;
    }
    inherits(StreamCipher, Transform);
    StreamCipher.prototype._update = function(chunk) {
      if (!this._called && this._alen) {
        var rump = 16 - this._alen % 16;
        if (rump < 16) {
          rump = Buffer5.alloc(rump, 0);
          this._ghash.update(rump);
        }
      }
      this._called = true;
      var out = this._mode.encrypt(this, chunk);
      if (this._decrypt) {
        this._ghash.update(chunk);
      } else {
        this._ghash.update(out);
      }
      this._len += chunk.length;
      return out;
    };
    StreamCipher.prototype._final = function() {
      if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
      var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
      if (this._decrypt && xorTest(tag, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
      this._authTag = tag;
      this._cipher.scrub();
    };
    StreamCipher.prototype.getAuthTag = function getAuthTag() {
      if (this._decrypt || !Buffer5.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
      return this._authTag;
    };
    StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
      if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
      this._authTag = tag;
    };
    StreamCipher.prototype.setAAD = function setAAD(buf2) {
      if (this._called) throw new Error("Attempting to set AAD in unsupported state");
      this._ghash.update(buf2);
      this._alen += buf2.length;
    };
    module2.exports = StreamCipher;
  }
});

// node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/streamCipher.js
var require_streamCipher = __commonJS({
  "node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/streamCipher.js"(exports2, module2) {
    init_buffer_polyfill();
    var aes = require_aes();
    var Buffer5 = require_safe_buffer().Buffer;
    var Transform = require_cipher_base();
    var inherits = require_inherits_browser();
    function StreamCipher(mode, key, iv, decrypt) {
      Transform.call(this);
      this._cipher = new aes.AES(key);
      this._prev = Buffer5.from(iv);
      this._cache = Buffer5.allocUnsafe(0);
      this._secCache = Buffer5.allocUnsafe(0);
      this._decrypt = decrypt;
      this._mode = mode;
    }
    inherits(StreamCipher, Transform);
    StreamCipher.prototype._update = function(chunk) {
      return this._mode.encrypt(this, chunk, this._decrypt);
    };
    StreamCipher.prototype._final = function() {
      this._cipher.scrub();
    };
    module2.exports = StreamCipher;
  }
});

// node_modules/.pnpm/evp_bytestokey@1.0.3/node_modules/evp_bytestokey/index.js
var require_evp_bytestokey = __commonJS({
  "node_modules/.pnpm/evp_bytestokey@1.0.3/node_modules/evp_bytestokey/index.js"(exports2, module2) {
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    var MD5 = require_md5();
    function EVP_BytesToKey(password, salt, keyBits, ivLen) {
      if (!Buffer5.isBuffer(password)) password = Buffer5.from(password, "binary");
      if (salt) {
        if (!Buffer5.isBuffer(salt)) salt = Buffer5.from(salt, "binary");
        if (salt.length !== 8) throw new RangeError("salt should be Buffer with 8 byte length");
      }
      var keyLen = keyBits / 8;
      var key = Buffer5.alloc(keyLen);
      var iv = Buffer5.alloc(ivLen || 0);
      var tmp = Buffer5.alloc(0);
      while (keyLen > 0 || ivLen > 0) {
        var hash = new MD5();
        hash.update(tmp);
        hash.update(password);
        if (salt) hash.update(salt);
        tmp = hash.digest();
        var used = 0;
        if (keyLen > 0) {
          var keyStart = key.length - keyLen;
          used = Math.min(keyLen, tmp.length);
          tmp.copy(key, keyStart, 0, used);
          keyLen -= used;
        }
        if (used < tmp.length && ivLen > 0) {
          var ivStart = iv.length - ivLen;
          var length6 = Math.min(ivLen, tmp.length - used);
          tmp.copy(iv, ivStart, used, used + length6);
          ivLen -= length6;
        }
      }
      tmp.fill(0);
      return { key, iv };
    }
    module2.exports = EVP_BytesToKey;
  }
});

// node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/encrypter.js
var require_encrypter = __commonJS({
  "node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/encrypter.js"(exports2) {
    init_buffer_polyfill();
    var MODES = require_modes();
    var AuthCipher = require_authCipher();
    var Buffer5 = require_safe_buffer().Buffer;
    var StreamCipher = require_streamCipher();
    var Transform = require_cipher_base();
    var aes = require_aes();
    var ebtk = require_evp_bytestokey();
    var inherits = require_inherits_browser();
    function Cipher(mode, key, iv) {
      Transform.call(this);
      this._cache = new Splitter();
      this._cipher = new aes.AES(key);
      this._prev = Buffer5.from(iv);
      this._mode = mode;
      this._autopadding = true;
    }
    inherits(Cipher, Transform);
    Cipher.prototype._update = function(data) {
      this._cache.add(data);
      var chunk;
      var thing;
      var out = [];
      while (chunk = this._cache.get()) {
        thing = this._mode.encrypt(this, chunk);
        out.push(thing);
      }
      return Buffer5.concat(out);
    };
    var PADDING = Buffer5.alloc(16, 16);
    Cipher.prototype._final = function() {
      var chunk = this._cache.flush();
      if (this._autopadding) {
        chunk = this._mode.encrypt(this, chunk);
        this._cipher.scrub();
        return chunk;
      }
      if (!chunk.equals(PADDING)) {
        this._cipher.scrub();
        throw new Error("data not multiple of block length");
      }
    };
    Cipher.prototype.setAutoPadding = function(setTo) {
      this._autopadding = !!setTo;
      return this;
    };
    function Splitter() {
      this.cache = Buffer5.allocUnsafe(0);
    }
    Splitter.prototype.add = function(data) {
      this.cache = Buffer5.concat([this.cache, data]);
    };
    Splitter.prototype.get = function() {
      if (this.cache.length > 15) {
        var out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
      }
      return null;
    };
    Splitter.prototype.flush = function() {
      var len = 16 - this.cache.length;
      var padBuff = Buffer5.allocUnsafe(len);
      var i = -1;
      while (++i < len) {
        padBuff.writeUInt8(len, i);
      }
      return Buffer5.concat([this.cache, padBuff]);
    };
    function createCipheriv(suite, password, iv) {
      var config = MODES[suite.toLowerCase()];
      if (!config) throw new TypeError("invalid suite type");
      if (typeof password === "string") password = Buffer5.from(password);
      if (password.length !== config.key / 8) throw new TypeError("invalid key length " + password.length);
      if (typeof iv === "string") iv = Buffer5.from(iv);
      if (config.mode !== "GCM" && iv.length !== config.iv) throw new TypeError("invalid iv length " + iv.length);
      if (config.type === "stream") {
        return new StreamCipher(config.module, password, iv);
      } else if (config.type === "auth") {
        return new AuthCipher(config.module, password, iv);
      }
      return new Cipher(config.module, password, iv);
    }
    function createCipher(suite, password) {
      var config = MODES[suite.toLowerCase()];
      if (!config) throw new TypeError("invalid suite type");
      var keys = ebtk(password, false, config.key, config.iv);
      return createCipheriv(suite, keys.key, keys.iv);
    }
    exports2.createCipheriv = createCipheriv;
    exports2.createCipher = createCipher;
  }
});

// node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/decrypter.js
var require_decrypter = __commonJS({
  "node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/decrypter.js"(exports2) {
    init_buffer_polyfill();
    var AuthCipher = require_authCipher();
    var Buffer5 = require_safe_buffer().Buffer;
    var MODES = require_modes();
    var StreamCipher = require_streamCipher();
    var Transform = require_cipher_base();
    var aes = require_aes();
    var ebtk = require_evp_bytestokey();
    var inherits = require_inherits_browser();
    function Decipher(mode, key, iv) {
      Transform.call(this);
      this._cache = new Splitter();
      this._last = void 0;
      this._cipher = new aes.AES(key);
      this._prev = Buffer5.from(iv);
      this._mode = mode;
      this._autopadding = true;
    }
    inherits(Decipher, Transform);
    Decipher.prototype._update = function(data) {
      this._cache.add(data);
      var chunk;
      var thing;
      var out = [];
      while (chunk = this._cache.get(this._autopadding)) {
        thing = this._mode.decrypt(this, chunk);
        out.push(thing);
      }
      return Buffer5.concat(out);
    };
    Decipher.prototype._final = function() {
      var chunk = this._cache.flush();
      if (this._autopadding) {
        return unpad(this._mode.decrypt(this, chunk));
      } else if (chunk) {
        throw new Error("data not multiple of block length");
      }
    };
    Decipher.prototype.setAutoPadding = function(setTo) {
      this._autopadding = !!setTo;
      return this;
    };
    function Splitter() {
      this.cache = Buffer5.allocUnsafe(0);
    }
    Splitter.prototype.add = function(data) {
      this.cache = Buffer5.concat([this.cache, data]);
    };
    Splitter.prototype.get = function(autoPadding) {
      var out;
      if (autoPadding) {
        if (this.cache.length > 16) {
          out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
      } else {
        if (this.cache.length >= 16) {
          out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
      }
      return null;
    };
    Splitter.prototype.flush = function() {
      if (this.cache.length) return this.cache;
    };
    function unpad(last2) {
      var padded = last2[15];
      if (padded < 1 || padded > 16) {
        throw new Error("unable to decrypt data");
      }
      var i = -1;
      while (++i < padded) {
        if (last2[i + (16 - padded)] !== padded) {
          throw new Error("unable to decrypt data");
        }
      }
      if (padded === 16) return;
      return last2.slice(0, 16 - padded);
    }
    function createDecipheriv(suite, password, iv) {
      var config = MODES[suite.toLowerCase()];
      if (!config) throw new TypeError("invalid suite type");
      if (typeof iv === "string") iv = Buffer5.from(iv);
      if (config.mode !== "GCM" && iv.length !== config.iv) throw new TypeError("invalid iv length " + iv.length);
      if (typeof password === "string") password = Buffer5.from(password);
      if (password.length !== config.key / 8) throw new TypeError("invalid key length " + password.length);
      if (config.type === "stream") {
        return new StreamCipher(config.module, password, iv, true);
      } else if (config.type === "auth") {
        return new AuthCipher(config.module, password, iv, true);
      }
      return new Decipher(config.module, password, iv);
    }
    function createDecipher(suite, password) {
      var config = MODES[suite.toLowerCase()];
      if (!config) throw new TypeError("invalid suite type");
      var keys = ebtk(password, false, config.key, config.iv);
      return createDecipheriv(suite, keys.key, keys.iv);
    }
    exports2.createDecipher = createDecipher;
    exports2.createDecipheriv = createDecipheriv;
  }
});

// node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/browser.js
var require_browser7 = __commonJS({
  "node_modules/.pnpm/browserify-aes@1.2.0/node_modules/browserify-aes/browser.js"(exports2) {
    init_buffer_polyfill();
    var ciphers = require_encrypter();
    var deciphers = require_decrypter();
    var modes = require_list();
    function getCiphers() {
      return Object.keys(modes);
    }
    exports2.createCipher = exports2.Cipher = ciphers.createCipher;
    exports2.createCipheriv = exports2.Cipheriv = ciphers.createCipheriv;
    exports2.createDecipher = exports2.Decipher = deciphers.createDecipher;
    exports2.createDecipheriv = exports2.Decipheriv = deciphers.createDecipheriv;
    exports2.listCiphers = exports2.getCiphers = getCiphers;
  }
});

// node_modules/.pnpm/browserify-des@1.0.2/node_modules/browserify-des/modes.js
var require_modes2 = __commonJS({
  "node_modules/.pnpm/browserify-des@1.0.2/node_modules/browserify-des/modes.js"(exports2) {
    init_buffer_polyfill();
    exports2["des-ecb"] = {
      key: 8,
      iv: 0
    };
    exports2["des-cbc"] = exports2.des = {
      key: 8,
      iv: 8
    };
    exports2["des-ede3-cbc"] = exports2.des3 = {
      key: 24,
      iv: 8
    };
    exports2["des-ede3"] = {
      key: 24,
      iv: 0
    };
    exports2["des-ede-cbc"] = {
      key: 16,
      iv: 8
    };
    exports2["des-ede"] = {
      key: 16,
      iv: 0
    };
  }
});

// node_modules/.pnpm/browserify-cipher@1.0.1/node_modules/browserify-cipher/browser.js
var require_browser8 = __commonJS({
  "node_modules/.pnpm/browserify-cipher@1.0.1/node_modules/browserify-cipher/browser.js"(exports2) {
    init_buffer_polyfill();
    var DES = require_browserify_des();
    var aes = require_browser7();
    var aesModes = require_modes();
    var desModes = require_modes2();
    var ebtk = require_evp_bytestokey();
    function createCipher(suite, password) {
      suite = suite.toLowerCase();
      var keyLen, ivLen;
      if (aesModes[suite]) {
        keyLen = aesModes[suite].key;
        ivLen = aesModes[suite].iv;
      } else if (desModes[suite]) {
        keyLen = desModes[suite].key * 8;
        ivLen = desModes[suite].iv;
      } else {
        throw new TypeError("invalid suite type");
      }
      var keys = ebtk(password, false, keyLen, ivLen);
      return createCipheriv(suite, keys.key, keys.iv);
    }
    function createDecipher(suite, password) {
      suite = suite.toLowerCase();
      var keyLen, ivLen;
      if (aesModes[suite]) {
        keyLen = aesModes[suite].key;
        ivLen = aesModes[suite].iv;
      } else if (desModes[suite]) {
        keyLen = desModes[suite].key * 8;
        ivLen = desModes[suite].iv;
      } else {
        throw new TypeError("invalid suite type");
      }
      var keys = ebtk(password, false, keyLen, ivLen);
      return createDecipheriv(suite, keys.key, keys.iv);
    }
    function createCipheriv(suite, key, iv) {
      suite = suite.toLowerCase();
      if (aesModes[suite]) return aes.createCipheriv(suite, key, iv);
      if (desModes[suite]) return new DES({ key, iv, mode: suite });
      throw new TypeError("invalid suite type");
    }
    function createDecipheriv(suite, key, iv) {
      suite = suite.toLowerCase();
      if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv);
      if (desModes[suite]) return new DES({ key, iv, mode: suite, decrypt: true });
      throw new TypeError("invalid suite type");
    }
    function getCiphers() {
      return Object.keys(desModes).concat(aes.getCiphers());
    }
    exports2.createCipher = exports2.Cipher = createCipher;
    exports2.createCipheriv = exports2.Cipheriv = createCipheriv;
    exports2.createDecipher = exports2.Decipher = createDecipher;
    exports2.createDecipheriv = exports2.Decipheriv = createDecipheriv;
    exports2.listCiphers = exports2.getCiphers = getCiphers;
  }
});

// node_modules/.pnpm/miller-rabin@4.0.1/node_modules/miller-rabin/lib/mr.js
var require_mr = __commonJS({
  "node_modules/.pnpm/miller-rabin@4.0.1/node_modules/miller-rabin/lib/mr.js"(exports2, module2) {
    init_buffer_polyfill();
    var bn = require_bn();
    var brorand = require_brorand();
    function MillerRabin(rand) {
      this.rand = rand || new brorand.Rand();
    }
    module2.exports = MillerRabin;
    MillerRabin.create = function create5(rand) {
      return new MillerRabin(rand);
    };
    MillerRabin.prototype._randbelow = function _randbelow(n2) {
      var len = n2.bitLength();
      var min_bytes = Math.ceil(len / 8);
      do
        var a = new bn(this.rand.generate(min_bytes));
      while (a.cmp(n2) >= 0);
      return a;
    };
    MillerRabin.prototype._randrange = function _randrange(start, stop) {
      var size = stop.sub(start);
      return start.add(this._randbelow(size));
    };
    MillerRabin.prototype.test = function test(n2, k, cb) {
      var len = n2.bitLength();
      var red = bn.mont(n2);
      var rone = new bn(1).toRed(red);
      if (!k)
        k = Math.max(1, len / 48 | 0);
      var n1 = n2.subn(1);
      for (var s = 0; !n1.testn(s); s++) {
      }
      var d = n2.shrn(s);
      var rn1 = n1.toRed(red);
      var prime = true;
      for (; k > 0; k--) {
        var a = this._randrange(new bn(2), n1);
        if (cb)
          cb(a);
        var x = a.toRed(red).redPow(d);
        if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
          continue;
        for (var i = 1; i < s; i++) {
          x = x.redSqr();
          if (x.cmp(rone) === 0)
            return false;
          if (x.cmp(rn1) === 0)
            break;
        }
        if (i === s)
          return false;
      }
      return prime;
    };
    MillerRabin.prototype.getDivisor = function getDivisor(n2, k) {
      var len = n2.bitLength();
      var red = bn.mont(n2);
      var rone = new bn(1).toRed(red);
      if (!k)
        k = Math.max(1, len / 48 | 0);
      var n1 = n2.subn(1);
      for (var s = 0; !n1.testn(s); s++) {
      }
      var d = n2.shrn(s);
      var rn1 = n1.toRed(red);
      for (; k > 0; k--) {
        var a = this._randrange(new bn(2), n1);
        var g = n2.gcd(a);
        if (g.cmpn(1) !== 0)
          return g;
        var x = a.toRed(red).redPow(d);
        if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
          continue;
        for (var i = 1; i < s; i++) {
          x = x.redSqr();
          if (x.cmp(rone) === 0)
            return x.fromRed().subn(1).gcd(n2);
          if (x.cmp(rn1) === 0)
            break;
        }
        if (i === s) {
          x = x.redSqr();
          return x.fromRed().subn(1).gcd(n2);
        }
      }
      return false;
    };
  }
});

// node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/lib/generatePrime.js
var require_generatePrime = __commonJS({
  "node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/lib/generatePrime.js"(exports2, module2) {
    init_buffer_polyfill();
    var randomBytes2 = require_browser2();
    module2.exports = findPrime;
    findPrime.simpleSieve = simpleSieve;
    findPrime.fermatTest = fermatTest;
    var BN2 = require_bn();
    var TWENTYFOUR = new BN2(24);
    var MillerRabin = require_mr();
    var millerRabin = new MillerRabin();
    var ONE2 = new BN2(1);
    var TWO = new BN2(2);
    var FIVE = new BN2(5);
    var SIXTEEN = new BN2(16);
    var EIGHT = new BN2(8);
    var TEN = new BN2(10);
    var THREE = new BN2(3);
    var SEVEN = new BN2(7);
    var ELEVEN = new BN2(11);
    var FOUR = new BN2(4);
    var TWELVE = new BN2(12);
    var primes = null;
    function _getPrimes() {
      if (primes !== null)
        return primes;
      var limit = 1048576;
      var res = [];
      res[0] = 2;
      for (var i = 1, k = 3; k < limit; k += 2) {
        var sqrt = Math.ceil(Math.sqrt(k));
        for (var j = 0; j < i && res[j] <= sqrt; j++)
          if (k % res[j] === 0)
            break;
        if (i !== j && res[j] <= sqrt)
          continue;
        res[i++] = k;
      }
      primes = res;
      return res;
    }
    function simpleSieve(p) {
      var primes2 = _getPrimes();
      for (var i = 0; i < primes2.length; i++)
        if (p.modn(primes2[i]) === 0) {
          if (p.cmpn(primes2[i]) === 0) {
            return true;
          } else {
            return false;
          }
        }
      return true;
    }
    function fermatTest(p) {
      var red = BN2.mont(p);
      return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
    }
    function findPrime(bits, gen) {
      if (bits < 16) {
        if (gen === 2 || gen === 5) {
          return new BN2([140, 123]);
        } else {
          return new BN2([140, 39]);
        }
      }
      gen = new BN2(gen);
      var num2, n2;
      while (true) {
        num2 = new BN2(randomBytes2(Math.ceil(bits / 8)));
        while (num2.bitLength() > bits) {
          num2.ishrn(1);
        }
        if (num2.isEven()) {
          num2.iadd(ONE2);
        }
        if (!num2.testn(1)) {
          num2.iadd(TWO);
        }
        if (!gen.cmp(TWO)) {
          while (num2.mod(TWENTYFOUR).cmp(ELEVEN)) {
            num2.iadd(FOUR);
          }
        } else if (!gen.cmp(FIVE)) {
          while (num2.mod(TEN).cmp(THREE)) {
            num2.iadd(FOUR);
          }
        }
        n2 = num2.shrn(1);
        if (simpleSieve(n2) && simpleSieve(num2) && fermatTest(n2) && fermatTest(num2) && millerRabin.test(n2) && millerRabin.test(num2)) {
          return num2;
        }
      }
    }
  }
});

// node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/lib/primes.json
var require_primes = __commonJS({
  "node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/lib/primes.json"(exports2, module2) {
    module2.exports = {
      modp1: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
      },
      modp2: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
      },
      modp5: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
      },
      modp14: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
      },
      modp15: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
      },
      modp16: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
      },
      modp17: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
      },
      modp18: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
      }
    };
  }
});

// node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/lib/dh.js
var require_dh = __commonJS({
  "node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/lib/dh.js"(exports2, module2) {
    init_buffer_polyfill();
    var BN2 = require_bn();
    var MillerRabin = require_mr();
    var millerRabin = new MillerRabin();
    var TWENTYFOUR = new BN2(24);
    var ELEVEN = new BN2(11);
    var TEN = new BN2(10);
    var THREE = new BN2(3);
    var SEVEN = new BN2(7);
    var primes = require_generatePrime();
    var randomBytes2 = require_browser2();
    module2.exports = DH;
    function setPublicKey(pub, enc) {
      enc = enc || "utf8";
      if (!import_buffer.Buffer.isBuffer(pub)) {
        pub = new import_buffer.Buffer(pub, enc);
      }
      this._pub = new BN2(pub);
      return this;
    }
    function setPrivateKey(priv, enc) {
      enc = enc || "utf8";
      if (!import_buffer.Buffer.isBuffer(priv)) {
        priv = new import_buffer.Buffer(priv, enc);
      }
      this._priv = new BN2(priv);
      return this;
    }
    var primeCache = {};
    function checkPrime(prime, generator) {
      var gen = generator.toString("hex");
      var hex = [gen, prime.toString(16)].join("_");
      if (hex in primeCache) {
        return primeCache[hex];
      }
      var error = 0;
      if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
        error += 1;
        if (gen === "02" || gen === "05") {
          error += 8;
        } else {
          error += 4;
        }
        primeCache[hex] = error;
        return error;
      }
      if (!millerRabin.test(prime.shrn(1))) {
        error += 2;
      }
      var rem;
      switch (gen) {
        case "02":
          if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
            error += 8;
          }
          break;
        case "05":
          rem = prime.mod(TEN);
          if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
            error += 8;
          }
          break;
        default:
          error += 4;
      }
      primeCache[hex] = error;
      return error;
    }
    function DH(prime, generator, malleable) {
      this.setGenerator(generator);
      this.__prime = new BN2(prime);
      this._prime = BN2.mont(this.__prime);
      this._primeLen = prime.length;
      this._pub = void 0;
      this._priv = void 0;
      this._primeCode = void 0;
      if (malleable) {
        this.setPublicKey = setPublicKey;
        this.setPrivateKey = setPrivateKey;
      } else {
        this._primeCode = 8;
      }
    }
    Object.defineProperty(DH.prototype, "verifyError", {
      enumerable: true,
      get: function() {
        if (typeof this._primeCode !== "number") {
          this._primeCode = checkPrime(this.__prime, this.__gen);
        }
        return this._primeCode;
      }
    });
    DH.prototype.generateKeys = function() {
      if (!this._priv) {
        this._priv = new BN2(randomBytes2(this._primeLen));
      }
      this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
      return this.getPublicKey();
    };
    DH.prototype.computeSecret = function(other) {
      other = new BN2(other);
      other = other.toRed(this._prime);
      var secret = other.redPow(this._priv).fromRed();
      var out = new import_buffer.Buffer(secret.toArray());
      var prime = this.getPrime();
      if (out.length < prime.length) {
        var front = new import_buffer.Buffer(prime.length - out.length);
        front.fill(0);
        out = import_buffer.Buffer.concat([front, out]);
      }
      return out;
    };
    DH.prototype.getPublicKey = function getPublicKey(enc) {
      return formatReturnValue(this._pub, enc);
    };
    DH.prototype.getPrivateKey = function getPrivateKey(enc) {
      return formatReturnValue(this._priv, enc);
    };
    DH.prototype.getPrime = function(enc) {
      return formatReturnValue(this.__prime, enc);
    };
    DH.prototype.getGenerator = function(enc) {
      return formatReturnValue(this._gen, enc);
    };
    DH.prototype.setGenerator = function(gen, enc) {
      enc = enc || "utf8";
      if (!import_buffer.Buffer.isBuffer(gen)) {
        gen = new import_buffer.Buffer(gen, enc);
      }
      this.__gen = gen;
      this._gen = new BN2(gen);
      return this;
    };
    function formatReturnValue(bn, enc) {
      var buf2 = new import_buffer.Buffer(bn.toArray());
      if (!enc) {
        return buf2;
      } else {
        return buf2.toString(enc);
      }
    }
  }
});

// node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/browser.js
var require_browser9 = __commonJS({
  "node_modules/.pnpm/diffie-hellman@5.0.3/node_modules/diffie-hellman/browser.js"(exports2) {
    init_buffer_polyfill();
    var generatePrime = require_generatePrime();
    var primes = require_primes();
    var DH = require_dh();
    function getDiffieHellman(mod3) {
      var prime = new import_buffer.Buffer(primes[mod3].prime, "hex");
      var gen = new import_buffer.Buffer(primes[mod3].gen, "hex");
      return new DH(prime, gen);
    }
    var ENCODINGS = {
      "binary": true,
      "hex": true,
      "base64": true
    };
    function createDiffieHellman(prime, enc, generator, genc) {
      if (import_buffer.Buffer.isBuffer(enc) || ENCODINGS[enc] === void 0) {
        return createDiffieHellman(prime, "binary", enc, generator);
      }
      enc = enc || "binary";
      genc = genc || "binary";
      generator = generator || new import_buffer.Buffer([2]);
      if (!import_buffer.Buffer.isBuffer(generator)) {
        generator = new import_buffer.Buffer(generator, genc);
      }
      if (typeof prime === "number") {
        return new DH(generatePrime(prime, generator), generator, true);
      }
      if (!import_buffer.Buffer.isBuffer(prime)) {
        prime = new import_buffer.Buffer(prime, enc);
      }
      return new DH(prime, generator, true);
    }
    exports2.DiffieHellmanGroup = exports2.createDiffieHellmanGroup = exports2.getDiffieHellman = getDiffieHellman;
    exports2.createDiffieHellman = exports2.DiffieHellman = createDiffieHellman;
  }
});

// node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    init_buffer_polyfill();
    (function(module3, exports3) {
      "use strict";
      function assert3(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number3, base5, endian) {
        if (BN2.isBN(number3)) {
          return number3;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number3 !== null) {
          if (base5 === "le" || base5 === "be") {
            endian = base5;
            base5 = 10;
          }
          this._init(number3 || 0, base5 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN2;
      } else {
        exports3.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer5;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer5 = window.Buffer;
        } else {
          Buffer5 = require_buffer().Buffer;
        }
      } catch (e) {
      }
      BN2.isBN = function isBN(num2) {
        if (num2 instanceof BN2) {
          return true;
        }
        return num2 !== null && typeof num2 === "object" && num2.constructor.wordSize === BN2.wordSize && Array.isArray(num2.words);
      };
      BN2.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN2.prototype._init = function init(number3, base5, endian) {
        if (typeof number3 === "number") {
          return this._initNumber(number3, base5, endian);
        }
        if (typeof number3 === "object") {
          return this._initArray(number3, base5, endian);
        }
        if (base5 === "hex") {
          base5 = 16;
        }
        assert3(base5 === (base5 | 0) && base5 >= 2 && base5 <= 36);
        number3 = number3.toString().replace(/\s+/g, "");
        var start = 0;
        if (number3[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number3.length) {
          if (base5 === 16) {
            this._parseHex(number3, start, endian);
          } else {
            this._parseBase(number3, base5, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base5, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number3, base5, endian) {
        if (number3 < 0) {
          this.negative = 1;
          number3 = -number3;
        }
        if (number3 < 67108864) {
          this.words = [number3 & 67108863];
          this.length = 1;
        } else if (number3 < 4503599627370496) {
          this.words = [
            number3 & 67108863,
            number3 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number3 < 9007199254740992);
          this.words = [
            number3 & 67108863,
            number3 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base5, endian);
      };
      BN2.prototype._initArray = function _initArray(number3, base5, endian) {
        assert3(typeof number3.length === "number");
        if (number3.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number3.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number3.length - 1, j = 0; i >= 0; i -= 3) {
            w = number3[i] | number3[i - 1] << 8 | number3[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number3.length; i += 3) {
            w = number3[i] | number3[i + 1] << 8 | number3[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string5, index) {
        var c = string5.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert3(false, "Invalid character in " + string5);
        }
      }
      function parseHexByte(string5, lowerBound, index) {
        var r = parseHex4Bits(string5, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string5, index - 1) << 4;
        }
        return r;
      }
      BN2.prototype._parseHex = function _parseHex(number3, start, endian) {
        this.length = Math.ceil((number3.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number3.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number3, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number3.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number3.length; i += 2) {
            w = parseHexByte(number3, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert3(c >= 0 && b < mul, "Invalid character");
          r += b;
        }
        return r;
      }
      BN2.prototype._parseBase = function _parseBase(number3, base5, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base5) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base5 | 0;
        var total = number3.length - start;
        var mod3 = total % limbLen;
        var end = Math.min(total, total - mod3) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number3, i, i + limbLen, base5);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod3 !== 0) {
          var pow = 1;
          word = parseBase(number3, i, number3.length, base5);
          for (i = 0; i < mod3; i++) {
            pow *= base5;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src4) {
        dest.words = src4.words;
        dest.length = src4.length;
        dest.negative = src4.negative;
        dest.red = src4.red;
      }
      BN2.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN2.prototype.clone = function clone() {
        var r = new BN2(null);
        this.copy(r);
        return r;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN2.prototype[/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")] = inspect4;
        } catch (e) {
          BN2.prototype.inspect = inspect4;
        }
      } else {
        BN2.prototype.inspect = inspect4;
      }
      function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString8(base5, padding) {
        base5 = base5 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base5 === 16 || base5 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base5 === (base5 | 0) && base5 >= 2 && base5 <= 36) {
          var groupSize = groupSizes[base5];
          var groupBase = groupBases[base5];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base5);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer5) {
        BN2.prototype.toBuffer = function toBuffer(endian, length6) {
          return this.toArrayLike(Buffer5, endian, length6);
        };
      }
      BN2.prototype.toArray = function toArray(endian, length6) {
        return this.toArrayLike(Array, endian, length6);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length6) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length6 || Math.max(1, byteLength);
        assert3(byteLength <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num2) {
        var w = new Array(num2.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num2.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num2) {
        while (this.length < num2.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num2.length; i++) {
          this.words[i] = this.words[i] | num2.words[i];
        }
        return this._strip();
      };
      BN2.prototype.ior = function ior(num2) {
        assert3((this.negative | num2.negative) === 0);
        return this.iuor(num2);
      };
      BN2.prototype.or = function or4(num2) {
        if (this.length > num2.length) return this.clone().ior(num2);
        return num2.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num2) {
        if (this.length > num2.length) return this.clone().iuor(num2);
        return num2.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num2) {
        var b;
        if (this.length > num2.length) {
          b = num2;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num2.words[i];
        }
        this.length = b.length;
        return this._strip();
      };
      BN2.prototype.iand = function iand(num2) {
        assert3((this.negative | num2.negative) === 0);
        return this.iuand(num2);
      };
      BN2.prototype.and = function and(num2) {
        if (this.length > num2.length) return this.clone().iand(num2);
        return num2.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num2) {
        if (this.length > num2.length) return this.clone().iuand(num2);
        return num2.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num2) {
        var a;
        var b;
        if (this.length > num2.length) {
          a = this;
          b = num2;
        } else {
          a = num2;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN2.prototype.ixor = function ixor(num2) {
        assert3((this.negative | num2.negative) === 0);
        return this.iuxor(num2);
      };
      BN2.prototype.xor = function xor(num2) {
        if (this.length > num2.length) return this.clone().ixor(num2);
        return num2.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num2) {
        if (this.length > num2.length) return this.clone().iuxor(num2);
        return num2.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN2.prototype.iadd = function iadd(num2) {
        var r;
        if (this.negative !== 0 && num2.negative === 0) {
          this.negative = 0;
          r = this.isub(num2);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num2.negative !== 0) {
          num2.negative = 0;
          r = this.isub(num2);
          num2.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num2.length) {
          a = this;
          b = num2;
        } else {
          a = num2;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN2.prototype.add = function add2(num2) {
        var res;
        if (num2.negative !== 0 && this.negative === 0) {
          num2.negative = 0;
          res = this.sub(num2);
          num2.negative ^= 1;
          return res;
        } else if (num2.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num2.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num2.length) return this.clone().iadd(num2);
        return num2.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num2) {
        if (num2.negative !== 0) {
          num2.negative = 0;
          var r = this.iadd(num2);
          num2.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num2);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num2);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num2;
        } else {
          a = num2;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN2.prototype.sub = function sub(num2) {
        return this.clone().isub(num2);
      };
      function smallMulTo(self2, num2, out) {
        out.negative = num2.negative ^ self2.negative;
        var len = self2.length + num2.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num2.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num2.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num2.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num2, out) {
        var a = self2.words;
        var b = num2.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num2.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num2, out) {
        out.negative = num2.negative ^ self2.negative;
        out.length = self2.length + num2.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num2.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num2.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num2, out) {
        return bigMulTo(self2, num2, out);
      }
      BN2.prototype.mulTo = function mulTo(num2, out) {
        var res;
        var len = this.length + num2.length;
        if (this.length === 10 && num2.length === 10) {
          res = comb10MulTo(this, num2, out);
        } else if (len < 63) {
          res = smallMulTo(this, num2, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num2, out);
        } else {
          res = jumboMulTo(this, num2, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN2.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m) {
        var N = Math.max(m, n2) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
      BN2.prototype.mul = function mul(num2) {
        var out = new BN2(null);
        out.words = new Array(this.length + num2.length);
        return this.mulTo(num2, out);
      };
      BN2.prototype.mulf = function mulf(num2) {
        var out = new BN2(null);
        out.words = new Array(this.length + num2.length);
        return jumboMulTo(this, num2, out);
      };
      BN2.prototype.imul = function imul(num2) {
        return this.clone().mulTo(num2, this);
      };
      BN2.prototype.imuln = function imuln(num2) {
        var isNegNum = num2 < 0;
        if (isNegNum) num2 = -num2;
        assert3(typeof num2 === "number");
        assert3(num2 < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num2;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        this.length = num2 === 0 ? 1 : this.length;
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.muln = function muln(num2) {
        return this.clone().imuln(num2);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num2) {
        var w = toBitArray(num2);
        if (w.length === 0) return new BN2(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h3;
        if (hint) {
          h3 = (hint - hint % 26) / 26;
        } else {
          h3 = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h3 -= s;
        h3 = Math.max(0, h3);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h3); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num2) {
        assert3(typeof num2 === "number");
        assert3(num2 < 67108864);
        if (num2 < 0) return this.isubn(-num2);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num2) {
            this.words[0] = num2 - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num2);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num2);
      };
      BN2.prototype._iaddn = function _iaddn(num2) {
        this.words[0] += num2;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num2) {
        assert3(typeof num2 === "number");
        assert3(num2 < 67108864);
        if (num2 < 0) return this.iaddn(-num2);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num2);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num2;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN2.prototype.addn = function addn(num2) {
        return this.clone().iaddn(num2);
      };
      BN2.prototype.subn = function subn(num2) {
        return this.clone().isubn(num2);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num2, mul, shift) {
        var len = num2.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num2.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num2.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0) return this._strip();
        assert3(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num2, mode) {
        var shift = this.length - num2.length;
        var a = this.clone();
        var b = num2;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN2(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN2.prototype.divmod = function divmod(num2, mode, positive2) {
        assert3(!num2.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod3, res;
        if (this.negative !== 0 && num2.negative === 0) {
          res = this.neg().divmod(num2, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod3 = res.mod.neg();
            if (positive2 && mod3.negative !== 0) {
              mod3.iadd(num2);
            }
          }
          return {
            div,
            mod: mod3
          };
        }
        if (this.negative === 0 && num2.negative !== 0) {
          res = this.divmod(num2.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num2.negative) !== 0) {
          res = this.neg().divmod(num2.neg(), mode);
          if (mode !== "div") {
            mod3 = res.mod.neg();
            if (positive2 && mod3.negative !== 0) {
              mod3.isub(num2);
            }
          }
          return {
            div: res.div,
            mod: mod3
          };
        }
        if (num2.length > this.length || this.cmp(num2) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num2.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num2.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modrn(num2.words[0]))
            };
          }
          return {
            div: this.divn(num2.words[0]),
            mod: new BN2(this.modrn(num2.words[0]))
          };
        }
        return this._wordDiv(num2, mode);
      };
      BN2.prototype.div = function div(num2) {
        return this.divmod(num2, "div", false).div;
      };
      BN2.prototype.mod = function mod3(num2) {
        return this.divmod(num2, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num2) {
        return this.divmod(num2, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num2) {
        var dm = this.divmod(num2);
        if (dm.mod.isZero()) return dm.div;
        var mod3 = dm.div.negative !== 0 ? dm.mod.isub(num2) : dm.mod;
        var half = num2.ushrn(1);
        var r2 = num2.andln(1);
        var cmp = mod3.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modrn = function modrn(num2) {
        var isNegNum = num2 < 0;
        if (isNegNum) num2 = -num2;
        assert3(num2 <= 67108863);
        var p = (1 << 26) % num2;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num2;
        }
        return isNegNum ? -acc : acc;
      };
      BN2.prototype.modn = function modn(num2) {
        return this.modrn(num2);
      };
      BN2.prototype.idivn = function idivn(num2) {
        var isNegNum = num2 < 0;
        if (isNegNum) num2 = -num2;
        assert3(num2 <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num2 | 0;
          carry = w % num2;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.divn = function divn(num2) {
        return this.clone().idivn(num2);
      };
      BN2.prototype.egcd = function egcd(p) {
        assert3(p.negative === 0);
        assert3(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN2(1);
        var B = new BN2(0);
        var C = new BN2(0);
        var D = new BN2(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN2.prototype._invmp = function _invmp(p) {
        assert3(p.negative === 0);
        assert3(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num2) {
        if (this.isZero()) return num2.abs();
        if (num2.isZero()) return this.abs();
        var a = this.clone();
        var b = num2.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN2.prototype.invm = function invm(num2) {
        return this.egcd(num2).a.umod(num2);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num2) {
        return this.words[0] & num2;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num2) {
        var negative = num2 < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num2 = -num2;
          }
          assert3(num2 <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num2 ? 0 : w < num2 ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num2) {
        if (this.negative !== 0 && num2.negative === 0) return -1;
        if (this.negative === 0 && num2.negative !== 0) return 1;
        var res = this.ucmp(num2);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num2) {
        if (this.length > num2.length) return 1;
        if (this.length < num2.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num2.words[i] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num2) {
        return this.cmpn(num2) === 1;
      };
      BN2.prototype.gt = function gt(num2) {
        return this.cmp(num2) === 1;
      };
      BN2.prototype.gten = function gten(num2) {
        return this.cmpn(num2) >= 0;
      };
      BN2.prototype.gte = function gte(num2) {
        return this.cmp(num2) >= 0;
      };
      BN2.prototype.ltn = function ltn(num2) {
        return this.cmpn(num2) === -1;
      };
      BN2.prototype.lt = function lt(num2) {
        return this.cmp(num2) === -1;
      };
      BN2.prototype.lten = function lten(num2) {
        return this.cmpn(num2) <= 0;
      };
      BN2.prototype.lte = function lte(num2) {
        return this.cmp(num2) <= 0;
      };
      BN2.prototype.eqn = function eqn(num2) {
        return this.cmpn(num2) === 0;
      };
      BN2.prototype.eq = function eq(num2) {
        return this.cmp(num2) === 0;
      };
      BN2.red = function red(num2) {
        return new Red(num2);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num2) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num2);
      };
      BN2.prototype.redIAdd = function redIAdd(num2) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num2);
      };
      BN2.prototype.redSub = function redSub(num2) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num2);
      };
      BN2.prototype.redISub = function redISub(num2) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num2);
      };
      BN2.prototype.redShl = function redShl(num2) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num2);
      };
      BN2.prototype.redMul = function redMul(num2) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num2);
        return this.red.mul(this, num2);
      };
      BN2.prototype.redIMul = function redIMul(num2) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num2);
        return this.red.imul(this, num2);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num2) {
        assert3(this.red && !num2.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num2);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name10, p) {
        this.name = name10;
        this.p = new BN2(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num2) {
        var r = num2;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num2) {
        return num2.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split2(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num2) {
        num2.words[num2.length] = 0;
        num2.words[num2.length + 1] = 0;
        num2.length += 2;
        var lo = 0;
        for (var i = 0; i < num2.length; i++) {
          var w = num2.words[i] | 0;
          lo += w * 977;
          num2.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num2.words[num2.length - 1] === 0) {
          num2.length--;
          if (num2.words[num2.length - 1] === 0) {
            num2.length--;
          }
        }
        return num2;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num2) {
        var carry = 0;
        for (var i = 0; i < num2.length; i++) {
          var hi = (num2.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num2.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num2.words[num2.length++] = carry;
        }
        return num2;
      };
      BN2._prime = function prime(name10) {
        if (primes[name10]) return primes[name10];
        var prime2;
        if (name10 === "k256") {
          prime2 = new K256();
        } else if (name10 === "p224") {
          prime2 = new P224();
        } else if (name10 === "p192") {
          prime2 = new P192();
        } else if (name10 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name10);
        }
        primes[name10] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN2._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert3(a.negative === 0, "red works only with positives");
        assert3(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert3((a.negative | b.negative) === 0, "red works only with positives");
        assert3(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add2(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num2) {
        this._verify1(a);
        return this.imod(a.ushln(num2));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert3(!q.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN2(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert3(i < m);
          var b = this.pow(c, new BN2(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num2) {
        if (num2.isZero()) return new BN2(1).toRed(this);
        if (num2.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num2.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num2.length - 1; i >= 0; i--) {
          var word = num2.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num2) {
        var r = num2.umod(this.m);
        return r === num2 ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num2) {
        var res = num2.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num2) {
        return new Mont(num2);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num2) {
        return this.imod(num2.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num2) {
        var r = this.imod(num2.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN2(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/.pnpm/browserify-rsa@4.1.1/node_modules/browserify-rsa/index.js
var require_browserify_rsa = __commonJS({
  "node_modules/.pnpm/browserify-rsa@4.1.1/node_modules/browserify-rsa/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var BN2 = require_bn2();
    var randomBytes2 = require_browser2();
    var Buffer5 = require_safe_buffer().Buffer;
    function getr(priv) {
      var len = priv.modulus.byteLength();
      var r;
      do {
        r = new BN2(randomBytes2(len));
      } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));
      return r;
    }
    function blind(priv) {
      var r = getr(priv);
      var blinder = r.toRed(BN2.mont(priv.modulus)).redPow(new BN2(priv.publicExponent)).fromRed();
      return { blinder, unblinder: r.invm(priv.modulus) };
    }
    function crt(msg, priv) {
      var blinds = blind(priv);
      var len = priv.modulus.byteLength();
      var blinded = new BN2(msg).mul(blinds.blinder).umod(priv.modulus);
      var c1 = blinded.toRed(BN2.mont(priv.prime1));
      var c2 = blinded.toRed(BN2.mont(priv.prime2));
      var qinv = priv.coefficient;
      var p = priv.prime1;
      var q = priv.prime2;
      var m1 = c1.redPow(priv.exponent1).fromRed();
      var m2 = c2.redPow(priv.exponent2).fromRed();
      var h3 = m1.isub(m2).imul(qinv).umod(p).imul(q);
      return m2.iadd(h3).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer5, "be", len);
    }
    crt.getr = getr;
    module2.exports = crt;
  }
});

// node_modules/.pnpm/vm-browserify@1.1.2/node_modules/vm-browserify/index.js
var require_vm_browserify = __commonJS({
  "node_modules/.pnpm/vm-browserify@1.1.2/node_modules/vm-browserify/index.js"(exports, module) {
    init_buffer_polyfill();
    var indexOf = function(xs, item) {
      if (xs.indexOf) return xs.indexOf(item);
      else for (var i = 0; i < xs.length; i++) {
        if (xs[i] === item) return i;
      }
      return -1;
    };
    var Object_keys = function(obj) {
      if (Object.keys) return Object.keys(obj);
      else {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
      }
    };
    var forEach = function(xs, fn) {
      if (xs.forEach) return xs.forEach(fn);
      else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
      }
    };
    var defineProp = (function() {
      try {
        Object.defineProperty({}, "_", {});
        return function(obj, name10, value2) {
          Object.defineProperty(obj, name10, {
            writable: true,
            enumerable: false,
            configurable: true,
            value: value2
          });
        };
      } catch (e) {
        return function(obj, name10, value2) {
          obj[name10] = value2;
        };
      }
    })();
    var globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function NodeScript(code10) {
      if (!(this instanceof Script)) return new Script(code10);
      this.code = code10;
    };
    Script.prototype.runInContext = function(context) {
      if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
      }
      var iframe = document.createElement("iframe");
      if (!iframe.style) iframe.style = {};
      iframe.style.display = "none";
      document.body.appendChild(iframe);
      var win = iframe.contentWindow;
      var wEval = win.eval, wExecScript = win.execScript;
      if (!wEval && wExecScript) {
        wExecScript.call(win, "null");
        wEval = win.eval;
      }
      forEach(Object_keys(context), function(key) {
        win[key] = context[key];
      });
      forEach(globals, function(key) {
        if (context[key]) {
          win[key] = context[key];
        }
      });
      var winKeys = Object_keys(win);
      var res = wEval.call(win, this.code);
      forEach(Object_keys(win), function(key) {
        if (key in context || indexOf(winKeys, key) === -1) {
          context[key] = win[key];
        }
      });
      forEach(globals, function(key) {
        if (!(key in context)) {
          defineProp(context, key, win[key]);
        }
      });
      document.body.removeChild(iframe);
      return res;
    };
    Script.prototype.runInThisContext = function() {
      return eval(this.code);
    };
    Script.prototype.runInNewContext = function(context) {
      var ctx = Script.createContext(context);
      var res = this.runInContext(ctx);
      if (context) {
        forEach(Object_keys(ctx), function(key) {
          context[key] = ctx[key];
        });
      }
      return res;
    };
    forEach(Object_keys(Script.prototype), function(name10) {
      exports[name10] = Script[name10] = function(code10) {
        var s = Script(code10);
        return s[name10].apply(s, [].slice.call(arguments, 1));
      };
    });
    exports.isContext = function(context) {
      return context instanceof Context;
    };
    exports.createScript = function(code10) {
      return exports.Script(code10);
    };
    exports.createContext = Script.createContext = function(context) {
      var copy = new Context();
      if (typeof context === "object") {
        forEach(Object_keys(context), function(key) {
          copy[key] = context[key];
        });
      }
      return copy;
    };
  }
});

// node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/api.js
var require_api = __commonJS({
  "node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/api.js"(exports2) {
    init_buffer_polyfill();
    var asn1 = require_asn1();
    var inherits = require_inherits_browser();
    var api = exports2;
    api.define = function define(name10, body) {
      return new Entity(name10, body);
    };
    function Entity(name10, body) {
      this.name = name10;
      this.body = body;
      this.decoders = {};
      this.encoders = {};
    }
    Entity.prototype._createNamed = function createNamed(base5) {
      var named;
      try {
        named = require_vm_browserify().runInThisContext(
          "(function " + this.name + "(entity) {\n  this._initNamed(entity);\n})"
        );
      } catch (e) {
        named = function(entity) {
          this._initNamed(entity);
        };
      }
      inherits(named, base5);
      named.prototype._initNamed = function initnamed(entity) {
        base5.call(this, entity);
      };
      return new named(this);
    };
    Entity.prototype._getDecoder = function _getDecoder(enc) {
      enc = enc || "der";
      if (!this.decoders.hasOwnProperty(enc))
        this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
      return this.decoders[enc];
    };
    Entity.prototype.decode = function decode44(data, enc, options) {
      return this._getDecoder(enc).decode(data, options);
    };
    Entity.prototype._getEncoder = function _getEncoder(enc) {
      enc = enc || "der";
      if (!this.encoders.hasOwnProperty(enc))
        this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
      return this.encoders[enc];
    };
    Entity.prototype.encode = function encode42(data, enc, reporter) {
      return this._getEncoder(enc).encode(data, reporter);
    };
  }
});

// node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/reporter.js
var require_reporter = __commonJS({
  "node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/reporter.js"(exports2) {
    init_buffer_polyfill();
    var inherits = require_inherits_browser();
    function Reporter(options) {
      this._reporterState = {
        obj: null,
        path: [],
        options: options || {},
        errors: []
      };
    }
    exports2.Reporter = Reporter;
    Reporter.prototype.isError = function isError(obj) {
      return obj instanceof ReporterError;
    };
    Reporter.prototype.save = function save() {
      var state = this._reporterState;
      return { obj: state.obj, pathLen: state.path.length };
    };
    Reporter.prototype.restore = function restore(data) {
      var state = this._reporterState;
      state.obj = data.obj;
      state.path = state.path.slice(0, data.pathLen);
    };
    Reporter.prototype.enterKey = function enterKey(key) {
      return this._reporterState.path.push(key);
    };
    Reporter.prototype.exitKey = function exitKey(index) {
      var state = this._reporterState;
      state.path = state.path.slice(0, index - 1);
    };
    Reporter.prototype.leaveKey = function leaveKey(index, key, value2) {
      var state = this._reporterState;
      this.exitKey(index);
      if (state.obj !== null)
        state.obj[key] = value2;
    };
    Reporter.prototype.path = function path() {
      return this._reporterState.path.join("/");
    };
    Reporter.prototype.enterObject = function enterObject() {
      var state = this._reporterState;
      var prev = state.obj;
      state.obj = {};
      return prev;
    };
    Reporter.prototype.leaveObject = function leaveObject(prev) {
      var state = this._reporterState;
      var now = state.obj;
      state.obj = prev;
      return now;
    };
    Reporter.prototype.error = function error(msg) {
      var err;
      var state = this._reporterState;
      var inherited = msg instanceof ReporterError;
      if (inherited) {
        err = msg;
      } else {
        err = new ReporterError(state.path.map(function(elem) {
          return "[" + JSON.stringify(elem) + "]";
        }).join(""), msg.message || msg, msg.stack);
      }
      if (!state.options.partial)
        throw err;
      if (!inherited)
        state.errors.push(err);
      return err;
    };
    Reporter.prototype.wrapResult = function wrapResult(result) {
      var state = this._reporterState;
      if (!state.options.partial)
        return result;
      return {
        result: this.isError(result) ? null : result,
        errors: state.errors
      };
    };
    function ReporterError(path, msg) {
      this.path = path;
      this.rethrow(msg);
    }
    inherits(ReporterError, Error);
    ReporterError.prototype.rethrow = function rethrow(msg) {
      this.message = msg + " at: " + (this.path || "(shallow)");
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ReporterError);
      if (!this.stack) {
        try {
          throw new Error(this.message);
        } catch (e) {
          this.stack = e.stack;
        }
      }
      return this;
    };
  }
});

// node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/buffer.js
var require_buffer2 = __commonJS({
  "node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/buffer.js"(exports2) {
    init_buffer_polyfill();
    var inherits = require_inherits_browser();
    var Reporter = require_base().Reporter;
    var Buffer5 = require_buffer().Buffer;
    function DecoderBuffer(base5, options) {
      Reporter.call(this, options);
      if (!Buffer5.isBuffer(base5)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = base5;
      this.offset = 0;
      this.length = base5.length;
    }
    inherits(DecoderBuffer, Reporter);
    exports2.DecoderBuffer = DecoderBuffer;
    DecoderBuffer.prototype.save = function save() {
      return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
    };
    DecoderBuffer.prototype.restore = function restore(save) {
      var res = new DecoderBuffer(this.base);
      res.offset = save.offset;
      res.length = this.offset;
      this.offset = save.offset;
      Reporter.prototype.restore.call(this, save.reporter);
      return res;
    };
    DecoderBuffer.prototype.isEmpty = function isEmpty() {
      return this.offset === this.length;
    };
    DecoderBuffer.prototype.readUInt8 = function readUInt82(fail) {
      if (this.offset + 1 <= this.length)
        return this.base.readUInt8(this.offset++, true);
      else
        return this.error(fail || "DecoderBuffer overrun");
    };
    DecoderBuffer.prototype.skip = function skip(bytes, fail) {
      if (!(this.offset + bytes <= this.length))
        return this.error(fail || "DecoderBuffer overrun");
      var res = new DecoderBuffer(this.base);
      res._reporterState = this._reporterState;
      res.offset = this.offset;
      res.length = this.offset + bytes;
      this.offset += bytes;
      return res;
    };
    DecoderBuffer.prototype.raw = function raw(save) {
      return this.base.slice(save ? save.offset : this.offset, this.length);
    };
    function EncoderBuffer(value2, reporter) {
      if (Array.isArray(value2)) {
        this.length = 0;
        this.value = value2.map(function(item) {
          if (!(item instanceof EncoderBuffer))
            item = new EncoderBuffer(item, reporter);
          this.length += item.length;
          return item;
        }, this);
      } else if (typeof value2 === "number") {
        if (!(0 <= value2 && value2 <= 255))
          return reporter.error("non-byte EncoderBuffer value");
        this.value = value2;
        this.length = 1;
      } else if (typeof value2 === "string") {
        this.value = value2;
        this.length = Buffer5.byteLength(value2);
      } else if (Buffer5.isBuffer(value2)) {
        this.value = value2;
        this.length = value2.length;
      } else {
        return reporter.error("Unsupported type: " + typeof value2);
      }
    }
    exports2.EncoderBuffer = EncoderBuffer;
    EncoderBuffer.prototype.join = function join2(out, offset) {
      if (!out)
        out = new Buffer5(this.length);
      if (!offset)
        offset = 0;
      if (this.length === 0)
        return out;
      if (Array.isArray(this.value)) {
        this.value.forEach(function(item) {
          item.join(out, offset);
          offset += item.length;
        });
      } else {
        if (typeof this.value === "number")
          out[offset] = this.value;
        else if (typeof this.value === "string")
          out.write(this.value, offset);
        else if (Buffer5.isBuffer(this.value))
          this.value.copy(out, offset);
        offset += this.length;
      }
      return out;
    };
  }
});

// node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/node.js"(exports2, module2) {
    init_buffer_polyfill();
    var Reporter = require_base().Reporter;
    var EncoderBuffer = require_base().EncoderBuffer;
    var DecoderBuffer = require_base().DecoderBuffer;
    var assert3 = require_minimalistic_assert();
    var tags = [
      "seq",
      "seqof",
      "set",
      "setof",
      "objid",
      "bool",
      "gentime",
      "utctime",
      "null_",
      "enum",
      "int",
      "objDesc",
      "bitstr",
      "bmpstr",
      "charstr",
      "genstr",
      "graphstr",
      "ia5str",
      "iso646str",
      "numstr",
      "octstr",
      "printstr",
      "t61str",
      "unistr",
      "utf8str",
      "videostr"
    ];
    var methods = [
      "key",
      "obj",
      "use",
      "optional",
      "explicit",
      "implicit",
      "def",
      "choice",
      "any",
      "contains"
    ].concat(tags);
    var overrided = [
      "_peekTag",
      "_decodeTag",
      "_use",
      "_decodeStr",
      "_decodeObjid",
      "_decodeTime",
      "_decodeNull",
      "_decodeInt",
      "_decodeBool",
      "_decodeList",
      "_encodeComposite",
      "_encodeStr",
      "_encodeObjid",
      "_encodeTime",
      "_encodeNull",
      "_encodeInt",
      "_encodeBool"
    ];
    function Node(enc, parent) {
      var state = {};
      this._baseState = state;
      state.enc = enc;
      state.parent = parent || null;
      state.children = null;
      state.tag = null;
      state.args = null;
      state.reverseArgs = null;
      state.choice = null;
      state.optional = false;
      state.any = false;
      state.obj = false;
      state.use = null;
      state.useDecoder = null;
      state.key = null;
      state["default"] = null;
      state.explicit = null;
      state.implicit = null;
      state.contains = null;
      if (!state.parent) {
        state.children = [];
        this._wrap();
      }
    }
    module2.exports = Node;
    var stateProps = [
      "enc",
      "parent",
      "children",
      "tag",
      "args",
      "reverseArgs",
      "choice",
      "optional",
      "any",
      "obj",
      "use",
      "alteredUse",
      "key",
      "default",
      "explicit",
      "implicit",
      "contains"
    ];
    Node.prototype.clone = function clone() {
      var state = this._baseState;
      var cstate = {};
      stateProps.forEach(function(prop2) {
        cstate[prop2] = state[prop2];
      });
      var res = new this.constructor(cstate.parent);
      res._baseState = cstate;
      return res;
    };
    Node.prototype._wrap = function wrap() {
      var state = this._baseState;
      methods.forEach(function(method) {
        this[method] = function _wrappedMethod() {
          var clone = new this.constructor(this);
          state.children.push(clone);
          return clone[method].apply(clone, arguments);
        };
      }, this);
    };
    Node.prototype._init = function init(body) {
      var state = this._baseState;
      assert3(state.parent === null);
      body.call(this);
      state.children = state.children.filter(function(child) {
        return child._baseState.parent === this;
      }, this);
      assert3.equal(state.children.length, 1, "Root node can have only one child");
    };
    Node.prototype._useArgs = function useArgs(args) {
      var state = this._baseState;
      var children = args.filter(function(arg) {
        return arg instanceof this.constructor;
      }, this);
      args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
      }, this);
      if (children.length !== 0) {
        assert3(state.children === null);
        state.children = children;
        children.forEach(function(child) {
          child._baseState.parent = this;
        }, this);
      }
      if (args.length !== 0) {
        assert3(state.args === null);
        state.args = args;
        state.reverseArgs = args.map(function(arg) {
          if (typeof arg !== "object" || arg.constructor !== Object)
            return arg;
          var res = {};
          Object.keys(arg).forEach(function(key) {
            if (key == (key | 0))
              key |= 0;
            var value2 = arg[key];
            res[value2] = key;
          });
          return res;
        });
      }
    };
    overrided.forEach(function(method) {
      Node.prototype[method] = function _overrided() {
        var state = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state.enc);
      };
    });
    tags.forEach(function(tag) {
      Node.prototype[tag] = function _tagMethod() {
        var state = this._baseState;
        var args = Array.prototype.slice.call(arguments);
        assert3(state.tag === null);
        state.tag = tag;
        this._useArgs(args);
        return this;
      };
    });
    Node.prototype.use = function use(item) {
      assert3(item);
      var state = this._baseState;
      assert3(state.use === null);
      state.use = item;
      return this;
    };
    Node.prototype.optional = function optional2() {
      var state = this._baseState;
      state.optional = true;
      return this;
    };
    Node.prototype.def = function def(val) {
      var state = this._baseState;
      assert3(state["default"] === null);
      state["default"] = val;
      state.optional = true;
      return this;
    };
    Node.prototype.explicit = function explicit(num2) {
      var state = this._baseState;
      assert3(state.explicit === null && state.implicit === null);
      state.explicit = num2;
      return this;
    };
    Node.prototype.implicit = function implicit(num2) {
      var state = this._baseState;
      assert3(state.explicit === null && state.implicit === null);
      state.implicit = num2;
      return this;
    };
    Node.prototype.obj = function obj() {
      var state = this._baseState;
      var args = Array.prototype.slice.call(arguments);
      state.obj = true;
      if (args.length !== 0)
        this._useArgs(args);
      return this;
    };
    Node.prototype.key = function key(newKey) {
      var state = this._baseState;
      assert3(state.key === null);
      state.key = newKey;
      return this;
    };
    Node.prototype.any = function any2() {
      var state = this._baseState;
      state.any = true;
      return this;
    };
    Node.prototype.choice = function choice(obj) {
      var state = this._baseState;
      assert3(state.choice === null);
      state.choice = obj;
      this._useArgs(Object.keys(obj).map(function(key) {
        return obj[key];
      }));
      return this;
    };
    Node.prototype.contains = function contains(item) {
      var state = this._baseState;
      assert3(state.use === null);
      state.contains = item;
      return this;
    };
    Node.prototype._decode = function decode44(input, options) {
      var state = this._baseState;
      if (state.parent === null)
        return input.wrapResult(state.children[0]._decode(input, options));
      var result = state["default"];
      var present = true;
      var prevKey = null;
      if (state.key !== null)
        prevKey = input.enterKey(state.key);
      if (state.optional) {
        var tag = null;
        if (state.explicit !== null)
          tag = state.explicit;
        else if (state.implicit !== null)
          tag = state.implicit;
        else if (state.tag !== null)
          tag = state.tag;
        if (tag === null && !state.any) {
          var save = input.save();
          try {
            if (state.choice === null)
              this._decodeGeneric(state.tag, input, options);
            else
              this._decodeChoice(input, options);
            present = true;
          } catch (e) {
            present = false;
          }
          input.restore(save);
        } else {
          present = this._peekTag(input, tag, state.any);
          if (input.isError(present))
            return present;
        }
      }
      var prevObj;
      if (state.obj && present)
        prevObj = input.enterObject();
      if (present) {
        if (state.explicit !== null) {
          var explicit = this._decodeTag(input, state.explicit);
          if (input.isError(explicit))
            return explicit;
          input = explicit;
        }
        var start = input.offset;
        if (state.use === null && state.choice === null) {
          if (state.any)
            var save = input.save();
          var body = this._decodeTag(
            input,
            state.implicit !== null ? state.implicit : state.tag,
            state.any
          );
          if (input.isError(body))
            return body;
          if (state.any)
            result = input.raw(save);
          else
            input = body;
        }
        if (options && options.track && state.tag !== null)
          options.track(input.path(), start, input.length, "tagged");
        if (options && options.track && state.tag !== null)
          options.track(input.path(), input.offset, input.length, "content");
        if (state.any)
          result = result;
        else if (state.choice === null)
          result = this._decodeGeneric(state.tag, input, options);
        else
          result = this._decodeChoice(input, options);
        if (input.isError(result))
          return result;
        if (!state.any && state.choice === null && state.children !== null) {
          state.children.forEach(function decodeChildren(child) {
            child._decode(input, options);
          });
        }
        if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
          var data = new DecoderBuffer(result);
          result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
        }
      }
      if (state.obj && present)
        result = input.leaveObject(prevObj);
      if (state.key !== null && (result !== null || present === true))
        input.leaveKey(prevKey, state.key, result);
      else if (prevKey !== null)
        input.exitKey(prevKey);
      return result;
    };
    Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
      var state = this._baseState;
      if (tag === "seq" || tag === "set")
        return null;
      if (tag === "seqof" || tag === "setof")
        return this._decodeList(input, tag, state.args[0], options);
      else if (/str$/.test(tag))
        return this._decodeStr(input, tag, options);
      else if (tag === "objid" && state.args)
        return this._decodeObjid(input, state.args[0], state.args[1], options);
      else if (tag === "objid")
        return this._decodeObjid(input, null, null, options);
      else if (tag === "gentime" || tag === "utctime")
        return this._decodeTime(input, tag, options);
      else if (tag === "null_")
        return this._decodeNull(input, options);
      else if (tag === "bool")
        return this._decodeBool(input, options);
      else if (tag === "objDesc")
        return this._decodeStr(input, tag, options);
      else if (tag === "int" || tag === "enum")
        return this._decodeInt(input, state.args && state.args[0], options);
      if (state.use !== null) {
        return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
      } else {
        return input.error("unknown tag: " + tag);
      }
    };
    Node.prototype._getUse = function _getUse(entity, obj) {
      var state = this._baseState;
      state.useDecoder = this._use(entity, obj);
      assert3(state.useDecoder._baseState.parent === null);
      state.useDecoder = state.useDecoder._baseState.children[0];
      if (state.implicit !== state.useDecoder._baseState.implicit) {
        state.useDecoder = state.useDecoder.clone();
        state.useDecoder._baseState.implicit = state.implicit;
      }
      return state.useDecoder;
    };
    Node.prototype._decodeChoice = function decodeChoice(input, options) {
      var state = this._baseState;
      var result = null;
      var match = false;
      Object.keys(state.choice).some(function(key) {
        var save = input.save();
        var node = state.choice[key];
        try {
          var value2 = node._decode(input, options);
          if (input.isError(value2))
            return false;
          result = { type: key, value: value2 };
          match = true;
        } catch (e) {
          input.restore(save);
          return false;
        }
        return true;
      }, this);
      if (!match)
        return input.error("Choice not matched");
      return result;
    };
    Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
      return new EncoderBuffer(data, this.reporter);
    };
    Node.prototype._encode = function encode42(data, reporter, parent) {
      var state = this._baseState;
      if (state["default"] !== null && state["default"] === data)
        return;
      var result = this._encodeValue(data, reporter, parent);
      if (result === void 0)
        return;
      if (this._skipDefault(result, reporter, parent))
        return;
      return result;
    };
    Node.prototype._encodeValue = function encode42(data, reporter, parent) {
      var state = this._baseState;
      if (state.parent === null)
        return state.children[0]._encode(data, reporter || new Reporter());
      var result = null;
      this.reporter = reporter;
      if (state.optional && data === void 0) {
        if (state["default"] !== null)
          data = state["default"];
        else
          return;
      }
      var content = null;
      var primitive = false;
      if (state.any) {
        result = this._createEncoderBuffer(data);
      } else if (state.choice) {
        result = this._encodeChoice(data, reporter);
      } else if (state.contains) {
        content = this._getUse(state.contains, parent)._encode(data, reporter);
        primitive = true;
      } else if (state.children) {
        content = state.children.map(function(child2) {
          if (child2._baseState.tag === "null_")
            return child2._encode(null, reporter, data);
          if (child2._baseState.key === null)
            return reporter.error("Child should have a key");
          var prevKey = reporter.enterKey(child2._baseState.key);
          if (typeof data !== "object")
            return reporter.error("Child expected, but input is not object");
          var res = child2._encode(data[child2._baseState.key], reporter, data);
          reporter.leaveKey(prevKey);
          return res;
        }, this).filter(function(child2) {
          return child2;
        });
        content = this._createEncoderBuffer(content);
      } else {
        if (state.tag === "seqof" || state.tag === "setof") {
          if (!(state.args && state.args.length === 1))
            return reporter.error("Too many args for : " + state.tag);
          if (!Array.isArray(data))
            return reporter.error("seqof/setof, but data is not Array");
          var child = this.clone();
          child._baseState.implicit = null;
          content = this._createEncoderBuffer(data.map(function(item) {
            var state2 = this._baseState;
            return this._getUse(state2.args[0], data)._encode(item, reporter);
          }, child));
        } else if (state.use !== null) {
          result = this._getUse(state.use, parent)._encode(data, reporter);
        } else {
          content = this._encodePrimitive(state.tag, data);
          primitive = true;
        }
      }
      var result;
      if (!state.any && state.choice === null) {
        var tag = state.implicit !== null ? state.implicit : state.tag;
        var cls = state.implicit === null ? "universal" : "context";
        if (tag === null) {
          if (state.use === null)
            reporter.error("Tag could be omitted only for .use()");
        } else {
          if (state.use === null)
            result = this._encodeComposite(tag, primitive, cls, content);
        }
      }
      if (state.explicit !== null)
        result = this._encodeComposite(state.explicit, false, "context", result);
      return result;
    };
    Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
      var state = this._baseState;
      var node = state.choice[data.type];
      if (!node) {
        assert3(
          false,
          data.type + " not found in " + JSON.stringify(Object.keys(state.choice))
        );
      }
      return node._encode(data.value, reporter);
    };
    Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
      var state = this._baseState;
      if (/str$/.test(tag))
        return this._encodeStr(data, tag);
      else if (tag === "objid" && state.args)
        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
      else if (tag === "objid")
        return this._encodeObjid(data, null, null);
      else if (tag === "gentime" || tag === "utctime")
        return this._encodeTime(data, tag);
      else if (tag === "null_")
        return this._encodeNull();
      else if (tag === "int" || tag === "enum")
        return this._encodeInt(data, state.args && state.reverseArgs[0]);
      else if (tag === "bool")
        return this._encodeBool(data);
      else if (tag === "objDesc")
        return this._encodeStr(data, tag);
      else
        throw new Error("Unsupported tag: " + tag);
    };
    Node.prototype._isNumstr = function isNumstr(str) {
      return /^[0-9 ]*$/.test(str);
    };
    Node.prototype._isPrintstr = function isPrintstr(str) {
      return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
    };
  }
});

// node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/index.js
var require_base = __commonJS({
  "node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/base/index.js"(exports2) {
    init_buffer_polyfill();
    var base5 = exports2;
    base5.Reporter = require_reporter().Reporter;
    base5.DecoderBuffer = require_buffer2().DecoderBuffer;
    base5.EncoderBuffer = require_buffer2().EncoderBuffer;
    base5.Node = require_node();
  }
});

// node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/constants/der.js
var require_der = __commonJS({
  "node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/constants/der.js"(exports2) {
    init_buffer_polyfill();
    var constants = require_constants();
    exports2.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    };
    exports2.tagClassByName = constants._reverse(exports2.tagClass);
    exports2.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    };
    exports2.tagByName = constants._reverse(exports2.tag);
  }
});

// node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/constants/index.js
var require_constants = __commonJS({
  "node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/constants/index.js"(exports2) {
    init_buffer_polyfill();
    var constants = exports2;
    constants._reverse = function reverse(map2) {
      var res = {};
      Object.keys(map2).forEach(function(key) {
        if ((key | 0) == key)
          key = key | 0;
        var value2 = map2[key];
        res[value2] = key;
      });
      return res;
    };
    constants.der = require_der();
  }
});

// node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/decoders/der.js
var require_der2 = __commonJS({
  "node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/decoders/der.js"(exports2, module2) {
    init_buffer_polyfill();
    var inherits = require_inherits_browser();
    var asn1 = require_asn1();
    var base5 = asn1.base;
    var bignum = asn1.bignum;
    var der = asn1.constants.der;
    function DERDecoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    module2.exports = DERDecoder;
    DERDecoder.prototype.decode = function decode44(data, options) {
      if (!(data instanceof base5.DecoderBuffer))
        data = new base5.DecoderBuffer(data, options);
      return this.tree._decode(data, options);
    };
    function DERNode(parent) {
      base5.Node.call(this, "der", parent);
    }
    inherits(DERNode, base5.Node);
    DERNode.prototype._peekTag = function peekTag(buffer2, tag, any2) {
      if (buffer2.isEmpty())
        return false;
      var state = buffer2.save();
      var decodedTag = derDecodeTag(buffer2, 'Failed to peek tag: "' + tag + '"');
      if (buffer2.isError(decodedTag))
        return decodedTag;
      buffer2.restore(state);
      return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any2;
    };
    DERNode.prototype._decodeTag = function decodeTag(buffer2, tag, any2) {
      var decodedTag = derDecodeTag(
        buffer2,
        'Failed to decode tag of "' + tag + '"'
      );
      if (buffer2.isError(decodedTag))
        return decodedTag;
      var len = derDecodeLen(
        buffer2,
        decodedTag.primitive,
        'Failed to get length of "' + tag + '"'
      );
      if (buffer2.isError(len))
        return len;
      if (!any2 && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
        return buffer2.error('Failed to match tag: "' + tag + '"');
      }
      if (decodedTag.primitive || len !== null)
        return buffer2.skip(len, 'Failed to match body of: "' + tag + '"');
      var state = buffer2.save();
      var res = this._skipUntilEnd(
        buffer2,
        'Failed to skip indefinite length body: "' + this.tag + '"'
      );
      if (buffer2.isError(res))
        return res;
      len = buffer2.offset - state.offset;
      buffer2.restore(state);
      return buffer2.skip(len, 'Failed to match body of: "' + tag + '"');
    };
    DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer2, fail) {
      while (true) {
        var tag = derDecodeTag(buffer2, fail);
        if (buffer2.isError(tag))
          return tag;
        var len = derDecodeLen(buffer2, tag.primitive, fail);
        if (buffer2.isError(len))
          return len;
        var res;
        if (tag.primitive || len !== null)
          res = buffer2.skip(len);
        else
          res = this._skipUntilEnd(buffer2, fail);
        if (buffer2.isError(res))
          return res;
        if (tag.tagStr === "end")
          break;
      }
    };
    DERNode.prototype._decodeList = function decodeList(buffer2, tag, decoder, options) {
      var result = [];
      while (!buffer2.isEmpty()) {
        var possibleEnd = this._peekTag(buffer2, "end");
        if (buffer2.isError(possibleEnd))
          return possibleEnd;
        var res = decoder.decode(buffer2, "der", options);
        if (buffer2.isError(res) && possibleEnd)
          break;
        result.push(res);
      }
      return result;
    };
    DERNode.prototype._decodeStr = function decodeStr(buffer2, tag) {
      if (tag === "bitstr") {
        var unused = buffer2.readUInt8();
        if (buffer2.isError(unused))
          return unused;
        return { unused, data: buffer2.raw() };
      } else if (tag === "bmpstr") {
        var raw = buffer2.raw();
        if (raw.length % 2 === 1)
          return buffer2.error("Decoding of string type: bmpstr length mismatch");
        var str = "";
        for (var i = 0; i < raw.length / 2; i++) {
          str += String.fromCharCode(raw.readUInt16BE(i * 2));
        }
        return str;
      } else if (tag === "numstr") {
        var numstr = buffer2.raw().toString("ascii");
        if (!this._isNumstr(numstr)) {
          return buffer2.error("Decoding of string type: numstr unsupported characters");
        }
        return numstr;
      } else if (tag === "octstr") {
        return buffer2.raw();
      } else if (tag === "objDesc") {
        return buffer2.raw();
      } else if (tag === "printstr") {
        var printstr = buffer2.raw().toString("ascii");
        if (!this._isPrintstr(printstr)) {
          return buffer2.error("Decoding of string type: printstr unsupported characters");
        }
        return printstr;
      } else if (/str$/.test(tag)) {
        return buffer2.raw().toString();
      } else {
        return buffer2.error("Decoding of string type: " + tag + " unsupported");
      }
    };
    DERNode.prototype._decodeObjid = function decodeObjid(buffer2, values, relative) {
      var result;
      var identifiers = [];
      var ident = 0;
      while (!buffer2.isEmpty()) {
        var subident = buffer2.readUInt8();
        ident <<= 7;
        ident |= subident & 127;
        if ((subident & 128) === 0) {
          identifiers.push(ident);
          ident = 0;
        }
      }
      if (subident & 128)
        identifiers.push(ident);
      var first2 = identifiers[0] / 40 | 0;
      var second = identifiers[0] % 40;
      if (relative)
        result = identifiers;
      else
        result = [first2, second].concat(identifiers.slice(1));
      if (values) {
        var tmp = values[result.join(" ")];
        if (tmp === void 0)
          tmp = values[result.join(".")];
        if (tmp !== void 0)
          result = tmp;
      }
      return result;
    };
    DERNode.prototype._decodeTime = function decodeTime(buffer2, tag) {
      var str = buffer2.raw().toString();
      if (tag === "gentime") {
        var year = str.slice(0, 4) | 0;
        var mon = str.slice(4, 6) | 0;
        var day = str.slice(6, 8) | 0;
        var hour = str.slice(8, 10) | 0;
        var min = str.slice(10, 12) | 0;
        var sec = str.slice(12, 14) | 0;
      } else if (tag === "utctime") {
        var year = str.slice(0, 2) | 0;
        var mon = str.slice(2, 4) | 0;
        var day = str.slice(4, 6) | 0;
        var hour = str.slice(6, 8) | 0;
        var min = str.slice(8, 10) | 0;
        var sec = str.slice(10, 12) | 0;
        if (year < 70)
          year = 2e3 + year;
        else
          year = 1900 + year;
      } else {
        return buffer2.error("Decoding " + tag + " time is not supported yet");
      }
      return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
    };
    DERNode.prototype._decodeNull = function decodeNull(buffer2) {
      return null;
    };
    DERNode.prototype._decodeBool = function decodeBool(buffer2) {
      var res = buffer2.readUInt8();
      if (buffer2.isError(res))
        return res;
      else
        return res !== 0;
    };
    DERNode.prototype._decodeInt = function decodeInt(buffer2, values) {
      var raw = buffer2.raw();
      var res = new bignum(raw);
      if (values)
        res = values[res.toString(10)] || res;
      return res;
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getDecoder("der").tree;
    };
    function derDecodeTag(buf2, fail) {
      var tag = buf2.readUInt8(fail);
      if (buf2.isError(tag))
        return tag;
      var cls = der.tagClass[tag >> 6];
      var primitive = (tag & 32) === 0;
      if ((tag & 31) === 31) {
        var oct = tag;
        tag = 0;
        while ((oct & 128) === 128) {
          oct = buf2.readUInt8(fail);
          if (buf2.isError(oct))
            return oct;
          tag <<= 7;
          tag |= oct & 127;
        }
      } else {
        tag &= 31;
      }
      var tagStr = der.tag[tag];
      return {
        cls,
        primitive,
        tag,
        tagStr
      };
    }
    function derDecodeLen(buf2, primitive, fail) {
      var len = buf2.readUInt8(fail);
      if (buf2.isError(len))
        return len;
      if (!primitive && len === 128)
        return null;
      if ((len & 128) === 0) {
        return len;
      }
      var num2 = len & 127;
      if (num2 > 4)
        return buf2.error("length octect is too long");
      len = 0;
      for (var i = 0; i < num2; i++) {
        len <<= 8;
        var j = buf2.readUInt8(fail);
        if (buf2.isError(j))
          return j;
        len |= j;
      }
      return len;
    }
  }
});

// node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/decoders/pem.js
var require_pem = __commonJS({
  "node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/decoders/pem.js"(exports2, module2) {
    init_buffer_polyfill();
    var inherits = require_inherits_browser();
    var Buffer5 = require_buffer().Buffer;
    var DERDecoder = require_der2();
    function PEMDecoder(entity) {
      DERDecoder.call(this, entity);
      this.enc = "pem";
    }
    inherits(PEMDecoder, DERDecoder);
    module2.exports = PEMDecoder;
    PEMDecoder.prototype.decode = function decode44(data, options) {
      var lines = data.toString().split(/[\r\n]+/g);
      var label = options.label.toUpperCase();
      var re = /^-----(BEGIN|END) ([^-]+)-----$/;
      var start = -1;
      var end = -1;
      for (var i = 0; i < lines.length; i++) {
        var match = lines[i].match(re);
        if (match === null)
          continue;
        if (match[2] !== label)
          continue;
        if (start === -1) {
          if (match[1] !== "BEGIN")
            break;
          start = i;
        } else {
          if (match[1] !== "END")
            break;
          end = i;
          break;
        }
      }
      if (start === -1 || end === -1)
        throw new Error("PEM section not found for: " + label);
      var base644 = lines.slice(start + 1, end).join("");
      base644.replace(/[^a-z0-9\+\/=]+/gi, "");
      var input = new Buffer5(base644, "base64");
      return DERDecoder.prototype.decode.call(this, input, options);
    };
  }
});

// node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/decoders/index.js
var require_decoders = __commonJS({
  "node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/decoders/index.js"(exports2) {
    init_buffer_polyfill();
    var decoders3 = exports2;
    decoders3.der = require_der2();
    decoders3.pem = require_pem();
  }
});

// node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/encoders/der.js
var require_der3 = __commonJS({
  "node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/encoders/der.js"(exports2, module2) {
    init_buffer_polyfill();
    var inherits = require_inherits_browser();
    var Buffer5 = require_buffer().Buffer;
    var asn1 = require_asn1();
    var base5 = asn1.base;
    var der = asn1.constants.der;
    function DEREncoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    module2.exports = DEREncoder;
    DEREncoder.prototype.encode = function encode42(data, reporter) {
      return this.tree._encode(data, reporter).join();
    };
    function DERNode(parent) {
      base5.Node.call(this, "der", parent);
    }
    inherits(DERNode, base5.Node);
    DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
      var encodedTag = encodeTag2(tag, primitive, cls, this.reporter);
      if (content.length < 128) {
        var header = new Buffer5(2);
        header[0] = encodedTag;
        header[1] = content.length;
        return this._createEncoderBuffer([header, content]);
      }
      var lenOctets = 1;
      for (var i = content.length; i >= 256; i >>= 8)
        lenOctets++;
      var header = new Buffer5(1 + 1 + lenOctets);
      header[0] = encodedTag;
      header[1] = 128 | lenOctets;
      for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
        header[i] = j & 255;
      return this._createEncoderBuffer([header, content]);
    };
    DERNode.prototype._encodeStr = function encodeStr(str, tag) {
      if (tag === "bitstr") {
        return this._createEncoderBuffer([str.unused | 0, str.data]);
      } else if (tag === "bmpstr") {
        var buf2 = new Buffer5(str.length * 2);
        for (var i = 0; i < str.length; i++) {
          buf2.writeUInt16BE(str.charCodeAt(i), i * 2);
        }
        return this._createEncoderBuffer(buf2);
      } else if (tag === "numstr") {
        if (!this._isNumstr(str)) {
          return this.reporter.error("Encoding of string type: numstr supports only digits and space");
        }
        return this._createEncoderBuffer(str);
      } else if (tag === "printstr") {
        if (!this._isPrintstr(str)) {
          return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
        }
        return this._createEncoderBuffer(str);
      } else if (/str$/.test(tag)) {
        return this._createEncoderBuffer(str);
      } else if (tag === "objDesc") {
        return this._createEncoderBuffer(str);
      } else {
        return this.reporter.error("Encoding of string type: " + tag + " unsupported");
      }
    };
    DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
      if (typeof id === "string") {
        if (!values)
          return this.reporter.error("string objid given, but no values map found");
        if (!values.hasOwnProperty(id))
          return this.reporter.error("objid not found in values map");
        id = values[id].split(/[\s\.]+/g);
        for (var i = 0; i < id.length; i++)
          id[i] |= 0;
      } else if (Array.isArray(id)) {
        id = id.slice();
        for (var i = 0; i < id.length; i++)
          id[i] |= 0;
      }
      if (!Array.isArray(id)) {
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
      }
      if (!relative) {
        if (id[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        id.splice(0, 2, id[0] * 40 + id[1]);
      }
      var size = 0;
      for (var i = 0; i < id.length; i++) {
        var ident = id[i];
        for (size++; ident >= 128; ident >>= 7)
          size++;
      }
      var objid = new Buffer5(size);
      var offset = objid.length - 1;
      for (var i = id.length - 1; i >= 0; i--) {
        var ident = id[i];
        objid[offset--] = ident & 127;
        while ((ident >>= 7) > 0)
          objid[offset--] = 128 | ident & 127;
      }
      return this._createEncoderBuffer(objid);
    };
    function two(num2) {
      if (num2 < 10)
        return "0" + num2;
      else
        return num2;
    }
    DERNode.prototype._encodeTime = function encodeTime(time, tag) {
      var str;
      var date = new Date(time);
      if (tag === "gentime") {
        str = [
          two(date.getFullYear()),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z"
        ].join("");
      } else if (tag === "utctime") {
        str = [
          two(date.getFullYear() % 100),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z"
        ].join("");
      } else {
        this.reporter.error("Encoding " + tag + " time is not supported yet");
      }
      return this._encodeStr(str, "octstr");
    };
    DERNode.prototype._encodeNull = function encodeNull() {
      return this._createEncoderBuffer("");
    };
    DERNode.prototype._encodeInt = function encodeInt(num2, values) {
      if (typeof num2 === "string") {
        if (!values)
          return this.reporter.error("String int or enum given, but no values map");
        if (!values.hasOwnProperty(num2)) {
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num2));
        }
        num2 = values[num2];
      }
      if (typeof num2 !== "number" && !Buffer5.isBuffer(num2)) {
        var numArray = num2.toArray();
        if (!num2.sign && numArray[0] & 128) {
          numArray.unshift(0);
        }
        num2 = new Buffer5(numArray);
      }
      if (Buffer5.isBuffer(num2)) {
        var size = num2.length;
        if (num2.length === 0)
          size++;
        var out = new Buffer5(size);
        num2.copy(out);
        if (num2.length === 0)
          out[0] = 0;
        return this._createEncoderBuffer(out);
      }
      if (num2 < 128)
        return this._createEncoderBuffer(num2);
      if (num2 < 256)
        return this._createEncoderBuffer([0, num2]);
      var size = 1;
      for (var i = num2; i >= 256; i >>= 8)
        size++;
      var out = new Array(size);
      for (var i = out.length - 1; i >= 0; i--) {
        out[i] = num2 & 255;
        num2 >>= 8;
      }
      if (out[0] & 128) {
        out.unshift(0);
      }
      return this._createEncoderBuffer(new Buffer5(out));
    };
    DERNode.prototype._encodeBool = function encodeBool(value2) {
      return this._createEncoderBuffer(value2 ? 255 : 0);
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getEncoder("der").tree;
    };
    DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
      var state = this._baseState;
      var i;
      if (state["default"] === null)
        return false;
      var data = dataBuffer.join();
      if (state.defaultBuffer === void 0)
        state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
      if (data.length !== state.defaultBuffer.length)
        return false;
      for (i = 0; i < data.length; i++)
        if (data[i] !== state.defaultBuffer[i])
          return false;
      return true;
    };
    function encodeTag2(tag, primitive, cls, reporter) {
      var res;
      if (tag === "seqof")
        tag = "seq";
      else if (tag === "setof")
        tag = "set";
      if (der.tagByName.hasOwnProperty(tag))
        res = der.tagByName[tag];
      else if (typeof tag === "number" && (tag | 0) === tag)
        res = tag;
      else
        return reporter.error("Unknown tag: " + tag);
      if (res >= 31)
        return reporter.error("Multi-octet tag encoding unsupported");
      if (!primitive)
        res |= 32;
      res |= der.tagClassByName[cls || "universal"] << 6;
      return res;
    }
  }
});

// node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/encoders/pem.js
var require_pem2 = __commonJS({
  "node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/encoders/pem.js"(exports2, module2) {
    init_buffer_polyfill();
    var inherits = require_inherits_browser();
    var DEREncoder = require_der3();
    function PEMEncoder(entity) {
      DEREncoder.call(this, entity);
      this.enc = "pem";
    }
    inherits(PEMEncoder, DEREncoder);
    module2.exports = PEMEncoder;
    PEMEncoder.prototype.encode = function encode42(data, options) {
      var buf2 = DEREncoder.prototype.encode.call(this, data);
      var p = buf2.toString("base64");
      var out = ["-----BEGIN " + options.label + "-----"];
      for (var i = 0; i < p.length; i += 64)
        out.push(p.slice(i, i + 64));
      out.push("-----END " + options.label + "-----");
      return out.join("\n");
    };
  }
});

// node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/encoders/index.js
var require_encoders = __commonJS({
  "node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1/encoders/index.js"(exports2) {
    init_buffer_polyfill();
    var encoders = exports2;
    encoders.der = require_der3();
    encoders.pem = require_pem2();
  }
});

// node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1.js
var require_asn1 = __commonJS({
  "node_modules/.pnpm/asn1.js@4.10.1/node_modules/asn1.js/lib/asn1.js"(exports2) {
    init_buffer_polyfill();
    var asn1 = exports2;
    asn1.bignum = require_bn();
    asn1.define = require_api().define;
    asn1.base = require_base();
    asn1.constants = require_constants();
    asn1.decoders = require_decoders();
    asn1.encoders = require_encoders();
  }
});

// node_modules/.pnpm/parse-asn1@5.1.9/node_modules/parse-asn1/certificate.js
var require_certificate = __commonJS({
  "node_modules/.pnpm/parse-asn1@5.1.9/node_modules/parse-asn1/certificate.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var asn = require_asn1();
    var Time = asn.define("Time", function() {
      this.choice({
        utcTime: this.utctime(),
        generalTime: this.gentime()
      });
    });
    var AttributeTypeValue = asn.define("AttributeTypeValue", function() {
      this.seq().obj(
        this.key("type").objid(),
        this.key("value").any()
      );
    });
    var AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
      this.seq().obj(
        this.key("algorithm").objid(),
        this.key("parameters").optional(),
        this.key("curve").objid().optional()
      );
    });
    var SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(
        this.key("algorithm").use(AlgorithmIdentifier),
        this.key("subjectPublicKey").bitstr()
      );
    });
    var RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
      this.setof(AttributeTypeValue);
    });
    var RDNSequence = asn.define("RDNSequence", function() {
      this.seqof(RelativeDistinguishedName);
    });
    var Name = asn.define("Name", function() {
      this.choice({
        rdnSequence: this.use(RDNSequence)
      });
    });
    var Validity = asn.define("Validity", function() {
      this.seq().obj(
        this.key("notBefore").use(Time),
        this.key("notAfter").use(Time)
      );
    });
    var Extension = asn.define("Extension", function() {
      this.seq().obj(
        this.key("extnID").objid(),
        this.key("critical").bool().def(false),
        this.key("extnValue").octstr()
      );
    });
    var TBSCertificate = asn.define("TBSCertificate", function() {
      this.seq().obj(
        this.key("version").explicit(0)["int"]().optional(),
        this.key("serialNumber")["int"](),
        this.key("signature").use(AlgorithmIdentifier),
        this.key("issuer").use(Name),
        this.key("validity").use(Validity),
        this.key("subject").use(Name),
        this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
        this.key("issuerUniqueID").implicit(1).bitstr().optional(),
        this.key("subjectUniqueID").implicit(2).bitstr().optional(),
        this.key("extensions").explicit(3).seqof(Extension).optional()
      );
    });
    var X509Certificate = asn.define("X509Certificate", function() {
      this.seq().obj(
        this.key("tbsCertificate").use(TBSCertificate),
        this.key("signatureAlgorithm").use(AlgorithmIdentifier),
        this.key("signatureValue").bitstr()
      );
    });
    module2.exports = X509Certificate;
  }
});

// node_modules/.pnpm/parse-asn1@5.1.9/node_modules/parse-asn1/asn1.js
var require_asn12 = __commonJS({
  "node_modules/.pnpm/parse-asn1@5.1.9/node_modules/parse-asn1/asn1.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var asn1 = require_asn1();
    exports2.certificate = require_certificate();
    var RSAPrivateKey = asn1.define("RSAPrivateKey", function() {
      this.seq().obj(
        this.key("version")["int"](),
        this.key("modulus")["int"](),
        this.key("publicExponent")["int"](),
        this.key("privateExponent")["int"](),
        this.key("prime1")["int"](),
        this.key("prime2")["int"](),
        this.key("exponent1")["int"](),
        this.key("exponent2")["int"](),
        this.key("coefficient")["int"]()
      );
    });
    exports2.RSAPrivateKey = RSAPrivateKey;
    var RSAPublicKey = asn1.define("RSAPublicKey", function() {
      this.seq().obj(
        this.key("modulus")["int"](),
        this.key("publicExponent")["int"]()
      );
    });
    exports2.RSAPublicKey = RSAPublicKey;
    var AlgorithmIdentifier = asn1.define("AlgorithmIdentifier", function() {
      this.seq().obj(
        this.key("algorithm").objid(),
        this.key("none").null_().optional(),
        this.key("curve").objid().optional(),
        this.key("params").seq().obj(
          this.key("p")["int"](),
          this.key("q")["int"](),
          this.key("g")["int"]()
        ).optional()
      );
    });
    var PublicKey = asn1.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(
        this.key("algorithm").use(AlgorithmIdentifier),
        this.key("subjectPublicKey").bitstr()
      );
    });
    exports2.PublicKey = PublicKey;
    var PrivateKeyInfo = asn1.define("PrivateKeyInfo", function() {
      this.seq().obj(
        this.key("version")["int"](),
        this.key("algorithm").use(AlgorithmIdentifier),
        this.key("subjectPrivateKey").octstr()
      );
    });
    exports2.PrivateKey = PrivateKeyInfo;
    var EncryptedPrivateKeyInfo = asn1.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(
        this.key("algorithm").seq().obj(
          this.key("id").objid(),
          this.key("decrypt").seq().obj(
            this.key("kde").seq().obj(
              this.key("id").objid(),
              this.key("kdeparams").seq().obj(
                this.key("salt").octstr(),
                this.key("iters")["int"]()
              )
            ),
            this.key("cipher").seq().obj(
              this.key("algo").objid(),
              this.key("iv").octstr()
            )
          )
        ),
        this.key("subjectPrivateKey").octstr()
      );
    });
    exports2.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
    var DSAPrivateKey = asn1.define("DSAPrivateKey", function() {
      this.seq().obj(
        this.key("version")["int"](),
        this.key("p")["int"](),
        this.key("q")["int"](),
        this.key("g")["int"](),
        this.key("pub_key")["int"](),
        this.key("priv_key")["int"]()
      );
    });
    exports2.DSAPrivateKey = DSAPrivateKey;
    exports2.DSAparam = asn1.define("DSAparam", function() {
      this["int"]();
    });
    var ECParameters = asn1.define("ECParameters", function() {
      this.choice({
        namedCurve: this.objid()
      });
    });
    var ECPrivateKey = asn1.define("ECPrivateKey", function() {
      this.seq().obj(
        this.key("version")["int"](),
        this.key("privateKey").octstr(),
        this.key("parameters").optional().explicit(0).use(ECParameters),
        this.key("publicKey").optional().explicit(1).bitstr()
      );
    });
    exports2.ECPrivateKey = ECPrivateKey;
    exports2.signature = asn1.define("signature", function() {
      this.seq().obj(
        this.key("r")["int"](),
        this.key("s")["int"]()
      );
    });
  }
});

// node_modules/.pnpm/parse-asn1@5.1.9/node_modules/parse-asn1/aesid.json
var require_aesid = __commonJS({
  "node_modules/.pnpm/parse-asn1@5.1.9/node_modules/parse-asn1/aesid.json"(exports2, module2) {
    module2.exports = {
      "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
      "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
      "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
      "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
      "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
      "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
      "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
      "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
      "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
      "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
      "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
      "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
    };
  }
});

// node_modules/.pnpm/parse-asn1@5.1.9/node_modules/parse-asn1/fixProc.js
var require_fixProc = __commonJS({
  "node_modules/.pnpm/parse-asn1@5.1.9/node_modules/parse-asn1/fixProc.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
    var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
    var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
    var evp = require_evp_bytestokey();
    var ciphers = require_browser7();
    var Buffer5 = require_safe_buffer().Buffer;
    module2.exports = function(okey, password) {
      var key = okey.toString();
      var match = key.match(findProc);
      var decrypted;
      if (!match) {
        var match2 = key.match(fullRegex);
        decrypted = Buffer5.from(match2[2].replace(/[\r\n]/g, ""), "base64");
      } else {
        var suite = "aes" + match[1];
        var iv = Buffer5.from(match[2], "hex");
        var cipherText = Buffer5.from(match[3].replace(/[\r\n]/g, ""), "base64");
        var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
        var out = [];
        var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
        out.push(cipher.update(cipherText));
        out.push(cipher["final"]());
        decrypted = Buffer5.concat(out);
      }
      var tag = key.match(startRegex)[1];
      return {
        tag,
        data: decrypted
      };
    };
  }
});

// node_modules/.pnpm/parse-asn1@5.1.9/node_modules/parse-asn1/index.js
var require_parse_asn1 = __commonJS({
  "node_modules/.pnpm/parse-asn1@5.1.9/node_modules/parse-asn1/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var asn1 = require_asn12();
    var aesid = require_aesid();
    var fixProc = require_fixProc();
    var ciphers = require_browser7();
    var pbkdf2Sync = require_browser6().pbkdf2Sync;
    var Buffer5 = require_safe_buffer().Buffer;
    function decrypt(data, password) {
      var salt = data.algorithm.decrypt.kde.kdeparams.salt;
      var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
      var algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
      var iv = data.algorithm.decrypt.cipher.iv;
      var cipherText = data.subjectPrivateKey;
      var keylen = parseInt(algo.split("-")[1], 10) / 8;
      var key = pbkdf2Sync(password, salt, iters, keylen, "sha1");
      var cipher = ciphers.createDecipheriv(algo, key, iv);
      var out = [];
      out.push(cipher.update(cipherText));
      out.push(cipher["final"]());
      return Buffer5.concat(out);
    }
    function parseKeys(buffer2) {
      var password;
      if (typeof buffer2 === "object" && !Buffer5.isBuffer(buffer2)) {
        password = buffer2.passphrase;
        buffer2 = buffer2.key;
      }
      if (typeof buffer2 === "string") {
        buffer2 = Buffer5.from(buffer2);
      }
      var stripped = fixProc(buffer2, password);
      var type = stripped.tag;
      var data = stripped.data;
      var subtype, ndata;
      switch (type) {
        case "CERTIFICATE":
          ndata = asn1.certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
        // falls through
        case "PUBLIC KEY":
          if (!ndata) {
            ndata = asn1.PublicKey.decode(data, "der");
          }
          subtype = ndata.algorithm.algorithm.join(".");
          switch (subtype) {
            case "1.2.840.113549.1.1.1":
              return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              ndata.subjectPrivateKey = ndata.subjectPublicKey;
              return {
                type: "ec",
                data: ndata
              };
            case "1.2.840.10040.4.1":
              ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, "der");
              return {
                type: "dsa",
                data: ndata.algorithm.params
              };
            default:
              throw new Error("unknown key id " + subtype);
          }
        // throw new Error('unknown key type ' + type)
        case "ENCRYPTED PRIVATE KEY":
          data = asn1.EncryptedPrivateKey.decode(data, "der");
          data = decrypt(data, password);
        // falls through
        case "PRIVATE KEY":
          ndata = asn1.PrivateKey.decode(data, "der");
          subtype = ndata.algorithm.algorithm.join(".");
          switch (subtype) {
            case "1.2.840.113549.1.1.1":
              return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
              return {
                curve: ndata.algorithm.curve,
                privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
              };
            case "1.2.840.10040.4.1":
              ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, "der");
              return {
                type: "dsa",
                params: ndata.algorithm.params
              };
            default:
              throw new Error("unknown key id " + subtype);
          }
        // throw new Error('unknown key type ' + type)
        case "RSA PUBLIC KEY":
          return asn1.RSAPublicKey.decode(data, "der");
        case "RSA PRIVATE KEY":
          return asn1.RSAPrivateKey.decode(data, "der");
        case "DSA PRIVATE KEY":
          return {
            type: "dsa",
            params: asn1.DSAPrivateKey.decode(data, "der")
          };
        case "EC PRIVATE KEY":
          data = asn1.ECPrivateKey.decode(data, "der");
          return {
            curve: data.parameters.value,
            privateKey: data.privateKey
          };
        default:
          throw new Error("unknown key type " + type);
      }
    }
    parseKeys.signature = asn1.signature;
    module2.exports = parseKeys;
  }
});

// node_modules/.pnpm/browserify-sign@4.2.5/node_modules/browserify-sign/browser/curves.json
var require_curves = __commonJS({
  "node_modules/.pnpm/browserify-sign@4.2.5/node_modules/browserify-sign/browser/curves.json"(exports2, module2) {
    module2.exports = {
      "1.3.132.0.10": "secp256k1",
      "1.3.132.0.33": "p224",
      "1.2.840.10045.3.1.1": "p192",
      "1.2.840.10045.3.1.7": "p256",
      "1.3.132.0.34": "p384",
      "1.3.132.0.35": "p521"
    };
  }
});

// node_modules/.pnpm/browserify-sign@4.2.5/node_modules/browserify-sign/browser/sign.js
var require_sign2 = __commonJS({
  "node_modules/.pnpm/browserify-sign@4.2.5/node_modules/browserify-sign/browser/sign.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    var createHmac = require_browser5();
    var crt = require_browserify_rsa();
    var EC2 = require_elliptic().ec;
    var BN2 = require_bn2();
    var parseKeys = require_parse_asn1();
    var curves = require_curves();
    var RSA_PKCS1_PADDING = 1;
    function sign2(hash, key, hashType, signType, tag) {
      var priv = parseKeys(key);
      if (priv.curve) {
        if (signType !== "ecdsa" && signType !== "ecdsa/rsa") {
          throw new Error("wrong private key type");
        }
        return ecSign(hash, priv);
      } else if (priv.type === "dsa") {
        if (signType !== "dsa") {
          throw new Error("wrong private key type");
        }
        return dsaSign(hash, priv, hashType);
      }
      if (signType !== "rsa" && signType !== "ecdsa/rsa") {
        throw new Error("wrong private key type");
      }
      if (key.padding !== void 0 && key.padding !== RSA_PKCS1_PADDING) {
        throw new Error("illegal or unsupported padding mode");
      }
      hash = Buffer5.concat([tag, hash]);
      var len = priv.modulus.byteLength();
      var pad = [0, 1];
      while (hash.length + pad.length + 1 < len) {
        pad.push(255);
      }
      pad.push(0);
      var i = -1;
      while (++i < hash.length) {
        pad.push(hash[i]);
      }
      var out = crt(pad, priv);
      return out;
    }
    function ecSign(hash, priv) {
      var curveId = curves[priv.curve.join(".")];
      if (!curveId) {
        throw new Error("unknown curve " + priv.curve.join("."));
      }
      var curve = new EC2(curveId);
      var key = curve.keyFromPrivate(priv.privateKey);
      var out = key.sign(hash);
      return Buffer5.from(out.toDER());
    }
    function dsaSign(hash, priv, algo) {
      var x = priv.params.priv_key;
      var p = priv.params.p;
      var q = priv.params.q;
      var g = priv.params.g;
      var r = new BN2(0);
      var k;
      var H = bits2int(hash, q).mod(q);
      var s = false;
      var kv = getKey(x, q, hash, algo);
      while (s === false) {
        k = makeKey(q, kv, algo);
        r = makeR(g, k, p, q);
        s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
        if (s.cmpn(0) === 0) {
          s = false;
          r = new BN2(0);
        }
      }
      return toDER(r, s);
    }
    function toDER(r, s) {
      r = r.toArray();
      s = s.toArray();
      if (r[0] & 128) {
        r = [0].concat(r);
      }
      if (s[0] & 128) {
        s = [0].concat(s);
      }
      var total = r.length + s.length + 4;
      var res = [
        48,
        total,
        2,
        r.length
      ];
      res = res.concat(r, [2, s.length], s);
      return Buffer5.from(res);
    }
    function getKey(x, q, hash, algo) {
      x = Buffer5.from(x.toArray());
      if (x.length < q.byteLength()) {
        var zeros = Buffer5.alloc(q.byteLength() - x.length);
        x = Buffer5.concat([zeros, x]);
      }
      var hlen = hash.length;
      var hbits = bits2octets(hash, q);
      var v = Buffer5.alloc(hlen);
      v.fill(1);
      var k = Buffer5.alloc(hlen);
      k = createHmac(algo, k).update(v).update(Buffer5.from([0])).update(x).update(hbits).digest();
      v = createHmac(algo, k).update(v).digest();
      k = createHmac(algo, k).update(v).update(Buffer5.from([1])).update(x).update(hbits).digest();
      v = createHmac(algo, k).update(v).digest();
      return { k, v };
    }
    function bits2int(obits, q) {
      var bits = new BN2(obits);
      var shift = (obits.length << 3) - q.bitLength();
      if (shift > 0) {
        bits.ishrn(shift);
      }
      return bits;
    }
    function bits2octets(bits, q) {
      bits = bits2int(bits, q);
      bits = bits.mod(q);
      var out = Buffer5.from(bits.toArray());
      if (out.length < q.byteLength()) {
        var zeros = Buffer5.alloc(q.byteLength() - out.length);
        out = Buffer5.concat([zeros, out]);
      }
      return out;
    }
    function makeKey(q, kv, algo) {
      var t;
      var k;
      do {
        t = Buffer5.alloc(0);
        while (t.length * 8 < q.bitLength()) {
          kv.v = createHmac(algo, kv.k).update(kv.v).digest();
          t = Buffer5.concat([t, kv.v]);
        }
        k = bits2int(t, q);
        kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer5.from([0])).digest();
        kv.v = createHmac(algo, kv.k).update(kv.v).digest();
      } while (k.cmp(q) !== -1);
      return k;
    }
    function makeR(g, k, p, q) {
      return g.toRed(BN2.mont(p)).redPow(k).fromRed().mod(q);
    }
    module2.exports = sign2;
    module2.exports.getKey = getKey;
    module2.exports.makeKey = makeKey;
  }
});

// node_modules/.pnpm/browserify-sign@4.2.5/node_modules/browserify-sign/browser/verify.js
var require_verify = __commonJS({
  "node_modules/.pnpm/browserify-sign@4.2.5/node_modules/browserify-sign/browser/verify.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    var BN2 = require_bn2();
    var EC2 = require_elliptic().ec;
    var parseKeys = require_parse_asn1();
    var curves = require_curves();
    function verify2(sig, hash, key, signType, tag) {
      var pub = parseKeys(key);
      if (pub.type === "ec") {
        if (signType !== "ecdsa" && signType !== "ecdsa/rsa") {
          throw new Error("wrong public key type");
        }
        return ecVerify(sig, hash, pub);
      } else if (pub.type === "dsa") {
        if (signType !== "dsa") {
          throw new Error("wrong public key type");
        }
        return dsaVerify(sig, hash, pub);
      }
      if (signType !== "rsa" && signType !== "ecdsa/rsa") {
        throw new Error("wrong public key type");
      }
      hash = Buffer5.concat([tag, hash]);
      var len = pub.modulus.byteLength();
      var pad = [1];
      var padNum = 0;
      while (hash.length + pad.length + 2 < len) {
        pad.push(255);
        padNum += 1;
      }
      pad.push(0);
      var i = -1;
      while (++i < hash.length) {
        pad.push(hash[i]);
      }
      pad = Buffer5.from(pad);
      var red = BN2.mont(pub.modulus);
      sig = new BN2(sig).toRed(red);
      sig = sig.redPow(new BN2(pub.publicExponent));
      sig = Buffer5.from(sig.fromRed().toArray());
      var out = padNum < 8 ? 1 : 0;
      len = Math.min(sig.length, pad.length);
      if (sig.length !== pad.length) {
        out = 1;
      }
      i = -1;
      while (++i < len) {
        out |= sig[i] ^ pad[i];
      }
      return out === 0;
    }
    function ecVerify(sig, hash, pub) {
      var curveId = curves[pub.data.algorithm.curve.join(".")];
      if (!curveId) {
        throw new Error("unknown curve " + pub.data.algorithm.curve.join("."));
      }
      var curve = new EC2(curveId);
      var pubkey = pub.data.subjectPrivateKey.data;
      return curve.verify(hash, sig, pubkey);
    }
    function dsaVerify(sig, hash, pub) {
      var p = pub.data.p;
      var q = pub.data.q;
      var g = pub.data.g;
      var y = pub.data.pub_key;
      var unpacked = parseKeys.signature.decode(sig, "der");
      var s = unpacked.s;
      var r = unpacked.r;
      checkValue(s, q);
      checkValue(r, q);
      var montp = BN2.mont(p);
      var w = s.invm(q);
      var v = g.toRed(montp).redPow(new BN2(hash).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);
      return v.cmp(r) === 0;
    }
    function checkValue(b, q) {
      if (b.cmpn(0) <= 0) {
        throw new Error("invalid sig");
      }
      if (b.cmp(q) >= 0) {
        throw new Error("invalid sig");
      }
    }
    module2.exports = verify2;
  }
});

// node_modules/.pnpm/browserify-sign@4.2.5/node_modules/browserify-sign/browser/index.js
var require_browser10 = __commonJS({
  "node_modules/.pnpm/browserify-sign@4.2.5/node_modules/browserify-sign/browser/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    var createHash = require_browser4();
    var stream = require_readable_browser();
    var inherits = require_inherits_browser();
    var sign2 = require_sign2();
    var verify2 = require_verify();
    var algorithms = require_algorithms();
    Object.keys(algorithms).forEach(function(key) {
      algorithms[key].id = Buffer5.from(algorithms[key].id, "hex");
      algorithms[key.toLowerCase()] = algorithms[key];
    });
    function Sign(algorithm) {
      stream.Writable.call(this);
      var data = algorithms[algorithm];
      if (!data) {
        throw new Error("Unknown message digest");
      }
      this._hashType = data.hash;
      this._hash = createHash(data.hash);
      this._tag = data.id;
      this._signType = data.sign;
    }
    inherits(Sign, stream.Writable);
    Sign.prototype._write = function _write(data, _, done) {
      this._hash.update(data);
      done();
    };
    Sign.prototype.update = function update(data, enc) {
      this._hash.update(typeof data === "string" ? Buffer5.from(data, enc) : data);
      return this;
    };
    Sign.prototype.sign = function signMethod(key, enc) {
      this.end();
      var hash = this._hash.digest();
      var sig = sign2(hash, key, this._hashType, this._signType, this._tag);
      return enc ? sig.toString(enc) : sig;
    };
    function Verify(algorithm) {
      stream.Writable.call(this);
      var data = algorithms[algorithm];
      if (!data) {
        throw new Error("Unknown message digest");
      }
      this._hash = createHash(data.hash);
      this._tag = data.id;
      this._signType = data.sign;
    }
    inherits(Verify, stream.Writable);
    Verify.prototype._write = function _write(data, _, done) {
      this._hash.update(data);
      done();
    };
    Verify.prototype.update = function update(data, enc) {
      this._hash.update(typeof data === "string" ? Buffer5.from(data, enc) : data);
      return this;
    };
    Verify.prototype.verify = function verifyMethod(key, sig, enc) {
      var sigBuffer = typeof sig === "string" ? Buffer5.from(sig, enc) : sig;
      this.end();
      var hash = this._hash.digest();
      return verify2(sigBuffer, hash, key, this._signType, this._tag);
    };
    function createSign(algorithm) {
      return new Sign(algorithm);
    }
    function createVerify(algorithm) {
      return new Verify(algorithm);
    }
    module2.exports = {
      Sign: createSign,
      Verify: createVerify,
      createSign,
      createVerify
    };
  }
});

// node_modules/.pnpm/create-ecdh@4.0.4/node_modules/create-ecdh/browser.js
var require_browser11 = __commonJS({
  "node_modules/.pnpm/create-ecdh@4.0.4/node_modules/create-ecdh/browser.js"(exports2, module2) {
    init_buffer_polyfill();
    var elliptic = require_elliptic();
    var BN2 = require_bn();
    module2.exports = function createECDH(curve) {
      return new ECDH(curve);
    };
    var aliases = {
      secp256k1: {
        name: "secp256k1",
        byteLength: 32
      },
      secp224r1: {
        name: "p224",
        byteLength: 28
      },
      prime256v1: {
        name: "p256",
        byteLength: 32
      },
      prime192v1: {
        name: "p192",
        byteLength: 24
      },
      ed25519: {
        name: "ed25519",
        byteLength: 32
      },
      secp384r1: {
        name: "p384",
        byteLength: 48
      },
      secp521r1: {
        name: "p521",
        byteLength: 66
      }
    };
    aliases.p224 = aliases.secp224r1;
    aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
    aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
    aliases.p384 = aliases.secp384r1;
    aliases.p521 = aliases.secp521r1;
    function ECDH(curve) {
      this.curveType = aliases[curve];
      if (!this.curveType) {
        this.curveType = {
          name: curve
        };
      }
      this.curve = new elliptic.ec(this.curveType.name);
      this.keys = void 0;
    }
    ECDH.prototype.generateKeys = function(enc, format5) {
      this.keys = this.curve.genKeyPair();
      return this.getPublicKey(enc, format5);
    };
    ECDH.prototype.computeSecret = function(other, inenc, enc) {
      inenc = inenc || "utf8";
      if (!import_buffer.Buffer.isBuffer(other)) {
        other = new import_buffer.Buffer(other, inenc);
      }
      var otherPub = this.curve.keyFromPublic(other).getPublic();
      var out = otherPub.mul(this.keys.getPrivate()).getX();
      return formatReturnValue(out, enc, this.curveType.byteLength);
    };
    ECDH.prototype.getPublicKey = function(enc, format5) {
      var key = this.keys.getPublic(format5 === "compressed", true);
      if (format5 === "hybrid") {
        if (key[key.length - 1] % 2) {
          key[0] = 7;
        } else {
          key[0] = 6;
        }
      }
      return formatReturnValue(key, enc);
    };
    ECDH.prototype.getPrivateKey = function(enc) {
      return formatReturnValue(this.keys.getPrivate(), enc);
    };
    ECDH.prototype.setPublicKey = function(pub, enc) {
      enc = enc || "utf8";
      if (!import_buffer.Buffer.isBuffer(pub)) {
        pub = new import_buffer.Buffer(pub, enc);
      }
      this.keys._importPublic(pub);
      return this;
    };
    ECDH.prototype.setPrivateKey = function(priv, enc) {
      enc = enc || "utf8";
      if (!import_buffer.Buffer.isBuffer(priv)) {
        priv = new import_buffer.Buffer(priv, enc);
      }
      var _priv = new BN2(priv);
      _priv = _priv.toString(16);
      this.keys = this.curve.genKeyPair();
      this.keys._importPrivate(_priv);
      return this;
    };
    function formatReturnValue(bn, enc, len) {
      if (!Array.isArray(bn)) {
        bn = bn.toArray();
      }
      var buf2 = new import_buffer.Buffer(bn);
      if (len && buf2.length < len) {
        var zeros = new import_buffer.Buffer(len - buf2.length);
        zeros.fill(0);
        buf2 = import_buffer.Buffer.concat([zeros, buf2]);
      }
      if (!enc) {
        return buf2;
      } else {
        return buf2.toString(enc);
      }
    }
  }
});

// node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/mgf.js
var require_mgf = __commonJS({
  "node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/mgf.js"(exports2, module2) {
    init_buffer_polyfill();
    var createHash = require_browser4();
    var Buffer5 = require_safe_buffer().Buffer;
    module2.exports = function(seed, len) {
      var t = Buffer5.alloc(0);
      var i = 0;
      var c;
      while (t.length < len) {
        c = i2ops(i++);
        t = Buffer5.concat([t, createHash("sha1").update(seed).update(c).digest()]);
      }
      return t.slice(0, len);
    };
    function i2ops(c) {
      var out = Buffer5.allocUnsafe(4);
      out.writeUInt32BE(c, 0);
      return out;
    }
  }
});

// node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/xor.js
var require_xor = __commonJS({
  "node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/xor.js"(exports2, module2) {
    init_buffer_polyfill();
    module2.exports = function xor(a, b) {
      var len = a.length;
      var i = -1;
      while (++i < len) {
        a[i] ^= b[i];
      }
      return a;
    };
  }
});

// node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/withPublic.js
var require_withPublic = __commonJS({
  "node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/withPublic.js"(exports2, module2) {
    init_buffer_polyfill();
    var BN2 = require_bn();
    var Buffer5 = require_safe_buffer().Buffer;
    function withPublic(paddedMsg, key) {
      return Buffer5.from(paddedMsg.toRed(BN2.mont(key.modulus)).redPow(new BN2(key.publicExponent)).fromRed().toArray());
    }
    module2.exports = withPublic;
  }
});

// node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/publicEncrypt.js
var require_publicEncrypt = __commonJS({
  "node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/publicEncrypt.js"(exports2, module2) {
    init_buffer_polyfill();
    var parseKeys = require_parse_asn1();
    var randomBytes2 = require_browser2();
    var createHash = require_browser4();
    var mgf = require_mgf();
    var xor = require_xor();
    var BN2 = require_bn();
    var withPublic = require_withPublic();
    var crt = require_browserify_rsa();
    var Buffer5 = require_safe_buffer().Buffer;
    module2.exports = function publicEncrypt(publicKey, msg, reverse) {
      var padding;
      if (publicKey.padding) {
        padding = publicKey.padding;
      } else if (reverse) {
        padding = 1;
      } else {
        padding = 4;
      }
      var key = parseKeys(publicKey);
      var paddedMsg;
      if (padding === 4) {
        paddedMsg = oaep(key, msg);
      } else if (padding === 1) {
        paddedMsg = pkcs1(key, msg, reverse);
      } else if (padding === 3) {
        paddedMsg = new BN2(msg);
        if (paddedMsg.cmp(key.modulus) >= 0) {
          throw new Error("data too long for modulus");
        }
      } else {
        throw new Error("unknown padding");
      }
      if (reverse) {
        return crt(paddedMsg, key);
      } else {
        return withPublic(paddedMsg, key);
      }
    };
    function oaep(key, msg) {
      var k = key.modulus.byteLength();
      var mLen = msg.length;
      var iHash = createHash("sha1").update(Buffer5.alloc(0)).digest();
      var hLen = iHash.length;
      var hLen2 = 2 * hLen;
      if (mLen > k - hLen2 - 2) {
        throw new Error("message too long");
      }
      var ps = Buffer5.alloc(k - mLen - hLen2 - 2);
      var dblen = k - hLen - 1;
      var seed = randomBytes2(hLen);
      var maskedDb = xor(Buffer5.concat([iHash, ps, Buffer5.alloc(1, 1), msg], dblen), mgf(seed, dblen));
      var maskedSeed = xor(seed, mgf(maskedDb, hLen));
      return new BN2(Buffer5.concat([Buffer5.alloc(1), maskedSeed, maskedDb], k));
    }
    function pkcs1(key, msg, reverse) {
      var mLen = msg.length;
      var k = key.modulus.byteLength();
      if (mLen > k - 11) {
        throw new Error("message too long");
      }
      var ps;
      if (reverse) {
        ps = Buffer5.alloc(k - mLen - 3, 255);
      } else {
        ps = nonZero(k - mLen - 3);
      }
      return new BN2(Buffer5.concat([Buffer5.from([0, reverse ? 1 : 2]), ps, Buffer5.alloc(1), msg], k));
    }
    function nonZero(len) {
      var out = Buffer5.allocUnsafe(len);
      var i = 0;
      var cache4 = randomBytes2(len * 2);
      var cur = 0;
      var num2;
      while (i < len) {
        if (cur === cache4.length) {
          cache4 = randomBytes2(len * 2);
          cur = 0;
        }
        num2 = cache4[cur++];
        if (num2) {
          out[i++] = num2;
        }
      }
      return out;
    }
  }
});

// node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/privateDecrypt.js
var require_privateDecrypt = __commonJS({
  "node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/privateDecrypt.js"(exports2, module2) {
    init_buffer_polyfill();
    var parseKeys = require_parse_asn1();
    var mgf = require_mgf();
    var xor = require_xor();
    var BN2 = require_bn();
    var crt = require_browserify_rsa();
    var createHash = require_browser4();
    var withPublic = require_withPublic();
    var Buffer5 = require_safe_buffer().Buffer;
    module2.exports = function privateDecrypt(privateKey, enc, reverse) {
      var padding;
      if (privateKey.padding) {
        padding = privateKey.padding;
      } else if (reverse) {
        padding = 1;
      } else {
        padding = 4;
      }
      var key = parseKeys(privateKey);
      var k = key.modulus.byteLength();
      if (enc.length > k || new BN2(enc).cmp(key.modulus) >= 0) {
        throw new Error("decryption error");
      }
      var msg;
      if (reverse) {
        msg = withPublic(new BN2(enc), key);
      } else {
        msg = crt(enc, key);
      }
      var zBuffer = Buffer5.alloc(k - msg.length);
      msg = Buffer5.concat([zBuffer, msg], k);
      if (padding === 4) {
        return oaep(key, msg);
      } else if (padding === 1) {
        return pkcs1(key, msg, reverse);
      } else if (padding === 3) {
        return msg;
      } else {
        throw new Error("unknown padding");
      }
    };
    function oaep(key, msg) {
      var k = key.modulus.byteLength();
      var iHash = createHash("sha1").update(Buffer5.alloc(0)).digest();
      var hLen = iHash.length;
      if (msg[0] !== 0) {
        throw new Error("decryption error");
      }
      var maskedSeed = msg.slice(1, hLen + 1);
      var maskedDb = msg.slice(hLen + 1);
      var seed = xor(maskedSeed, mgf(maskedDb, hLen));
      var db = xor(maskedDb, mgf(seed, k - hLen - 1));
      if (compare4(iHash, db.slice(0, hLen))) {
        throw new Error("decryption error");
      }
      var i = hLen;
      while (db[i] === 0) {
        i++;
      }
      if (db[i++] !== 1) {
        throw new Error("decryption error");
      }
      return db.slice(i);
    }
    function pkcs1(key, msg, reverse) {
      var p1 = msg.slice(0, 2);
      var i = 2;
      var status = 0;
      while (msg[i++] !== 0) {
        if (i >= msg.length) {
          status++;
          break;
        }
      }
      var ps = msg.slice(2, i - 1);
      if (p1.toString("hex") !== "0002" && !reverse || p1.toString("hex") !== "0001" && reverse) {
        status++;
      }
      if (ps.length < 8) {
        status++;
      }
      if (status) {
        throw new Error("decryption error");
      }
      return msg.slice(i);
    }
    function compare4(a, b) {
      a = Buffer5.from(a);
      b = Buffer5.from(b);
      var dif = 0;
      var len = a.length;
      if (a.length !== b.length) {
        dif++;
        len = Math.min(a.length, b.length);
      }
      var i = -1;
      while (++i < len) {
        dif += a[i] ^ b[i];
      }
      return dif;
    }
  }
});

// node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/browser.js
var require_browser12 = __commonJS({
  "node_modules/.pnpm/public-encrypt@4.0.3/node_modules/public-encrypt/browser.js"(exports2) {
    init_buffer_polyfill();
    exports2.publicEncrypt = require_publicEncrypt();
    exports2.privateDecrypt = require_privateDecrypt();
    exports2.privateEncrypt = function privateEncrypt(key, buf2) {
      return exports2.publicEncrypt(key, buf2, true);
    };
    exports2.publicDecrypt = function publicDecrypt(key, buf2) {
      return exports2.privateDecrypt(key, buf2, true);
    };
  }
});

// node_modules/.pnpm/randomfill@1.0.4/node_modules/randomfill/browser.js
var require_browser13 = __commonJS({
  "node_modules/.pnpm/randomfill@1.0.4/node_modules/randomfill/browser.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    function oldBrowser() {
      throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
    }
    var safeBuffer = require_safe_buffer();
    var randombytes = require_browser2();
    var Buffer5 = safeBuffer.Buffer;
    var kBufferMaxLength = safeBuffer.kMaxLength;
    var crypto2 = globalThis.crypto || globalThis.msCrypto;
    var kMaxUint32 = Math.pow(2, 32) - 1;
    function assertOffset(offset, length6) {
      if (typeof offset !== "number" || offset !== offset) {
        throw new TypeError("offset must be a number");
      }
      if (offset > kMaxUint32 || offset < 0) {
        throw new TypeError("offset must be a uint32");
      }
      if (offset > kBufferMaxLength || offset > length6) {
        throw new RangeError("offset out of range");
      }
    }
    function assertSize(size, offset, length6) {
      if (typeof size !== "number" || size !== size) {
        throw new TypeError("size must be a number");
      }
      if (size > kMaxUint32 || size < 0) {
        throw new TypeError("size must be a uint32");
      }
      if (size + offset > length6 || size > kBufferMaxLength) {
        throw new RangeError("buffer too small");
      }
    }
    if (crypto2 && crypto2.getRandomValues || false) {
      exports2.randomFill = randomFill;
      exports2.randomFillSync = randomFillSync;
    } else {
      exports2.randomFill = oldBrowser;
      exports2.randomFillSync = oldBrowser;
    }
    function randomFill(buf2, offset, size, cb) {
      if (!Buffer5.isBuffer(buf2) && !(buf2 instanceof globalThis.Uint8Array)) {
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      }
      if (typeof offset === "function") {
        cb = offset;
        offset = 0;
        size = buf2.length;
      } else if (typeof size === "function") {
        cb = size;
        size = buf2.length - offset;
      } else if (typeof cb !== "function") {
        throw new TypeError('"cb" argument must be a function');
      }
      assertOffset(offset, buf2.length);
      assertSize(size, offset, buf2.length);
      return actualFill(buf2, offset, size, cb);
    }
    function actualFill(buf2, offset, size, cb) {
      if (true) {
        var ourBuf = buf2.buffer;
        var uint = new Uint8Array(ourBuf, offset, size);
        crypto2.getRandomValues(uint);
        if (cb) {
          import_process.default.nextTick(function() {
            cb(null, buf2);
          });
          return;
        }
        return buf2;
      }
      if (cb) {
        randombytes(size, function(err, bytes2) {
          if (err) {
            return cb(err);
          }
          bytes2.copy(buf2, offset);
          cb(null, buf2);
        });
        return;
      }
      var bytes = randombytes(size);
      bytes.copy(buf2, offset);
      return buf2;
    }
    function randomFillSync(buf2, offset, size) {
      if (typeof offset === "undefined") {
        offset = 0;
      }
      if (!Buffer5.isBuffer(buf2) && !(buf2 instanceof globalThis.Uint8Array)) {
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      }
      assertOffset(offset, buf2.length);
      if (size === void 0) size = buf2.length - offset;
      assertSize(size, offset, buf2.length);
      return actualFill(buf2, offset, size);
    }
  }
});

// node_modules/.pnpm/crypto-browserify@3.12.1/node_modules/crypto-browserify/index.js
var require_crypto_browserify = __commonJS({
  "node_modules/.pnpm/crypto-browserify@3.12.1/node_modules/crypto-browserify/index.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    exports2.randomBytes = exports2.rng = exports2.pseudoRandomBytes = exports2.prng = require_browser2();
    exports2.createHash = exports2.Hash = require_browser4();
    exports2.createHmac = exports2.Hmac = require_browser5();
    var algos = require_algos();
    var algoKeys = Object.keys(algos);
    var hashes4 = [
      "sha1",
      "sha224",
      "sha256",
      "sha384",
      "sha512",
      "md5",
      "rmd160"
    ].concat(algoKeys);
    exports2.getHashes = function() {
      return hashes4;
    };
    var p = require_browser6();
    exports2.pbkdf2 = p.pbkdf2;
    exports2.pbkdf2Sync = p.pbkdf2Sync;
    var aes = require_browser8();
    exports2.Cipher = aes.Cipher;
    exports2.createCipher = aes.createCipher;
    exports2.Cipheriv = aes.Cipheriv;
    exports2.createCipheriv = aes.createCipheriv;
    exports2.Decipher = aes.Decipher;
    exports2.createDecipher = aes.createDecipher;
    exports2.Decipheriv = aes.Decipheriv;
    exports2.createDecipheriv = aes.createDecipheriv;
    exports2.getCiphers = aes.getCiphers;
    exports2.listCiphers = aes.listCiphers;
    var dh = require_browser9();
    exports2.DiffieHellmanGroup = dh.DiffieHellmanGroup;
    exports2.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
    exports2.getDiffieHellman = dh.getDiffieHellman;
    exports2.createDiffieHellman = dh.createDiffieHellman;
    exports2.DiffieHellman = dh.DiffieHellman;
    var sign2 = require_browser10();
    exports2.createSign = sign2.createSign;
    exports2.Sign = sign2.Sign;
    exports2.createVerify = sign2.createVerify;
    exports2.Verify = sign2.Verify;
    exports2.createECDH = require_browser11();
    var publicEncrypt = require_browser12();
    exports2.publicEncrypt = publicEncrypt.publicEncrypt;
    exports2.privateEncrypt = publicEncrypt.privateEncrypt;
    exports2.publicDecrypt = publicEncrypt.publicDecrypt;
    exports2.privateDecrypt = publicEncrypt.privateDecrypt;
    var rf = require_browser13();
    exports2.randomFill = rf.randomFill;
    exports2.randomFillSync = rf.randomFillSync;
    exports2.createCredentials = function() {
      throw new Error("sorry, createCredentials is not implemented yet\nwe accept pull requests\nhttps://github.com/browserify/crypto-browserify");
    };
    exports2.constants = {
      DH_CHECK_P_NOT_SAFE_PRIME: 2,
      DH_CHECK_P_NOT_PRIME: 1,
      DH_UNABLE_TO_CHECK_GENERATOR: 4,
      DH_NOT_SUITABLE_GENERATOR: 8,
      NPN_ENABLED: 1,
      ALPN_ENABLED: 1,
      RSA_PKCS1_PADDING: 1,
      RSA_SSLV23_PADDING: 2,
      RSA_NO_PADDING: 3,
      RSA_PKCS1_OAEP_PADDING: 4,
      RSA_X931_PADDING: 5,
      RSA_PKCS1_PSS_PADDING: 6,
      POINT_CONVERSION_COMPRESSED: 2,
      POINT_CONVERSION_UNCOMPRESSED: 4,
      POINT_CONVERSION_HYBRID: 6
    };
  }
});

// node_modules/.pnpm/brorand@1.1.0/node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/.pnpm/brorand@1.1.0/node_modules/brorand/index.js"(exports2, module2) {
    init_buffer_polyfill();
    var r;
    module2.exports = function rand(len) {
      if (!r)
        r = new Rand(null);
      return r.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module2.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n2) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n2);
      var res = new Uint8Array(n2);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n2) {
          var arr = new Uint8Array(n2);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n2) {
          var arr = new Uint8Array(n2);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto2 = require_crypto_browserify();
        if (typeof crypto2.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n2) {
          return crypto2.randomBytes(n2);
        };
      } catch (e) {
      }
    }
    var crypto2;
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/base.js
var require_base2 = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/base.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var BN2 = require_bn();
    var utils = require_utils2();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert3 = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN2(conf.p, 16);
      this.red = conf.prime ? BN2.red(conf.prime) : BN2.mont(this.p);
      this.zero = new BN2(0).toRed(this.red);
      this.one = new BN2(1).toRed(this.red);
      this.two = new BN2(2).toRed(this.red);
      this.n = conf.n && new BN2(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module2.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate4() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
      assert3(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF(k, 1, this._bitLength);
      var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1; l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null);
      var b = this.jpoint(null, null, null);
      for (var i = I; i > 0; i--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i)
            b = b.mixedAdd(doubles.points[j]);
          else if (nafW === -i)
            b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
      }
      return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
      var w = 4;
      var nafPoints = p._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k, w, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i = naf.length - 1; i >= 0; i--) {
        for (var l = 0; i >= 0 && naf[i] === 0; i--)
          l++;
        if (i >= 0)
          l++;
        acc = acc.dblp(l);
        if (i < 0)
          break;
        var z = naf[i];
        assert3(z !== 0);
        if (p.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i;
      var j;
      var p;
      for (i = 0; i < len; i++) {
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
      }
      for (i = len - 1; i >= 1; i -= 2) {
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
          naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
          max = Math.max(naf[a].length, max);
          max = Math.max(naf[b].length, max);
          continue;
        }
        var comb = [
          points[a],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b]
          /* 7 */
        ];
        if (points[a].y.cmp(points[b].y) === 0) {
          comb[1] = points[a].add(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].add(points[b].neg());
        } else {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for (j = 0; j < max; j++) {
          var ja = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b][j] = 0;
          wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i = max; i >= 0; i--) {
        var k = 0;
        while (i >= 0) {
          var zero = true;
          for (j = 0; j < len; j++) {
            tmp[j] = naf[j][i] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k++;
          i--;
        }
        if (i >= 0)
          k++;
        acc = acc.dblp(k);
        if (i < 0)
          break;
        for (j = 0; j < len; j++) {
          var z = tmp[j];
          p;
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i = 0; i < len; i++)
        wnd[i] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate4() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert3(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert3(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode42(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i = 0; i < power; i += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i = 1; i < max; i++)
        res[i] = res[i - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
      var r = this;
      for (var i = 0; i < k; i++)
        r = r.dbl();
      return r;
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/short.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var utils = require_utils2();
    var BN2 = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var assert3 = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN2(conf.a, 16).toRed(this.red);
      this.b = new BN2(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module2.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN2(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN2(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert3(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN2(vec.a, 16),
            b: new BN2(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num2) {
      var red = num2 === this.p ? this.red : BN2.mont(num2);
      var tinv = new BN2(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s = new BN2(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s).fromRed();
      var l2 = ntinv.redSub(s).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u = lambda;
      var v = this.n.clone();
      var x1 = new BN2(1);
      var y1 = new BN2(0);
      var x2 = new BN2(0);
      var y2 = new BN2(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i = 0;
      var r;
      var x;
      while (u.cmpn(0) !== 0) {
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r.neg();
          b1 = x;
        } else if (a1 && ++i === 2) {
          break;
        }
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      a2 = r.neg();
      b2 = x;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k).divRound(this.n);
      var c2 = v1.b.neg().mul(k).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c2.mul(v2.b);
      var k1 = k.sub(p1).sub(p2);
      var k2 = q1.add(q2).neg();
      return { k1, k2 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN2(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate4(point) {
      if (point.inf)
        return true;
      var x = point.x;
      var y = point.y;
      var ax = this.a.redMul(x);
      var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split2 = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split2.k1.negative) {
          split2.k1.ineg();
          p = p.neg(true);
        }
        if (split2.k2.negative) {
          split2.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split2.k1;
        ncoeffs[i * 2 + 1] = split2.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };
    function Point(curve, x, y, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN2(x, 16);
        this.y = new BN2(y, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x, y, isRed) {
      return new Point(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add2(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p.x).redInvm());
      var nx = c.redSqr().redISub(this.x).redISub(p.x);
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
      var nx = c.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k) {
      k = new BN2(k, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
          return p.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x, y, z) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN2(0);
      } else {
        this.x = new BN2(x, 16);
        this.y = new BN2(y, 16);
        this.z = new BN2(z, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
      return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add2(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p.z));
      var s2 = p.y.redMul(z2.redMul(this.z));
      var h3 = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h3.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h3.redSqr();
      var h32 = h22.redMul(h3);
      var v = u1.redMul(h22);
      var nx = r.redSqr().redIAdd(h32).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(p.z).redMul(h3);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p.x.redMul(z2);
      var s1 = this.y;
      var s2 = p.y.redMul(z2).redMul(this.z);
      var h3 = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h3.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h3.redSqr();
      var h32 = h22.redMul(h3);
      var v = u1.redMul(h22);
      var nx = r.redSqr().redIAdd(h32).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(h3);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i;
      if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for (i = 0; i < pow; i++)
          r = r.dbl();
        return r;
      }
      var a = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i = 0; i < pow; i++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s).redISub(s);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = b.redSqr();
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        var e = a.redAdd(a).redIAdd(a);
        var f = e.redSqr();
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f.redISub(d).redISub(d);
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s).redISub(s);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
      var yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
      k = new BN2(k, kbase);
      return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
      var zs = this.z.redSqr();
      var rx = x.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/mont.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var BN2 = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var utils = require_utils2();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN2(conf.a, 16).toRed(this.red);
      this.b = new BN2(conf.b, 16).toRed(this.red);
      this.i4 = new BN2(4).toRed(this.red).redInvm();
      this.two = new BN2(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module2.exports = MontCurve;
    MontCurve.prototype.validate = function validate4(point) {
      var x = point.normalize().x;
      var x2 = x.redSqr();
      var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
      var y = rhs.redSqrt();
      return y.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x, z) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN2(x, 16);
        this.z = new BN2(z, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x, z) {
      return new Point(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a = this.x.redAdd(this.z);
      var aa = a.redSqr();
      var b = this.x.redSub(this.z);
      var bb = b.redSqr();
      var c = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add2() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p, diff) {
      var a = this.x.redAdd(this.z);
      var b = this.x.redSub(this.z);
      var c = p.x.redAdd(p.z);
      var d = p.x.redSub(p.z);
      var da = d.redMul(a);
      var cb = c.redMul(b);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k) {
      var t = k.clone();
      var a = this;
      var b = this.curve.point(null, null);
      var c = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i = bits.length - 1; i >= 0; i--) {
        if (bits[i] === 0) {
          a = a.diffAdd(b, c);
          b = b.dbl();
        } else {
          b = a.diffAdd(b, c);
          a = a.dbl();
        }
      }
      return b;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var utils = require_utils2();
    var BN2 = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var assert3 = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN2(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN2(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN2(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert3(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module2.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num2) {
      if (this.mOneA)
        return num2.redNeg();
      else
        return this.a.redMul(num2);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num2) {
      if (this.oneC)
        return num2;
      else
        return this.c.redMul(num2);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
      return this.point(x, y, z, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN2(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var x2 = x.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x2));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
      var y2 = rhs.redMul(lhs.redInvm());
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
      y = new BN2(y, 16);
      if (!y.red)
        y = y.toRed(this.red);
      var y2 = y.redSqr();
      var lhs = y2.redSub(this.c2);
      var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x2 = lhs.redMul(rhs.redInvm());
      if (x2.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y);
      }
      var x = x2.redSqrt();
      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x.fromRed().isOdd() !== odd)
        x = x.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.validate = function validate4(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x2 = point.x.redSqr();
      var y2 = point.y.redSqr();
      var lhs = x2.redMul(this.a).redAdd(y2);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x, y, z, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN2(x, 16);
        this.y = new BN2(y, 16);
        this.z = z ? new BN2(z, 16) : this.curve.one;
        this.t = t && new BN2(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x, y, z, t) {
      return new Point(this, x, y, z, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = this.z.redSqr();
      c = c.redIAdd(c);
      var d = this.curve._mulA(a);
      var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
      var g = d.redAdd(b);
      var f = g.redSub(c);
      var h3 = d.redSub(b);
      var nx = e.redMul(f);
      var ny = g.redMul(h3);
      var nt = e.redMul(h3);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b = this.x.redAdd(this.y).redSqr();
      var c = this.x.redSqr();
      var d = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h3;
      var j;
      if (this.curve.twisted) {
        e = this.curve._mulA(c);
        var f = e.redAdd(d);
        if (this.zOne) {
          nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
          ny = f.redMul(e.redSub(d));
          nz = f.redSqr().redSub(f).redSub(f);
        } else {
          h3 = this.z.redSqr();
          j = f.redSub(h3).redISub(h3);
          nx = b.redSub(c).redISub(d).redMul(j);
          ny = f.redMul(e.redSub(d));
          nz = f.redMul(j);
        }
      } else {
        e = c.redAdd(d);
        h3 = this.curve._mulC(this.z).redSqr();
        j = e.redSub(h3).redSub(h3);
        nx = this.curve._mulC(b.redISub(e)).redMul(j);
        ny = this.curve._mulC(e).redMul(c.redISub(d));
        nz = e.redMul(j);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p) {
      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
      var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
      var c = this.t.redMul(this.curve.dd).redMul(p.t);
      var d = this.z.redMul(p.z.redAdd(p.z));
      var e = b.redSub(a);
      var f = d.redSub(c);
      var g = d.redAdd(c);
      var h3 = b.redAdd(a);
      var nx = e.redMul(f);
      var ny = g.redMul(h3);
      var nt = e.redMul(h3);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p) {
      var a = this.z.redMul(p.z);
      var b = a.redSqr();
      var c = this.x.redMul(p.x);
      var d = this.y.redMul(p.y);
      var e = this.curve.d.redMul(c).redMul(d);
      var f = b.redSub(e);
      var g = b.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
      var nx = a.redMul(f).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        nz = f.redMul(g);
      } else {
        ny = a.redMul(g).redMul(d.redSub(c));
        nz = this.curve._mulC(f).redMul(g);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add2(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p);
      else
        return this._projAdd(p);
    };
    Point.prototype.mul = function mul(k) {
      if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x) {
      var rx = x.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/index.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var curve = exports2;
    curve.base = require_base2();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js
var require_utils4 = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var assert3 = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports2.inherits = inherits;
    function isSurrogatePair(msg, i) {
      if ((msg.charCodeAt(i) & 64512) !== 55296) {
        return false;
      }
      if (i < 0 || i + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            if (c < 128) {
              res[p++] = c;
            } else if (c < 2048) {
              res[p++] = c >> 6 | 192;
              res[p++] = c & 63 | 128;
            } else if (isSurrogatePair(msg, i)) {
              c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
              res[p++] = c >> 18 | 240;
              res[p++] = c >> 12 & 63 | 128;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            } else {
              res[p++] = c >> 12 | 224;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
      } else {
        for (i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
      }
      return res;
    }
    exports2.toArray = toArray;
    function toHex3(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    exports2.toHex = toHex3;
    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
      return res >>> 0;
    }
    exports2.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i = 0; i < msg.length; i++) {
        var w = msg[i];
        if (endian === "little")
          w = htonl(w);
        res += zero8(w.toString(16));
      }
      return res;
    }
    exports2.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports2.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports2.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert3(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i = 0, k = start; i < res.length; i++, k += 4) {
        var w;
        if (endian === "big")
          w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else
          w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
      }
      return res;
    }
    exports2.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
        var m = msg[i];
        if (endian === "big") {
          res[k] = m >>> 24;
          res[k + 1] = m >>> 16 & 255;
          res[k + 2] = m >>> 8 & 255;
          res[k + 3] = m & 255;
        } else {
          res[k + 3] = m >>> 24;
          res[k + 2] = m >>> 16 & 255;
          res[k + 1] = m >>> 8 & 255;
          res[k] = m & 255;
        }
      }
      return res;
    }
    exports2.split32 = split32;
    function rotr32(w, b) {
      return w >>> b | w << 32 - b;
    }
    exports2.rotr32 = rotr32;
    function rotl32(w, b) {
      return w << b | w >>> 32 - b;
    }
    exports2.rotl32 = rotl32;
    function sum32(a, b) {
      return a + b >>> 0;
    }
    exports2.sum32 = sum32;
    function sum32_3(a, b, c) {
      return a + b + c >>> 0;
    }
    exports2.sum32_3 = sum32_3;
    function sum32_4(a, b, c, d) {
      return a + b + c + d >>> 0;
    }
    exports2.sum32_4 = sum32_4;
    function sum32_5(a, b, c, d, e) {
      return a + b + c + d + e >>> 0;
    }
    exports2.sum32_5 = sum32_5;
    function sum64(buf2, pos, ah, al) {
      var bh = buf2[pos];
      var bl = buf2[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf2[pos] = hi >>> 0;
      buf2[pos + 1] = lo;
    }
    exports2.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports2.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports2.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports2.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports2.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports2.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports2.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num2) {
      var r = al << 32 - num2 | ah >>> num2;
      return r >>> 0;
    }
    exports2.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num2) {
      var r = ah << 32 - num2 | al >>> num2;
      return r >>> 0;
    }
    exports2.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num2) {
      return ah >>> num2;
    }
    exports2.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num2) {
      var r = ah << 32 - num2 | al >>> num2;
      return r >>> 0;
    }
    exports2.shr64_lo = shr64_lo;
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/common.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var utils = require_utils4();
    var assert3 = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports2.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for (var i = 0; i < msg.length; i += this._delta32)
          this._update(msg, i, i + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest4(enc) {
      this.update(this._pad());
      assert3(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k = bytes - (len + this.padLength) % bytes;
      var res = new Array(k + this.padLength);
      res[0] = 128;
      for (var i = 1; i < k; i++)
        res[i] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t = 8; t < this.padLength; t++)
          res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len & 255;
      } else {
        res[i++] = len & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 24 & 255;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for (t = 8; t < this.padLength; t++)
          res[i++] = 0;
      }
      return res;
    };
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/common.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var utils = require_utils4();
    var rotr32 = utils.rotr32;
    function ft_1(s, x, y, z) {
      if (s === 0)
        return ch32(x, y, z);
      if (s === 1 || s === 3)
        return p32(x, y, z);
      if (s === 2)
        return maj32(x, y, z);
    }
    exports2.ft_1 = ft_1;
    function ch32(x, y, z) {
      return x & y ^ ~x & z;
    }
    exports2.ch32 = ch32;
    function maj32(x, y, z) {
      return x & y ^ x & z ^ y & z;
    }
    exports2.maj32 = maj32;
    function p32(x, y, z) {
      return x ^ y ^ z;
    }
    exports2.p32 = p32;
    function s0_256(x) {
      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    exports2.s0_256 = s0_256;
    function s1_256(x) {
      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    exports2.s1_256 = s1_256;
    function g0_256(x) {
      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    exports2.g0_256 = g0_256;
    function g1_256(x) {
      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    exports2.g1_256 = g1_256;
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/1.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var utils = require_utils4();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module2.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      for (i = 0; i < W.length; i++) {
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b, 30);
        b = a;
        a = t;
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
    };
    SHA1.prototype._digest = function digest4(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/256.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var utils = require_utils4();
    var common = require_common();
    var shaCommon = require_common2();
    var assert3 = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA2562() {
      if (!(this instanceof SHA2562))
        return new SHA2562();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA2562, BlockHash);
    module2.exports = SHA2562;
    SHA2562.blockSize = 512;
    SHA2562.outSize = 256;
    SHA2562.hmacStrength = 192;
    SHA2562.padLength = 64;
    SHA2562.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      var f = this.h[5];
      var g = this.h[6];
      var h3 = this.h[7];
      assert3(this.k.length === W.length);
      for (i = 0; i < W.length; i++) {
        var T1 = sum32_5(h3, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b, c));
        h3 = g;
        g = f;
        f = e;
        e = sum32(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
      this.h[5] = sum32(this.h[5], f);
      this.h[6] = sum32(this.h[6], g);
      this.h[7] = sum32(this.h[7], h3);
    };
    SHA2562.prototype._digest = function digest4(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/224.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var utils = require_utils4();
    var SHA2562 = require__2();
    function SHA2242() {
      if (!(this instanceof SHA2242))
        return new SHA2242();
      SHA2562.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA2242, SHA2562);
    module2.exports = SHA2242;
    SHA2242.blockSize = 512;
    SHA2242.outSize = 224;
    SHA2242.hmacStrength = 192;
    SHA2242.padLength = 64;
    SHA2242.prototype._digest = function digest4(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/512.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var utils = require_utils4();
    var common = require_common();
    var assert3 = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA5122() {
      if (!(this instanceof SHA5122))
        return new SHA5122();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA5122, BlockHash);
    module2.exports = SHA5122;
    SHA5122.blockSize = 1024;
    SHA5122.outSize = 512;
    SHA5122.hmacStrength = 192;
    SHA5122.padLength = 128;
    SHA5122.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W = this.W;
      for (var i = 0; i < 32; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i += 2) {
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14];
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32];
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W[i + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA5122.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert3(this.k.length === W.length);
      for (var i = 0; i < W.length; i += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA5122.prototype._digest = function digest4(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ ~xh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ ~xl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ xh & zh ^ yh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ xl & zl ^ yl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/384.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var utils = require_utils4();
    var SHA5122 = require__4();
    function SHA3842() {
      if (!(this instanceof SHA3842))
        return new SHA3842();
      SHA5122.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA3842, SHA5122);
    module2.exports = SHA3842;
    SHA3842.blockSize = 1024;
    SHA3842.outSize = 384;
    SHA3842.hmacStrength = 192;
    SHA3842.padLength = 128;
    SHA3842.prototype._digest = function digest4(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha.js
var require_sha3 = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    exports2.sha1 = require__();
    exports2.sha224 = require__3();
    exports2.sha256 = require__2();
    exports2.sha384 = require__5();
    exports2.sha512 = require__4();
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/ripemd.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var utils = require_utils4();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD1602() {
      if (!(this instanceof RIPEMD1602))
        return new RIPEMD1602();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD1602, BlockHash);
    exports2.ripemd160 = RIPEMD1602;
    RIPEMD1602.blockSize = 512;
    RIPEMD1602.outSize = 160;
    RIPEMD1602.hmacStrength = 192;
    RIPEMD1602.padLength = 64;
    RIPEMD1602.prototype._update = function update(msg, start) {
      var A = this.h[0];
      var B = this.h[1];
      var C = this.h[2];
      var D = this.h[3];
      var E = this.h[4];
      var Ah = A;
      var Bh = B;
      var Ch = C;
      var Dh = D;
      var Eh = E;
      for (var j = 0; j < 80; j++) {
        var T = sum32(
          rotl32(
            sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
            s[j]
          ),
          E
        );
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(
          rotl32(
            sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
            sh[j]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
      }
      T = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D, Eh);
      this.h[2] = sum32_3(this.h[3], E, Ah);
      this.h[3] = sum32_3(this.h[4], A, Bh);
      this.h[4] = sum32_3(this.h[0], B, Ch);
      this.h[0] = T;
    };
    RIPEMD1602.prototype._digest = function digest4(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f(j, x, y, z) {
      if (j <= 15)
        return x ^ y ^ z;
      else if (j <= 31)
        return x & y | ~x & z;
      else if (j <= 47)
        return (x | ~y) ^ z;
      else if (j <= 63)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    function K(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/hmac.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var utils = require_utils4();
    var assert3 = require_minimalistic_assert();
    function Hmac(hash, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash, key, enc);
      this.Hash = hash;
      this.blockSize = hash.blockSize / 8;
      this.outSize = hash.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key, enc));
    }
    module2.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert3(key.length <= this.blockSize);
      for (var i = key.length; i < this.blockSize; i++)
        key.push(0);
      for (i = 0; i < key.length; i++)
        key[i] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i = 0; i < key.length; i++)
        key[i] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest4(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js
var require_hash2 = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js"(exports2) {
    init_buffer_polyfill();
    var hash = exports2;
    hash.utils = require_utils4();
    hash.common = require_common();
    hash.sha = require_sha3();
    hash.ripemd = require_ripemd();
    hash.hmac = require_hmac();
    hash.sha1 = hash.sha.sha1;
    hash.sha256 = hash.sha.sha256;
    hash.sha224 = hash.sha.sha224;
    hash.sha384 = hash.sha.sha384;
    hash.sha512 = hash.sha.sha512;
    hash.ripemd160 = hash.ripemd.ripemd160;
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports2, module2) {
    init_buffer_polyfill();
    module2.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curves.js
var require_curves2 = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curves.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var curves = exports2;
    var hash = require_hash2();
    var curve = require_curve();
    var utils = require_utils2();
    var assert3 = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert3(this.g.validate(), "Invalid curve");
      assert3(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name10, options) {
      Object.defineProperty(curves, name10, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name10, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/.pnpm/hmac-drbg@1.0.1/node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/.pnpm/hmac-drbg@1.0.1/node_modules/hmac-drbg/lib/hmac-drbg.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var hash = require_hash2();
    var utils = require_utils();
    var assert3 = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert3(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module2.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i = 0; i < this.V.length; i++) {
        this.K[i] = 0;
        this.V[i] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac3() {
      return new hash.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add2, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add2;
        add2 = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add2 = utils.toArray(add2, addEnc);
      assert3(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add2 || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add2, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add2;
        add2 = enc;
        enc = null;
      }
      if (add2) {
        add2 = utils.toArray(add2, addEnc || "hex");
        this._update(add2);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add2);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/key.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var BN2 = require_bn();
    var utils = require_utils2();
    var assert3 = utils.assert;
    function KeyPair(ec2, options) {
      this.ec = ec2;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module2.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec2, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec2, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate4() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN2(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert3(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert3(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert3(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign2(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify2(msg, signature2, options) {
      return this.ec.verify(msg, signature2, this, void 0, options);
    };
    KeyPair.prototype.inspect = function inspect4() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/signature.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var BN2 = require_bn();
    var utils = require_utils2();
    var assert3 = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert3(options.r && options.s, "Signature without r or s");
      this.r = new BN2(options.r, 16);
      this.s = new BN2(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module2.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf2, p) {
      var initial = buf2[p.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      if (buf2[p.place] === 0) {
        return false;
      }
      var val = 0;
      for (var i = 0, off = p.place; i < octetLen; i++, off++) {
        val <<= 8;
        val |= buf2[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p.place = off;
      return val;
    }
    function rmPadding(buf2) {
      var i = 0;
      var len = buf2.length - 1;
      while (!buf2[i] && !(buf2[i + 1] & 128) && i < len) {
        i++;
      }
      if (i === 0) {
        return buf2;
      }
      return buf2.slice(i);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p = new Position();
      if (data[p.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p);
      if (len === false) {
        return false;
      }
      if (len + p.place !== data.length) {
        return false;
      }
      if (data[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p);
      if (rlen === false) {
        return false;
      }
      if ((data[p.place] & 128) !== 0) {
        return false;
      }
      var r = data.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data[p.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p.place) {
        return false;
      }
      if ((data[p.place] & 128) !== 0) {
        return false;
      }
      var s = data.slice(p.place, slen + p.place);
      if (r[0] === 0) {
        if (r[1] & 128) {
          r = r.slice(1);
        } else {
          return false;
        }
      }
      if (s[0] === 0) {
        if (s[1] & 128) {
          s = s.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN2(r);
      this.s = new BN2(s);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r = this.r.toArray();
      var s = this.s.toArray();
      if (r[0] & 128)
        r = [0].concat(r);
      if (s[0] & 128)
        s = [0].concat(s);
      r = rmPadding(r);
      s = rmPadding(s);
      while (!s[0] && !(s[1] & 128)) {
        s = s.slice(1);
      }
      var arr = [2];
      constructLength(arr, r.length);
      arr = arr.concat(r);
      arr.push(2);
      constructLength(arr, s.length);
      var backHalf = arr.concat(s);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var BN2 = require_bn();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils2();
    var curves = require_curves2();
    var rand = require_brorand();
    var assert3 = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC2(options) {
      if (!(this instanceof EC2))
        return new EC2(options);
      if (typeof options === "string") {
        assert3(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module2.exports = EC2;
    EC2.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC2.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC2.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC2.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN2(2));
      for (; ; ) {
        var priv = new BN2(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC2.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
      var byteLength;
      if (BN2.isBN(msg) || typeof msg === "number") {
        msg = new BN2(msg, 16);
        byteLength = msg.byteLength();
      } else if (typeof msg === "object") {
        byteLength = msg.length;
        msg = new BN2(msg, 16);
      } else {
        var str = msg.toString();
        byteLength = str.length + 1 >>> 1;
        msg = new BN2(str, 16);
      }
      if (typeof bitLength !== "number") {
        bitLength = byteLength * 8;
      }
      var delta = bitLength - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC2.prototype.sign = function sign2(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      if (typeof msg !== "string" && typeof msg !== "number" && !BN2.isBN(msg)) {
        assert3(
          typeof msg === "object" && msg && typeof msg.length === "number",
          "Expected message to be an array-like, a hex string, or a BN instance"
        );
        assert3(msg.length >>> 0 === msg.length);
        for (var i = 0; i < msg.length; i++) assert3((msg[i] & 255) === msg[i]);
      }
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(msg, false, options.msgBitLength);
      assert3(!msg.isNeg(), "Can not sign a negative message");
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      assert3(new BN2(nonce).eq(msg), "Can not sign message");
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN2(1));
      for (var iter = 0; ; iter++) {
        var k = options.k ? options.k(iter) : new BN2(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0)
          continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        if (options.canonical && s.cmp(this.nh) > 0) {
          s = this.n.sub(s);
          recoveryParam ^= 1;
        }
        return new Signature({ r, s, recoveryParam });
      }
    };
    EC2.prototype.verify = function verify2(msg, signature2, key, enc, options) {
      if (!options)
        options = {};
      msg = this._truncateToN(msg, false, options.msgBitLength);
      key = this.keyFromPublic(key, enc);
      signature2 = new Signature(signature2, "hex");
      var r = signature2.r;
      var s = signature2.s;
      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r) === 0;
      }
      p = this.g.jmulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r);
    };
    EC2.prototype.recoverPubKey = function(msg, signature2, j, enc) {
      assert3((3 & j) === j, "The recovery param is more than two bits");
      signature2 = new Signature(signature2, enc);
      var n2 = this.n;
      var e = new BN2(msg);
      var r = signature2.r;
      var s = signature2.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
      else
        r = this.curve.pointFromX(r, isYOdd);
      var rInv = signature2.r.invm(n2);
      var s1 = n2.sub(e).mul(rInv).umod(n2);
      var s2 = s.mul(rInv).umod(n2);
      return this.g.mulAdd(s1, r, s2);
    };
    EC2.prototype.getKeyRecoveryParam = function(e, signature2, Q, enc) {
      signature2 = new Signature(signature2, enc);
      if (signature2.recoveryParam !== null)
        return signature2.recoveryParam;
      for (var i = 0; i < 4; i++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature2, i);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q))
          return i;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var utils = require_utils2();
    var assert3 = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a = hash.slice(0, eddsa.encodingLength);
      a[0] &= 248;
      a[lastIx] &= 127;
      a[lastIx] |= 64;
      return a;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign2(message) {
      assert3(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify2(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert3(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module2.exports = KeyPair;
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var BN2 = require_bn();
    var utils = require_utils2();
    var assert3 = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        assert3(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert3(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN2)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes4() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex3() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module2.exports = Signature;
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var hash = require_hash2();
    var curves = require_curves2();
    var utils = require_utils2();
    var assert3 = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert3(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module2.exports = EDDSA;
    EDDSA.prototype.sign = function sign2(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r = this.hashInt(key.messagePrefix(), message);
      var R = this.g.mul(r);
      var Rencoded = this.encodePoint(R);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S = r.add(s_).umod(this.curve.n);
      return this.makeSignature({ R, S, Rencoded });
    };
    EDDSA.prototype.verify = function verify2(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
        return false;
      }
      var key = this.keyFromPublic(pub);
      var h3 = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h3));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i = 0; i < arguments.length; i++)
        hash2.update(arguments[i]);
      return utils.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y = utils.intFromLE(normed);
      return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num2) {
      return num2.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint3(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var elliptic = exports2;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils2();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves2();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js
var require_encode = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js"(exports2, module2) {
    init_buffer_polyfill();
    module2.exports = encode42;
    var MSB5 = 128;
    var REST5 = 127;
    var MSBALL4 = ~REST5;
    var INT4 = Math.pow(2, 31);
    function encode42(num2, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num2 > Number.MAX_SAFE_INTEGER) {
        encode42.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num2 >= INT4) {
        out[offset++] = num2 & 255 | MSB5;
        num2 /= 128;
      }
      while (num2 & MSBALL4) {
        out[offset++] = num2 & 255 | MSB5;
        num2 >>>= 7;
      }
      out[offset] = num2 | 0;
      encode42.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js
var require_decode = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js"(exports2, module2) {
    init_buffer_polyfill();
    module2.exports = read4;
    var MSB5 = 128;
    var REST5 = 127;
    function read4(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l || shift > 49) {
          read4.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST5) << shift : (b & REST5) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB5);
      read4.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js
var require_length = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js"(exports2, module2) {
    init_buffer_polyfill();
    var N15 = Math.pow(2, 7);
    var N25 = Math.pow(2, 14);
    var N35 = Math.pow(2, 21);
    var N45 = Math.pow(2, 28);
    var N55 = Math.pow(2, 35);
    var N65 = Math.pow(2, 42);
    var N75 = Math.pow(2, 49);
    var N84 = Math.pow(2, 56);
    var N94 = Math.pow(2, 63);
    module2.exports = function(value2) {
      return value2 < N15 ? 1 : value2 < N25 ? 2 : value2 < N35 ? 3 : value2 < N45 ? 4 : value2 < N55 ? 5 : value2 < N65 ? 6 : value2 < N75 ? 7 : value2 < N84 ? 8 : value2 < N94 ? 9 : 10;
    };
  }
});

// node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js
var require_varint = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js"(exports2, module2) {
    init_buffer_polyfill();
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js
var require_err_code = __commonJS({
  "node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code10, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code10 === "object") {
        props = code10;
        code10 = "";
      }
      if (code10) {
        props.code = code10;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        const output = assign(new ErrClass(), props);
        return output;
      }
    }
    module2.exports = createError;
  }
});

// node_modules/.pnpm/is-electron@2.2.2/node_modules/is-electron/index.js
var require_is_electron = __commonJS({
  "node_modules/.pnpm/is-electron@2.2.2/node_modules/is-electron/index.js"(exports2, module2) {
    init_buffer_polyfill();
    function isElectron() {
      if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
        return true;
      }
      if (typeof import_process.default !== "undefined" && typeof import_process.default.versions === "object" && !!import_process.default.versions.electron) {
        return true;
      }
      if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
        return true;
      }
      return false;
    }
    module2.exports = isElectron;
  }
});

// node_modules/.pnpm/ipfs-utils@9.0.14_encoding@0.1.13/node_modules/ipfs-utils/src/env.js
var require_env = __commonJS({
  "node_modules/.pnpm/ipfs-utils@9.0.14_encoding@0.1.13/node_modules/ipfs-utils/src/env.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var isElectron = require_is_electron();
    var IS_ENV_WITH_DOM = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
    var IS_ELECTRON = isElectron();
    var IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
    var IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
    var IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
    var IS_NODE = typeof __require === "function" && typeof import_process.default !== "undefined" && typeof import_process.default.release !== "undefined" && import_process.default.release.name === "node" && !IS_ELECTRON;
    var IS_WEBWORKER = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
    var IS_TEST = typeof import_process.default !== "undefined" && typeof import_process.default.env !== "undefined" && false;
    var IS_REACT_NATIVE = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    module2.exports = {
      isTest: IS_TEST,
      isElectron: IS_ELECTRON,
      isElectronMain: IS_ELECTRON_MAIN,
      isElectronRenderer: IS_ELECTRON_RENDERER,
      isNode: IS_NODE,
      /**
       * Detects browser main thread  **NOT** web worker or service worker
       */
      isBrowser: IS_BROWSER,
      isWebWorker: IS_WEBWORKER,
      isEnvWithDom: IS_ENV_WITH_DOM,
      isReactNative: IS_REACT_NATIVE
    };
  }
});

// node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports2, module2) {
    init_buffer_polyfill();
    var s = 1e3;
    var m = s * 60;
    var h3 = m * 60;
    var d = h3 * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse5(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse5(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n2 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y;
        case "weeks":
        case "week":
        case "w":
          return n2 * w;
        case "days":
        case "day":
        case "d":
          return n2 * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h3;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h3) {
        return Math.round(ms / h3) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h3) {
        return plural(ms, msAbs, h3, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n2, name10) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name10 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js
var require_common3 = __commonJS({
  "node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js"(exports2, module2) {
    init_buffer_polyfill();
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce4;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format5) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format5];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split2 = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split2) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name10) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name10, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name10, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce4(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js
var require_browser14 = __commonJS({
  "node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js"(exports2, module2) {
    init_buffer_polyfill();
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof import_process.default !== "undefined" && "env" in import_process.default) {
        r = import_process.default.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common3()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/.pnpm/ipfs-utils@9.0.14_encoding@0.1.13/node_modules/ipfs-utils/src/http/error.js
var require_error = __commonJS({
  "node_modules/.pnpm/ipfs-utils@9.0.14_encoding@0.1.13/node_modules/ipfs-utils/src/http/error.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var TimeoutError = class extends Error {
      constructor(message = "Request timed out") {
        super(message);
        this.name = "TimeoutError";
      }
    };
    exports2.TimeoutError = TimeoutError;
    var AbortError = class extends Error {
      constructor(message = "The operation was aborted.") {
        super(message);
        this.name = "AbortError";
      }
    };
    exports2.AbortError = AbortError;
    var HTTPError2 = class extends Error {
      /**
       * @param {Response} response
       */
      constructor(response) {
        super(response.statusText);
        this.name = "HTTPError";
        this.response = response;
      }
    };
    exports2.HTTPError = HTTPError2;
  }
});

// node_modules/.pnpm/node-fetch@2.7.0_encoding@0.1.13/node_modules/node-fetch/browser.js
var require_browser15 = __commonJS({
  "node_modules/.pnpm/node-fetch@2.7.0_encoding@0.1.13/node_modules/node-fetch/browser.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof globalThis !== "undefined") {
        return globalThis;
      }
      throw new Error("unable to locate global object");
    };
    var globalObject = getGlobal();
    module2.exports = exports2 = globalObject.fetch;
    if (globalObject.fetch) {
      exports2.default = globalObject.fetch.bind(globalObject);
    }
    exports2.Headers = globalObject.Headers;
    exports2.Request = globalObject.Request;
    exports2.Response = globalObject.Response;
  }
});

// node_modules/.pnpm/native-fetch@3.0.0_node-fetch@2.7.0_encoding@0.1.13_/node_modules/native-fetch/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/native-fetch@3.0.0_node-fetch@2.7.0_encoding@0.1.13_/node_modules/native-fetch/src/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    if (globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response) {
      module2.exports = {
        default: globalThis.fetch,
        Headers: globalThis.Headers,
        Request: globalThis.Request,
        Response: globalThis.Response
      };
    } else {
      module2.exports = {
        default: require_browser15().default,
        Headers: require_browser15().Headers,
        Request: require_browser15().Request,
        Response: require_browser15().Response
      };
    }
  }
});

// node_modules/.pnpm/ipfs-utils@9.0.14_encoding@0.1.13/node_modules/ipfs-utils/src/fetch.browser.js
var require_fetch_browser = __commonJS({
  "node_modules/.pnpm/ipfs-utils@9.0.14_encoding@0.1.13/node_modules/ipfs-utils/src/fetch.browser.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = require_src();
  }
});

// node_modules/.pnpm/ipfs-utils@9.0.14_encoding@0.1.13/node_modules/ipfs-utils/src/http/fetch.browser.js
var require_fetch_browser2 = __commonJS({
  "node_modules/.pnpm/ipfs-utils@9.0.14_encoding@0.1.13/node_modules/ipfs-utils/src/http/fetch.browser.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var { TimeoutError, AbortError } = require_error();
    var { Response: Response2, Request, Headers, default: fetch2 } = require_fetch_browser();
    var fetchWithProgress = (url, options = {}) => {
      const request = new XMLHttpRequest();
      request.open(options.method || "GET", url.toString(), true);
      const { timeout, headers } = options;
      if (timeout && timeout > 0 && timeout < Infinity) {
        request.timeout = timeout;
      }
      if (options.overrideMimeType != null) {
        request.overrideMimeType(options.overrideMimeType);
      }
      if (headers) {
        for (const [name10, value2] of new Headers(headers)) {
          request.setRequestHeader(name10, value2);
        }
      }
      if (options.signal) {
        options.signal.onabort = () => request.abort();
      }
      if (options.onUploadProgress) {
        request.upload.onprogress = options.onUploadProgress;
      }
      request.responseType = "arraybuffer";
      return new Promise((resolve2, reject) => {
        const handleEvent = (event) => {
          switch (event.type) {
            case "error": {
              resolve2(Response2.error());
              break;
            }
            case "load": {
              resolve2(
                new ResponseWithURL(request.responseURL, request.response, {
                  status: request.status,
                  statusText: request.statusText,
                  headers: parseHeaders(request.getAllResponseHeaders())
                })
              );
              break;
            }
            case "timeout": {
              reject(new TimeoutError());
              break;
            }
            case "abort": {
              reject(new AbortError());
              break;
            }
            default: {
              break;
            }
          }
        };
        request.onerror = handleEvent;
        request.onload = handleEvent;
        request.ontimeout = handleEvent;
        request.onabort = handleEvent;
        request.send(options.body);
      });
    };
    var fetchWithStreaming = fetch2;
    var fetchWith = (url, options = {}) => options.onUploadProgress != null ? fetchWithProgress(url, options) : fetchWithStreaming(url, options);
    var parseHeaders = (input) => {
      const headers = new Headers();
      for (const line of input.trim().split(/[\r\n]+/)) {
        const index = line.indexOf(": ");
        if (index > 0) {
          headers.set(line.slice(0, index), line.slice(index + 1));
        }
      }
      return headers;
    };
    var ResponseWithURL = class extends Response2 {
      /**
       * @param {string} url
       * @param {BodyInit} body
       * @param {ResponseInit} options
       */
      constructor(url, body, options) {
        super(body, options);
        Object.defineProperty(this, "url", { value: url });
      }
    };
    module2.exports = {
      fetch: fetchWith,
      Request,
      Headers
    };
  }
});

// node_modules/.pnpm/is-plain-obj@2.1.0/node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "node_modules/.pnpm/is-plain-obj@2.1.0/node_modules/is-plain-obj/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = (value2) => {
      if (Object.prototype.toString.call(value2) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value2);
      return prototype === null || prototype === Object.prototype;
    };
  }
});

// node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.js
var require_merge_options = __commonJS({
  "node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var isOptionObject = require_is_plain_obj();
    var { hasOwnProperty } = Object.prototype;
    var { propertyIsEnumerable } = Object;
    var defineProperty = (object3, name10, value2) => Object.defineProperty(object3, name10, {
      value: value2,
      writable: true,
      enumerable: true,
      configurable: true
    });
    var globalThis2 = exports2;
    var defaultMergeOptions = {
      concatArrays: false,
      ignoreUndefined: false
    };
    var getEnumerableOwnPropertyKeys = (value2) => {
      const keys = [];
      for (const key in value2) {
        if (hasOwnProperty.call(value2, key)) {
          keys.push(key);
        }
      }
      if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value2);
        for (const symbol4 of symbols) {
          if (propertyIsEnumerable.call(value2, symbol4)) {
            keys.push(symbol4);
          }
        }
      }
      return keys;
    };
    function clone(value2) {
      if (Array.isArray(value2)) {
        return cloneArray(value2);
      }
      if (isOptionObject(value2)) {
        return cloneOptionObject(value2);
      }
      return value2;
    }
    function cloneArray(array2) {
      const result = array2.slice(0, 0);
      getEnumerableOwnPropertyKeys(array2).forEach((key) => {
        defineProperty(result, key, clone(array2[key]));
      });
      return result;
    }
    function cloneOptionObject(object3) {
      const result = Object.getPrototypeOf(object3) === null ? /* @__PURE__ */ Object.create(null) : {};
      getEnumerableOwnPropertyKeys(object3).forEach((key) => {
        defineProperty(result, key, clone(object3[key]));
      });
      return result;
    }
    var mergeKeys = (merged, source, keys, config) => {
      keys.forEach((key) => {
        if (typeof source[key] === "undefined" && config.ignoreUndefined) {
          return;
        }
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
          defineProperty(merged, key, merge2(merged[key], source[key], config));
        } else {
          defineProperty(merged, key, clone(source[key]));
        }
      });
      return merged;
    };
    var concatArrays = (merged, source, config) => {
      let result = merged.slice(0, 0);
      let resultIndex = 0;
      [merged, source].forEach((array2) => {
        const indices = [];
        for (let k = 0; k < array2.length; k++) {
          if (!hasOwnProperty.call(array2, k)) {
            continue;
          }
          indices.push(String(k));
          if (array2 === merged) {
            defineProperty(result, resultIndex++, array2[k]);
          } else {
            defineProperty(result, resultIndex++, clone(array2[k]));
          }
        }
        result = mergeKeys(result, array2, getEnumerableOwnPropertyKeys(array2).filter((key) => !indices.includes(key)), config);
      });
      return result;
    };
    function merge2(merged, source, config) {
      if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays(merged, source, config);
      }
      if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone(source);
      }
      return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
    }
    module2.exports = function(...options) {
      const config = merge2(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
      let merged = { _: {} };
      for (const option of options) {
        if (option === void 0) {
          continue;
        }
        if (!isOptionObject(option)) {
          throw new TypeError("`" + option + "` is not an Option Object");
        }
        merged = merge2(merged, { _: option }, config);
      }
      return merged._;
    };
  }
});

// node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/src/url-browser.js
var require_url_browser = __commonJS({
  "node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/src/url-browser.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    function getDefaultBase() {
      if (isReactNative) {
        return "http://localhost";
      }
      if (!self.location) {
        return "";
      }
      return self.location.protocol + "//" + self.location.host;
    }
    var URL2 = self.URL;
    var defaultBase = getDefaultBase();
    var URLWithLegacySupport = class {
      constructor(url = "", base5 = defaultBase) {
        this.super = new URL2(url, base5);
        this.path = this.pathname + this.search;
        this.auth = this.username && this.password ? this.username + ":" + this.password : null;
        this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
      }
      get hash() {
        return this.super.hash;
      }
      get host() {
        return this.super.host;
      }
      get hostname() {
        return this.super.hostname;
      }
      get href() {
        return this.super.href;
      }
      get origin() {
        return this.super.origin;
      }
      get password() {
        return this.super.password;
      }
      get pathname() {
        return this.super.pathname;
      }
      get port() {
        return this.super.port;
      }
      get protocol() {
        return this.super.protocol;
      }
      get search() {
        return this.super.search;
      }
      get searchParams() {
        return this.super.searchParams;
      }
      get username() {
        return this.super.username;
      }
      set hash(hash) {
        this.super.hash = hash;
      }
      set host(host) {
        this.super.host = host;
      }
      set hostname(hostname) {
        this.super.hostname = hostname;
      }
      set href(href) {
        this.super.href = href;
      }
      set password(password) {
        this.super.password = password;
      }
      set pathname(pathname) {
        this.super.pathname = pathname;
      }
      set port(port) {
        this.super.port = port;
      }
      set protocol(protocol) {
        this.super.protocol = protocol;
      }
      set search(search) {
        this.super.search = search;
      }
      set username(username) {
        this.super.username = username;
      }
      /**
       * @param {any} o
       */
      static createObjectURL(o) {
        return URL2.createObjectURL(o);
      }
      /**
       * @param {string} o
       */
      static revokeObjectURL(o) {
        URL2.revokeObjectURL(o);
      }
      toJSON() {
        return this.super.toJSON();
      }
      toString() {
        return this.super.toString();
      }
      format() {
        return this.toString();
      }
    };
    function format5(obj) {
      if (typeof obj === "string") {
        const url = new URL2(obj);
        return url.toString();
      }
      if (!(obj instanceof URL2)) {
        const userPass = (
          // @ts-ignore its not supported in node but we normalise
          obj.username && obj.password ? `${obj.username}:${obj.password}@` : ""
        );
        const auth = obj.auth ? obj.auth + "@" : "";
        const port = obj.port ? ":" + obj.port : "";
        const protocol = obj.protocol ? obj.protocol + "//" : "";
        const host = obj.host || "";
        const hostname = obj.hostname || "";
        const search = obj.search || (obj.query ? "?" + obj.query : "");
        const hash = obj.hash || "";
        const pathname = obj.pathname || "";
        const path = obj.path || pathname + search;
        return `${protocol}${userPass || auth}${host || hostname + port}${path}${hash}`;
      }
    }
    module2.exports = {
      URLWithLegacySupport,
      URLSearchParams: self.URLSearchParams,
      defaultBase,
      format: format5
    };
  }
});

// node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/src/relative.js
var require_relative = __commonJS({
  "node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/src/relative.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var { URLWithLegacySupport, format: format5 } = require_url_browser();
    module2.exports = (url, location2 = {}, protocolMap = {}, defaultProtocol) => {
      let protocol = location2.protocol ? location2.protocol.replace(":", "") : "http";
      protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
      let urlParsed;
      try {
        urlParsed = new URLWithLegacySupport(url);
      } catch (err) {
        urlParsed = {};
      }
      const base5 = Object.assign({}, location2, {
        protocol: protocol || urlParsed.protocol,
        host: location2.host || urlParsed.host
      });
      return new URLWithLegacySupport(url, format5(base5)).toString();
    };
  }
});

// node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/index.js
var require_iso_url = __commonJS({
  "node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var {
      URLWithLegacySupport,
      format: format5,
      URLSearchParams: URLSearchParams2,
      defaultBase
    } = require_url_browser();
    var relative = require_relative();
    module2.exports = {
      URL: URLWithLegacySupport,
      URLSearchParams: URLSearchParams2,
      format: format5,
      relative,
      defaultBase
    };
  }
});

// node_modules/.pnpm/any-signal@3.0.1/node_modules/any-signal/index.js
var require_any_signal = __commonJS({
  "node_modules/.pnpm/any-signal@3.0.1/node_modules/any-signal/index.js"(exports2, module2) {
    init_buffer_polyfill();
    function anySignal2(signals) {
      const controller = new globalThis.AbortController();
      function onAbort() {
        controller.abort();
        for (const signal of signals) {
          if (!signal || !signal.removeEventListener) continue;
          signal.removeEventListener("abort", onAbort);
        }
      }
      for (const signal of signals) {
        if (!signal || !signal.addEventListener) continue;
        if (signal.aborted) {
          onAbort();
          break;
        }
        signal.addEventListener("abort", onAbort);
      }
      return controller.signal;
    }
    module2.exports = anySignal2;
    module2.exports.anySignal = anySignal2;
  }
});

// node_modules/.pnpm/browser-readablestream-to-it@1.0.3/node_modules/browser-readablestream-to-it/index.js
var require_browser_readablestream_to_it = __commonJS({
  "node_modules/.pnpm/browser-readablestream-to-it@1.0.3/node_modules/browser-readablestream-to-it/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    async function* browserReadableStreamToIt2(stream, options = {}) {
      const reader = stream.getReader();
      try {
        while (true) {
          const result = await reader.read();
          if (result.done) {
            return;
          }
          yield result.value;
        }
      } finally {
        if (options.preventCancel !== true) {
          reader.cancel();
        }
        reader.releaseLock();
      }
    }
    module2.exports = browserReadableStreamToIt2;
  }
});

// node_modules/.pnpm/it-all@1.0.6/node_modules/it-all/index.js
var require_it_all = __commonJS({
  "node_modules/.pnpm/it-all@1.0.6/node_modules/it-all/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var all2 = async (source) => {
      const arr = [];
      for await (const entry of source) {
        arr.push(entry);
      }
      return arr;
    };
    module2.exports = all2;
  }
});

// node_modules/.pnpm/ipfs-utils@9.0.14_encoding@0.1.13/node_modules/ipfs-utils/src/http.js
var require_http = __commonJS({
  "node_modules/.pnpm/ipfs-utils@9.0.14_encoding@0.1.13/node_modules/ipfs-utils/src/http.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var { fetch: fetch2, Request, Headers } = require_fetch_browser2();
    var { TimeoutError, HTTPError: HTTPError2 } = require_error();
    var merge2 = require_merge_options().bind({ ignoreUndefined: true });
    var { URL: URL2, URLSearchParams: URLSearchParams2 } = require_iso_url();
    var anySignal2 = require_any_signal();
    var browserReableStreamToIt = require_browser_readablestream_to_it();
    var { isBrowser: isBrowser2, isWebWorker: isWebWorker2 } = require_env();
    var all2 = require_it_all();
    var timeout = (promise, ms, abortController) => {
      if (ms === void 0) {
        return promise;
      }
      const start = Date.now();
      const timedOut = () => {
        const time = Date.now() - start;
        return time >= ms;
      };
      return new Promise((resolve2, reject) => {
        const timeoutID = setTimeout(() => {
          if (timedOut()) {
            reject(new TimeoutError());
            abortController.abort();
          }
        }, ms);
        const after = (next) => {
          const fn = (res) => {
            clearTimeout(timeoutID);
            if (timedOut()) {
              reject(new TimeoutError());
              return;
            }
            next(res);
          };
          return fn;
        };
        promise.then(after(resolve2), after(reject));
      });
    };
    var defaults = {
      throwHttpErrors: true,
      credentials: "same-origin"
    };
    var HTTP3 = class {
      /**
       *
       * @param {HTTPOptions} options
       */
      constructor(options = {}) {
        this.opts = merge2(defaults, options);
      }
      /**
       * Fetch
       *
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       * @returns {Promise<ExtendedResponse>}
       */
      async fetch(resource, options = {}) {
        const opts = merge2(this.opts, options);
        const headers = new Headers(opts.headers);
        if (typeof resource !== "string" && !(resource instanceof URL2 || resource instanceof Request)) {
          throw new TypeError("`resource` must be a string, URL, or Request");
        }
        const url = new URL2(resource.toString(), opts.base);
        const {
          searchParams,
          transformSearchParams,
          json
        } = opts;
        if (searchParams) {
          if (typeof transformSearchParams === "function") {
            url.search = transformSearchParams(new URLSearchParams2(opts.searchParams));
          } else {
            url.search = new URLSearchParams2(opts.searchParams);
          }
        }
        if (json) {
          opts.body = JSON.stringify(opts.json);
          headers.set("content-type", "application/json");
        }
        const abortController = new AbortController();
        const signal = anySignal2([abortController.signal, opts.signal]);
        if (globalThis.ReadableStream != null && opts.body instanceof globalThis.ReadableStream && (isBrowser2 || isWebWorker2)) {
          opts.body = new Blob(await all2(browserReableStreamToIt(opts.body)));
        }
        const response = await timeout(
          fetch2(
            url.toString(),
            {
              ...opts,
              signal,
              // @ts-expect-error non-browser fetch implementations may take extra options
              timeout: void 0,
              headers,
              // https://fetch.spec.whatwg.org/#dom-requestinit-duplex
              // https://github.com/whatwg/fetch/issues/1254
              duplex: "half"
            }
          ),
          opts.timeout,
          abortController
        );
        if (!response.ok && opts.throwHttpErrors) {
          if (opts.handleError) {
            await opts.handleError(response);
          }
          throw new HTTPError2(response);
        }
        response.iterator = async function* () {
          yield* fromStream(response.body);
        };
        response.ndjson = async function* () {
          for await (const chunk of ndjson(response.iterator())) {
            if (options.transform) {
              yield options.transform(chunk);
            } else {
              yield chunk;
            }
          }
        };
        return response;
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      post(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "POST" });
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      get(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "GET" });
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      put(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "PUT" });
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      delete(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "DELETE" });
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      options(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "OPTIONS" });
      }
    };
    var ndjson = async function* (source) {
      const decoder = new TextDecoder();
      let buf2 = "";
      for await (const chunk of source) {
        buf2 += decoder.decode(chunk, { stream: true });
        const lines = buf2.split(/\r?\n/);
        for (let i = 0; i < lines.length - 1; i++) {
          const l = lines[i].trim();
          if (l.length > 0) {
            yield JSON.parse(l);
          }
        }
        buf2 = lines[lines.length - 1];
      }
      buf2 += decoder.decode();
      buf2 = buf2.trim();
      if (buf2.length !== 0) {
        yield JSON.parse(buf2);
      }
    };
    var fromStream = (source) => {
      if (isAsyncIterable2(source)) {
        return source;
      }
      if (isNodeReadableStream(source)) {
        const iter = source[Symbol.asyncIterator]();
        return {
          [Symbol.asyncIterator]() {
            return {
              next: iter.next.bind(iter),
              return(value2) {
                source.destroy();
                if (typeof iter.return === "function") {
                  return iter.return();
                }
                return Promise.resolve({ done: true, value: value2 });
              }
            };
          }
        };
      }
      if (isWebReadableStream(source)) {
        const reader = source.getReader();
        return (async function* () {
          try {
            while (true) {
              const { done, value: value2 } = await reader.read();
              if (done) return;
              if (value2) {
                yield value2;
              }
            }
          } finally {
            reader.releaseLock();
          }
        })();
      }
      throw new TypeError("Body can't be converted to AsyncIterable");
    };
    var isAsyncIterable2 = (value2) => {
      return typeof value2 === "object" && value2 !== null && typeof /** @type {any} */
      value2[Symbol.asyncIterator] === "function";
    };
    var isWebReadableStream = (value2) => {
      return value2 && typeof /** @type {any} */
      value2.getReader === "function";
    };
    var isNodeReadableStream = (value2) => Object.prototype.hasOwnProperty.call(value2, "readable") && Object.prototype.hasOwnProperty.call(value2, "writable");
    HTTP3.HTTPError = HTTPError2;
    HTTP3.TimeoutError = TimeoutError;
    HTTP3.streamToAsyncIterator = fromStream;
    HTTP3.post = (resource, options) => new HTTP3(options).post(resource, options);
    HTTP3.get = (resource, options) => new HTTP3(options).get(resource, options);
    HTTP3.put = (resource, options) => new HTTP3(options).put(resource, options);
    HTTP3.delete = (resource, options) => new HTTP3(options).delete(resource, options);
    HTTP3.options = (resource, options) => new HTTP3(options).options(resource, options);
    module2.exports = HTTP3;
  }
});

// node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve2, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve2.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var base644 = exports2;
    base644.length = function length6(string5) {
      var p = string5.length;
      if (!p)
        return 0;
      var n2 = 0;
      while (--p % 4 > 1 && string5.charAt(p) === "=")
        ++n2;
      return Math.ceil(string5.length * 3) / 4 - n2;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base644.encode = function encode42(buffer2, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer2[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base644.decode = function decode44(string5, buffer2, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string5.length; ) {
        var c = string5.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer2[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer2[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer2[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base644.test = function test(string5) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string5);
    };
  }
});

// node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf2, pos) {
          f32[0] = val;
          buf2[pos] = f8b[0];
          buf2[pos + 1] = f8b[1];
          buf2[pos + 2] = f8b[2];
          buf2[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf2, pos) {
          f32[0] = val;
          buf2[pos] = f8b[3];
          buf2[pos + 1] = f8b[2];
          buf2[pos + 2] = f8b[1];
          buf2[pos + 3] = f8b[0];
        }
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf2, pos) {
          f8b[0] = buf2[pos];
          f8b[1] = buf2[pos + 1];
          f8b[2] = buf2[pos + 2];
          f8b[3] = buf2[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf2, pos) {
          f8b[3] = buf2[pos];
          f8b[2] = buf2[pos + 1];
          f8b[1] = buf2[pos + 2];
          f8b[0] = buf2[pos + 3];
          return f32[0];
        }
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
      else (function() {
        function writeFloat_ieee754(writeUint, val, buf2, pos) {
          var sign2 = val < 0 ? 1 : 0;
          if (sign2)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf2, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf2, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign2 << 31 | 2139095040) >>> 0, buf2, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign2 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf2, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign2 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf2, pos);
          }
        }
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf2, pos) {
          var uint = readUint(buf2, pos), sign2 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 1401298464324817e-60 * mantissa : sign2 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
      if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf2, pos) {
          f64[0] = val;
          buf2[pos] = f8b[0];
          buf2[pos + 1] = f8b[1];
          buf2[pos + 2] = f8b[2];
          buf2[pos + 3] = f8b[3];
          buf2[pos + 4] = f8b[4];
          buf2[pos + 5] = f8b[5];
          buf2[pos + 6] = f8b[6];
          buf2[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf2, pos) {
          f64[0] = val;
          buf2[pos] = f8b[7];
          buf2[pos + 1] = f8b[6];
          buf2[pos + 2] = f8b[5];
          buf2[pos + 3] = f8b[4];
          buf2[pos + 4] = f8b[3];
          buf2[pos + 5] = f8b[2];
          buf2[pos + 6] = f8b[1];
          buf2[pos + 7] = f8b[0];
        }
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf2, pos) {
          f8b[0] = buf2[pos];
          f8b[1] = buf2[pos + 1];
          f8b[2] = buf2[pos + 2];
          f8b[3] = buf2[pos + 3];
          f8b[4] = buf2[pos + 4];
          f8b[5] = buf2[pos + 5];
          f8b[6] = buf2[pos + 6];
          f8b[7] = buf2[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf2, pos) {
          f8b[7] = buf2[pos];
          f8b[6] = buf2[pos + 1];
          f8b[5] = buf2[pos + 2];
          f8b[4] = buf2[pos + 3];
          f8b[3] = buf2[pos + 4];
          f8b[2] = buf2[pos + 5];
          f8b[1] = buf2[pos + 6];
          f8b[0] = buf2[pos + 7];
          return f64[0];
        }
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
      else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf2, pos) {
          var sign2 = val < 0 ? 1 : 0;
          if (sign2)
            val = -val;
          if (val === 0) {
            writeUint(0, buf2, pos + off0);
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf2, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf2, pos + off0);
            writeUint(2146959360, buf2, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf2, pos + off0);
            writeUint((sign2 << 31 | 2146435072) >>> 0, buf2, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf2, pos + off0);
              writeUint((sign2 << 31 | mantissa / 4294967296) >>> 0, buf2, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf2, pos + off0);
              writeUint((sign2 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf2, pos + off1);
            }
          }
        }
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf2, pos) {
          var lo = readUint(buf2, pos + off0), hi = readUint(buf2, pos + off1);
          var sign2 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 5e-324 * mantissa : sign2 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
      return exports3;
    }
    function writeUintLE(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf2, pos) {
      buf2[pos] = val >>> 24;
      buf2[pos + 1] = val >>> 16 & 255;
      buf2[pos + 2] = val >>> 8 & 255;
      buf2[pos + 3] = val & 255;
    }
    function readUintLE(buf2, pos) {
      return (buf2[pos] | buf2[pos + 1] << 8 | buf2[pos + 2] << 16 | buf2[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf2, pos) {
      return (buf2[pos] << 24 | buf2[pos + 1] << 16 | buf2[pos + 2] << 8 | buf2[pos + 3]) >>> 0;
    }
  }
});

// node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    init_buffer_polyfill();
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var utf8 = exports2;
    utf8.length = function utf8_length(string5) {
      var len = 0, c = 0;
      for (var i = 0; i < string5.length; ++i) {
        c = string5.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string5.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer2, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer2[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer2[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string5, buffer2, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string5.length; ++i) {
        c1 = string5.charCodeAt(i);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string5.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = pool;
    function pool(alloc2, slice2, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc2(size2);
        if (offset + size2 > SIZE) {
          slab = alloc2(SIZE);
          offset = 0;
        }
        var buf2 = slice2.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf2;
      };
    }
  }
});

// node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value2) {
      if (value2 === 0)
        return zero;
      var sign2 = value2 < 0;
      if (sign2)
        value2 = -value2;
      var lo = value2 >>> 0, hi = (value2 - lo) / 4294967296 >>> 0;
      if (sign2) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from7(value2) {
      if (typeof value2 === "number")
        return LongBits.fromNumber(value2);
      if (util.isString(value2)) {
        if (util.Long)
          value2 = util.Long.fromString(value2);
        else
          return LongBits.fromNumber(parseInt(value2, 10));
      }
      return value2.low || value2.high ? new LongBits(value2.low >>> 0, value2.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length6() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof globalThis !== "undefined" && globalThis && globalThis.process && globalThis.process.versions && globalThis.process.versions.node);
    util.global = util.isNode && globalThis || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value2) {
      return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2;
    };
    util.isString = function isString(value2) {
      return typeof value2 === "string" || value2 instanceof String;
    };
    util.isObject = function isObject(value2) {
      return value2 && typeof value2 === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop2) {
      var value2 = obj[prop2];
      if (value2 != null && obj.hasOwnProperty(prop2))
        return typeof value2 !== "object" || (Array.isArray(value2) ? value2.length : Object.keys(value2).length) > 0;
      return false;
    };
    util.Buffer = (function() {
      try {
        var Buffer5 = util.inquire("buffer").Buffer;
        return Buffer5.prototype.utf8Write ? Buffer5 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    })();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value2) {
      return value2 ? util.LongBits.from(value2).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge2(dst, src4, ifNotSet) {
      for (var keys = Object.keys(src4), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src4[keys[i]];
      return dst;
    }
    util.merge = merge2;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name10) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge2(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get() {
            return name10;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value2() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name10) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name10)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer5 = util.Buffer;
      if (!Buffer5) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer5.from !== Uint8Array.from && Buffer5.from || /* istanbul ignore next */
      function Buffer_from(value2, encoding) {
        return new Buffer5(value2, encoding);
      };
      util._Buffer_allocUnsafe = Buffer5.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer5(size);
      };
    };
  }
});

// node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter2;
    var LongBits = util.LongBits;
    var base644 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create5 = function create6() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter2();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create5();
    Writer.alloc = function alloc2(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf2, pos) {
      buf2[pos] = val & 255;
    }
    function writeVarint32(val, buf2, pos) {
      while (val > 127) {
        buf2[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf2[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value2) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value2 = value2 >>> 0) < 128 ? 1 : value2 < 16384 ? 2 : value2 < 2097152 ? 3 : value2 < 268435456 ? 4 : 5,
        value2
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value2) {
      return value2 < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value2)) : this.uint32(value2);
    };
    Writer.prototype.sint32 = function write_sint32(value2) {
      return this.uint32((value2 << 1 ^ value2 >> 31) >>> 0);
    };
    function writeVarint64(val, buf2, pos) {
      while (val.hi) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf2[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value2) {
      var bits = LongBits.from(value2);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value2) {
      var bits = LongBits.from(value2).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value2) {
      return this._push(writeByte, 1, value2 ? 1 : 0);
    };
    function writeFixed32(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value2) {
      return this._push(writeFixed32, 4, value2 >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value2) {
      var bits = LongBits.from(value2);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value2) {
      return this._push(util.float.writeFloatLE, 4, value2);
    };
    Writer.prototype.double = function write_double(value2) {
      return this._push(util.float.writeDoubleLE, 8, value2);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf2, pos) {
      buf2.set(val, pos);
    } : function writeBytes_for(val, buf2, pos) {
      for (var i = 0; i < val.length; ++i)
        buf2[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value2) {
      var len = value2.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value2)) {
        var buf2 = Writer.alloc(len = base644.length(value2));
        base644.decode(value2, buf2, 0);
        value2 = buf2;
      }
      return this.uint32(len)._push(writeBytes, len, value2);
    };
    Writer.prototype.string = function write_string(value2) {
      var len = utf8.length(value2);
      return len ? this.uint32(len)._push(utf8.write, len, value2) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf2, pos);
        pos += head.len;
        head = head.next;
      }
      return buf2;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter2 = BufferWriter_;
      Writer.create = create5();
      BufferWriter2._configure();
    };
  }
});

// node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = BufferWriter2;
    var Writer = require_writer();
    (BufferWriter2.prototype = Object.create(Writer.prototype)).constructor = BufferWriter2;
    var util = require_minimal();
    function BufferWriter2() {
      Writer.call(this);
    }
    BufferWriter2._configure = function() {
      BufferWriter2.alloc = util._Buffer_allocUnsafe;
      BufferWriter2.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
        buf2.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf2, pos) {
        if (val.copy)
          val.copy(buf2, pos, 0, val.length);
        else for (var i = 0; i < val.length; )
          buf2[pos++] = val[i++];
      };
    };
    BufferWriter2.prototype.bytes = function write_bytes_buffer(value2) {
      if (util.isString(value2))
        value2 = util._Buffer_from(value2, "base64");
      var len = value2.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter2.writeBytesBuffer, len, value2);
      return this;
    };
    function writeStringBuffer(val, buf2, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf2, pos);
      else if (buf2.utf8Write)
        buf2.utf8Write(val, pos);
      else
        buf2.write(val, pos);
    }
    BufferWriter2.prototype.string = function write_string_buffer(value2) {
      var len = util.Buffer.byteLength(value2);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value2);
      return this;
    };
    BufferWriter2._configure();
  }
});

// node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader2;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
      if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    } : function create_array2(buffer2) {
      if (Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    };
    var create5 = function create6() {
      return util.Buffer ? function create_buffer_setup(buffer2) {
        return (Reader.create = function create_buffer(buffer3) {
          return util.Buffer.isBuffer(buffer3) ? new BufferReader2(buffer3) : create_array(buffer3);
        })(buffer2);
      } : create_array;
    };
    Reader.create = create5();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ (function read_uint32_setup() {
      var value2 = 4294967295;
      return function read_uint32() {
        value2 = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value2;
        value2 = (value2 | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value2;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value2;
      };
    })();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value2 = this.uint32();
      return value2 >>> 1 ^ -(value2 & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf2, end) {
      return (buf2[end - 4] | buf2[end - 3] << 8 | buf2[end - 2] << 16 | buf2[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value2 = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value2;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value2 = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value2;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length6 = this.uint32(), start = this.pos, end = this.pos + length6;
      if (end > this.len)
        throw indexOutOfRange(this, length6);
      this.pos += length6;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length6) {
      if (typeof length6 === "number") {
        if (this.pos + length6 > this.len)
          throw indexOutOfRange(this, length6);
        this.pos += length6;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        /* istanbul ignore next */
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader2 = BufferReader_;
      Reader.create = create5();
      BufferReader2._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = BufferReader2;
    var Reader = require_reader();
    (BufferReader2.prototype = Object.create(Reader.prototype)).constructor = BufferReader2;
    var util = require_minimal();
    function BufferReader2(buffer2) {
      Reader.call(this, buffer2);
    }
    BufferReader2._configure = function() {
      if (util.Buffer)
        BufferReader2.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader2.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader2._configure();
  }
});

// node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = {};
  }
});

// node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure2;
    function configure2() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure2();
  }
});

// node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/.pnpm/protobufjs@7.5.4/node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    module2.exports = require_index_minimal();
  }
});

// node_modules/.pnpm/stream-to-it@0.2.4/node_modules/stream-to-it/source.js
var require_source = __commonJS({
  "node_modules/.pnpm/stream-to-it@0.2.4/node_modules/stream-to-it/source.js"(exports2, module2) {
    init_buffer_polyfill();
    module2.exports = (readable) => {
      if (readable[Symbol.asyncIterator]) return readable;
      if (readable.getReader) {
        return (async function* () {
          const reader = readable.getReader();
          try {
            while (true) {
              const { done, value: value2 } = await reader.read();
              if (done) return;
              yield value2;
            }
          } finally {
            reader.releaseLock();
          }
        })();
      }
      throw new Error("unknown stream");
    };
  }
});

// (disabled):node_modules/.pnpm/ipfs-utils@9.0.14_encoding@0.1.13/node_modules/ipfs-utils/src/files/glob-source.js
var require_glob_source = __commonJS({
  "(disabled):node_modules/.pnpm/ipfs-utils@9.0.14_encoding@0.1.13/node_modules/ipfs-utils/src/files/glob-source.js"() {
    init_buffer_polyfill();
  }
});

// node_modules/.pnpm/ipfs-utils@9.0.14_encoding@0.1.13/node_modules/ipfs-utils/src/files/url-source.js
var require_url_source = __commonJS({
  "node_modules/.pnpm/ipfs-utils@9.0.14_encoding@0.1.13/node_modules/ipfs-utils/src/files/url-source.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var HTTP3 = require_http();
    var urlSource = (url, options) => {
      return {
        path: decodeURIComponent(new URL(url).pathname.split("/").pop() || ""),
        content: readURLContent(url, options)
      };
    };
    async function* readURLContent(url, options) {
      const http = new HTTP3();
      const response = await http.get(url, options);
      yield* response.iterator();
    }
    module2.exports = urlSource;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/networks.js
var require_networks = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/networks.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.testnet = exports2.regtest = exports2.liquid = void 0;
    var strToGenesisHash = (str) => import_buffer.Buffer.from(str, "hex").reverse();
    var RegtestGenesisBlockHash = strToGenesisHash(
      "00902a6b70c2ca83b5d9c815d96a0e2f4202179316970d14ea1847dae5b1ca21"
    );
    var TestnetGenesisBlockHash = strToGenesisHash(
      "a771da8e52ee6ad581ed1e9a99825e5b3b7992225534eaa2ae23244fe26ab1c1"
    );
    var LiquidGenesisBlockHash = strToGenesisHash(
      "1466275836220db2944ca059a3a10ef6fd2ea684b0688d2c379296888a206003"
    );
    exports2.liquid = {
      messagePrefix: "Liquid Signed Message:\n",
      bech32: "ex",
      blech32: "lq",
      bip32: {
        public: 76067358,
        private: 76066276
      },
      pubKeyHash: 57,
      scriptHash: 39,
      wif: 128,
      confidentialPrefix: 12,
      assetHash: "6f0279e9ed041c3d710a9f57d0c02928416460c4b722ae3457a11eec381c526d",
      genesisBlockHash: LiquidGenesisBlockHash,
      name: "liquid"
    };
    exports2.regtest = {
      messagePrefix: "Liquid Signed Message:\n",
      bech32: "ert",
      blech32: "el",
      bip32: {
        public: 70617039,
        private: 70615956
      },
      pubKeyHash: 235,
      scriptHash: 75,
      wif: 239,
      confidentialPrefix: 4,
      assetHash: "5ac9f65c0efcc4775e0baec4ec03abdde22473cd3cf33c0419ca290e0751b225",
      genesisBlockHash: RegtestGenesisBlockHash,
      name: "regtest"
    };
    exports2.testnet = {
      ...exports2.regtest,
      bech32: "tex",
      blech32: "tlq",
      pubKeyHash: 36,
      scriptHash: 19,
      confidentialPrefix: 23,
      assetHash: "144c654344aa716d6f3abcc1ca90e5641e4e2a7f633bc09fe3baf64585819a49",
      genesisBlockHash: TestnetGenesisBlockHash,
      name: "testnet"
    };
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/bip66.js
var require_bip66 = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/bip66.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encode = exports2.decode = exports2.check = void 0;
    function check15(buffer2) {
      if (buffer2.length < 8) return false;
      if (buffer2.length > 72) return false;
      if (buffer2[0] !== 48) return false;
      if (buffer2[1] !== buffer2.length - 2) return false;
      if (buffer2[2] !== 2) return false;
      const lenR = buffer2[3];
      if (lenR === 0) return false;
      if (5 + lenR >= buffer2.length) return false;
      if (buffer2[4 + lenR] !== 2) return false;
      const lenS = buffer2[5 + lenR];
      if (lenS === 0) return false;
      if (6 + lenR + lenS !== buffer2.length) return false;
      if (buffer2[4] & 128) return false;
      if (lenR > 1 && buffer2[4] === 0 && !(buffer2[5] & 128)) return false;
      if (buffer2[lenR + 6] & 128) return false;
      if (lenS > 1 && buffer2[lenR + 6] === 0 && !(buffer2[lenR + 7] & 128))
        return false;
      return true;
    }
    exports2.check = check15;
    function decode44(buffer2) {
      if (buffer2.length < 8) throw new Error("DER sequence length is too short");
      if (buffer2.length > 72) throw new Error("DER sequence length is too long");
      if (buffer2[0] !== 48) throw new Error("Expected DER sequence");
      if (buffer2[1] !== buffer2.length - 2)
        throw new Error("DER sequence length is invalid");
      if (buffer2[2] !== 2) throw new Error("Expected DER integer");
      const lenR = buffer2[3];
      if (lenR === 0) throw new Error("R length is zero");
      if (5 + lenR >= buffer2.length) throw new Error("R length is too long");
      if (buffer2[4 + lenR] !== 2) throw new Error("Expected DER integer (2)");
      const lenS = buffer2[5 + lenR];
      if (lenS === 0) throw new Error("S length is zero");
      if (6 + lenR + lenS !== buffer2.length) throw new Error("S length is invalid");
      if (buffer2[4] & 128) throw new Error("R value is negative");
      if (lenR > 1 && buffer2[4] === 0 && !(buffer2[5] & 128))
        throw new Error("R value excessively padded");
      if (buffer2[lenR + 6] & 128) throw new Error("S value is negative");
      if (lenS > 1 && buffer2[lenR + 6] === 0 && !(buffer2[lenR + 7] & 128))
        throw new Error("S value excessively padded");
      return {
        r: buffer2.slice(4, 4 + lenR),
        s: buffer2.slice(6 + lenR)
      };
    }
    exports2.decode = decode44;
    function encode42(r, s) {
      const lenR = r.length;
      const lenS = s.length;
      if (lenR === 0) throw new Error("R length is zero");
      if (lenS === 0) throw new Error("S length is zero");
      if (lenR > 33) throw new Error("R length is too long");
      if (lenS > 33) throw new Error("S length is too long");
      if (r[0] & 128) throw new Error("R value is negative");
      if (s[0] & 128) throw new Error("S value is negative");
      if (lenR > 1 && r[0] === 0 && !(r[1] & 128))
        throw new Error("R value excessively padded");
      if (lenS > 1 && s[0] === 0 && !(s[1] & 128))
        throw new Error("S value excessively padded");
      const signature2 = import_buffer.Buffer.allocUnsafe(6 + lenR + lenS);
      signature2[0] = 48;
      signature2[1] = signature2.length - 2;
      signature2[2] = 2;
      signature2[3] = r.length;
      r.copy(signature2, 4);
      signature2[4 + lenR] = 2;
      signature2[5 + lenR] = s.length;
      s.copy(signature2, 6 + lenR);
      return signature2;
    }
    exports2.encode = encode42;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/ops.js
var require_ops = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/ops.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.REVERSE_OPS = exports2.OPS = void 0;
    var OPS10 = {
      // push value
      OP_FALSE: 0,
      OP_0: 0,
      OP_PUSHDATA1: 76,
      OP_PUSHDATA2: 77,
      OP_PUSHDATA4: 78,
      OP_1NEGATE: 79,
      OP_RESERVED: 80,
      OP_TRUE: 81,
      OP_1: 81,
      OP_2: 82,
      OP_3: 83,
      OP_4: 84,
      OP_5: 85,
      OP_6: 86,
      OP_7: 87,
      OP_8: 88,
      OP_9: 89,
      OP_10: 90,
      OP_11: 91,
      OP_12: 92,
      OP_13: 93,
      OP_14: 94,
      OP_15: 95,
      OP_16: 96,
      // control
      OP_NOP: 97,
      OP_VER: 98,
      OP_IF: 99,
      OP_NOTIF: 100,
      OP_VERIF: 101,
      OP_VERNOTIF: 102,
      OP_ELSE: 103,
      OP_ENDIF: 104,
      OP_VERIFY: 105,
      OP_RETURN: 106,
      // stack ops
      OP_TOALTSTACK: 107,
      OP_FROMALTSTACK: 108,
      OP_2DROP: 109,
      OP_2DUP: 110,
      OP_3DUP: 111,
      OP_2OVER: 112,
      OP_2ROT: 113,
      OP_2SWAP: 114,
      OP_IFDUP: 115,
      OP_DEPTH: 116,
      OP_DROP: 117,
      OP_DUP: 118,
      OP_NIP: 119,
      OP_OVER: 120,
      OP_PICK: 121,
      OP_ROLL: 122,
      OP_ROT: 123,
      OP_SWAP: 124,
      OP_TUCK: 125,
      // splice ops
      OP_CAT: 126,
      OP_SUBSTR: 127,
      OP_SUBSTR_LAZY: 195,
      OP_LEFT: 128,
      OP_RIGHT: 129,
      OP_SIZE: 130,
      // bit logic
      OP_INVERT: 131,
      OP_AND: 132,
      OP_OR: 133,
      OP_XOR: 134,
      OP_EQUAL: 135,
      OP_EQUALVERIFY: 136,
      OP_RESERVED1: 137,
      OP_RESERVED2: 138,
      // numeric
      OP_1ADD: 139,
      OP_1SUB: 140,
      OP_2MUL: 141,
      OP_2DIV: 142,
      OP_NEGATE: 143,
      OP_ABS: 144,
      OP_NOT: 145,
      OP_0NOTEQUAL: 146,
      OP_ADD: 147,
      OP_SUB: 148,
      OP_MUL: 149,
      OP_DIV: 150,
      OP_MOD: 151,
      OP_LSHIFT: 152,
      OP_RSHIFT: 153,
      OP_BOOLAND: 154,
      OP_BOOLOR: 155,
      OP_NUMEQUAL: 156,
      OP_NUMEQUALVERIFY: 157,
      OP_NUMNOTEQUAL: 158,
      OP_LESSTHAN: 159,
      OP_GREATERTHAN: 160,
      OP_LESSTHANOREQUAL: 161,
      OP_GREATERTHANOREQUAL: 162,
      OP_MIN: 163,
      OP_MAX: 164,
      OP_WITHIN: 165,
      // crypto
      OP_RIPEMD160: 166,
      OP_SHA1: 167,
      OP_SHA256: 168,
      OP_HASH160: 169,
      OP_HASH256: 170,
      OP_CODESEPARATOR: 171,
      OP_CHECKSIG: 172,
      OP_CHECKSIGVERIFY: 173,
      OP_CHECKMULTISIG: 174,
      OP_CHECKMULTISIGVERIFY: 175,
      OP_DETERMINISTICRANDOM: 192,
      OP_CHECKSIGFROMSTACK: 193,
      OP_CHECKSIGFROMSTACKVERIFY: 194,
      // expansion
      OP_NOP1: 176,
      OP_NOP2: 177,
      OP_CHECKLOCKTIMEVERIFY: 177,
      OP_NOP3: 178,
      OP_CHECKSEQUENCEVERIFY: 178,
      OP_NOP4: 179,
      OP_NOP5: 180,
      OP_NOP6: 181,
      OP_NOP7: 182,
      OP_NOP8: 183,
      OP_NOP9: 184,
      OP_NOP10: 185,
      // Elements: Tapscript (Streaming sha2 opcodes)
      OP_SHA256INITIALIZE: 196,
      OP_SHA256UPDATE: 197,
      OP_SHA256FINALIZE: 198,
      // Introspection opcodes
      // inputs
      OP_INSPECTINPUTOUTPOINT: 199,
      OP_INSPECTINPUTASSET: 200,
      OP_INSPECTINPUTVALUE: 201,
      OP_INSPECTINPUTSCRIPTPUBKEY: 202,
      OP_INSPECTINPUTSEQUENCE: 203,
      OP_INSPECTINPUTISSUANCE: 204,
      // current index
      OP_PUSHCURRENTINPUTINDEX: 205,
      // outputs
      OP_INSPECTOUTPUTASSET: 206,
      OP_INSPECTOUTPUTVALUE: 207,
      OP_INSPECTOUTPUTNONCE: 208,
      OP_INSPECTOUTPUTSCRIPTPUBKEY: 209,
      // transaction
      OP_INSPECTVERSION: 210,
      OP_INSPECTLOCKTIME: 211,
      OP_INSPECTNUMINPUTS: 212,
      OP_INSPECTNUMOUTPUTS: 213,
      OP_TXWEIGHT: 214,
      // Arithmetic opcodes
      OP_ADD64: 215,
      OP_SUB64: 216,
      OP_MUL64: 217,
      OP_DIV64: 218,
      OP_NEG64: 219,
      OP_LESSTHAN64: 220,
      OP_LESSTHANOREQUAL64: 221,
      OP_GREATERTHAN64: 222,
      OP_GREATERTHANOREQUAL64: 223,
      // Conversion opcodes
      OP_SCRIPTNUMTOLE64: 224,
      OP_LE64TOSCRIPTNUM: 225,
      OP_LE32TOLE64: 226,
      // Crypto opcodes
      OP_ECMULSCALARVERIFY: 227,
      OP_TWEAKVERIFY: 228,
      OP_PUBKEYHASH: 253,
      OP_PUBKEY: 254,
      OP_INVALIDOPCODE: 255
    };
    exports2.OPS = OPS10;
    var REVERSE_OPS = {};
    exports2.REVERSE_OPS = REVERSE_OPS;
    for (const op of Object.keys(OPS10)) {
      const code10 = OPS10[op];
      REVERSE_OPS[code10] = op;
    }
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/push_data.js
var require_push_data = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/push_data.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decode = exports2.encode = exports2.encodingLength = void 0;
    var ops_1 = require_ops();
    function encodingLength7(i) {
      return i < ops_1.OPS.OP_PUSHDATA1 ? 1 : i <= 255 ? 2 : i <= 65535 ? 3 : 5;
    }
    exports2.encodingLength = encodingLength7;
    function encode42(buffer2, num2, offset) {
      const size = encodingLength7(num2);
      if (size === 1) {
        buffer2.writeUInt8(num2, offset);
      } else if (size === 2) {
        buffer2.writeUInt8(ops_1.OPS.OP_PUSHDATA1, offset);
        buffer2.writeUInt8(num2, offset + 1);
      } else if (size === 3) {
        buffer2.writeUInt8(ops_1.OPS.OP_PUSHDATA2, offset);
        buffer2.writeUInt16LE(num2, offset + 1);
      } else {
        buffer2.writeUInt8(ops_1.OPS.OP_PUSHDATA4, offset);
        buffer2.writeUInt32LE(num2, offset + 1);
      }
      return size;
    }
    exports2.encode = encode42;
    function decode44(buffer2, offset) {
      const opcode = buffer2.readUInt8(offset);
      let num2;
      let size;
      if (opcode < ops_1.OPS.OP_PUSHDATA1) {
        num2 = opcode;
        size = 1;
      } else if (opcode === ops_1.OPS.OP_PUSHDATA1) {
        if (offset + 2 > buffer2.length) return null;
        num2 = buffer2.readUInt8(offset + 1);
        size = 2;
      } else if (opcode === ops_1.OPS.OP_PUSHDATA2) {
        if (offset + 3 > buffer2.length) return null;
        num2 = buffer2.readUInt16LE(offset + 1);
        size = 3;
      } else {
        if (offset + 5 > buffer2.length) return null;
        if (opcode !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
        num2 = buffer2.readUInt32LE(offset + 1);
        size = 5;
      }
      return {
        opcode,
        number: num2,
        size
      };
    }
    exports2.decode = decode44;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/script_number.js
var require_script_number = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/script_number.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encode = exports2.decode = void 0;
    function decode44(buffer2, maxLength, minimal) {
      maxLength = maxLength || 4;
      minimal = minimal === void 0 ? true : minimal;
      const length6 = buffer2.length;
      if (length6 === 0) return 0;
      if (length6 > maxLength) throw new TypeError("Script number overflow");
      if (minimal) {
        if ((buffer2[length6 - 1] & 127) === 0) {
          if (length6 <= 1 || (buffer2[length6 - 2] & 128) === 0)
            throw new Error("Non-minimally encoded script number");
        }
      }
      if (length6 === 5) {
        const a = buffer2.readUInt32LE(0);
        const b = buffer2.readUInt8(4);
        if (b & 128) return -((b & ~128) * 4294967296 + a);
        return b * 4294967296 + a;
      }
      let result = 0;
      for (let i = 0; i < length6; ++i) {
        result |= buffer2[i] << 8 * i;
      }
      if (buffer2[length6 - 1] & 128)
        return -(result & ~(128 << 8 * (length6 - 1)));
      return result;
    }
    exports2.decode = decode44;
    function scriptNumSize2(i) {
      return i > 2147483647 ? 5 : i > 8388607 ? 4 : i > 32767 ? 3 : i > 127 ? 2 : i > 0 ? 1 : 0;
    }
    function encode42(_number) {
      let value2 = Math.abs(_number);
      const size = scriptNumSize2(value2);
      const buffer2 = import_buffer.Buffer.allocUnsafe(size);
      const negative = _number < 0;
      for (let i = 0; i < size; ++i) {
        buffer2.writeUInt8(value2 & 255, i);
        value2 >>= 8;
      }
      if (buffer2[size - 1] & 128) {
        buffer2.writeUInt8(negative ? 128 : 0, size - 1);
      } else if (negative) {
        buffer2[size - 1] |= 128;
      }
      return buffer2;
    }
    exports2.encode = encode42;
  }
});

// node_modules/.pnpm/typeforce@1.18.0/node_modules/typeforce/native.js
var require_native = __commonJS({
  "node_modules/.pnpm/typeforce@1.18.0/node_modules/typeforce/native.js"(exports2, module2) {
    init_buffer_polyfill();
    var types = {
      Array: function(value2) {
        return value2 !== null && value2 !== void 0 && value2.constructor === Array;
      },
      Boolean: function(value2) {
        return typeof value2 === "boolean";
      },
      Function: function(value2) {
        return typeof value2 === "function";
      },
      Nil: function(value2) {
        return value2 === void 0 || value2 === null;
      },
      Number: function(value2) {
        return typeof value2 === "number";
      },
      Object: function(value2) {
        return typeof value2 === "object";
      },
      String: function(value2) {
        return typeof value2 === "string";
      },
      "": function() {
        return true;
      }
    };
    types.Null = types.Nil;
    for (typeName in types) {
      types[typeName].toJSON = function(t) {
        return t;
      }.bind(null, typeName);
    }
    var typeName;
    module2.exports = types;
  }
});

// node_modules/.pnpm/typeforce@1.18.0/node_modules/typeforce/errors.js
var require_errors = __commonJS({
  "node_modules/.pnpm/typeforce@1.18.0/node_modules/typeforce/errors.js"(exports2, module2) {
    init_buffer_polyfill();
    var native = require_native();
    function getTypeName(fn) {
      return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1];
    }
    function getValueTypeName(value2) {
      return native.Nil(value2) ? "" : getTypeName(value2.constructor);
    }
    function getValue(value2) {
      if (native.Function(value2)) return "";
      if (native.String(value2)) return JSON.stringify(value2);
      if (value2 && native.Object(value2)) return "";
      return value2;
    }
    function captureStackTrace(e, t) {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(e, t);
      }
    }
    function tfJSON(type) {
      if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type);
      if (native.Array(type)) return "Array";
      if (type && native.Object(type)) return "Object";
      return type !== void 0 ? type : "";
    }
    function tfErrorString(type, value2, valueTypeName) {
      var valueJson = getValue(value2);
      return "Expected " + tfJSON(type) + ", got" + (valueTypeName !== "" ? " " + valueTypeName : "") + (valueJson !== "" ? " " + valueJson : "");
    }
    function TfTypeError(type, value2, valueTypeName) {
      valueTypeName = valueTypeName || getValueTypeName(value2);
      this.message = tfErrorString(type, value2, valueTypeName);
      captureStackTrace(this, TfTypeError);
      this.__type = type;
      this.__value = value2;
      this.__valueTypeName = valueTypeName;
    }
    TfTypeError.prototype = Object.create(Error.prototype);
    TfTypeError.prototype.constructor = TfTypeError;
    function tfPropertyErrorString(type, label, name10, value2, valueTypeName) {
      var description = '" of type ';
      if (label === "key") description = '" with key type ';
      return tfErrorString('property "' + tfJSON(name10) + description + tfJSON(type), value2, valueTypeName);
    }
    function TfPropertyTypeError(type, property, label, value2, valueTypeName) {
      if (type) {
        valueTypeName = valueTypeName || getValueTypeName(value2);
        this.message = tfPropertyErrorString(type, label, property, value2, valueTypeName);
      } else {
        this.message = 'Unexpected property "' + property + '"';
      }
      captureStackTrace(this, TfTypeError);
      this.__label = label;
      this.__property = property;
      this.__type = type;
      this.__value = value2;
      this.__valueTypeName = valueTypeName;
    }
    TfPropertyTypeError.prototype = Object.create(Error.prototype);
    TfPropertyTypeError.prototype.constructor = TfTypeError;
    function tfCustomError(expected14, actual) {
      return new TfTypeError(expected14, {}, actual);
    }
    function tfSubError(e, property, label) {
      if (e instanceof TfPropertyTypeError) {
        property = property + "." + e.__property;
        e = new TfPropertyTypeError(
          e.__type,
          property,
          e.__label,
          e.__value,
          e.__valueTypeName
        );
      } else if (e instanceof TfTypeError) {
        e = new TfPropertyTypeError(
          e.__type,
          property,
          label,
          e.__value,
          e.__valueTypeName
        );
      }
      captureStackTrace(e);
      return e;
    }
    module2.exports = {
      TfTypeError,
      TfPropertyTypeError,
      tfCustomError,
      tfSubError,
      tfJSON,
      getValueTypeName
    };
  }
});

// node_modules/.pnpm/typeforce@1.18.0/node_modules/typeforce/extra.js
var require_extra = __commonJS({
  "node_modules/.pnpm/typeforce@1.18.0/node_modules/typeforce/extra.js"(exports2, module2) {
    init_buffer_polyfill();
    var NATIVE = require_native();
    var ERRORS = require_errors();
    function _Buffer(value2) {
      return import_buffer.Buffer.isBuffer(value2);
    }
    function Hex(value2) {
      return typeof value2 === "string" && /^([0-9a-f]{2})+$/i.test(value2);
    }
    function _LengthN(type, length6) {
      var name10 = type.toJSON();
      function Length(value2) {
        if (!type(value2)) return false;
        if (value2.length === length6) return true;
        throw ERRORS.tfCustomError(name10 + "(Length: " + length6 + ")", name10 + "(Length: " + value2.length + ")");
      }
      Length.toJSON = function() {
        return name10;
      };
      return Length;
    }
    var _ArrayN = _LengthN.bind(null, NATIVE.Array);
    var _BufferN = _LengthN.bind(null, _Buffer);
    var _HexN = _LengthN.bind(null, Hex);
    var _StringN = _LengthN.bind(null, NATIVE.String);
    function Range(a, b, f) {
      f = f || NATIVE.Number;
      function _range(value2, strict) {
        return f(value2, strict) && value2 > a && value2 < b;
      }
      _range.toJSON = function() {
        return `${f.toJSON()} between [${a}, ${b}]`;
      };
      return _range;
    }
    var INT53_MAX = Math.pow(2, 53) - 1;
    function Finite(value2) {
      return typeof value2 === "number" && isFinite(value2);
    }
    function Int8(value2) {
      return value2 << 24 >> 24 === value2;
    }
    function Int16(value2) {
      return value2 << 16 >> 16 === value2;
    }
    function Int32(value2) {
      return (value2 | 0) === value2;
    }
    function Int53(value2) {
      return typeof value2 === "number" && value2 >= -INT53_MAX && value2 <= INT53_MAX && Math.floor(value2) === value2;
    }
    function UInt8(value2) {
      return (value2 & 255) === value2;
    }
    function UInt16(value2) {
      return (value2 & 65535) === value2;
    }
    function UInt32(value2) {
      return value2 >>> 0 === value2;
    }
    function UInt53(value2) {
      return typeof value2 === "number" && value2 >= 0 && value2 <= INT53_MAX && Math.floor(value2) === value2;
    }
    var types = {
      ArrayN: _ArrayN,
      Buffer: _Buffer,
      BufferN: _BufferN,
      Finite,
      Hex,
      HexN: _HexN,
      Int8,
      Int16,
      Int32,
      Int53,
      Range,
      StringN: _StringN,
      UInt8,
      UInt16,
      UInt32,
      UInt53
    };
    for (typeName in types) {
      types[typeName].toJSON = function(t) {
        return t;
      }.bind(null, typeName);
    }
    var typeName;
    module2.exports = types;
  }
});

// node_modules/.pnpm/typeforce@1.18.0/node_modules/typeforce/index.js
var require_typeforce = __commonJS({
  "node_modules/.pnpm/typeforce@1.18.0/node_modules/typeforce/index.js"(exports2, module2) {
    init_buffer_polyfill();
    var ERRORS = require_errors();
    var NATIVE = require_native();
    var tfJSON = ERRORS.tfJSON;
    var TfTypeError = ERRORS.TfTypeError;
    var TfPropertyTypeError = ERRORS.TfPropertyTypeError;
    var tfSubError = ERRORS.tfSubError;
    var getValueTypeName = ERRORS.getValueTypeName;
    var TYPES = {
      arrayOf: function arrayOf(type, options) {
        type = compile2(type);
        options = options || {};
        function _arrayOf(array2, strict) {
          if (!NATIVE.Array(array2)) return false;
          if (NATIVE.Nil(array2)) return false;
          if (options.minLength !== void 0 && array2.length < options.minLength) return false;
          if (options.maxLength !== void 0 && array2.length > options.maxLength) return false;
          if (options.length !== void 0 && array2.length !== options.length) return false;
          return array2.every(function(value2, i) {
            try {
              return typeforce(type, value2, strict);
            } catch (e) {
              throw tfSubError(e, i);
            }
          });
        }
        _arrayOf.toJSON = function() {
          var str = "[" + tfJSON(type) + "]";
          if (options.length !== void 0) {
            str += "{" + options.length + "}";
          } else if (options.minLength !== void 0 || options.maxLength !== void 0) {
            str += "{" + (options.minLength === void 0 ? 0 : options.minLength) + "," + (options.maxLength === void 0 ? Infinity : options.maxLength) + "}";
          }
          return str;
        };
        return _arrayOf;
      },
      maybe: function maybe(type) {
        type = compile2(type);
        function _maybe(value2, strict) {
          return NATIVE.Nil(value2) || type(value2, strict, maybe);
        }
        _maybe.toJSON = function() {
          return "?" + tfJSON(type);
        };
        return _maybe;
      },
      map: function map2(propertyType, propertyKeyType) {
        propertyType = compile2(propertyType);
        if (propertyKeyType) propertyKeyType = compile2(propertyKeyType);
        function _map(value2, strict) {
          if (!NATIVE.Object(value2)) return false;
          if (NATIVE.Nil(value2)) return false;
          for (var propertyName in value2) {
            try {
              if (propertyKeyType) {
                typeforce(propertyKeyType, propertyName, strict);
              }
            } catch (e) {
              throw tfSubError(e, propertyName, "key");
            }
            try {
              var propertyValue = value2[propertyName];
              typeforce(propertyType, propertyValue, strict);
            } catch (e) {
              throw tfSubError(e, propertyName);
            }
          }
          return true;
        }
        if (propertyKeyType) {
          _map.toJSON = function() {
            return "{" + tfJSON(propertyKeyType) + ": " + tfJSON(propertyType) + "}";
          };
        } else {
          _map.toJSON = function() {
            return "{" + tfJSON(propertyType) + "}";
          };
        }
        return _map;
      },
      object: function object3(uncompiled) {
        var type = {};
        for (var typePropertyName in uncompiled) {
          type[typePropertyName] = compile2(uncompiled[typePropertyName]);
        }
        function _object(value2, strict) {
          if (!NATIVE.Object(value2)) return false;
          if (NATIVE.Nil(value2)) return false;
          var propertyName;
          try {
            for (propertyName in type) {
              var propertyType = type[propertyName];
              var propertyValue = value2[propertyName];
              typeforce(propertyType, propertyValue, strict);
            }
          } catch (e) {
            throw tfSubError(e, propertyName);
          }
          if (strict) {
            for (propertyName in value2) {
              if (type[propertyName]) continue;
              throw new TfPropertyTypeError(void 0, propertyName);
            }
          }
          return true;
        }
        _object.toJSON = function() {
          return tfJSON(type);
        };
        return _object;
      },
      anyOf: function anyOf() {
        var types = [].slice.call(arguments).map(compile2);
        function _anyOf(value2, strict) {
          return types.some(function(type) {
            try {
              return typeforce(type, value2, strict);
            } catch (e) {
              return false;
            }
          });
        }
        _anyOf.toJSON = function() {
          return types.map(tfJSON).join("|");
        };
        return _anyOf;
      },
      allOf: function allOf() {
        var types = [].slice.call(arguments).map(compile2);
        function _allOf(value2, strict) {
          return types.every(function(type) {
            try {
              return typeforce(type, value2, strict);
            } catch (e) {
              return false;
            }
          });
        }
        _allOf.toJSON = function() {
          return types.map(tfJSON).join(" & ");
        };
        return _allOf;
      },
      quacksLike: function quacksLike(type) {
        function _quacksLike(value2) {
          return type === getValueTypeName(value2);
        }
        _quacksLike.toJSON = function() {
          return type;
        };
        return _quacksLike;
      },
      tuple: function tuple() {
        var types = [].slice.call(arguments).map(compile2);
        function _tuple(values, strict) {
          if (NATIVE.Nil(values)) return false;
          if (NATIVE.Nil(values.length)) return false;
          if (strict && values.length !== types.length) return false;
          return types.every(function(type, i) {
            try {
              return typeforce(type, values[i], strict);
            } catch (e) {
              throw tfSubError(e, i);
            }
          });
        }
        _tuple.toJSON = function() {
          return "(" + types.map(tfJSON).join(", ") + ")";
        };
        return _tuple;
      },
      value: function value2(expected14) {
        function _value(actual) {
          return actual === expected14;
        }
        _value.toJSON = function() {
          return expected14;
        };
        return _value;
      }
    };
    TYPES.oneOf = TYPES.anyOf;
    function compile2(type) {
      if (NATIVE.String(type)) {
        if (type[0] === "?") return TYPES.maybe(type.slice(1));
        return NATIVE[type] || TYPES.quacksLike(type);
      } else if (type && NATIVE.Object(type)) {
        if (NATIVE.Array(type)) {
          if (type.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
          return TYPES.arrayOf(type[0]);
        }
        return TYPES.object(type);
      } else if (NATIVE.Function(type)) {
        return type;
      }
      return TYPES.value(type);
    }
    function typeforce(type, value2, strict, surrogate) {
      if (NATIVE.Function(type)) {
        if (type(value2, strict)) return true;
        throw new TfTypeError(surrogate || type, value2);
      }
      return typeforce(compile2(type), value2, strict);
    }
    for (typeName in NATIVE) {
      typeforce[typeName] = NATIVE[typeName];
    }
    var typeName;
    for (typeName in TYPES) {
      typeforce[typeName] = TYPES[typeName];
    }
    var EXTRA = require_extra();
    for (typeName in EXTRA) {
      typeforce[typeName] = EXTRA[typeName];
    }
    typeforce.compile = compile2;
    typeforce.TfTypeError = TfTypeError;
    typeforce.TfPropertyTypeError = TfPropertyTypeError;
    module2.exports = typeforce;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/types.js
var require_types2 = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/types.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.oneOf = exports2.Null = exports2.BufferN = exports2.Function = exports2.UInt32 = exports2.UInt8 = exports2.tuple = exports2.maybe = exports2.Object = exports2.Hex = exports2.Buffer = exports2.String = exports2.Boolean = exports2.Array = exports2.Number = exports2.BufferOne = exports2.ConfidentialValue = exports2.AssetBuffer = exports2.AssetBufferWithFlag = exports2.ConfidentialCommitment = exports2.Hash256bit = exports2.Hash160bit = exports2.Buffer256bit = exports2.isTaptree = exports2.isTapleaf = exports2.TAPLEAF_VERSION_MASK = exports2.Network = exports2.ECPoint = exports2.Satoshi = exports2.Signer = exports2.BIP32Path = exports2.UInt31 = exports2.isPoint = exports2.typeforce = void 0;
    var buffer_1 = require_buffer();
    exports2.typeforce = require_typeforce();
    var ZERO322 = buffer_1.Buffer.alloc(32, 0);
    var EC_P2 = buffer_1.Buffer.from(
      "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
      "hex"
    );
    function isPoint3(p) {
      if (!buffer_1.Buffer.isBuffer(p)) return false;
      if (p.length < 33) return false;
      const t = p[0];
      const x = p.slice(1, 33);
      if (x.compare(ZERO322) === 0) return false;
      if (x.compare(EC_P2) >= 0) return false;
      if ((t === 2 || t === 3) && p.length === 33) {
        return true;
      }
      const y = p.slice(33);
      if (y.compare(ZERO322) === 0) return false;
      if (y.compare(EC_P2) >= 0) return false;
      if (t === 4 && p.length === 65) return true;
      return false;
    }
    exports2.isPoint = isPoint3;
    var UINT31_MAX = Math.pow(2, 31) - 1;
    function UInt31(value2) {
      return exports2.typeforce.UInt32(value2) && value2 <= UINT31_MAX;
    }
    exports2.UInt31 = UInt31;
    function BIP32Path(value2) {
      return exports2.typeforce.String(value2) && !!value2.match(/^(m\/)?(\d+'?\/)*\d+'?$/);
    }
    exports2.BIP32Path = BIP32Path;
    BIP32Path.toJSON = () => {
      return "BIP32 derivation path";
    };
    function Signer(obj) {
      return (exports2.typeforce.Buffer(obj.publicKey) || typeof obj.getPublicKey === "function") && typeof obj.sign === "function";
    }
    exports2.Signer = Signer;
    var SATOSHI_MAX = 21 * 1e14;
    function Satoshi(value2) {
      return exports2.typeforce.UInt53(value2) && value2 <= SATOSHI_MAX;
    }
    exports2.Satoshi = Satoshi;
    exports2.ECPoint = exports2.typeforce.quacksLike("Point");
    exports2.Network = exports2.typeforce.compile({
      messagePrefix: exports2.typeforce.oneOf(
        exports2.typeforce.Buffer,
        exports2.typeforce.String
      ),
      bip32: {
        public: exports2.typeforce.UInt32,
        private: exports2.typeforce.UInt32
      },
      pubKeyHash: exports2.typeforce.UInt8,
      scriptHash: exports2.typeforce.UInt8,
      wif: exports2.typeforce.UInt8,
      assetHash: exports2.typeforce.String,
      confidentialPrefix: exports2.typeforce.UInt8,
      name: exports2.typeforce.String
    });
    exports2.TAPLEAF_VERSION_MASK = 254;
    function isTapleaf2(o) {
      if (!o || !("output" in o)) return false;
      if (!buffer_1.Buffer.isBuffer(o.output)) return false;
      if (o.version !== void 0)
        return (o.version & exports2.TAPLEAF_VERSION_MASK) === o.version;
      return true;
    }
    exports2.isTapleaf = isTapleaf2;
    function isTaptree2(scriptTree) {
      if (!(0, exports2.Array)(scriptTree)) return isTapleaf2(scriptTree);
      if (scriptTree.length !== 2) return false;
      return scriptTree.every((t) => isTaptree2(t));
    }
    exports2.isTaptree = isTaptree2;
    exports2.Buffer256bit = exports2.typeforce.BufferN(32);
    exports2.Hash160bit = exports2.typeforce.BufferN(20);
    exports2.Hash256bit = exports2.typeforce.BufferN(32);
    exports2.ConfidentialCommitment = exports2.typeforce.BufferN(33);
    exports2.AssetBufferWithFlag = exports2.typeforce.BufferN(33);
    exports2.AssetBuffer = exports2.typeforce.BufferN(32);
    exports2.ConfidentialValue = exports2.typeforce.BufferN(9);
    exports2.BufferOne = exports2.typeforce.BufferN(1);
    exports2.Number = exports2.typeforce.Number;
    exports2.Array = exports2.typeforce.Array;
    exports2.Boolean = exports2.typeforce.Boolean;
    exports2.String = exports2.typeforce.String;
    exports2.Buffer = exports2.typeforce.Buffer;
    exports2.Hex = exports2.typeforce.Hex;
    exports2.Object = exports2.typeforce.Object;
    exports2.maybe = exports2.typeforce.maybe;
    exports2.tuple = exports2.typeforce.tuple;
    exports2.UInt8 = exports2.typeforce.UInt8;
    exports2.UInt32 = exports2.typeforce.UInt32;
    exports2.Function = exports2.typeforce.Function;
    exports2.BufferN = exports2.typeforce.BufferN;
    exports2.Null = exports2.typeforce.Null;
    exports2.oneOf = exports2.typeforce.oneOf;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/script_signature.js
var require_script_signature = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/script_signature.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encode = exports2.decode = void 0;
    var bip66 = __importStar(require_bip66());
    var types = __importStar(require_types2());
    var { typeforce } = types;
    var ZERO3 = import_buffer.Buffer.alloc(1, 0);
    function toDER(x) {
      let i = 0;
      while (x[i] === 0) ++i;
      if (i === x.length) return ZERO3;
      x = x.slice(i);
      if (x[0] & 128) return import_buffer.Buffer.concat([ZERO3, x], 1 + x.length);
      return x;
    }
    function fromDER(x) {
      if (x[0] === 0) x = x.slice(1);
      const buffer2 = import_buffer.Buffer.alloc(32, 0);
      const bstart = Math.max(0, 32 - x.length);
      x.copy(buffer2, bstart);
      return buffer2;
    }
    function decode44(buffer2) {
      const hashType = buffer2.readUInt8(buffer2.length - 1);
      const hashTypeMod = hashType & ~128;
      if (hashTypeMod <= 0 || hashTypeMod >= 4)
        throw new Error("Invalid hashType " + hashType);
      const decoded = bip66.decode(buffer2.slice(0, -1));
      const r = fromDER(decoded.r);
      const s = fromDER(decoded.s);
      const signature2 = import_buffer.Buffer.concat([r, s], 64);
      return { signature: signature2, hashType };
    }
    exports2.decode = decode44;
    function encode42(signature2, hashType) {
      typeforce(
        {
          signature: types.BufferN(64),
          hashType: types.UInt8
        },
        { signature: signature2, hashType }
      );
      const hashTypeMod = hashType & ~128;
      if (hashTypeMod <= 0 || hashTypeMod >= 4)
        throw new Error("Invalid hashType " + hashType);
      const hashTypeBuffer = import_buffer.Buffer.allocUnsafe(1);
      hashTypeBuffer.writeUInt8(hashType, 0);
      const r = toDER(signature2.slice(0, 32));
      const s = toDER(signature2.slice(32, 64));
      return import_buffer.Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);
    }
    exports2.encode = encode42;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/script.js
var require_script = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/script.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signature = exports2.number = exports2.isCanonicalScriptSignature = exports2.isDefinedHashType = exports2.isCanonicalPubKey = exports2.toStack = exports2.fromASM = exports2.toASM = exports2.decompile = exports2.compile = exports2.isPushOnly = exports2.OPS = void 0;
    var bip66 = __importStar(require_bip66());
    var ops_1 = require_ops();
    Object.defineProperty(exports2, "OPS", {
      enumerable: true,
      get: function() {
        return ops_1.OPS;
      }
    });
    var pushdata = __importStar(require_push_data());
    var scriptNumber = __importStar(require_script_number());
    var scriptSignature = __importStar(require_script_signature());
    var types = __importStar(require_types2());
    var { typeforce } = types;
    var OP_INT_BASE3 = ops_1.OPS.OP_RESERVED;
    function isOPInt2(value2) {
      return types.Number(value2) && (value2 === ops_1.OPS.OP_0 || value2 >= ops_1.OPS.OP_1 && value2 <= ops_1.OPS.OP_16 || value2 === ops_1.OPS.OP_1NEGATE);
    }
    function isPushOnlyChunk2(value2) {
      return types.Buffer(value2) || isOPInt2(value2);
    }
    function isPushOnly2(value2) {
      return types.Array(value2) && value2.every(isPushOnlyChunk2);
    }
    exports2.isPushOnly = isPushOnly2;
    function asMinimalOP2(buffer2) {
      if (buffer2.length === 0) return ops_1.OPS.OP_0;
      if (buffer2.length !== 1) return;
      if (buffer2[0] >= 1 && buffer2[0] <= 16) return OP_INT_BASE3 + buffer2[0];
      if (buffer2[0] === 129) return ops_1.OPS.OP_1NEGATE;
    }
    function chunksIsBuffer2(buf2) {
      return import_buffer.Buffer.isBuffer(buf2);
    }
    function chunksIsArray2(buf2) {
      return types.Array(buf2);
    }
    function singleChunkIsBuffer2(buf2) {
      return import_buffer.Buffer.isBuffer(buf2);
    }
    function compile2(chunks) {
      if (chunksIsBuffer2(chunks)) return chunks;
      typeforce(types.Array, chunks);
      const bufferSize = chunks.reduce((accum, chunk) => {
        if (singleChunkIsBuffer2(chunk)) {
          if (chunk.length === 1 && asMinimalOP2(chunk) !== void 0) {
            return accum + 1;
          }
          return accum + pushdata.encodingLength(chunk.length) + chunk.length;
        }
        return accum + 1;
      }, 0);
      const buffer2 = import_buffer.Buffer.allocUnsafe(bufferSize);
      let offset = 0;
      chunks.forEach((chunk) => {
        if (singleChunkIsBuffer2(chunk)) {
          const opcode = asMinimalOP2(chunk);
          if (opcode !== void 0) {
            buffer2.writeUInt8(opcode, offset);
            offset += 1;
            return;
          }
          offset += pushdata.encode(buffer2, chunk.length, offset);
          chunk.copy(buffer2, offset);
          offset += chunk.length;
        } else {
          buffer2.writeUInt8(chunk, offset);
          offset += 1;
        }
      });
      if (offset !== buffer2.length) throw new Error("Could not decode chunks");
      return buffer2;
    }
    exports2.compile = compile2;
    function decompile2(buffer2) {
      if (chunksIsArray2(buffer2)) return buffer2;
      typeforce(types.Buffer, buffer2);
      const chunks = [];
      let i = 0;
      while (i < buffer2.length) {
        const opcode = buffer2[i];
        if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {
          const d = pushdata.decode(buffer2, i);
          if (d === null) return null;
          i += d.size;
          if (i + d.number > buffer2.length) return null;
          const data = buffer2.slice(i, i + d.number);
          i += d.number;
          const op = asMinimalOP2(data);
          if (op !== void 0) {
            chunks.push(op);
          } else {
            chunks.push(data);
          }
        } else {
          chunks.push(opcode);
          i += 1;
        }
      }
      return chunks;
    }
    exports2.decompile = decompile2;
    function toASM2(chunks) {
      if (chunksIsBuffer2(chunks)) {
        chunks = decompile2(chunks);
      }
      return chunks.map((chunk) => {
        if (singleChunkIsBuffer2(chunk)) {
          const op = asMinimalOP2(chunk);
          if (op === void 0) return chunk.toString("hex");
          chunk = op;
        }
        return ops_1.REVERSE_OPS[chunk];
      }).join(" ");
    }
    exports2.toASM = toASM2;
    function fromASM(asm) {
      typeforce(types.String, asm);
      return compile2(
        asm.split(" ").map((chunkStr) => {
          if (ops_1.OPS[chunkStr] !== void 0) return ops_1.OPS[chunkStr];
          typeforce(types.Hex, chunkStr);
          return import_buffer.Buffer.from(chunkStr, "hex");
        })
      );
    }
    exports2.fromASM = fromASM;
    function toStack2(chunks) {
      chunks = decompile2(chunks);
      typeforce(isPushOnly2, chunks);
      return chunks.map((op) => {
        if (singleChunkIsBuffer2(op)) return op;
        if (op === ops_1.OPS.OP_0) return import_buffer.Buffer.allocUnsafe(0);
        return scriptNumber.encode(op - OP_INT_BASE3);
      });
    }
    exports2.toStack = toStack2;
    function isCanonicalPubKey2(buffer2) {
      return types.isPoint(buffer2);
    }
    exports2.isCanonicalPubKey = isCanonicalPubKey2;
    function isDefinedHashType2(hashType) {
      const hashTypeMod = hashType & ~128;
      return hashTypeMod > 0 && hashTypeMod < 4;
    }
    exports2.isDefinedHashType = isDefinedHashType2;
    function isCanonicalScriptSignature2(buffer2) {
      if (!import_buffer.Buffer.isBuffer(buffer2)) return false;
      if (!isDefinedHashType2(buffer2[buffer2.length - 1])) return false;
      return bip66.check(buffer2.slice(0, -1));
    }
    exports2.isCanonicalScriptSignature = isCanonicalScriptSignature2;
    exports2.number = scriptNumber;
    exports2.signature = scriptSignature;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/lazy.js
var require_lazy = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/lazy.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.value = exports2.prop = void 0;
    function prop2(object3, name10, f) {
      Object.defineProperty(object3, name10, {
        configurable: true,
        enumerable: true,
        get() {
          const _value = f.call(this);
          this[name10] = _value;
          return _value;
        },
        set(_value) {
          Object.defineProperty(this, name10, {
            configurable: true,
            enumerable: true,
            value: _value,
            writable: true
          });
        }
      });
    }
    exports2.prop = prop2;
    function value2(f) {
      let _value;
      return () => {
        if (_value !== void 0) return _value;
        _value = f();
        return _value;
      };
    }
    exports2.value = value2;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/embed.js
var require_embed = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/embed.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2data = void 0;
    var networks_1 = require_networks();
    var bscript = __importStar(require_script());
    var types_1 = require_types2();
    var lazy = __importStar(require_lazy());
    var OPS10 = bscript.OPS;
    function stacksEqual2(a, b) {
      if (a.length !== b.length) return false;
      return a.every((x, i) => {
        return x.equals(b[i]);
      });
    }
    function p2data2(a, opts) {
      if (!a.data && !a.output) throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          data: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a
      );
      const network = a.network || networks_1.liquid;
      const o = { name: "embed", network };
      lazy.prop(o, "output", () => {
        if (!a.data) return;
        return bscript.compile([OPS10.OP_RETURN].concat(a.data));
      });
      lazy.prop(o, "data", () => {
        if (!a.output) return;
        return bscript.decompile(a.output).slice(1);
      });
      if (opts.validate) {
        if (a.output) {
          const chunks = bscript.decompile(a.output);
          if (chunks[0] !== OPS10.OP_RETURN) throw new TypeError("Output is invalid");
          if (!chunks.slice(1).every(types_1.typeforce.Buffer))
            throw new TypeError("Output is invalid");
          if (a.data && !stacksEqual2(a.data, o.data))
            throw new TypeError("Data mismatch");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2data = p2data2;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/p2ms.js
var require_p2ms = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/p2ms.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2ms = void 0;
    var networks_1 = require_networks();
    var bscript = __importStar(require_script());
    var types_1 = require_types2();
    var lazy = __importStar(require_lazy());
    var OPS10 = bscript.OPS;
    var OP_INT_BASE3 = OPS10.OP_RESERVED;
    function stacksEqual2(a, b) {
      if (a.length !== b.length) return false;
      return a.every((x, i) => {
        return x.equals(b[i]);
      });
    }
    function p2ms2(a, opts) {
      if (!a.input && !a.output && !(a.pubkeys && a.m !== void 0) && !a.signatures)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      function isAcceptableSignature(x) {
        return bscript.isCanonicalScriptSignature(x) || (opts.allowIncomplete && x === OPS10.OP_0) !== void 0;
      }
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          m: types_1.typeforce.maybe(types_1.typeforce.Number),
          n: types_1.typeforce.maybe(types_1.typeforce.Number),
          output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          pubkeys: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.isPoint)
          ),
          signatures: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(isAcceptableSignature)
          ),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer)
        },
        a
      );
      const network = a.network || networks_1.liquid;
      const o = { network };
      let chunks = [];
      let decoded = false;
      function decode44(output) {
        if (decoded) return;
        decoded = true;
        chunks = bscript.decompile(output);
        o.m = chunks[0] - OP_INT_BASE3;
        o.n = chunks[chunks.length - 2] - OP_INT_BASE3;
        o.pubkeys = chunks.slice(1, -2);
      }
      lazy.prop(o, "output", () => {
        if (!a.m) return;
        if (!o.n) return;
        if (!a.pubkeys) return;
        return bscript.compile(
          [].concat(
            OP_INT_BASE3 + a.m,
            a.pubkeys,
            OP_INT_BASE3 + o.n,
            OPS10.OP_CHECKMULTISIG
          )
        );
      });
      lazy.prop(o, "m", () => {
        if (!o.output) return;
        decode44(o.output);
        return o.m;
      });
      lazy.prop(o, "n", () => {
        if (!o.pubkeys) return;
        return o.pubkeys.length;
      });
      lazy.prop(o, "pubkeys", () => {
        if (!a.output) return;
        decode44(a.output);
        return o.pubkeys;
      });
      lazy.prop(o, "signatures", () => {
        if (!a.input) return;
        return bscript.decompile(a.input).slice(1);
      });
      lazy.prop(o, "input", () => {
        if (!a.signatures) return;
        return bscript.compile([OPS10.OP_0].concat(a.signatures));
      });
      lazy.prop(o, "witness", () => {
        if (!o.input) return;
        return [];
      });
      lazy.prop(o, "name", () => {
        if (!o.m || !o.n) return;
        return `p2ms(${o.m} of ${o.n})`;
      });
      if (opts.validate) {
        if (a.output) {
          decode44(a.output);
          if (!types_1.typeforce.Number(chunks[0]))
            throw new TypeError("Output is invalid");
          if (!types_1.typeforce.Number(chunks[chunks.length - 2]))
            throw new TypeError("Output is invalid");
          if (chunks[chunks.length - 1] !== OPS10.OP_CHECKMULTISIG)
            throw new TypeError("Output is invalid");
          if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)
            throw new TypeError("Output is invalid");
          if (!o.pubkeys.every((x) => (0, types_1.isPoint)(x)))
            throw new TypeError("Output is invalid");
          if (a.m !== void 0 && a.m !== o.m) throw new TypeError("m mismatch");
          if (a.n !== void 0 && a.n !== o.n) throw new TypeError("n mismatch");
          if (a.pubkeys && !stacksEqual2(a.pubkeys, o.pubkeys))
            throw new TypeError("Pubkeys mismatch");
        }
        if (a.pubkeys) {
          if (a.n !== void 0 && a.n !== a.pubkeys.length)
            throw new TypeError("Pubkey count mismatch");
          o.n = a.pubkeys.length;
          if (o.n < o.m) throw new TypeError("Pubkey count cannot be less than m");
        }
        if (a.signatures) {
          if (a.signatures.length < o.m)
            throw new TypeError("Not enough signatures provided");
          if (a.signatures.length > o.m)
            throw new TypeError("Too many signatures provided");
        }
        if (a.input) {
          if (a.input[0] !== OPS10.OP_0) throw new TypeError("Input is invalid");
          if (o.signatures.length === 0 || !o.signatures.every(isAcceptableSignature))
            throw new TypeError("Input has invalid signature(s)");
          if (a.signatures && !stacksEqual2(a.signatures, o.signatures))
            throw new TypeError("Signature mismatch");
          if (a.m !== void 0 && a.m !== a.signatures.length)
            throw new TypeError("Signature count mismatch");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2ms = p2ms2;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/p2pk.js
var require_p2pk = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/p2pk.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2pk = void 0;
    var networks_1 = require_networks();
    var bscript = __importStar(require_script());
    var types_1 = require_types2();
    var lazy = __importStar(require_lazy());
    var OPS10 = bscript.OPS;
    function p2pk2(a, opts) {
      if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          pubkey: types_1.typeforce.maybe(types_1.isPoint),
          signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer)
        },
        a
      );
      const _chunks = lazy.value(() => {
        return bscript.decompile(a.input);
      });
      const network = a.network || networks_1.liquid;
      const o = { name: "p2pk", network };
      lazy.prop(o, "output", () => {
        if (!a.pubkey) return;
        return bscript.compile([a.pubkey, OPS10.OP_CHECKSIG]);
      });
      lazy.prop(o, "pubkey", () => {
        if (!a.output) return;
        return a.output.slice(1, -1);
      });
      lazy.prop(o, "signature", () => {
        if (!a.input) return;
        return _chunks()[0];
      });
      lazy.prop(o, "input", () => {
        if (!a.signature) return;
        return bscript.compile([a.signature]);
      });
      lazy.prop(o, "witness", () => {
        if (!o.input) return;
        return [];
      });
      if (opts.validate) {
        if (a.output) {
          if (a.output[a.output.length - 1] !== OPS10.OP_CHECKSIG)
            throw new TypeError("Output is invalid");
          if (!(0, types_1.isPoint)(o.pubkey))
            throw new TypeError("Output pubkey is invalid");
          if (a.pubkey && !a.pubkey.equals(o.pubkey))
            throw new TypeError("Pubkey mismatch");
        }
        if (a.signature) {
          if (a.input && !a.input.equals(o.input))
            throw new TypeError("Signature mismatch");
        }
        if (a.input) {
          if (_chunks().length !== 1) throw new TypeError("Input is invalid");
          if (!bscript.isCanonicalScriptSignature(o.signature))
            throw new TypeError("Input has invalid signature");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2pk = p2pk2;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/crypto.js
var require_crypto = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/crypto.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.taggedHash = exports2.hash256 = exports2.hash160 = exports2.sha256 = exports2.sha1 = exports2.ripemd160 = void 0;
    var create_hash_1 = __importDefault(require_browser4());
    function ripemd1603(buffer2) {
      try {
        return (0, create_hash_1.default)("rmd160").update(buffer2).digest();
      } catch (err) {
        return (0, create_hash_1.default)("ripemd160").update(buffer2).digest();
      }
    }
    exports2.ripemd160 = ripemd1603;
    function sha1(buffer2) {
      return (0, create_hash_1.default)("sha1").update(buffer2).digest();
    }
    exports2.sha1 = sha1;
    function sha2567(buffer2) {
      return (0, create_hash_1.default)("sha256").update(buffer2).digest();
    }
    exports2.sha256 = sha2567;
    function hash1603(buffer2) {
      return ripemd1603(sha2567(buffer2));
    }
    exports2.hash160 = hash1603;
    function hash2562(buffer2) {
      return sha2567(sha2567(buffer2));
    }
    exports2.hash256 = hash2562;
    var TAGS = [
      "BIP0340/challenge",
      "BIP0340/aux",
      "BIP0340/nonce",
      "TapLeaf",
      "TapLeaf/elements",
      "TapBranch/elements",
      "TapSighash",
      "TapSighash/elements",
      "TapTweak",
      "TapTweak/elements",
      "KeyAgg list",
      "KeyAgg coefficient"
    ];
    var TAGGED_HASH_PREFIXES3 = Object.fromEntries(
      TAGS.map((tag) => {
        const tagHash = sha2567(import_buffer.Buffer.from(tag, "utf-8"));
        return [tag, import_buffer.Buffer.concat([tagHash, tagHash])];
      })
    );
    function taggedHash3(prefix, data) {
      return sha2567(import_buffer.Buffer.concat([TAGGED_HASH_PREFIXES3[prefix], data]));
    }
    exports2.taggedHash = taggedHash3;
  }
});

// node_modules/.pnpm/base-x@3.0.11/node_modules/base-x/src/index.js
var require_src2 = __commonJS({
  "node_modules/.pnpm/base-x@3.0.11/node_modules/base-x/src/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var _Buffer = require_safe_buffer().Buffer;
    function base5(ALPHABET2) {
      if (ALPHABET2.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET2.length; i++) {
        var x = ALPHABET2.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET2.length;
      var LEADER = ALPHABET2.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode42(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length6 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length6) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length6 = i2;
          pbegin++;
        }
        var it2 = size - length6;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET2.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length6 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (psz < source.length) {
          var charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          var carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length6) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length6 = i2;
          psz++;
        }
        var it4 = size - length6;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
        vch.fill(0, 0, zeroes);
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode44(string5) {
        var buffer2 = decodeUnsafe(string5);
        if (buffer2) {
          return buffer2;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode42,
        decodeUnsafe,
        decode: decode44
      };
    }
    module2.exports = base5;
  }
});

// node_modules/.pnpm/bs58@4.0.1/node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/.pnpm/bs58@4.0.1/node_modules/bs58/index.js"(exports2, module2) {
    init_buffer_polyfill();
    var basex = require_src2();
    var ALPHABET2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module2.exports = basex(ALPHABET2);
  }
});

// node_modules/.pnpm/bs58check@2.1.2/node_modules/bs58check/base.js
var require_base3 = __commonJS({
  "node_modules/.pnpm/bs58check@2.1.2/node_modules/bs58check/base.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var base582 = require_bs58();
    var Buffer5 = require_safe_buffer().Buffer;
    module2.exports = function(checksumFn) {
      function encode42(payload) {
        var checksum2 = checksumFn(payload);
        return base582.encode(Buffer5.concat([
          payload,
          checksum2
        ], payload.length + 4));
      }
      function decodeRaw(buffer2) {
        var payload = buffer2.slice(0, -4);
        var checksum2 = buffer2.slice(-4);
        var newChecksum = checksumFn(payload);
        if (checksum2[0] ^ newChecksum[0] | checksum2[1] ^ newChecksum[1] | checksum2[2] ^ newChecksum[2] | checksum2[3] ^ newChecksum[3]) return;
        return payload;
      }
      function decodeUnsafe(string5) {
        var buffer2 = base582.decodeUnsafe(string5);
        if (!buffer2) return;
        return decodeRaw(buffer2);
      }
      function decode44(string5) {
        var buffer2 = base582.decode(string5);
        var payload = decodeRaw(buffer2, checksumFn);
        if (!payload) throw new Error("Invalid checksum");
        return payload;
      }
      return {
        encode: encode42,
        decode: decode44,
        decodeUnsafe
      };
    };
  }
});

// node_modules/.pnpm/bs58check@2.1.2/node_modules/bs58check/index.js
var require_bs58check = __commonJS({
  "node_modules/.pnpm/bs58check@2.1.2/node_modules/bs58check/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var createHash = require_browser4();
    var bs58checkBase = require_base3();
    function sha256x22(buffer2) {
      var tmp = createHash("sha256").update(buffer2).digest();
      return createHash("sha256").update(tmp).digest();
    }
    module2.exports = bs58checkBase(sha256x22);
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/p2pkh.js
var require_p2pkh = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/p2pkh.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2pkh = void 0;
    var bcrypto = __importStar(require_crypto());
    var networks_1 = require_networks();
    var bscript = __importStar(require_script());
    var types_1 = require_types2();
    var lazy = __importStar(require_lazy());
    var bs58check_1 = __importDefault(require_bs58check());
    var OPS10 = bscript.OPS;
    function p2pkh2(a, opts) {
      if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input && !a.confidentialAddress)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(25)),
          pubkey: types_1.typeforce.maybe(types_1.isPoint),
          signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          blindkey: types_1.typeforce.maybe(types_1.isPoint),
          confidentialAddress: types_1.typeforce.maybe(types_1.typeforce.String)
        },
        a
      );
      const _address = lazy.value(() => {
        const payload = bs58check_1.default.decode(a.address);
        const version = payload.readUInt8(0);
        const hash = payload.slice(1);
        return { version, hash };
      });
      const _chunks = lazy.value(() => {
        return bscript.decompile(a.input);
      });
      const _confidentialAddress = lazy.value(() => {
        const payload = bs58check_1.default.decode(a.confidentialAddress);
        const blindkey = payload.slice(2, 35);
        const unconfidentialAddressBuffer = import_buffer.Buffer.concat([
          import_buffer.Buffer.from([payload.readUInt8(1)]),
          payload.slice(35)
        ]);
        const unconfidentialAddress = bs58check_1.default.encode(
          unconfidentialAddressBuffer
        );
        return { blindkey, unconfidentialAddress };
      });
      const network = a.network || networks_1.liquid;
      const o = { name: "p2pkh", network };
      lazy.prop(o, "address", () => {
        if (!o.hash) return;
        const payload = import_buffer.Buffer.allocUnsafe(21);
        payload.writeUInt8(network.pubKeyHash, 0);
        o.hash.copy(payload, 1);
        return bs58check_1.default.encode(payload);
      });
      lazy.prop(o, "hash", () => {
        if (a.output) return a.output.slice(3, 23);
        if (a.address) return _address().hash;
        if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
        if (a.confidentialAddress) {
          const address = _confidentialAddress().unconfidentialAddress;
          return bs58check_1.default.decode(address).slice(1);
        }
      });
      lazy.prop(o, "output", () => {
        if (!o.hash) return;
        return bscript.compile([
          OPS10.OP_DUP,
          OPS10.OP_HASH160,
          o.hash,
          OPS10.OP_EQUALVERIFY,
          OPS10.OP_CHECKSIG
        ]);
      });
      lazy.prop(o, "pubkey", () => {
        if (!a.input) return;
        return _chunks()[1];
      });
      lazy.prop(o, "signature", () => {
        if (!a.input) return;
        return _chunks()[0];
      });
      lazy.prop(o, "input", () => {
        if (!a.pubkey) return;
        if (!a.signature) return;
        return bscript.compile([a.signature, a.pubkey]);
      });
      lazy.prop(o, "witness", () => {
        if (!o.input) return;
        return [];
      });
      lazy.prop(o, "blindkey", () => {
        if (a.confidentialAddress) return _confidentialAddress().blindkey;
        if (a.blindkey) return a.blindkey;
      });
      lazy.prop(o, "confidentialAddress", () => {
        if (!o.address) return;
        if (!o.blindkey) return;
        const payload = bs58check_1.default.decode(o.address);
        const confidentialAddress = import_buffer.Buffer.concat([
          import_buffer.Buffer.from([network.confidentialPrefix, payload.readUInt8(0)]),
          o.blindkey,
          import_buffer.Buffer.from(payload.slice(1))
        ]);
        return bs58check_1.default.encode(confidentialAddress);
      });
      if (opts.validate) {
        let hash = import_buffer.Buffer.from([]);
        let blindkey = import_buffer.Buffer.from([]);
        if (a.address) {
          if (_address().version !== network.pubKeyHash)
            throw new TypeError("Invalid version or Network mismatch");
          if (_address().hash.length !== 20) throw new TypeError("Invalid address");
          hash = _address().hash;
        }
        if (a.hash) {
          if (hash.length > 0 && !hash.equals(a.hash))
            throw new TypeError("Hash mismatch");
          else hash = a.hash;
        }
        if (a.output) {
          if (a.output.length !== 25 || a.output[0] !== OPS10.OP_DUP || a.output[1] !== OPS10.OP_HASH160 || a.output[2] !== 20 || a.output[23] !== OPS10.OP_EQUALVERIFY || a.output[24] !== OPS10.OP_CHECKSIG)
            throw new TypeError("Output is invalid");
          const hash2 = a.output.slice(3, 23);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        if (a.pubkey) {
          const pkh = bcrypto.hash160(a.pubkey);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
          else hash = pkh;
        }
        if (a.input) {
          const chunks = _chunks();
          if (chunks.length !== 2) throw new TypeError("Input is invalid");
          if (!bscript.isCanonicalScriptSignature(chunks[0]))
            throw new TypeError("Input has invalid signature");
          if (!(0, types_1.isPoint)(chunks[1]))
            throw new TypeError("Input has invalid pubkey");
          if (a.signature && !a.signature.equals(chunks[0]))
            throw new TypeError("Signature mismatch");
          if (a.pubkey && !a.pubkey.equals(chunks[1]))
            throw new TypeError("Pubkey mismatch");
          const pkh = bcrypto.hash160(chunks[1]);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
        }
        if (a.confidentialAddress) {
          if (a.address && a.address !== _confidentialAddress().unconfidentialAddress)
            throw new TypeError("Address mismatch");
          if (blindkey.length > 0 && !blindkey.equals(_confidentialAddress().blindkey))
            throw new TypeError("Blindkey mismatch");
          else blindkey = _confidentialAddress().blindkey;
        }
        if (a.blindkey) {
          if (!(0, types_1.isPoint)(a.blindkey))
            throw new TypeError("Blindkey is invalid");
          if (blindkey.length > 0 && !blindkey.equals(a.blindkey))
            throw new TypeError("Blindkey mismatch");
          else blindkey = a.blindkey;
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2pkh = p2pkh2;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/p2sh.js
var require_p2sh = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/p2sh.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2sh = void 0;
    var bcrypto = __importStar(require_crypto());
    var networks_1 = require_networks();
    var bscript = __importStar(require_script());
    var types_1 = require_types2();
    var lazy = __importStar(require_lazy());
    var bs58check2 = __importStar(require_bs58check());
    var OPS10 = bscript.OPS;
    function stacksEqual2(a, b) {
      if (a.length !== b.length) return false;
      return a.every((x, i) => {
        return x.equals(b[i]);
      });
    }
    function p2sh2(a, opts) {
      if (!a.address && !a.hash && !a.output && !a.redeem && !a.input && !a.confidentialAddress)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(23)),
          redeem: types_1.typeforce.maybe({
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          }),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          ),
          blindkey: types_1.typeforce.maybe(types_1.isPoint),
          confidentialAddress: types_1.typeforce.maybe(types_1.typeforce.String)
        },
        a
      );
      let network = a.network;
      if (!network) {
        network = a.redeem && a.redeem.network || networks_1.liquid;
      }
      const o = { network };
      const _address = lazy.value(() => {
        const payload = bs58check2.decode(a.address);
        const version = payload.readUInt8(0);
        const hash = payload.slice(1);
        return { version, hash };
      });
      const _chunks = lazy.value(() => {
        return bscript.decompile(a.input);
      });
      const _redeem = lazy.value(() => {
        const chunks = _chunks();
        return {
          network,
          output: chunks[chunks.length - 1],
          input: bscript.compile(chunks.slice(0, -1)),
          witness: a.witness || []
        };
      });
      const _confidentialAddress = lazy.value(() => {
        const payload = bs58check2.decode(a.confidentialAddress);
        const blindkey = payload.slice(2, 35);
        const unconfidentialAddressBuffer = import_buffer.Buffer.concat([
          import_buffer.Buffer.from([payload.readUInt8(1)]),
          payload.slice(35)
        ]);
        const unconfidentialAddress = bs58check2.encode(unconfidentialAddressBuffer);
        return { blindkey, unconfidentialAddress };
      });
      lazy.prop(o, "address", () => {
        if (!o.hash) return;
        const payload = import_buffer.Buffer.allocUnsafe(21);
        payload.writeUInt8(o.network.scriptHash, 0);
        o.hash.copy(payload, 1);
        return bs58check2.encode(payload);
      });
      lazy.prop(o, "hash", () => {
        if (a.output) return a.output.slice(2, 22);
        if (a.address) return _address().hash;
        if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);
        if (a.confidentialAddress) {
          const address = _confidentialAddress().unconfidentialAddress;
          return bs58check2.decode(address).slice(1);
        }
      });
      lazy.prop(o, "output", () => {
        if (!o.hash) return;
        return bscript.compile([OPS10.OP_HASH160, o.hash, OPS10.OP_EQUAL]);
      });
      lazy.prop(o, "redeem", () => {
        if (!a.input) return;
        return _redeem();
      });
      lazy.prop(o, "input", () => {
        if (!a.redeem || !a.redeem.input || !a.redeem.output) return;
        return bscript.compile(
          [].concat(bscript.decompile(a.redeem.input), a.redeem.output)
        );
      });
      lazy.prop(o, "witness", () => {
        if (o.redeem && o.redeem.witness) return o.redeem.witness;
        if (o.input) return [];
      });
      lazy.prop(o, "name", () => {
        const nameParts = ["p2sh"];
        if (o.redeem !== void 0 && o.redeem.name !== void 0)
          nameParts.push(o.redeem.name);
        return nameParts.join("-");
      });
      lazy.prop(o, "blindkey", () => {
        if (a.confidentialAddress) return _confidentialAddress().blindkey;
        if (a.blindkey) return a.blindkey;
      });
      lazy.prop(o, "confidentialAddress", () => {
        if (!o.address) return;
        if (!o.blindkey) return;
        const payload = bs58check2.decode(o.address);
        const confidentialAddress = import_buffer.Buffer.concat([
          import_buffer.Buffer.from([network.confidentialPrefix, payload.readUInt8(0)]),
          o.blindkey,
          import_buffer.Buffer.from(payload.slice(1))
        ]);
        return bs58check2.encode(confidentialAddress);
      });
      if (opts.validate) {
        let hash = import_buffer.Buffer.from([]);
        let blindkey = import_buffer.Buffer.from([]);
        if (a.address) {
          if (_address().version !== network.scriptHash)
            throw new TypeError("Invalid version or Network mismatch");
          if (_address().hash.length !== 20) throw new TypeError("Invalid address");
          hash = _address().hash;
        }
        if (a.hash) {
          if (hash.length > 0 && !hash.equals(a.hash))
            throw new TypeError("Hash mismatch");
          else hash = a.hash;
        }
        if (a.output) {
          if (a.output.length !== 23 || a.output[0] !== OPS10.OP_HASH160 || a.output[1] !== 20 || a.output[22] !== OPS10.OP_EQUAL)
            throw new TypeError("Output is invalid");
          const hash2 = a.output.slice(2, 22);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        const checkRedeem = (redeem) => {
          if (redeem.output) {
            const decompile2 = bscript.decompile(redeem.output);
            if (!decompile2 || decompile2.length < 1)
              throw new TypeError("Redeem.output too short");
            const hash2 = bcrypto.hash160(redeem.output);
            if (hash.length > 0 && !hash.equals(hash2))
              throw new TypeError("Hash mismatch");
            else hash = hash2;
          }
          if (redeem.input) {
            const hasInput = redeem.input.length > 0;
            const hasWitness = redeem.witness && redeem.witness.length > 0;
            if (!hasInput && !hasWitness) throw new TypeError("Empty input");
            if (hasInput && hasWitness)
              throw new TypeError("Input and witness provided");
            if (hasInput) {
              const richunks = bscript.decompile(redeem.input);
              if (!bscript.isPushOnly(richunks))
                throw new TypeError("Non push-only scriptSig");
            }
          }
        };
        if (a.input) {
          const chunks = _chunks();
          if (!chunks || chunks.length < 1) throw new TypeError("Input too short");
          if (!import_buffer.Buffer.isBuffer(_redeem().output))
            throw new TypeError("Input is invalid");
          checkRedeem(_redeem());
        }
        if (a.redeem) {
          if (a.redeem.network && a.redeem.network !== network)
            throw new TypeError("Network mismatch");
          if (a.input) {
            const redeem = _redeem();
            if (a.redeem.output && !a.redeem.output.equals(redeem.output))
              throw new TypeError("Redeem.output mismatch");
            if (a.redeem.input && !a.redeem.input.equals(redeem.input))
              throw new TypeError("Redeem.input mismatch");
          }
          checkRedeem(a.redeem);
        }
        if (a.witness) {
          if (a.redeem && a.redeem.witness && !stacksEqual2(a.redeem.witness, a.witness))
            throw new TypeError("Witness and redeem.witness mismatch");
        }
        if (a.confidentialAddress) {
          if (a.address && a.address !== _confidentialAddress().unconfidentialAddress)
            throw new TypeError("Address mismatch");
          if (blindkey.length > 0 && !blindkey.equals(_confidentialAddress().blindkey))
            throw new TypeError("Blindkey mismatch");
          else blindkey = _confidentialAddress().blindkey;
        }
        if (a.blindkey) {
          if (!(0, types_1.isPoint)(a.blindkey))
            throw new TypeError("Blindkey is invalid");
          if (blindkey.length > 0 && !blindkey.equals(a.blindkey))
            throw new TypeError("Blindkey mismatch");
          else blindkey = a.blindkey;
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2sh = p2sh2;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/p2wpkh.js
var require_p2wpkh = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/p2wpkh.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2wpkh = void 0;
    var baddress = __importStar(require_address());
    var bcrypto = __importStar(require_crypto());
    var networks_1 = require_networks();
    var bscript = __importStar(require_script());
    var types_1 = require_types2();
    var lazy = __importStar(require_lazy());
    var bech32_1 = require_dist();
    var OPS10 = bscript.OPS;
    var EMPTY_BUFFER4 = import_buffer.Buffer.alloc(0);
    function p2wpkh2(a, opts) {
      if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness && !a.confidentialAddress)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
          input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(22)),
          pubkey: types_1.typeforce.maybe(types_1.isPoint),
          signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a
      );
      const network = a.network || networks_1.liquid;
      const _address = lazy.value(() => {
        const result = bech32_1.bech32.decode(a.address);
        const version = result.words.shift();
        const data = bech32_1.bech32.fromWords(result.words);
        return {
          version,
          prefix: result.prefix,
          data: import_buffer.Buffer.from(data)
        };
      });
      const _confidentialAddress = lazy.value(() => {
        const result = baddress.fromBlech32(a.confidentialAddress);
        return {
          blindingKey: result.pubkey,
          unconfidentialAddress: baddress.toBech32(
            result.data.slice(2),
            result.version,
            network.bech32
          )
        };
      });
      const o = { name: "p2wpkh", network };
      lazy.prop(o, "address", () => {
        if (!o.hash) return;
        const words = bech32_1.bech32.toWords(o.hash);
        words.unshift(0);
        return bech32_1.bech32.encode(network.bech32, words);
      });
      lazy.prop(o, "hash", () => {
        if (a.output) return a.output.slice(2, 22);
        if (a.address) return _address().data;
        if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
        if (a.confidentialAddress) {
          const addr = _confidentialAddress().unconfidentialAddress;
          return baddress.fromBech32(addr).data;
        }
      });
      lazy.prop(o, "output", () => {
        if (!o.hash) return;
        return bscript.compile([OPS10.OP_0, o.hash]);
      });
      lazy.prop(o, "pubkey", () => {
        if (a.pubkey) return a.pubkey;
        if (!a.witness) return;
        return a.witness[1];
      });
      lazy.prop(o, "signature", () => {
        if (!a.witness) return;
        return a.witness[0];
      });
      lazy.prop(o, "input", () => {
        if (!o.witness) return;
        return EMPTY_BUFFER4;
      });
      lazy.prop(o, "witness", () => {
        if (!a.pubkey) return;
        if (!a.signature) return;
        return [a.signature, a.pubkey];
      });
      lazy.prop(o, "blindkey", () => {
        if (a.confidentialAddress) return _confidentialAddress().blindingKey;
        if (a.blindkey) return a.blindkey;
      });
      lazy.prop(o, "confidentialAddress", () => {
        if (!o.address) return;
        if (!o.blindkey) return;
        if (!o.network) return;
        const res = baddress.fromBech32(o.address);
        const data = import_buffer.Buffer.concat([
          import_buffer.Buffer.from([res.version, res.data.length]),
          res.data
        ]);
        if (res.version !== 0) return;
        return baddress.toBlech32(data, o.blindkey, o.network.blech32, 0);
      });
      if (opts.validate) {
        let hash = import_buffer.Buffer.from([]);
        let blindkey = import_buffer.Buffer.from([]);
        if (a.address) {
          if (network && network.bech32 !== _address().prefix)
            throw new TypeError("Invalid prefix or Network mismatch");
          if (_address().version !== 0)
            throw new TypeError("Invalid address version");
          if (_address().data.length !== 20)
            throw new TypeError("Invalid address data");
          hash = _address().data;
        }
        if (a.hash) {
          if (hash.length > 0 && !hash.equals(a.hash))
            throw new TypeError("Hash mismatch");
          else hash = a.hash;
        }
        if (a.output) {
          if (a.output.length !== 22 || a.output[0] !== OPS10.OP_0 || a.output[1] !== 20)
            throw new TypeError("Output is invalid");
          if (hash.length > 0 && !hash.equals(a.output.slice(2)))
            throw new TypeError("Hash mismatch");
          else hash = a.output.slice(2);
        }
        if (a.pubkey) {
          const pkh = bcrypto.hash160(a.pubkey);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
          else hash = pkh;
          if (!(0, types_1.isPoint)(a.pubkey) || a.pubkey.length !== 33)
            throw new TypeError("Invalid pubkey for p2wpkh");
        }
        if (a.witness) {
          if (a.witness.length !== 2) throw new TypeError("Witness is invalid");
          if (!bscript.isCanonicalScriptSignature(a.witness[0]))
            throw new TypeError("Witness has invalid signature");
          if (!(0, types_1.isPoint)(a.witness[1]) || a.witness[1].length !== 33)
            throw new TypeError("Witness has invalid pubkey");
          if (a.signature && !a.signature.equals(a.witness[0]))
            throw new TypeError("Signature mismatch");
          if (a.pubkey && !a.pubkey.equals(a.witness[1]))
            throw new TypeError("Pubkey mismatch");
          const pkh = bcrypto.hash160(a.witness[1]);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
        }
        if (a.confidentialAddress) {
          if (a.address && a.address !== _confidentialAddress().unconfidentialAddress)
            throw new TypeError("Address mismatch");
          if (blindkey.length > 0 && !blindkey.equals(_confidentialAddress().blindingKey))
            throw new TypeError("Blindkey mismatch");
          else blindkey = _confidentialAddress().blindingKey;
        }
        if (a.blindkey) {
          if (!(0, types_1.isPoint)(a.blindkey))
            throw new TypeError("Blindkey is invalid");
          if (blindkey.length > 0 && !blindkey.equals(a.blindkey))
            throw new TypeError("Blindkey mismatch");
          else blindkey = a.blindkey;
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2wpkh = p2wpkh2;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/p2wsh.js
var require_p2wsh = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/p2wsh.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2wsh = void 0;
    var baddress = __importStar(require_address());
    var bcrypto = __importStar(require_crypto());
    var networks_1 = require_networks();
    var bscript = __importStar(require_script());
    var types_1 = require_types2();
    var lazy = __importStar(require_lazy());
    var bech32_1 = require_dist();
    var OPS10 = bscript.OPS;
    var EMPTY_BUFFER4 = import_buffer.Buffer.alloc(0);
    function stacksEqual2(a, b) {
      if (a.length !== b.length) return false;
      return a.every((x, i) => {
        return x.equals(b[i]);
      });
    }
    function chunkHasUncompressedPubkey2(chunk) {
      if (import_buffer.Buffer.isBuffer(chunk) && chunk.length === 65 && chunk[0] === 4 && (0, types_1.isPoint)(chunk)) {
        return true;
      } else {
        return false;
      }
    }
    function p2wsh2(a, opts) {
      if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness && !a.confidentialAddress)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
          redeem: types_1.typeforce.maybe({
            input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          }),
          input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          ),
          blindkey: types_1.typeforce.maybe(types_1.isPoint),
          confidentialAddress: types_1.typeforce.maybe(types_1.typeforce.String)
        },
        a
      );
      let network = a.network;
      if (!network) {
        network = a.redeem && a.redeem.network || networks_1.liquid;
      }
      const _address = lazy.value(() => {
        const result = bech32_1.bech32.decode(a.address);
        const version = result.words.shift();
        const data = bech32_1.bech32.fromWords(result.words);
        return {
          version,
          prefix: result.prefix,
          data: import_buffer.Buffer.from(data)
        };
      });
      const _rchunks = lazy.value(() => {
        return bscript.decompile(a.redeem.input);
      });
      const _confidentialAddress = lazy.value(() => {
        const result = baddress.fromBlech32(a.confidentialAddress);
        return {
          blindingKey: result.pubkey,
          unconfidentialAddress: baddress.toBech32(
            result.data.slice(2),
            result.version,
            network.bech32
          )
        };
      });
      const o = { network };
      lazy.prop(o, "address", () => {
        if (!o.hash) return;
        const words = bech32_1.bech32.toWords(o.hash);
        words.unshift(0);
        return bech32_1.bech32.encode(network.bech32, words);
      });
      lazy.prop(o, "hash", () => {
        if (a.output) return a.output.slice(2);
        if (a.address) return _address().data;
        if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);
        if (a.confidentialAddress) {
          const addr = _confidentialAddress().unconfidentialAddress;
          return baddress.fromBech32(addr).data;
        }
      });
      lazy.prop(o, "output", () => {
        if (!o.hash) return;
        return bscript.compile([OPS10.OP_0, o.hash]);
      });
      lazy.prop(o, "redeem", () => {
        if (!a.witness) return;
        return {
          output: a.witness[a.witness.length - 1],
          input: EMPTY_BUFFER4,
          witness: a.witness.slice(0, -1)
        };
      });
      lazy.prop(o, "input", () => {
        if (!o.witness) return;
        return EMPTY_BUFFER4;
      });
      lazy.prop(o, "witness", () => {
        if (a.redeem && a.redeem.input && a.redeem.input.length > 0 && a.redeem.output && a.redeem.output.length > 0) {
          const stack = bscript.toStack(_rchunks());
          o.redeem = Object.assign({ witness: stack }, a.redeem);
          o.redeem.input = EMPTY_BUFFER4;
          return [].concat(stack, a.redeem.output);
        }
        if (!a.redeem) return;
        if (!a.redeem.output) return;
        if (!a.redeem.witness) return;
        return [].concat(a.redeem.witness, a.redeem.output);
      });
      lazy.prop(o, "name", () => {
        const nameParts = ["p2wsh"];
        if (o.redeem !== void 0 && o.redeem.name !== void 0)
          nameParts.push(o.redeem.name);
        return nameParts.join("-");
      });
      lazy.prop(o, "blindkey", () => {
        if (a.confidentialAddress) return _confidentialAddress().blindingKey;
        if (a.blindkey) return a.blindkey;
      });
      lazy.prop(o, "confidentialAddress", () => {
        if (!o.address) return;
        if (!o.blindkey) return;
        const res = baddress.fromBech32(o.address);
        const data = import_buffer.Buffer.concat([
          import_buffer.Buffer.from([res.version, res.data.length]),
          res.data
        ]);
        return baddress.toBlech32(data, o.blindkey, o.network.blech32, 0);
      });
      if (opts.validate) {
        let hash = import_buffer.Buffer.from([]);
        let blindkey = import_buffer.Buffer.from([]);
        if (a.address) {
          if (_address().prefix !== network.bech32)
            throw new TypeError("Invalid prefix or Network mismatch");
          if (_address().version !== 0)
            throw new TypeError("Invalid address version");
          if (_address().data.length !== 32)
            throw new TypeError("Invalid address data");
          hash = _address().data;
        }
        if (a.hash) {
          if (hash.length > 0 && !hash.equals(a.hash))
            throw new TypeError("Hash mismatch");
          else hash = a.hash;
        }
        if (a.output) {
          if (a.output.length !== 34 || a.output[0] !== OPS10.OP_0 || a.output[1] !== 32)
            throw new TypeError("Output is invalid");
          const hash2 = a.output.slice(2);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        if (a.redeem) {
          if (a.redeem.network && a.redeem.network !== network)
            throw new TypeError("Network mismatch");
          if (a.redeem.input && a.redeem.input.length > 0 && a.redeem.witness && a.redeem.witness.length > 0)
            throw new TypeError("Ambiguous witness source");
          if (a.redeem.output) {
            if (bscript.decompile(a.redeem.output).length === 0)
              throw new TypeError("Redeem.output is invalid");
            const hash2 = bcrypto.sha256(a.redeem.output);
            if (hash.length > 0 && !hash.equals(hash2))
              throw new TypeError("Hash mismatch");
            else hash = hash2;
          }
          if (a.redeem.input && !bscript.isPushOnly(_rchunks()))
            throw new TypeError("Non push-only scriptSig");
          if (a.witness && a.redeem.witness && !stacksEqual2(a.witness, a.redeem.witness))
            throw new TypeError("Witness and redeem.witness mismatch");
          if (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey2) || a.redeem.output && (bscript.decompile(a.redeem.output) || []).some(
            chunkHasUncompressedPubkey2
          )) {
            throw new TypeError(
              "redeem.input or redeem.output contains uncompressed pubkey"
            );
          }
        }
        if (a.witness && a.witness.length > 0) {
          const wScript = a.witness[a.witness.length - 1];
          if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))
            throw new TypeError("Witness and redeem.output mismatch");
          if (a.witness.some(chunkHasUncompressedPubkey2) || (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey2))
            throw new TypeError("Witness contains uncompressed pubkey");
        }
        if (a.confidentialAddress) {
          if (a.address && a.address !== _confidentialAddress().unconfidentialAddress)
            throw new TypeError("Address mismatch");
          if (blindkey.length > 0 && !blindkey.equals(_confidentialAddress().blindingKey))
            throw new TypeError("Blindkey mismatch");
          else blindkey = _confidentialAddress().blindingKey;
        }
        if (a.blindkey) {
          if (!(0, types_1.isPoint)(a.blindkey))
            throw new TypeError("Blindkey is invalid");
          if (blindkey.length > 0 && !blindkey.equals(a.blindkey))
            throw new TypeError("Blindkey mismatch");
          else blindkey = a.blindkey;
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2wsh = p2wsh2;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/index.js
var require_payments = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/payments/index.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2wsh = exports2.p2wpkh = exports2.p2sh = exports2.p2pkh = exports2.p2pk = exports2.p2ms = exports2.embed = void 0;
    var embed_1 = require_embed();
    Object.defineProperty(exports2, "embed", {
      enumerable: true,
      get: function() {
        return embed_1.p2data;
      }
    });
    var p2ms_1 = require_p2ms();
    Object.defineProperty(exports2, "p2ms", {
      enumerable: true,
      get: function() {
        return p2ms_1.p2ms;
      }
    });
    var p2pk_1 = require_p2pk();
    Object.defineProperty(exports2, "p2pk", {
      enumerable: true,
      get: function() {
        return p2pk_1.p2pk;
      }
    });
    var p2pkh_1 = require_p2pkh();
    Object.defineProperty(exports2, "p2pkh", {
      enumerable: true,
      get: function() {
        return p2pkh_1.p2pkh;
      }
    });
    var p2sh_1 = require_p2sh();
    Object.defineProperty(exports2, "p2sh", {
      enumerable: true,
      get: function() {
        return p2sh_1.p2sh;
      }
    });
    var p2wpkh_1 = require_p2wpkh();
    Object.defineProperty(exports2, "p2wpkh", {
      enumerable: true,
      get: function() {
        return p2wpkh_1.p2wpkh;
      }
    });
    var p2wsh_1 = require_p2wsh();
    Object.defineProperty(exports2, "p2wsh", {
      enumerable: true,
      get: function() {
        return p2wsh_1.p2wsh;
      }
    });
  }
});

// node_modules/.pnpm/long@4.0.0/node_modules/long/src/long.js
var require_long = __commonJS({
  "node_modules/.pnpm/long@4.0.0/node_modules/long/src/long.js"(exports2, module2) {
    init_buffer_polyfill();
    module2.exports = Long;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e) {
    }
    function Long(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long.prototype.__isLong__;
    Object.defineProperty(Long.prototype, "__isLong__", { value: true });
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long.isLong = isLong;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value2, unsigned) {
      var obj, cachedObj, cache4;
      if (unsigned) {
        value2 >>>= 0;
        if (cache4 = 0 <= value2 && value2 < 256) {
          cachedObj = UINT_CACHE[value2];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value2, (value2 | 0) < 0 ? -1 : 0, true);
        if (cache4)
          UINT_CACHE[value2] = obj;
        return obj;
      } else {
        value2 |= 0;
        if (cache4 = -128 <= value2 && value2 < 128) {
          cachedObj = INT_CACHE[value2];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value2, value2 < 0 ? -1 : 0, false);
        if (cache4)
          INT_CACHE[value2] = obj;
        return obj;
      }
    }
    Long.fromInt = fromInt;
    function fromNumber(value2, unsigned) {
      if (isNaN(value2))
        return unsigned ? UZERO : ZERO3;
      if (unsigned) {
        if (value2 < 0)
          return UZERO;
        if (value2 >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value2 <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value2 + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value2 < 0)
        return fromNumber(-value2, unsigned).neg();
      return fromBits(value2 % TWO_PWR_32_DBL | 0, value2 / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long(lowBits, highBits, unsigned);
    }
    Long.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString8(str, unsigned, radix2) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO3;
      if (typeof unsigned === "number") {
        radix2 = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix2 = radix2 || 10;
      if (radix2 < 2 || 36 < radix2)
        throw RangeError("radix");
      var p;
      if ((p = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p === 0) {
        return fromString8(str.substring(1), unsigned, radix2).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix2, 8));
      var result = ZERO3;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value2 = parseInt(str.substring(i, i + size), radix2);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix2, size));
          result = result.mul(power).add(fromNumber(value2));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value2));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long.fromString = fromString8;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString8(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO3 = fromInt(0);
    Long.ZERO = ZERO3;
    var UZERO = fromInt(0, true);
    Long.UZERO = UZERO;
    var ONE2 = fromInt(1);
    Long.ONE = ONE2;
    var UONE = fromInt(1, true);
    Long.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString8(radix2) {
      radix2 = radix2 || 10;
      if (radix2 < 2 || 36 < radix2)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix2), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix2) + rem1.toInt().toString(radix2);
        } else
          return "-" + this.neg().toString(radix2);
      }
      var radixToPower = fromNumber(pow_dbl(radix2, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix2);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals9(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(
        /* validates */
        other
      );
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(
        /* validates */
        other
      ) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(
        /* validates */
        other
      ) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare4(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE2);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add2(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return ZERO3;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(
          this.low,
          this.high,
          multiplier.low,
          multiplier.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO3;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO3;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO3;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO3;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE2) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE2;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO3)) {
              return divisor.isNegative() ? ONE2 : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO3;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO3;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE2;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or4(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits(high, 0, this.unsigned);
        else
          return fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes4(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long.fromBytes = function fromBytes2(bytes, unsigned, le) {
      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    };
    Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
        unsigned
      );
    };
    Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long(
        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
        unsigned
      );
    };
  }
});

// node_modules/.pnpm/blech32@1.1.2/node_modules/blech32/dist/blech32.cjs.development.js
var require_blech32_cjs_development = __commonJS({
  "node_modules/.pnpm/blech32@1.1.2/node_modules/blech32/dist/blech32.cjs.development.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Long = _interopDefault(require_long());
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function convertBits(bytes, from7, to, pad) {
      if (from7 < 1 || from7 > 8 || to < 1 || from7 > 8) {
        throw new Error("only bits groups between 1 and 8 are allowed");
      }
      var regrouped = [];
      var nextByte = 0;
      var filledBits = 0;
      for (var _iterator = _createForOfIteratorHelperLoose(bytes), _step; !(_step = _iterator()).done; ) {
        var n2 = _step.value;
        var b = n2 << 8 - from7;
        var remFromBits = from7;
        while (remFromBits > 0) {
          var remToBits = to - filledBits;
          var toExtract = remFromBits;
          if (remToBits < toExtract) {
            toExtract = remToBits;
          }
          nextByte = nextByte << toExtract | b >> 8 - toExtract;
          b = (b << toExtract) % 256;
          remFromBits -= toExtract;
          filledBits += toExtract;
          if (filledBits === to) {
            regrouped.push(nextByte);
            filledBits = 0;
            nextByte = 0;
          }
        }
      }
      if (pad && filledBits > 0) {
        nextByte = nextByte << to - filledBits;
        regrouped.push(nextByte);
        filledBits = 0;
        nextByte = 0;
      }
      if (filledBits > 0 && (filledBits > 4 || nextByte !== 0)) {
        throw new Error("invalid incomplete group of bits");
      }
      return regrouped;
    }
    function validateWitnessVersion(version) {
      if (version < 0 || version > 16) {
        throw new Error("invalid witness version");
      }
    }
    var CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var MAX_LEN = 1e3;
    function hexToLong(hex) {
      return Long.fromString(hex, true, 16);
    }
    var GENERATORS = /* @__PURE__ */ ["7d52fba40bd886", "5e8dbf1a03950c", "1c3a3c74072a18", "385d72fa0e5139", "7093e5a608865b"].map(hexToLong);
    var BLECH32 = "blech32";
    var BLECH32M = "blech32m";
    function getEncodingType(witnessVersion) {
      validateWitnessVersion(witnessVersion);
      if (witnessVersion === 0) {
        return BLECH32;
      } else if (witnessVersion === 1) {
        return BLECH32M;
      } else {
        throw new Error("Unsuported witness version (" + witnessVersion + "), only 0 (blech32) or 1 (blech32m) are supported");
      }
    }
    function getEncodingConst(enc) {
      if (enc === BLECH32) {
        return Long.fromNumber(1);
      } else if (enc === BLECH32M) {
        return hexToLong("455972a3350f7a1");
      } else {
        throw new Error("Invalid encoding type");
      }
    }
    function polymod(values) {
      var chk = Long.fromNumber(1);
      for (var p = 0; p < values.length; ++p) {
        var top = chk.shiftRight(55);
        chk = chk.and(hexToLong("7fffffffffffff")).shiftLeft(5).xor(values[p]);
        for (var i = 0; i < 5; i++) {
          if (top.shiftRight(Long.fromNumber(i)).and(1).equals(1)) {
            chk = chk.xor(GENERATORS[i]);
          }
        }
      }
      return chk;
    }
    function hrpExpand(hrp) {
      var ret = [];
      for (var p = 0; p < hrp.length; ++p) {
        ret.push(hrp.charCodeAt(p) >> 5);
      }
      ret.push(0);
      for (var _p = 0; _p < hrp.length; ++_p) {
        ret.push(hrp.charCodeAt(_p) & 31);
      }
      return Uint8Array.from(ret);
    }
    function verifyChecksum(hrp, data, enc) {
      var hrpAndData = Array.from(hrpExpand(hrp)).concat(data);
      return polymod(hrpAndData).equals(getEncodingConst(enc));
    }
    var zeros = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    function createChecksum(hrp, data, enc) {
      var values = Array.from(hrpExpand(hrp)).concat(Array.from(data)).concat(zeros);
      var mod3 = polymod(values).xor(getEncodingConst(enc));
      var ret = [];
      for (var p = 0; p < 12; ++p) {
        ret.push(mod3.shiftRight(5 * (11 - p)).and(31));
      }
      return ret.map(function(_long) {
        return _long.toInt();
      });
    }
    function encode42(hrp, data, enc) {
      var checkSum = createChecksum(hrp, data, enc);
      var combined = Array.from(data).concat(checkSum);
      var ret = hrp + "1";
      for (var p = 0; p < combined.length; ++p) {
        ret += CHARSET.charAt(combined[p]);
      }
      return ret;
    }
    function decode44(blechString, enc) {
      var has_lower = false;
      var has_upper = false;
      for (var p = 0; p < blechString.length; ++p) {
        if (blechString.charCodeAt(p) < 33 || blechString.charCodeAt(p) > 126) {
          throw new Error("Invalid charcode in blech32 string");
        }
        if (blechString.charCodeAt(p) >= 97 && blechString.charCodeAt(p) <= 122) {
          has_lower = true;
        }
        if (blechString.charCodeAt(p) >= 65 && blechString.charCodeAt(p) <= 90) {
          has_upper = true;
        }
      }
      if (has_lower && has_upper) {
        throw new Error("blech32 has lowercases AND uppercases");
      }
      blechString = blechString.toLowerCase();
      var pos = blechString.lastIndexOf("1");
      if (pos < 1 || pos + 13 > blechString.length) {
        throw new Error('Invalid index of "1"');
      }
      var hrp = blechString.substring(0, pos);
      var data = [];
      for (var _p2 = pos + 1; _p2 < blechString.length; ++_p2) {
        var d = CHARSET.indexOf(blechString.charAt(_p2));
        if (d === -1) {
          throw new Error('"' + blechString.charAt(_p2) + '" is not allowed in blech32 strings');
        }
        data.push(d);
      }
      if (!verifyChecksum(hrp, data, enc)) {
        throw new Error("invalid " + enc + ' checksum "' + blechString + '"');
      }
      return {
        hrp,
        data: Uint8Array.from(data.slice(0, data.length - 12))
      };
    }
    function encodeAddress(_ref) {
      var witness = _ref.witness, witnessVersion = _ref.witnessVersion, blindingPublicKey = _ref.blindingPublicKey, hrp = _ref.hrp;
      validateWitnessVersion(witnessVersion);
      var witnessProgram = import_buffer.Buffer.concat([import_buffer.Buffer.from(blindingPublicKey, "hex"), import_buffer.Buffer.from(witness, "hex")]);
      var witnessProgLength = witnessProgram.length;
      if (witnessVersion === 0 && witnessProgLength !== 53 && witnessProgLength !== 65) throw new Error("witness version 0 needs witness program length = 53 OR = 65");
      if (witnessProgLength < 2 || witnessProgLength > 65) throw new Error("witness program length should be >= 2 and <= 65");
      var data = [witnessVersion].concat(convertBits(Array.from(witnessProgram), 8, 5, true));
      return encode42(hrp, Uint8Array.from(data), getEncodingType(data[0]));
    }
    function decodeAddress(addr, enc) {
      var _decode = decode44(addr, enc), hrp = _decode.hrp, data = _decode.data;
      var witnessVersion = data[0];
      validateWitnessVersion(witnessVersion);
      if (data.length === 0 || data.length > MAX_LEN) throw new Error("Invalid data length");
      var witnessProgram = convertBits(Array.from(data.slice(1)), 5, 8, false);
      if (witnessProgram.length < 2 || witnessProgram.length > 65) throw new Error("Invalid witness data length");
      if (data[0] === 0 && witnessProgram.length !== 53 && witnessProgram.length !== 65) throw new Error("Invalid witness data length for witness version 0");
      var blindingPublicKey = import_buffer.Buffer.from(witnessProgram.slice(0, 33)).toString("hex");
      var witness = import_buffer.Buffer.from(witnessProgram.slice(33)).toString("hex");
      return {
        witness,
        blindingPublicKey,
        witnessVersion,
        hrp
      };
    }
    var Blech32Address = /* @__PURE__ */ (function() {
      function Blech32Address2(data) {
        this.witness = data.witness;
        this.blindingPublicKey = data.blindingPublicKey;
        this.witnessVersion = data.witnessVersion;
        this.address = encodeAddress(data);
      }
      Blech32Address2.from = function from7(witness, blindingPublicKey, hrp, witnessVersion) {
        return new Blech32Address2({
          witness,
          witnessVersion,
          blindingPublicKey,
          hrp
        });
      };
      Blech32Address2.fromString = function fromString8(blechString, encodingType) {
        return new Blech32Address2(decodeAddress(blechString, encodingType));
      };
      return Blech32Address2;
    })();
    exports2.BLECH32 = BLECH32;
    exports2.BLECH32M = BLECH32M;
    exports2.Blech32Address = Blech32Address;
    exports2.MAX_LEN = MAX_LEN;
    exports2.decode = decode44;
    exports2.encode = encode42;
    exports2.getEncodingType = getEncodingType;
  }
});

// node_modules/.pnpm/blech32@1.1.2/node_modules/blech32/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/.pnpm/blech32@1.1.2/node_modules/blech32/dist/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_blech32_cjs_development();
    }
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/address.js
var require_address = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/address.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getScriptType = exports2.isConfidential = exports2.decodeType = exports2.getNetwork = exports2.toOutputScript = exports2.fromOutputScript = exports2.toConfidential = exports2.toBlech32 = exports2.toBech32 = exports2.toBase58Check = exports2.fromConfidential = exports2.fromBlech32 = exports2.fromBech32 = exports2.fromBase58Check = exports2.ScriptType = exports2.AddressType = void 0;
    var networks2 = __importStar(require_networks());
    var payments = __importStar(require_payments());
    var bscript = __importStar(require_script());
    var types = __importStar(require_types2());
    var blech32_1 = require_dist2();
    var bech32_1 = require_dist();
    var bs58check2 = __importStar(require_bs58check());
    var ops_1 = require_ops();
    var { typeforce } = types;
    var FUTURE_SEGWIT_MAX_SIZE = 40;
    var FUTURE_SEGWIT_MIN_SIZE = 2;
    var FUTURE_SEGWIT_MAX_VERSION = 16;
    var FUTURE_SEGWIT_MIN_VERSION = 1;
    var FUTURE_SEGWIT_VERSION_DIFF = 80;
    function _toFutureSegwitAddress(output, network) {
      const data = output.slice(2);
      if (data.length < FUTURE_SEGWIT_MIN_SIZE || data.length > FUTURE_SEGWIT_MAX_SIZE)
        throw new TypeError("Invalid program length for segwit address");
      const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;
      if (version < FUTURE_SEGWIT_MIN_VERSION || version > FUTURE_SEGWIT_MAX_VERSION)
        throw new TypeError("Invalid version for segwit address");
      if (output[1] !== data.length)
        throw new TypeError("Invalid script for segwit address");
      return toBech32(data, version, network.bech32);
    }
    var AddressType2;
    (function(AddressType3) {
      AddressType3[AddressType3["P2Pkh"] = 0] = "P2Pkh";
      AddressType3[AddressType3["P2Sh"] = 1] = "P2Sh";
      AddressType3[AddressType3["P2Wpkh"] = 2] = "P2Wpkh";
      AddressType3[AddressType3["P2Wsh"] = 3] = "P2Wsh";
      AddressType3[AddressType3["ConfidentialP2Pkh"] = 4] = "ConfidentialP2Pkh";
      AddressType3[AddressType3["ConfidentialP2Sh"] = 5] = "ConfidentialP2Sh";
      AddressType3[AddressType3["ConfidentialP2Wpkh"] = 6] = "ConfidentialP2Wpkh";
      AddressType3[AddressType3["ConfidentialP2Wsh"] = 7] = "ConfidentialP2Wsh";
    })(AddressType2 = exports2.AddressType || (exports2.AddressType = {}));
    var ScriptType;
    (function(ScriptType2) {
      ScriptType2[ScriptType2["P2Pkh"] = 0] = "P2Pkh";
      ScriptType2[ScriptType2["P2Sh"] = 1] = "P2Sh";
      ScriptType2[ScriptType2["P2Wpkh"] = 2] = "P2Wpkh";
      ScriptType2[ScriptType2["P2Wsh"] = 3] = "P2Wsh";
      ScriptType2[ScriptType2["P2Tr"] = 4] = "P2Tr";
    })(ScriptType = exports2.ScriptType || (exports2.ScriptType = {}));
    function isConfidentialAddressType(addressType) {
      return addressType >= 4;
    }
    function fromBase58Check(address) {
      const payload = bs58check2.decode(address);
      if (payload.length < 21) throw new TypeError(address + " is too short");
      if (payload.length > 21) throw new TypeError(address + " is too long");
      const version = payload.readUInt8(0);
      const hash = payload.slice(1);
      return { version, hash };
    }
    exports2.fromBase58Check = fromBase58Check;
    function fromBech322(address) {
      let result;
      let version;
      try {
        result = bech32_1.bech32.decode(address);
      } catch (e) {
      }
      if (result) {
        version = result.words[0];
        if (version !== 0) throw new TypeError(address + " uses wrong encoding");
      } else {
        result = bech32_1.bech32m.decode(address);
        version = result.words[0];
        if (version === 0) throw new TypeError(address + " uses wrong encoding");
      }
      const data = bech32_1.bech32.fromWords(result.words.slice(1));
      return {
        version,
        prefix: result.prefix,
        data: import_buffer.Buffer.from(data)
      };
    }
    exports2.fromBech32 = fromBech322;
    function fromBlech32(address) {
      let result;
      try {
        result = blech32_1.Blech32Address.fromString(address, blech32_1.BLECH32);
      } catch {
        result = blech32_1.Blech32Address.fromString(address, blech32_1.BLECH32M);
      }
      const pubkey = import_buffer.Buffer.from(result.blindingPublicKey, "hex");
      const prg = import_buffer.Buffer.from(result.witness, "hex");
      const data = import_buffer.Buffer.concat([
        import_buffer.Buffer.from([
          result.witnessVersion ? result.witnessVersion + FUTURE_SEGWIT_VERSION_DIFF : result.witnessVersion,
          prg.length
        ]),
        prg
      ]);
      return {
        version: result.witnessVersion,
        pubkey,
        data
      };
    }
    exports2.fromBlech32 = fromBlech32;
    function fromConfidential(address) {
      const network = getNetwork(address);
      if (address.startsWith(network.blech32))
        return fromConfidentialSegwit(address, network);
      return fromConfidentialLegacy(address, network);
    }
    exports2.fromConfidential = fromConfidential;
    function toBase58Check(hash, version) {
      typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);
      const payload = import_buffer.Buffer.allocUnsafe(21);
      payload.writeUInt8(version, 0);
      hash.copy(payload, 1);
      return bs58check2.encode(payload);
    }
    exports2.toBase58Check = toBase58Check;
    function toBech32(data, version, prefix) {
      const words = bech32_1.bech32.toWords(data);
      words.unshift(version);
      return version === 0 ? bech32_1.bech32.encode(prefix, words) : bech32_1.bech32m.encode(prefix, words);
    }
    exports2.toBech32 = toBech32;
    function toBlech32(data, pubkey, prefix, witnessVersion) {
      return blech32_1.Blech32Address.from(
        data.slice(2).toString("hex"),
        pubkey.toString("hex"),
        prefix,
        witnessVersion
      ).address;
    }
    exports2.toBlech32 = toBlech32;
    function toConfidential(address, blindingKey) {
      const network = getNetwork(address);
      if (address.startsWith(network.bech32))
        return toConfidentialSegwit(address, blindingKey, network);
      return toConfidentialLegacy(address, blindingKey, network);
    }
    exports2.toConfidential = toConfidential;
    function fromOutputScript2(output, network) {
      network = network || networks2.liquid;
      try {
        return payments.p2pkh({ output, network }).address;
      } catch (e) {
      }
      try {
        return payments.p2sh({ output, network }).address;
      } catch (e) {
      }
      try {
        return payments.p2wpkh({ output, network }).address;
      } catch (e) {
      }
      try {
        return payments.p2wsh({ output, network }).address;
      } catch (e) {
      }
      try {
        return _toFutureSegwitAddress(output, network);
      } catch (e) {
      }
      throw new Error(bscript.toASM(output) + " has no matching Address");
    }
    exports2.fromOutputScript = fromOutputScript2;
    function toOutputScript2(address, network) {
      network = network || getNetwork(address);
      let decodedBase58;
      let decodedBech32;
      let decodedConfidential;
      try {
        decodedBase58 = fromBase58Check(address);
      } catch (e) {
      }
      if (decodedBase58) {
        if (decodedBase58.version === network.pubKeyHash)
          return payments.p2pkh({ hash: decodedBase58.hash }).output;
        if (decodedBase58.version === network.scriptHash)
          return payments.p2sh({ hash: decodedBase58.hash }).output;
      } else {
        try {
          decodedBech32 = fromBech322(address);
        } catch (e) {
        }
        if (decodedBech32) {
          if (decodedBech32.prefix !== network.bech32)
            throw new Error(address + " has an invalid prefix");
          if (decodedBech32.version === 0) {
            if (decodedBech32.data.length === 20)
              return payments.p2wpkh({ hash: decodedBech32.data }).output;
            if (decodedBech32.data.length === 32)
              return payments.p2wsh({ hash: decodedBech32.data }).output;
          } else if (decodedBech32.version >= FUTURE_SEGWIT_MIN_VERSION && decodedBech32.version <= FUTURE_SEGWIT_MAX_VERSION && decodedBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE && decodedBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE) {
            return bscript.compile([
              decodedBech32.version + FUTURE_SEGWIT_VERSION_DIFF,
              decodedBech32.data
            ]);
          }
        } else {
          try {
            decodedConfidential = fromConfidential(address);
          } catch (e) {
          }
          if (decodedConfidential) {
            return toOutputScript2(
              decodedConfidential.unconfidentialAddress,
              network
            );
          }
        }
      }
      throw new Error(address + " has no matching Script");
    }
    exports2.toOutputScript = toOutputScript2;
    function isNetwork(network, address) {
      if (address.startsWith(network.blech32) || address.startsWith(network.bech32))
        return true;
      try {
        const payload = bs58check2.decode(address);
        const prefix = payload.readUInt8(0);
        if (prefix === network.confidentialPrefix || prefix === network.pubKeyHash || prefix === network.scriptHash)
          return true;
      } catch {
        return false;
      }
      return false;
    }
    function getNetwork(address) {
      const allNetworks = [networks2.liquid, networks2.regtest, networks2.testnet];
      for (const network of allNetworks) {
        if (isNetwork(network, address)) return network;
      }
      throw new Error(address + " has an invalid prefix");
    }
    exports2.getNetwork = getNetwork;
    function fromConfidentialLegacy(address, network) {
      const payload = bs58check2.decode(address);
      const prefix = payload.readUInt8(1);
      if (prefix !== network.pubKeyHash && prefix !== network.scriptHash)
        throw new TypeError(address + "is not valid");
      if (payload.length < 55) throw new TypeError(address + " is too short");
      if (payload.length > 55) throw new TypeError(address + " is too long");
      const blindingKey = payload.slice(2, 35);
      const scriptHash = payload.slice(35, payload.length);
      const versionBuf = import_buffer.Buffer.of(prefix);
      const scriptHashWithNetworkPrefix = import_buffer.Buffer.concat([versionBuf, scriptHash]);
      const unconfidentialAddress = bs58check2.encode(scriptHashWithNetworkPrefix);
      const script = toOutputScript2(unconfidentialAddress);
      return { blindingKey, unconfidentialAddress, scriptPubKey: script };
    }
    function fromConfidentialSegwit(address, network) {
      const result = fromBlech32(address);
      const unconfidentialAddress = fromOutputScript2(result.data, network);
      return {
        blindingKey: result.pubkey,
        unconfidentialAddress,
        scriptPubKey: result.data
      };
    }
    function toConfidentialLegacy(address, blindingKey, network) {
      const payload = bs58check2.decode(address);
      const prefix = payload.readUInt8(0);
      if (payload.length !== 21 || prefix !== network.pubKeyHash && prefix !== network.scriptHash)
        throw new TypeError(address + "is not valid");
      if (blindingKey.length < 33) throw new TypeError("Blinding key is too short");
      if (blindingKey.length > 33) throw new TypeError("Blinding key is too long");
      const prefixBuf = import_buffer.Buffer.alloc(2);
      prefixBuf[0] = network.confidentialPrefix;
      prefixBuf[1] = prefix;
      const confidentialAddress = import_buffer.Buffer.concat([
        prefixBuf,
        blindingKey,
        import_buffer.Buffer.from(payload.slice(1))
      ]);
      return bs58check2.encode(confidentialAddress);
    }
    function toConfidentialSegwit(address, blindingKey, network) {
      const data = toOutputScript2(address, network);
      const version = fromBech322(address).version;
      return toBlech32(data, blindingKey, network.blech32, version);
    }
    function isBlech32(address, network) {
      return address.startsWith(network.blech32);
    }
    function decodeBlech32(address) {
      const blech32addr = fromBlech32(address);
      switch (blech32addr.data.length - 2) {
        case 20:
          return AddressType2.ConfidentialP2Wpkh;
        case 32:
          return AddressType2.ConfidentialP2Wsh;
        default:
          throw new Error(
            `invalid blech32 program length: ${blech32addr.data.length - 2}`
          );
      }
    }
    function isBech32(address, network) {
      return address.startsWith(network.bech32);
    }
    function decodeBech32(address) {
      const bech32addr = fromBech322(address);
      switch (bech32addr.data.length) {
        case 20:
          return AddressType2.P2Wpkh;
        case 32:
          return AddressType2.P2Wsh;
        default:
          throw new Error("invalid program length");
      }
    }
    function UnkownPrefixError(prefix, network) {
      return new Error(
        `unknown address prefix (${prefix}), need ${network.pubKeyHash} or ${network.scriptHash}`
      );
    }
    function decodeBase58(address, network) {
      const payload = bs58check2.decode(address);
      if (payload.readUInt8(0) === network.confidentialPrefix) {
        const unconfidentialPart = payload.slice(35);
        if (unconfidentialPart.length !== 20) {
          throw new Error("decoded address is of unknown size");
        }
        const addrPrefix = payload.readUInt8(1);
        switch (addrPrefix) {
          case network.pubKeyHash:
            return AddressType2.ConfidentialP2Pkh;
          case network.scriptHash:
            return AddressType2.ConfidentialP2Sh;
          default:
            throw UnkownPrefixError(addrPrefix, network);
        }
      }
      const prefix = payload.readUInt8(0);
      const unconfidential = payload.slice(1);
      if (unconfidential.length !== 20) {
        throw new Error("decoded address is of unknown size");
      }
      switch (prefix) {
        case network.pubKeyHash:
          return AddressType2.P2Pkh;
        case network.scriptHash:
          return AddressType2.P2Sh;
        default:
          throw UnkownPrefixError(prefix, network);
      }
    }
    function decodeType(address, network) {
      network = network || getNetwork(address);
      if (isBech32(address, network)) {
        return decodeBech32(address);
      }
      if (isBlech32(address, network)) {
        return decodeBlech32(address);
      }
      return decodeBase58(address, network);
    }
    exports2.decodeType = decodeType;
    function isConfidential(address) {
      const type = decodeType(address);
      return isConfidentialAddressType(type);
    }
    exports2.isConfidential = isConfidential;
    function getScriptType(script) {
      switch (script[0]) {
        case ops_1.OPS.OP_0:
          if (script.slice(2).length === 20) {
            return ScriptType.P2Wpkh;
          }
          return ScriptType.P2Wsh;
        case ops_1.OPS.OP_HASH160:
          return ScriptType.P2Sh;
        case ops_1.OPS.OP_DUP:
          return ScriptType.P2Pkh;
        case ops_1.OPS.OP_1:
          return ScriptType.P2Tr;
        default:
          throw new Error("unknow script type");
      }
    }
    exports2.getScriptType = getScriptType;
  }
});

// node_modules/.pnpm/varuint-bitcoin@1.1.2/node_modules/varuint-bitcoin/index.js
var require_varuint_bitcoin = __commonJS({
  "node_modules/.pnpm/varuint-bitcoin@1.1.2/node_modules/varuint-bitcoin/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var Buffer5 = require_safe_buffer().Buffer;
    var MAX_SAFE_INTEGER = 9007199254740991;
    function checkUInt532(n2) {
      if (n2 < 0 || n2 > MAX_SAFE_INTEGER || n2 % 1 !== 0) throw new RangeError("value out of range");
    }
    function encode42(number3, buffer2, offset) {
      checkUInt532(number3);
      if (!buffer2) buffer2 = Buffer5.allocUnsafe(encodingLength7(number3));
      if (!Buffer5.isBuffer(buffer2)) throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      if (number3 < 253) {
        buffer2.writeUInt8(number3, offset);
        encode42.bytes = 1;
      } else if (number3 <= 65535) {
        buffer2.writeUInt8(253, offset);
        buffer2.writeUInt16LE(number3, offset + 1);
        encode42.bytes = 3;
      } else if (number3 <= 4294967295) {
        buffer2.writeUInt8(254, offset);
        buffer2.writeUInt32LE(number3, offset + 1);
        encode42.bytes = 5;
      } else {
        buffer2.writeUInt8(255, offset);
        buffer2.writeUInt32LE(number3 >>> 0, offset + 1);
        buffer2.writeUInt32LE(number3 / 4294967296 | 0, offset + 5);
        encode42.bytes = 9;
      }
      return buffer2;
    }
    function decode44(buffer2, offset) {
      if (!Buffer5.isBuffer(buffer2)) throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      var first2 = buffer2.readUInt8(offset);
      if (first2 < 253) {
        decode44.bytes = 1;
        return first2;
      } else if (first2 === 253) {
        decode44.bytes = 3;
        return buffer2.readUInt16LE(offset + 1);
      } else if (first2 === 254) {
        decode44.bytes = 5;
        return buffer2.readUInt32LE(offset + 1);
      } else {
        decode44.bytes = 9;
        var lo = buffer2.readUInt32LE(offset + 1);
        var hi = buffer2.readUInt32LE(offset + 5);
        var number3 = hi * 4294967296 + lo;
        checkUInt532(number3);
        return number3;
      }
    }
    function encodingLength7(number3) {
      checkUInt532(number3);
      return number3 < 253 ? 1 : number3 <= 65535 ? 3 : number3 <= 4294967295 ? 5 : 9;
    }
    module2.exports = { encode: encode42, decode: decode44, encodingLength: encodingLength7 };
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/bufferutils.js
var require_bufferutils = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/bufferutils.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BufferReader = exports2.BufferWriter = exports2.cloneBuffer = exports2.reverseBuffer = exports2.writeUInt64LE = exports2.readUInt64LE = exports2.varSliceSize = exports2.varuint = void 0;
    var types = __importStar(require_types2());
    var { typeforce } = types;
    var varuint = __importStar(require_varuint_bitcoin());
    exports2.varuint = varuint;
    var CONFIDENTIAL_COMMITMENT = 33;
    var CONFIDENTIAL_VALUE = 9;
    function verifuint(value2, max) {
      if (typeof value2 !== "number")
        throw new Error("cannot write a non-number as a number");
      if (value2 < 0)
        throw new Error("specified a negative value for writing an unsigned value");
      if (value2 > max) throw new Error("RangeError: value out of range");
      if (Math.floor(value2) !== value2)
        throw new Error("value has a fractional component");
    }
    function varSliceSize(someScript) {
      const length6 = someScript.length;
      return varuint.encodingLength(length6) + length6;
    }
    exports2.varSliceSize = varSliceSize;
    function readUInt64LE(buffer2, offset) {
      const a = buffer2.readUInt32LE(offset);
      let b = buffer2.readUInt32LE(offset + 4);
      b *= 4294967296;
      verifuint(b + a, 18446744073709552e3);
      return b + a;
    }
    exports2.readUInt64LE = readUInt64LE;
    function writeUInt64LE(buffer2, value2, offset) {
      verifuint(value2, 18446744073709552e3);
      buffer2.writeInt32LE(value2 & -1, offset);
      buffer2.writeUInt32LE(Math.floor(value2 / 4294967296), offset + 4);
      return offset + 8;
    }
    exports2.writeUInt64LE = writeUInt64LE;
    function reverseBuffer2(buffer2) {
      if (buffer2.length < 1) return buffer2;
      let j = buffer2.length - 1;
      let tmp = 0;
      for (let i = 0; i < buffer2.length / 2; i++) {
        tmp = buffer2[i];
        buffer2[i] = buffer2[j];
        buffer2[j] = tmp;
        j--;
      }
      return buffer2;
    }
    exports2.reverseBuffer = reverseBuffer2;
    function cloneBuffer2(buffer2) {
      const clone = import_buffer.Buffer.allocUnsafe(buffer2.length);
      buffer2.copy(clone);
      return clone;
    }
    exports2.cloneBuffer = cloneBuffer2;
    var BufferWriter2 = class _BufferWriter {
      constructor(buffer2, offset = 0) {
        this.buffer = buffer2;
        this.offset = offset;
        typeforce(types.tuple(types.Buffer, types.UInt32), [buffer2, offset]);
      }
      static withCapacity(size) {
        return new _BufferWriter(import_buffer.Buffer.alloc(size));
      }
      writeUInt8(i) {
        this.offset = this.buffer.writeUInt8(i, this.offset);
      }
      writeInt32(i) {
        this.offset = this.buffer.writeInt32LE(i, this.offset);
      }
      writeUInt32(i) {
        this.offset = this.buffer.writeUInt32LE(i, this.offset);
      }
      writeUInt64(i) {
        this.offset = writeUInt64LE(this.buffer, i, this.offset);
      }
      writeVarInt(i) {
        varuint.encode(i, this.buffer, this.offset);
        this.offset += varuint.encode.bytes;
      }
      writeSlice(slice2) {
        if (this.buffer.length < this.offset + slice2.length) {
          throw new Error("Cannot write slice out of bounds");
        }
        this.offset += slice2.copy(this.buffer, this.offset);
      }
      writeVarSlice(slice2) {
        this.writeVarInt(slice2.length);
        this.writeSlice(slice2);
      }
      writeVector(vector) {
        this.writeVarInt(vector.length);
        vector.forEach((buf2) => this.writeVarSlice(buf2));
      }
      writeConfidentialInFields(input) {
        this.writeVarSlice(input.issuanceRangeProof || import_buffer.Buffer.alloc(0));
        this.writeVarSlice(input.inflationRangeProof || import_buffer.Buffer.alloc(0));
        this.writeVector(input.witness);
        this.writeVector(input.peginWitness || []);
      }
      writeConfidentialOutFields(output) {
        this.writeVarSlice(output.surjectionProof || import_buffer.Buffer.alloc(0));
        this.writeVarSlice(output.rangeProof || import_buffer.Buffer.alloc(0));
      }
      end() {
        if (this.buffer.length === this.offset) {
          return this.buffer;
        }
        throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
      }
    };
    exports2.BufferWriter = BufferWriter2;
    var BufferReader2 = class {
      constructor(buffer2, offset = 0) {
        this.buffer = buffer2;
        this.offset = offset;
        typeforce(types.tuple(types.Buffer, types.UInt32), [buffer2, offset]);
      }
      readUInt8() {
        const result = this.buffer.readUInt8(this.offset);
        this.offset++;
        return result;
      }
      readInt32() {
        const result = this.buffer.readInt32LE(this.offset);
        this.offset += 4;
        return result;
      }
      readUInt32() {
        const result = this.buffer.readUInt32LE(this.offset);
        this.offset += 4;
        return result;
      }
      readUInt64() {
        const result = readUInt64LE(this.buffer, this.offset);
        this.offset += 8;
        return result;
      }
      readVarInt() {
        const vi = varuint.decode(this.buffer, this.offset);
        this.offset += varuint.decode.bytes;
        return vi;
      }
      readSlice(n2) {
        if (this.buffer.length < this.offset + n2) {
          throw new Error("Cannot read slice out of bounds");
        }
        const result = this.buffer.slice(this.offset, this.offset + n2);
        this.offset += n2;
        return result;
      }
      readVarSlice() {
        return this.readSlice(this.readVarInt());
      }
      readVector() {
        const count = this.readVarInt();
        const vector = [];
        for (let i = 0; i < count; i++) vector.push(this.readVarSlice());
        return vector;
      }
      // CConfidentialAsset size 33, prefixA 10, prefixB 11
      readConfidentialAsset() {
        const version = this.readUInt8();
        const versionBuffer = this.buffer.slice(this.offset - 1, this.offset);
        if (version === 1 || version === 255)
          return import_buffer.Buffer.concat([
            versionBuffer,
            this.readSlice(CONFIDENTIAL_COMMITMENT - 1)
          ]);
        else if (version === 10 || version === 11)
          return import_buffer.Buffer.concat([
            versionBuffer,
            this.readSlice(CONFIDENTIAL_COMMITMENT - 1)
          ]);
        return versionBuffer;
      }
      // CConfidentialNonce size 33, prefixA 2, prefixB 3
      readConfidentialNonce() {
        const version = this.readUInt8();
        const versionBuffer = this.buffer.slice(this.offset - 1, this.offset);
        if (version === 1 || version === 255)
          return import_buffer.Buffer.concat([
            versionBuffer,
            this.readSlice(CONFIDENTIAL_COMMITMENT - 1)
          ]);
        else if (version === 2 || version === 3)
          return import_buffer.Buffer.concat([
            versionBuffer,
            this.readSlice(CONFIDENTIAL_COMMITMENT - 1)
          ]);
        return versionBuffer;
      }
      // CConfidentialValue size 9, prefixA 8, prefixB 9
      readConfidentialValue() {
        const version = this.readUInt8();
        const versionBuffer = this.buffer.slice(this.offset - 1, this.offset);
        if (version === 1 || version === 255)
          return import_buffer.Buffer.concat([
            versionBuffer,
            this.readSlice(CONFIDENTIAL_VALUE - 1)
          ]);
        else if (version === 8 || version === 9)
          return import_buffer.Buffer.concat([
            versionBuffer,
            this.readSlice(CONFIDENTIAL_COMMITMENT - 1)
          ]);
        return versionBuffer;
      }
      readConfidentialInFields() {
        const issuanceRangeProof = this.readVarSlice();
        const inflationRangeProof = this.readVarSlice();
        const witness = this.readVector();
        const peginWitness = this.readVector();
        return {
          issuanceRangeProof,
          inflationRangeProof,
          witness,
          peginWitness
        };
      }
      readConfidentialOutFields() {
        const surjectionProof = this.readVarSlice();
        const rangeProof = this.readVarSlice();
        return { surjectionProof, rangeProof };
      }
      readIssuance() {
        const issuanceNonce = this.readSlice(32);
        const issuanceEntropy = this.readSlice(32);
        const amount = this.readConfidentialValue();
        const inflation = this.readConfidentialValue();
        return {
          assetBlindingNonce: issuanceNonce,
          assetEntropy: issuanceEntropy,
          assetAmount: amount,
          tokenAmount: inflation
        };
      }
    };
    exports2.BufferReader = BufferReader2;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/sha256d.js
var require_sha256d = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/sha256d.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha256Midstate = exports2.hash = exports2.Hash = exports2.blockSize = exports2.digestLength = void 0;
    exports2.digestLength = 32;
    exports2.blockSize = 64;
    var K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    function hashBlocks(w, v, p, pos, len) {
      let a;
      let b;
      let c;
      let d;
      let e;
      let f;
      let g;
      let h3;
      let u;
      let i;
      let j;
      let t1;
      let t2;
      while (len >= 64) {
        a = v[0];
        b = v[1];
        c = v[2];
        d = v[3];
        e = v[4];
        f = v[5];
        g = v[6];
        h3 = v[7];
        for (i = 0; i < 16; i++) {
          j = pos + i * 4;
          w[i] = (p[j] & 255) << 24 | (p[j + 1] & 255) << 16 | (p[j + 2] & 255) << 8 | p[j + 3] & 255;
        }
        for (i = 16; i < 64; i++) {
          u = w[i - 2];
          t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
          u = w[i - 15];
          t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
          w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
        }
        for (i = 0; i < 64; i++) {
          t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h3 + (K[i] + w[i] | 0) | 0) | 0;
          t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
          h3 = g;
          g = f;
          f = e;
          e = d + t1 | 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 | 0;
        }
        v[0] += a;
        v[1] += b;
        v[2] += c;
        v[3] += d;
        v[4] += e;
        v[5] += f;
        v[6] += g;
        v[7] += h3;
        pos += 64;
        len -= 64;
      }
      return pos;
    }
    var Hash2 = class {
      constructor() {
        this.digestLength = exports2.digestLength;
        this.blockSize = exports2.blockSize;
        this.finished = false;
        this.state = new Int32Array(8);
        this.temp = new Int32Array(64);
        this.buffer = new Uint8Array(128);
        this.bufferLength = 0;
        this.bytesHashed = 0;
        this.reset();
      }
      // Resets hash state making it possible
      // to re-use this instance to hash other data.
      reset() {
        this.state[0] = 1779033703;
        this.state[1] = 3144134277;
        this.state[2] = 1013904242;
        this.state[3] = 2773480762;
        this.state[4] = 1359893119;
        this.state[5] = 2600822924;
        this.state[6] = 528734635;
        this.state[7] = 1541459225;
        this.bufferLength = 0;
        this.bytesHashed = 0;
        this.finished = false;
        return this;
      }
      // Cleans internal buffers and re-initializes hash state.
      clean() {
        for (let i = 0; i < this.buffer.length; i++) {
          this.buffer[i] = 0;
        }
        for (let i = 0; i < this.temp.length; i++) {
          this.temp[i] = 0;
        }
        this.reset();
      }
      // Updates hash state with the given data.
      //
      // Optionally, length of the data can be specified to hash
      // fewer bytes than data.length.
      //
      // Throws error when trying to update already finalized hash:
      // instance must be reset to use it again.
      update(data, dataLength = data.length) {
        if (this.finished) {
          throw new Error("SHA256: can't update because hash was finished.");
        }
        let dataPos = 0;
        this.bytesHashed += dataLength;
        if (this.bufferLength > 0) {
          while (this.bufferLength < 64 && dataLength > 0) {
            this.buffer[this.bufferLength++] = data[dataPos++];
            dataLength--;
          }
          if (this.bufferLength === 64) {
            hashBlocks(this.temp, this.state, this.buffer, 0, 64);
            this.bufferLength = 0;
          }
        }
        if (dataLength >= 64) {
          dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);
          dataLength %= 64;
        }
        while (dataLength > 0) {
          this.buffer[this.bufferLength++] = data[dataPos++];
          dataLength--;
        }
        return this;
      }
      // Finalizes hash state and puts hash into out.
      //
      // If hash was already finalized, puts the same value.
      finish(out) {
        if (!this.finished) {
          const bytesHashed = this.bytesHashed;
          const left = this.bufferLength;
          const bitLenHi = bytesHashed / 536870912 | 0;
          const bitLenLo = bytesHashed << 3;
          const padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this.buffer[left] = 128;
          for (let i = left + 1; i < padLength - 8; i++) {
            this.buffer[i] = 0;
          }
          this.buffer[padLength - 8] = bitLenHi >>> 24 & 255;
          this.buffer[padLength - 7] = bitLenHi >>> 16 & 255;
          this.buffer[padLength - 6] = bitLenHi >>> 8 & 255;
          this.buffer[padLength - 5] = bitLenHi >>> 0 & 255;
          this.buffer[padLength - 4] = bitLenLo >>> 24 & 255;
          this.buffer[padLength - 3] = bitLenLo >>> 16 & 255;
          this.buffer[padLength - 2] = bitLenLo >>> 8 & 255;
          this.buffer[padLength - 1] = bitLenLo >>> 0 & 255;
          hashBlocks(this.temp, this.state, this.buffer, 0, padLength);
          this.finished = true;
        }
        for (let i = 0; i < 8; i++) {
          out[i * 4 + 0] = this.state[i] >>> 24 & 255;
          out[i * 4 + 1] = this.state[i] >>> 16 & 255;
          out[i * 4 + 2] = this.state[i] >>> 8 & 255;
          out[i * 4 + 3] = this.state[i] >>> 0 & 255;
        }
        return this;
      }
      // Returns the final hash digest.
      digest() {
        const out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      }
      // Internal function for use in HMAC for optimization.
      _saveState(out) {
        for (let i = 0; i < this.state.length; i++) {
          out[i] = this.state[i];
        }
      }
      // Internal function for use in HMAC for optimization.
      _restoreState(from7, bytesHashed) {
        for (let i = 0; i < this.state.length; i++) {
          this.state[i] = from7[i];
        }
        this.bytesHashed = bytesHashed;
        this.finished = false;
        this.bufferLength = 0;
      }
    };
    exports2.Hash = Hash2;
    function hash(data) {
      const h3 = new Hash2().update(data);
      const digest4 = h3.digest();
      h3.clean();
      return digest4;
    }
    exports2.hash = hash;
    function sha256Midstate(data) {
      let d = data;
      if (data.length > exports2.blockSize) {
        d = data.slice(0, exports2.blockSize);
      }
      const h3 = new Hash2();
      h3.reset();
      h3.update(Uint8Array.from(d));
      const midstate = import_buffer.Buffer.alloc(exports2.digestLength);
      for (let i = 0; i < 8; i++) {
        midstate[i * 4 + 0] = h3.state[i] >>> 24 & 255;
        midstate[i * 4 + 1] = h3.state[i] >>> 16 & 255;
        midstate[i * 4 + 2] = h3.state[i] >>> 8 & 255;
        midstate[i * 4 + 3] = h3.state[i] >>> 0 & 255;
      }
      return midstate;
    }
    exports2.sha256Midstate = sha256Midstate;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/value.js
var require_value = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/value.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ElementsValue = void 0;
    var bufferutils_1 = require_bufferutils();
    var ElementsValue = class _ElementsValue {
      constructor(prefix, value2) {
        this.prefix = prefix;
        this.value = value2;
      }
      static fromNumber(num2) {
        if (num2 < 0) {
          throw new Error("Invalid negative number");
        }
        const value2 = import_buffer.Buffer.allocUnsafe(8);
        (0, bufferutils_1.writeUInt64LE)(value2, num2, 0);
        return new _ElementsValue(this.UNCONFIDENTIAL_PREFIX, value2.reverse());
      }
      static fromHex(hex) {
        const bytes = import_buffer.Buffer.from(hex, "hex");
        return this.fromBytes(bytes);
      }
      static fromBytes(bytes) {
        if (bytes.length === 8) {
          return new _ElementsValue(_ElementsValue.UNCONFIDENTIAL_PREFIX, bytes);
        }
        const prefix = bytes.length > 0 ? bytes[0] : 0;
        const value2 = bytes.length > 1 ? bytes.slice(1) : import_buffer.Buffer.alloc(0);
        if (prefix !== _ElementsValue.UNCONFIDENTIAL_PREFIX && !_ElementsValue.CONFIDENTIAL_PREFIXES.includes(prefix)) {
          throw new Error("Invalid value prefix");
        }
        if (prefix === _ElementsValue.UNCONFIDENTIAL_PREFIX && value2.length !== 8) {
          throw new Error("Invalid unconfidential value length");
        }
        if (_ElementsValue.CONFIDENTIAL_PREFIXES.includes(prefix) && value2.length !== 32) {
          throw new Error("Invalid confidential value length");
        }
        return new _ElementsValue(prefix, value2);
      }
      get hex() {
        return import_buffer.Buffer.concat([import_buffer.Buffer.of(this.prefix), this.value]).toString("hex");
      }
      get bytes() {
        return import_buffer.Buffer.concat([import_buffer.Buffer.of(this.prefix), this.value]);
      }
      get number() {
        if (this.prefix !== _ElementsValue.UNCONFIDENTIAL_PREFIX) {
          throw new Error("Invalid value prefix");
        }
        return (0, bufferutils_1.readUInt64LE)(reverseWithoutMutate(this.value), 0);
      }
      get isConfidential() {
        return this.prefix !== _ElementsValue.UNCONFIDENTIAL_PREFIX;
      }
    };
    exports2.ElementsValue = ElementsValue;
    ElementsValue.UNCONFIDENTIAL_PREFIX = 1;
    ElementsValue.CONFIDENTIAL_PREFIXES = [8, 9];
    function reverseWithoutMutate(buf2) {
      return import_buffer.Buffer.from(buf2).reverse();
    }
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/issuance.js
var require_issuance = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/issuance.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.amountWithPrecisionToSatoshis = exports2.calculateReissuanceToken = exports2.calculateAsset = exports2.issuanceEntropyFromInput = exports2.generateEntropy = exports2.isReissuance = exports2.newIssuance = exports2.hashContract = exports2.validateIssuanceContract = exports2.hasTokenAmount = void 0;
    var bufferutils_1 = require_bufferutils();
    var bcrypto = __importStar(require_crypto());
    var sha256d_1 = require_sha256d();
    var value_1 = require_value();
    function hasTokenAmount(issuance) {
      if (issuance.tokenAmount && issuance.tokenAmount.length > 1) return true;
      return false;
    }
    exports2.hasTokenAmount = hasTokenAmount;
    function validateIssuanceContract(contract) {
      const precisionIsValid = contract.precision >= 0 && contract.precision <= 8;
      return precisionIsValid;
    }
    exports2.validateIssuanceContract = validateIssuanceContract;
    function hashContract(contract) {
      if (!validateIssuanceContract(contract))
        throw new Error("Invalid asset contract");
      const sortedKeys = Object.keys(contract).sort();
      const sortedContract = sortedKeys.reduce(
        (obj, key) => ({ ...obj, [key]: contract[key] }),
        {}
      );
      return bcrypto.sha256(import_buffer.Buffer.from(JSON.stringify(sortedContract)));
    }
    exports2.hashContract = hashContract;
    function newIssuance(assetSats, tokenSats, contract) {
      if (assetSats < 0) throw new Error("Invalid asset amount");
      if (tokenSats < 0) throw new Error("Invalid token amount");
      const contractHash = contract ? hashContract(contract) : import_buffer.Buffer.alloc(32);
      const issuanceObject = {
        assetAmount: assetSats === 0 ? import_buffer.Buffer.of(0) : value_1.ElementsValue.fromNumber(assetSats).bytes,
        tokenAmount: tokenSats === 0 ? import_buffer.Buffer.of(0) : value_1.ElementsValue.fromNumber(tokenSats).bytes,
        assetBlindingNonce: import_buffer.Buffer.alloc(32),
        // in case of issuance, the asset entropy = the contract hash.
        assetEntropy: contractHash
      };
      return issuanceObject;
    }
    exports2.newIssuance = newIssuance;
    function isReissuance(issuance) {
      return !issuance.assetBlindingNonce.equals(import_buffer.Buffer.alloc(32));
    }
    exports2.isReissuance = isReissuance;
    function generateEntropy(outPoint, contractHash = import_buffer.Buffer.alloc(32)) {
      if (outPoint.txHash.length !== 32) {
        throw new Error("Invalid txHash length");
      }
      const tBuffer = import_buffer.Buffer.allocUnsafe(36);
      const s = new bufferutils_1.BufferWriter(tBuffer, 0);
      s.writeSlice(outPoint.txHash);
      s.writeInt32(outPoint.vout);
      const prevoutHash = bcrypto.hash256(s.buffer);
      const concatened = import_buffer.Buffer.concat([prevoutHash, contractHash]);
      return (0, sha256d_1.sha256Midstate)(concatened);
    }
    exports2.generateEntropy = generateEntropy;
    function issuanceEntropyFromInput(input) {
      if (!input.issuance) throw new Error("input does not contain issuance data");
      return isReissuance(input.issuance) ? input.issuance.assetEntropy : generateEntropy(
        { txHash: input.hash, vout: input.index },
        input.issuance.assetEntropy
      );
    }
    exports2.issuanceEntropyFromInput = issuanceEntropyFromInput;
    function calculateAsset(entropy) {
      if (entropy.length !== 32) throw new Error("Invalid entropy length");
      const kZero = import_buffer.Buffer.alloc(32);
      return (0, sha256d_1.sha256Midstate)(import_buffer.Buffer.concat([entropy, kZero]));
    }
    exports2.calculateAsset = calculateAsset;
    function calculateReissuanceToken(entropy, confidential = false) {
      if (entropy.length !== 32) throw new Error("Invalid entropy length");
      return (0, sha256d_1.sha256Midstate)(
        import_buffer.Buffer.concat([
          entropy,
          import_buffer.Buffer.of(getTokenFlag(confidential) + 1),
          import_buffer.Buffer.alloc(31)
        ])
      );
    }
    exports2.calculateReissuanceToken = calculateReissuanceToken;
    function getTokenFlag(confidential) {
      if (confidential) return 1;
      return 0;
    }
    function amountWithPrecisionToSatoshis(assetAmount, precision = 8) {
      return Math.pow(10, precision) * assetAmount;
    }
    exports2.amountWithPrecisionToSatoshis = amountWithPrecisionToSatoshis;
  }
});

// node_modules/.pnpm/ecpair@2.1.0/node_modules/ecpair/src/networks.js
var require_networks2 = __commonJS({
  "node_modules/.pnpm/ecpair@2.1.0/node_modules/ecpair/src/networks.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.testnet = exports2.bitcoin = void 0;
    exports2.bitcoin = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "bc",
      bip32: {
        public: 76067358,
        private: 76066276
      },
      pubKeyHash: 0,
      scriptHash: 5,
      wif: 128
    };
    exports2.testnet = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "tb",
      bip32: {
        public: 70617039,
        private: 70615956
      },
      pubKeyHash: 111,
      scriptHash: 196,
      wif: 239
    };
  }
});

// node_modules/.pnpm/ecpair@2.1.0/node_modules/ecpair/src/types.js
var require_types3 = __commonJS({
  "node_modules/.pnpm/ecpair@2.1.0/node_modules/ecpair/src/types.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.maybe = exports2.Boolean = exports2.Array = exports2.Buffer256bit = exports2.Network = exports2.typeforce = void 0;
    exports2.typeforce = require_typeforce();
    exports2.Network = exports2.typeforce.compile({
      messagePrefix: exports2.typeforce.oneOf(
        exports2.typeforce.Buffer,
        exports2.typeforce.String
      ),
      bip32: {
        public: exports2.typeforce.UInt32,
        private: exports2.typeforce.UInt32
      },
      pubKeyHash: exports2.typeforce.UInt8,
      scriptHash: exports2.typeforce.UInt8,
      wif: exports2.typeforce.UInt8
    });
    exports2.Buffer256bit = exports2.typeforce.BufferN(32);
    exports2.Array = exports2.typeforce.Array;
    exports2.Boolean = exports2.typeforce.Boolean;
    exports2.maybe = exports2.typeforce.maybe;
  }
});

// node_modules/.pnpm/wif@2.0.6/node_modules/wif/index.js
var require_wif = __commonJS({
  "node_modules/.pnpm/wif@2.0.6/node_modules/wif/index.js"(exports2, module2) {
    init_buffer_polyfill();
    var bs58check2 = require_bs58check();
    function decodeRaw(buffer2, version) {
      if (version !== void 0 && buffer2[0] !== version) throw new Error("Invalid network version");
      if (buffer2.length === 33) {
        return {
          version: buffer2[0],
          privateKey: buffer2.slice(1, 33),
          compressed: false
        };
      }
      if (buffer2.length !== 34) throw new Error("Invalid WIF length");
      if (buffer2[33] !== 1) throw new Error("Invalid compression flag");
      return {
        version: buffer2[0],
        privateKey: buffer2.slice(1, 33),
        compressed: true
      };
    }
    function encodeRaw2(version, privateKey, compressed) {
      var result = new import_buffer.Buffer(compressed ? 34 : 33);
      result.writeUInt8(version, 0);
      privateKey.copy(result, 1);
      if (compressed) {
        result[33] = 1;
      }
      return result;
    }
    function decode44(string5, version) {
      return decodeRaw(bs58check2.decode(string5), version);
    }
    function encode42(version, privateKey, compressed) {
      if (typeof version === "number") return bs58check2.encode(encodeRaw2(version, privateKey, compressed));
      return bs58check2.encode(
        encodeRaw2(
          version.version,
          version.privateKey,
          version.compressed
        )
      );
    }
    module2.exports = {
      decode: decode44,
      decodeRaw,
      encode: encode42,
      encodeRaw: encodeRaw2
    };
  }
});

// node_modules/.pnpm/ecpair@2.1.0/node_modules/ecpair/src/testecc.js
var require_testecc = __commonJS({
  "node_modules/.pnpm/ecpair@2.1.0/node_modules/ecpair/src/testecc.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.testEcc = void 0;
    var h3 = (hex) => import_buffer.Buffer.from(hex, "hex");
    function testEcc2(ecc2) {
      assert3(
        ecc2.isPoint(
          h3("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
        )
      );
      assert3(
        !ecc2.isPoint(
          h3("030000000000000000000000000000000000000000000000000000000000000005")
        )
      );
      assert3(
        ecc2.isPrivate(
          h3("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
        )
      );
      assert3(
        ecc2.isPrivate(
          h3("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
        )
      );
      assert3(
        !ecc2.isPrivate(
          h3("0000000000000000000000000000000000000000000000000000000000000000")
        )
      );
      assert3(
        !ecc2.isPrivate(
          h3("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
        )
      );
      assert3(
        !ecc2.isPrivate(
          h3("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")
        )
      );
      assert3(
        import_buffer.Buffer.from(
          ecc2.privateAdd(
            h3("0000000000000000000000000000000000000000000000000000000000000001"),
            h3("0000000000000000000000000000000000000000000000000000000000000000")
          )
        ).equals(
          h3("0000000000000000000000000000000000000000000000000000000000000001")
        )
      );
      assert3(
        ecc2.privateAdd(
          h3("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"),
          h3("0000000000000000000000000000000000000000000000000000000000000003")
        ) === null
      );
      assert3(
        import_buffer.Buffer.from(
          ecc2.privateAdd(
            h3("e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500"),
            h3("b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665")
          )
        ).equals(
          h3("9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24")
        )
      );
      assert3(
        import_buffer.Buffer.from(
          ecc2.privateNegate(
            h3("0000000000000000000000000000000000000000000000000000000000000001")
          )
        ).equals(
          h3("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
        )
      );
      assert3(
        import_buffer.Buffer.from(
          ecc2.privateNegate(
            h3("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")
          )
        ).equals(
          h3("0000000000000000000000000000000000000000000000000000000000000003")
        )
      );
      assert3(
        import_buffer.Buffer.from(
          ecc2.privateNegate(
            h3("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
          )
        ).equals(
          h3("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")
        )
      );
      assert3(
        import_buffer.Buffer.from(
          ecc2.pointCompress(
            h3(
              "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
            ),
            true
          )
        ).equals(
          h3("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
        )
      );
      assert3(
        import_buffer.Buffer.from(
          ecc2.pointCompress(
            h3(
              "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
            ),
            false
          )
        ).equals(
          h3(
            "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
          )
        )
      );
      assert3(
        import_buffer.Buffer.from(
          ecc2.pointCompress(
            h3("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
            true
          )
        ).equals(
          h3("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
        )
      );
      assert3(
        import_buffer.Buffer.from(
          ecc2.pointCompress(
            h3("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
            false
          )
        ).equals(
          h3(
            "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
          )
        )
      );
      assert3(
        import_buffer.Buffer.from(
          ecc2.pointFromScalar(
            h3("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
          )
        ).equals(
          h3("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")
        )
      );
      assert3(
        ecc2.xOnlyPointAddTweak(
          h3("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
          h3("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
        ) === null
      );
      let xOnlyRes = ecc2.xOnlyPointAddTweak(
        h3("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"),
        h3("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac")
      );
      assert3(
        import_buffer.Buffer.from(xOnlyRes.xOnlyPubkey).equals(
          h3("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")
        ) && xOnlyRes.parity === 1
      );
      xOnlyRes = ecc2.xOnlyPointAddTweak(
        h3("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"),
        h3("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47")
      );
      assert3(
        import_buffer.Buffer.from(xOnlyRes.xOnlyPubkey).equals(
          h3("9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c")
        ) && xOnlyRes.parity === 0
      );
      assert3(
        import_buffer.Buffer.from(
          ecc2.sign(
            h3("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
            h3("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
          )
        ).equals(
          h3(
            "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
          )
        )
      );
      assert3(
        ecc2.verify(
          h3("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
          h3("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
          h3(
            "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
          )
        )
      );
      if (ecc2.signSchnorr) {
        assert3(
          import_buffer.Buffer.from(
            ecc2.signSchnorr(
              h3("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
              h3("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"),
              h3("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")
            )
          ).equals(
            h3(
              "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
            )
          )
        );
      }
      if (ecc2.verifySchnorr) {
        assert3(
          ecc2.verifySchnorr(
            h3("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
            h3("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"),
            h3(
              "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
            )
          )
        );
      }
    }
    exports2.testEcc = testEcc2;
    function assert3(bool) {
      if (!bool) throw new Error("ecc library invalid");
    }
  }
});

// node_modules/.pnpm/ecpair@2.1.0/node_modules/ecpair/src/ecpair.js
var require_ecpair = __commonJS({
  "node_modules/.pnpm/ecpair@2.1.0/node_modules/ecpair/src/ecpair.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ECPairFactory = exports2.networks = void 0;
    var networks2 = require_networks2();
    exports2.networks = networks2;
    var types = require_types3();
    var randomBytes2 = require_browser2();
    var wif = require_wif();
    var testecc_1 = require_testecc();
    var isOptions = types.typeforce.maybe(
      types.typeforce.compile({
        compressed: types.maybe(types.Boolean),
        network: types.maybe(types.Network)
      })
    );
    var toXOnly2 = (pubKey) => pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
    function ECPairFactory(ecc2) {
      (0, testecc_1.testEcc)(ecc2);
      function isPoint3(maybePoint) {
        return ecc2.isPoint(maybePoint);
      }
      function fromPrivateKey(buffer2, options) {
        types.typeforce(types.Buffer256bit, buffer2);
        if (!ecc2.isPrivate(buffer2))
          throw new TypeError("Private key not in range [1, n)");
        types.typeforce(isOptions, options);
        return new ECPair(buffer2, void 0, options);
      }
      function fromPublicKey(buffer2, options) {
        types.typeforce(ecc2.isPoint, buffer2);
        types.typeforce(isOptions, options);
        return new ECPair(void 0, buffer2, options);
      }
      function fromWIF(wifString, network) {
        const decoded = wif.decode(wifString);
        const version = decoded.version;
        if (types.Array(network)) {
          network = network.filter((x) => {
            return version === x.wif;
          }).pop();
          if (!network) throw new Error("Unknown network version");
        } else {
          network = network || networks2.bitcoin;
          if (version !== network.wif) throw new Error("Invalid network version");
        }
        return fromPrivateKey(decoded.privateKey, {
          compressed: decoded.compressed,
          network
        });
      }
      function makeRandom(options) {
        types.typeforce(isOptions, options);
        if (options === void 0) options = {};
        const rng = options.rng || randomBytes2;
        let d;
        do {
          d = rng(32);
          types.typeforce(types.Buffer256bit, d);
        } while (!ecc2.isPrivate(d));
        return fromPrivateKey(d, options);
      }
      class ECPair {
        constructor(__D, __Q, options) {
          __publicField(this, "__D");
          __publicField(this, "__Q");
          __publicField(this, "compressed");
          __publicField(this, "network");
          __publicField(this, "lowR");
          this.__D = __D;
          this.__Q = __Q;
          this.lowR = false;
          if (options === void 0) options = {};
          this.compressed = options.compressed === void 0 ? true : options.compressed;
          this.network = options.network || networks2.bitcoin;
          if (__Q !== void 0)
            this.__Q = import_buffer.Buffer.from(ecc2.pointCompress(__Q, this.compressed));
        }
        get privateKey() {
          return this.__D;
        }
        get publicKey() {
          if (!this.__Q) {
            const p = ecc2.pointFromScalar(this.__D, this.compressed);
            this.__Q = import_buffer.Buffer.from(p);
          }
          return this.__Q;
        }
        toWIF() {
          if (!this.__D) throw new Error("Missing private key");
          return wif.encode(this.network.wif, this.__D, this.compressed);
        }
        tweak(t) {
          if (this.privateKey) return this.tweakFromPrivateKey(t);
          return this.tweakFromPublicKey(t);
        }
        sign(hash, lowR) {
          if (!this.__D) throw new Error("Missing private key");
          if (lowR === void 0) lowR = this.lowR;
          if (lowR === false) {
            return import_buffer.Buffer.from(ecc2.sign(hash, this.__D));
          } else {
            let sig = ecc2.sign(hash, this.__D);
            const extraData = import_buffer.Buffer.alloc(32, 0);
            let counter = 0;
            while (sig[0] > 127) {
              counter++;
              extraData.writeUIntLE(counter, 0, 6);
              sig = ecc2.sign(hash, this.__D, extraData);
            }
            return import_buffer.Buffer.from(sig);
          }
        }
        signSchnorr(hash) {
          if (!this.privateKey) throw new Error("Missing private key");
          if (!ecc2.signSchnorr)
            throw new Error("signSchnorr not supported by ecc library");
          return import_buffer.Buffer.from(ecc2.signSchnorr(hash, this.privateKey));
        }
        verify(hash, signature2) {
          return ecc2.verify(hash, this.publicKey, signature2);
        }
        verifySchnorr(hash, signature2) {
          if (!ecc2.verifySchnorr)
            throw new Error("verifySchnorr not supported by ecc library");
          return ecc2.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature2);
        }
        tweakFromPublicKey(t) {
          const xOnlyPubKey = toXOnly2(this.publicKey);
          const tweakedPublicKey = ecc2.xOnlyPointAddTweak(xOnlyPubKey, t);
          if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null)
            throw new Error("Cannot tweak public key!");
          const parityByte = import_buffer.Buffer.from([
            tweakedPublicKey.parity === 0 ? 2 : 3
          ]);
          return fromPublicKey(
            import_buffer.Buffer.concat([parityByte, tweakedPublicKey.xOnlyPubkey]),
            { network: this.network, compressed: this.compressed }
          );
        }
        tweakFromPrivateKey(t) {
          const hasOddY = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1;
          const privateKey = hasOddY ? ecc2.privateNegate(this.privateKey) : this.privateKey;
          const tweakedPrivateKey = ecc2.privateAdd(privateKey, t);
          if (!tweakedPrivateKey) throw new Error("Invalid tweaked private key!");
          return fromPrivateKey(import_buffer.Buffer.from(tweakedPrivateKey), {
            network: this.network,
            compressed: this.compressed
          });
        }
      }
      return {
        isPoint: isPoint3,
        fromPrivateKey,
        fromPublicKey,
        fromWIF,
        makeRandom
      };
    }
    exports2.ECPairFactory = ECPairFactory;
  }
});

// node_modules/.pnpm/ecpair@2.1.0/node_modules/ecpair/src/index.js
var require_src3 = __commonJS({
  "node_modules/.pnpm/ecpair@2.1.0/node_modules/ecpair/src/index.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.networks = exports2.ECPairFactory = exports2.default = void 0;
    var ecpair_1 = require_ecpair();
    Object.defineProperty(exports2, "default", {
      enumerable: true,
      get: function() {
        return ecpair_1.ECPairFactory;
      }
    });
    Object.defineProperty(exports2, "ECPairFactory", {
      enumerable: true,
      get: function() {
        return ecpair_1.ECPairFactory;
      }
    });
    Object.defineProperty(exports2, "networks", {
      enumerable: true,
      get: function() {
        return ecpair_1.networks;
      }
    });
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/bip341.js
var require_bip341 = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/bip341.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findScriptPath = exports2.toHashTree = exports2.tapLeafHash = exports2.BIP341Factory = exports2.LEAF_VERSION_TAPSCRIPT = void 0;
    var crypto_1 = require_crypto();
    var ecpair_1 = require_src3();
    var bufferutils_1 = require_bufferutils();
    exports2.LEAF_VERSION_TAPSCRIPT = 196;
    function BIP341Factory(ecc2) {
      return {
        taprootSignKey: taprootSignKey(ecc2),
        taprootSignScriptStack: taprootSignScriptStack(ecc2),
        taprootOutputScript: taprootOutputScript(ecc2)
      };
    }
    exports2.BIP341Factory = BIP341Factory;
    function tapLeafHash(leaf) {
      const leafVersion = leaf.version || exports2.LEAF_VERSION_TAPSCRIPT;
      const script = import_buffer.Buffer.from(leaf.scriptHex, "hex");
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        1 + (0, bufferutils_1.varSliceSize)(script)
      );
      bufferWriter.writeUInt8(leafVersion);
      bufferWriter.writeVarSlice(script);
      return (0, crypto_1.taggedHash)("TapLeaf/elements", bufferWriter.end());
    }
    exports2.tapLeafHash = tapLeafHash;
    function toHashTree2(leaves, withScriptHex = false) {
      switch (leaves.length) {
        case 0:
          return { hash: import_buffer.Buffer.alloc(32) };
        case 1:
          const leaf = leaves[0];
          const version = leaf.version || exports2.LEAF_VERSION_TAPSCRIPT;
          if ((version & 1) !== 0) {
            throw new Error("Invalid leaf version");
          }
          return {
            hash: tapLeafHash(leaf),
            scriptHex: withScriptHex ? leaf.scriptHex : void 0
          };
        default:
          const middleIndex = Math.ceil(leaves.length / 2);
          const left = toHashTree2(leaves.slice(0, middleIndex), withScriptHex);
          const right = toHashTree2(leaves.slice(middleIndex), withScriptHex);
          let leftHash = left.hash;
          let rightHash = right.hash;
          if (left.hash.compare(right.hash) > 0) {
            [leftHash, rightHash] = [rightHash, leftHash];
          }
          return {
            left,
            right,
            hash: (0, crypto_1.taggedHash)(
              "TapBranch/elements",
              import_buffer.Buffer.concat([leftHash, rightHash])
            )
          };
      }
    }
    exports2.toHashTree = toHashTree2;
    function findScriptPath2(node, hash) {
      if (node.left) {
        if (node.left.hash.equals(hash)) return node.right ? [node.right.hash] : [];
        const leftPath = findScriptPath2(node.left, hash);
        if (leftPath.length)
          return node.right ? leftPath.concat([node.right.hash]) : leftPath;
      }
      if (node.right) {
        if (node.right.hash.equals(hash)) return node.left ? [node.left.hash] : [];
        const rightPath = findScriptPath2(node.right, hash);
        if (rightPath.length)
          return node.left ? rightPath.concat([node.left.hash]) : rightPath;
      }
      return [];
    }
    exports2.findScriptPath = findScriptPath2;
    function tweakPublicKey(publicKey, hash, ecc2) {
      const XOnlyPubKey = publicKey.slice(1, 33);
      const toTweak = import_buffer.Buffer.concat([XOnlyPubKey, hash]);
      const tweakHash = (0, crypto_1.taggedHash)("TapTweak/elements", toTweak);
      const tweaked = ecc2.xOnlyPointAddTweak(XOnlyPubKey, tweakHash);
      if (!tweaked) throw new Error("Invalid tweaked key");
      return tweaked;
    }
    function taprootOutputScript(ecc2) {
      return (internalPublicKey, tree) => {
        let treeHash = import_buffer.Buffer.alloc(0);
        if (tree) {
          treeHash = tree.hash;
        }
        const { xOnlyPubkey } = tweakPublicKey(internalPublicKey, treeHash, ecc2);
        return import_buffer.Buffer.concat([import_buffer.Buffer.from([81, 32]), xOnlyPubkey]);
      };
    }
    function taprootSignScriptStack(ecc2) {
      return (internalPublicKey, leaf, treeRootHash, path) => {
        const { parity } = tweakPublicKey(internalPublicKey, treeRootHash, ecc2);
        const parityBit = import_buffer.Buffer.of(
          (leaf.version || exports2.LEAF_VERSION_TAPSCRIPT) + parity
        );
        const control = import_buffer.Buffer.concat([
          parityBit,
          internalPublicKey.slice(1),
          ...path
        ]);
        return [import_buffer.Buffer.from(leaf.scriptHex, "hex"), control];
      };
    }
    var N_LESS_1 = import_buffer.Buffer.from(
      "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
      "hex"
    );
    var ONE2 = import_buffer.Buffer.from(
      "0000000000000000000000000000000000000000000000000000000000000001",
      "hex"
    );
    function taprootSignKey(ecc2) {
      return (messageHash, key) => {
        const signingEcPair = (0, ecpair_1.ECPairFactory)(ecc2).fromPrivateKey(key);
        const privateKey = signingEcPair.publicKey[0] === 2 ? signingEcPair.privateKey : ecc2.privateAdd(ecc2.privateSub(N_LESS_1, key), ONE2);
        const tweakHash = (0, crypto_1.taggedHash)(
          "TapTweak/elements",
          signingEcPair.publicKey.slice(1, 33)
        );
        const newPrivateKey = ecc2.privateAdd(privateKey, tweakHash);
        if (newPrivateKey === null) throw new Error("Invalid Tweak");
        const signed = ecc2.signSchnorr(messageHash, newPrivateKey);
        const ok = ecc2.verifySchnorr(
          messageHash,
          (0, ecpair_1.ECPairFactory)(ecc2).fromPrivateKey(import_buffer.Buffer.from(newPrivateKey)).publicKey.slice(1),
          signed
        );
        if (!ok) throw new Error("Invalid Signature");
        return import_buffer.Buffer.from(signed);
      };
    }
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/transaction.js
var require_transaction = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/transaction.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Transaction = exports2.ZERO = void 0;
    var bufferutils_1 = require_bufferutils();
    var bcrypto = __importStar(require_crypto());
    var bscript = __importStar(require_script());
    var script_1 = require_script();
    var types = __importStar(require_types2());
    var { typeforce } = types;
    var EMPTY_BUFFER4 = import_buffer.Buffer.allocUnsafe(0);
    var EMPTY_WITNESS = [];
    exports2.ZERO = import_buffer.Buffer.from(
      "0000000000000000000000000000000000000000000000000000000000000000",
      "hex"
    );
    var ONE2 = import_buffer.Buffer.from(
      "0000000000000000000000000000000000000000000000000000000000000001",
      "hex"
    );
    var WITNESS_SCALE_FACTOR = 4;
    var OUTPOINT_ISSUANCE_FLAG = 1 << 31 >>> 0;
    var OUTPOINT_PEGIN_FLAG = 1 << 30 >>> 0;
    var OUTPOINT_INDEX_MASK = 1073741823;
    var MINUS_1 = 4294967295;
    var VALUE_UINT64_MAX2 = import_buffer.Buffer.from("ffffffffffffffff", "hex");
    var BLANK_OUTPUT = {
      script: EMPTY_BUFFER4,
      asset: exports2.ZERO,
      nonce: exports2.ZERO,
      valueBuffer: VALUE_UINT64_MAX2
    };
    var Transaction2 = class _Transaction {
      constructor() {
        this.version = 1;
        this.locktime = 0;
        this.flag = 0;
        this.ins = [];
        this.outs = [];
      }
      static fromBuffer(buffer2, _NO_STRICT) {
        const bufferReader = new bufferutils_1.BufferReader(buffer2);
        const tx = new _Transaction();
        tx.version = bufferReader.readInt32();
        tx.flag = bufferReader.readUInt8();
        let hasWitnesses = false;
        if (tx.flag & _Transaction.ADVANCED_TRANSACTION_FLAG) {
          hasWitnesses = true;
        }
        const vinLen = bufferReader.readVarInt();
        for (let i = 0; i < vinLen; ++i) {
          const inHash = bufferReader.readSlice(32);
          let inIndex = bufferReader.readUInt32();
          const inScript = bufferReader.readVarSlice();
          const inSequence = bufferReader.readUInt32();
          let inIsPegin = false;
          let inIssuance;
          if (inIndex !== MINUS_1) {
            if (inIndex & OUTPOINT_ISSUANCE_FLAG) {
              inIssuance = bufferReader.readIssuance();
            }
            if (inIndex & OUTPOINT_PEGIN_FLAG) {
              inIsPegin = true;
            }
            inIndex &= OUTPOINT_INDEX_MASK;
          }
          tx.ins.push({
            hash: inHash,
            index: inIndex,
            script: inScript,
            sequence: inSequence,
            witness: EMPTY_WITNESS,
            isPegin: inIsPegin,
            issuance: inIssuance,
            peginWitness: EMPTY_WITNESS,
            issuanceRangeProof: EMPTY_BUFFER4,
            inflationRangeProof: EMPTY_BUFFER4
          });
        }
        const voutLen = bufferReader.readVarInt();
        for (let i = 0; i < voutLen; ++i) {
          const asset = bufferReader.readConfidentialAsset();
          const value2 = bufferReader.readConfidentialValue();
          const nonce = bufferReader.readConfidentialNonce();
          const script = bufferReader.readVarSlice();
          tx.outs.push({
            asset,
            value: value2,
            nonce,
            script,
            rangeProof: EMPTY_BUFFER4,
            surjectionProof: EMPTY_BUFFER4
          });
        }
        tx.locktime = bufferReader.readUInt32();
        if (hasWitnesses) {
          for (let i = 0; i < vinLen; ++i) {
            const {
              witness,
              peginWitness,
              issuanceRangeProof,
              inflationRangeProof
            } = bufferReader.readConfidentialInFields();
            tx.ins[i].witness = witness;
            tx.ins[i].peginWitness = peginWitness;
            tx.ins[i].issuanceRangeProof = issuanceRangeProof;
            tx.ins[i].inflationRangeProof = inflationRangeProof;
          }
          for (let i = 0; i < voutLen; ++i) {
            const { rangeProof, surjectionProof } = bufferReader.readConfidentialOutFields();
            tx.outs[i].rangeProof = rangeProof;
            tx.outs[i].surjectionProof = surjectionProof;
          }
        }
        if (_NO_STRICT) return tx;
        if (bufferReader.offset !== buffer2.length)
          throw new Error("Transaction has unexpected data");
        return tx;
      }
      static fromHex(hex) {
        return _Transaction.fromBuffer(import_buffer.Buffer.from(hex, "hex"), false);
      }
      static isCoinbaseHash(buffer2) {
        typeforce(types.Hash256bit, buffer2);
        for (let i = 0; i < 32; ++i) {
          if (buffer2[i] !== 0) return false;
        }
        return true;
      }
      isCoinbase() {
        return this.ins.length === 1 && _Transaction.isCoinbaseHash(this.ins[0].hash);
      }
      // A quick and reliable way to validate that all the buffers are of correct type and length
      validateIssuance(assetBlindingNonce, assetEntropy, assetAmount, tokenAmount) {
        typeforce(types.Hash256bit, assetBlindingNonce);
        typeforce(types.Hash256bit, assetEntropy);
        typeforce(
          types.oneOf(
            types.ConfidentialValue,
            types.ConfidentialCommitment,
            types.BufferOne
          ),
          assetAmount
        );
        typeforce(
          types.oneOf(
            types.ConfidentialValue,
            types.ConfidentialCommitment,
            types.BufferOne
          ),
          tokenAmount
        );
        return true;
      }
      addInput(hash, index, sequence, scriptSig, issuance) {
        typeforce(
          types.tuple(
            types.Hash256bit,
            types.UInt32,
            types.maybe(types.UInt32),
            types.maybe(types.Buffer),
            types.maybe(types.Object)
          ),
          arguments
        );
        let isPegin = false;
        if (index !== MINUS_1) {
          if (index & OUTPOINT_ISSUANCE_FLAG) {
            if (!issuance) {
              throw new Error(
                "Issuance flag has been set but the Issuance object is not defined or invalid"
              );
            } else
              this.validateIssuance(
                issuance.assetBlindingNonce,
                issuance.assetEntropy,
                issuance.assetAmount,
                issuance.tokenAmount
              );
          }
          if (index & OUTPOINT_PEGIN_FLAG) {
            isPegin = true;
          }
          index &= OUTPOINT_INDEX_MASK;
        }
        return this.ins.push({
          hash,
          index,
          isPegin,
          issuance,
          script: scriptSig || EMPTY_BUFFER4,
          witness: EMPTY_WITNESS,
          peginWitness: EMPTY_WITNESS,
          issuanceRangeProof: EMPTY_BUFFER4,
          inflationRangeProof: EMPTY_BUFFER4,
          sequence: sequence ?? _Transaction.DEFAULT_SEQUENCE
        }) - 1;
      }
      addOutput(scriptPubKey, value2, asset, nonce, rangeProof, surjectionProof) {
        typeforce(
          types.tuple(
            types.Buffer,
            types.oneOf(types.ConfidentialValue, types.ConfidentialCommitment),
            types.AssetBufferWithFlag,
            types.oneOf(types.ConfidentialCommitment, types.BufferOne),
            types.maybe(types.Buffer),
            types.maybe(types.Buffer)
          ),
          arguments
        );
        return this.outs.push({
          script: scriptPubKey,
          value: value2,
          asset,
          nonce: nonce || EMPTY_BUFFER4,
          rangeProof: rangeProof || EMPTY_BUFFER4,
          surjectionProof: surjectionProof || EMPTY_BUFFER4
        }) - 1;
      }
      hasWitnesses() {
        return this.flag === 1 || this.ins.some((x) => {
          return x.witness.length !== 0;
        }) || this.outs.some((x) => {
          return x.rangeProof.length !== 0 && x.surjectionProof.length !== 0;
        });
      }
      weight(discountCT = true) {
        const base5 = this.__byteLength(false, false);
        const total = this.__byteLength(true, false);
        let weight = base5 * (WITNESS_SCALE_FACTOR - 1) + total;
        if (!discountCT) {
          return weight;
        }
        for (const txOut of this.outs) {
          let witnessWeight = 0;
          if (txOut.rangeProof !== void 0 && txOut.rangeProof.length > 0) {
            witnessWeight += txOut.rangeProof.length;
            witnessWeight += bufferutils_1.varuint.encodingLength(
              txOut.rangeProof.length
            );
          }
          if (txOut.surjectionProof !== void 0 && txOut.surjectionProof.length > 0) {
            witnessWeight += txOut.surjectionProof.length;
            witnessWeight += bufferutils_1.varuint.encodingLength(
              txOut.surjectionProof.length
            );
          }
          weight -= Math.max(witnessWeight - 2, 0);
          if (txOut.rangeProof !== void 0 && txOut.rangeProof.length > 0) {
            weight -= (33 - 9) * 4;
            weight -= (33 - 1) * 4;
          }
        }
        return weight;
      }
      virtualSize(discountCT = true) {
        const vsize = (this.weight(discountCT) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR;
        return Math.floor(vsize);
      }
      byteLength(_ALLOW_WITNESS) {
        return this.__byteLength(_ALLOW_WITNESS || true);
      }
      clone() {
        const newTx = new _Transaction();
        newTx.version = this.version;
        newTx.locktime = this.locktime;
        newTx.flag = this.flag;
        newTx.ins = this.ins.map((txIn) => {
          return {
            hash: txIn.hash,
            index: txIn.index,
            script: txIn.script,
            sequence: txIn.sequence,
            witness: txIn.witness,
            isPegin: txIn.isPegin,
            issuance: txIn.issuance,
            peginWitness: txIn.peginWitness,
            issuanceRangeProof: txIn.issuanceRangeProof,
            inflationRangeProof: txIn.inflationRangeProof
          };
        });
        newTx.outs = this.outs.map((txOut) => {
          return {
            script: txOut.script,
            value: txOut.value,
            asset: txOut.asset,
            nonce: txOut.nonce,
            rangeProof: txOut.rangeProof,
            surjectionProof: txOut.surjectionProof
          };
        });
        return newTx;
      }
      /**
       * Hash transaction for signing a specific input.
       *
       * Bitcoin uses a different hash for each signed transaction input.
       * This method copies the transaction, makes the necessary changes based on the
       * hashType, and then hashes the result.
       * This hash can then be used to sign the provided transaction input.
       */
      hashForSignature(inIndex, prevOutScript, hashType) {
        typeforce(
          types.tuple(
            types.UInt32,
            types.Buffer,
            /* types.UInt8 */
            types.Number
          ),
          arguments
        );
        if (inIndex >= this.ins.length) return ONE2;
        const ourScript = bscript.compile(
          bscript.decompile(prevOutScript).filter((x) => {
            return x !== script_1.OPS.OP_CODESEPARATOR;
          })
        );
        const txTmp = this.clone();
        if ((hashType & 31) === _Transaction.SIGHASH_NONE) {
          txTmp.outs = [];
          txTmp.ins.forEach((input, i) => {
            if (i === inIndex) return;
            input.sequence = 0;
          });
        } else if ((hashType & 31) === _Transaction.SIGHASH_SINGLE) {
          if (inIndex >= this.outs.length) return ONE2;
          txTmp.outs.length = inIndex + 1;
          for (let i = 0; i < inIndex; i++) {
            txTmp.outs[i] = BLANK_OUTPUT;
          }
          txTmp.ins.forEach((input, y) => {
            if (y === inIndex) return;
            input.sequence = 0;
          });
        }
        if (hashType & _Transaction.SIGHASH_ANYONECANPAY) {
          txTmp.ins = [txTmp.ins[inIndex]];
          txTmp.ins[0].script = ourScript;
        } else {
          txTmp.ins.forEach((input) => {
            input.script = EMPTY_BUFFER4;
          });
          txTmp.ins[inIndex].script = ourScript;
        }
        const buffer2 = import_buffer.Buffer.allocUnsafe(txTmp.__byteLength(false, true) + 4);
        buffer2.writeInt32LE(hashType, buffer2.length - 4);
        txTmp.__toBuffer(buffer2, 0, false, true, true);
        return bcrypto.hash256(buffer2);
      }
      // differs from bitcoin core
      // https://github.com/ElementsProject/elements/blob/84b3f7b0045b50a585d60e56e77e8914b6cf6040/doc/taproot-sighash.mediawiki
      hashForWitnessV1(inIndex, prevOutScripts, prevoutAssetsValues, hashType, genesisBlockHash, leafHash, annex) {
        typeforce(
          types.tuple(
            types.UInt32,
            typeforce.arrayOf(types.Buffer),
            typeforce.arrayOf(types.Object),
            types.UInt32
          ),
          arguments
        );
        if (prevOutScripts.length !== this.ins.length) {
          throw new Error("Must supply prevout script and value for all inputs");
        }
        const outputType = hashType === _Transaction.SIGHASH_DEFAULT ? _Transaction.SIGHASH_ALL : hashType & _Transaction.SIGHASH_OUTPUT_MASK;
        const inputType = hashType & _Transaction.SIGHASH_INPUT_MASK;
        const isAnyoneCanPay = inputType === _Transaction.SIGHASH_ANYONECANPAY;
        const isNone = outputType === _Transaction.SIGHASH_NONE;
        const isSingle = outputType === _Transaction.SIGHASH_SINGLE;
        let hashPrevouts = EMPTY_BUFFER4;
        let hashSequences = EMPTY_BUFFER4;
        let hashOutputs = EMPTY_BUFFER4;
        let hashIssuances = EMPTY_BUFFER4;
        let hashScriptPubKeys = EMPTY_BUFFER4;
        let hashOutpointsFlags = EMPTY_BUFFER4;
        let hashIssuancesProofs = EMPTY_BUFFER4;
        let hashOutputsWitnesses = EMPTY_BUFFER4;
        let hashSpentAssetsAmounts = EMPTY_BUFFER4;
        if (!isAnyoneCanPay) {
          hashPrevouts = getPrevoutsSHA256(this.ins);
          hashOutpointsFlags = getOutpointFlagsSHA256(this.ins);
          hashSpentAssetsAmounts = getSpentAssetsAmountsSHA256(prevoutAssetsValues);
          hashIssuancesProofs = getIssuanceProofsSHA256(this.ins);
          hashScriptPubKeys = getPrevoutScriptsSHA256(prevOutScripts);
          hashSequences = getSequenceSHA256(this.ins);
          hashIssuances = getIssuanceSHA256(this.ins);
        }
        if (!(isNone || isSingle)) {
          hashOutputs = getOutputsSHA256(this.outs);
          hashOutputsWitnesses = getOutputWitnessesSHA256(this.outs);
        } else if (isSingle && inIndex < this.outs.length) {
          const output = this.outs[inIndex];
          hashOutputs = getOutputsSHA256([output]);
          hashOutputsWitnesses = getOutputWitnessesSHA256([output]);
        }
        const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);
        const inputPartSize = isAnyoneCanPay ? 1 + 32 + 4 + prevoutAssetsValues[inIndex].asset.length + prevoutAssetsValues[inIndex].value.length + (0, bufferutils_1.varSliceSize)(prevOutScripts[inIndex]) + 4 + (this.ins[inIndex].issuance ? getIssuanceSize(this.ins[inIndex]) : 1) : 4;
        const fullMsgSize = 32 * 2 + 1 + 4 + 4 + 1 + inputPartSize;
        const sigMsgSize = fullMsgSize + (!isAnyoneCanPay ? 7 * 32 : 0) + (!(isNone || isSingle) ? 32 + 32 : 0) + (annex ? 32 : 0) + (isSingle ? 32 + 32 : 0) + (leafHash ? 37 : 0);
        const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);
        sigMsgWriter.writeSlice(genesisBlockHash);
        sigMsgWriter.writeSlice(genesisBlockHash);
        sigMsgWriter.writeUInt8(hashType);
        sigMsgWriter.writeInt32(this.version);
        sigMsgWriter.writeUInt32(this.locktime);
        if (!isAnyoneCanPay) {
          sigMsgWriter.writeSlice(hashOutpointsFlags);
          sigMsgWriter.writeSlice(hashPrevouts);
          sigMsgWriter.writeSlice(hashSpentAssetsAmounts);
          sigMsgWriter.writeSlice(hashScriptPubKeys);
          sigMsgWriter.writeSlice(hashSequences);
          sigMsgWriter.writeSlice(hashIssuances);
          sigMsgWriter.writeSlice(hashIssuancesProofs);
        }
        if (!(isNone || isSingle)) {
          sigMsgWriter.writeSlice(hashOutputs);
          sigMsgWriter.writeSlice(hashOutputsWitnesses);
        }
        sigMsgWriter.writeUInt8(spendType);
        if (isAnyoneCanPay) {
          const input = this.ins[inIndex];
          sigMsgWriter.writeUInt8(getInputFlag(input));
          sigMsgWriter.writeSlice(input.hash);
          sigMsgWriter.writeUInt32(input.index);
          sigMsgWriter.writeSlice(prevoutAssetsValues[inIndex].asset);
          sigMsgWriter.writeSlice(prevoutAssetsValues[inIndex].value);
          sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);
          sigMsgWriter.writeUInt32(input.sequence);
          if (input.issuance) {
            sigMsgWriter.writeSlice(input.issuance.assetBlindingNonce);
            sigMsgWriter.writeSlice(input.issuance.assetEntropy);
            sigMsgWriter.writeSlice(input.issuance.assetAmount);
            sigMsgWriter.writeSlice(input.issuance.tokenAmount);
            const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
              (0, bufferutils_1.varSliceSize)(input.issuanceRangeProof) + (0, bufferutils_1.varSliceSize)(input.inflationRangeProof)
            );
            bufferWriter.writeVarSlice(input.issuanceRangeProof || import_buffer.Buffer.of(0));
            bufferWriter.writeVarSlice(
              input.inflationRangeProof || import_buffer.Buffer.of(0)
            );
            const hashIssuance = bcrypto.sha256(bufferWriter.end());
            sigMsgWriter.writeSlice(hashIssuance);
          } else {
            sigMsgWriter.writeSlice(import_buffer.Buffer.of(0));
          }
        } else {
          sigMsgWriter.writeUInt32(inIndex);
        }
        if (annex) {
          const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            (0, bufferutils_1.varSliceSize)(annex)
          );
          bufferWriter.writeVarSlice(annex);
          sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));
        }
        if (isSingle) {
          sigMsgWriter.writeSlice(hashOutputs);
          sigMsgWriter.writeSlice(hashOutputsWitnesses);
        }
        if (leafHash) {
          sigMsgWriter.writeSlice(leafHash);
          sigMsgWriter.writeUInt8(0);
          sigMsgWriter.writeUInt32(4294967295);
        }
        return bcrypto.taggedHash("TapSighash/elements", sigMsgWriter.end());
      }
      hashForWitnessV0(inIndex, prevOutScript, value2, hashType) {
        typeforce(
          types.tuple(types.UInt32, types.Buffer, types.Buffer, types.UInt32),
          arguments
        );
        let hashOutputs = exports2.ZERO;
        let hashPrevouts = exports2.ZERO;
        let hashSequence = exports2.ZERO;
        let hashIssuances = exports2.ZERO;
        if (!(hashType & _Transaction.SIGHASH_ANYONECANPAY)) {
          const prevoutsHashWriter = bufferutils_1.BufferWriter.withCapacity(
            (32 + 4) * this.ins.length
          );
          this.ins.forEach((txIn) => {
            prevoutsHashWriter.writeSlice(txIn.hash);
            prevoutsHashWriter.writeUInt32(txIn.index);
          });
          hashPrevouts = bcrypto.hash256(prevoutsHashWriter.end());
        }
        if (!(hashType & _Transaction.SIGHASH_ANYONECANPAY) && (hashType & 31) !== _Transaction.SIGHASH_SINGLE && (hashType & 31) !== _Transaction.SIGHASH_NONE) {
          const sequenceHashWriter = bufferutils_1.BufferWriter.withCapacity(
            4 * this.ins.length
          );
          this.ins.forEach((txIn) => {
            sequenceHashWriter.writeUInt32(txIn.sequence);
          });
          hashSequence = bcrypto.hash256(sequenceHashWriter.end());
        }
        if (!(hashType & _Transaction.SIGHASH_ANYONECANPAY)) {
          const sizeOfIssuances = this.ins.reduce(
            (sum, txIn) => txIn.issuance ? sum + getIssuanceSize(txIn) : sum + 1,
            0
          );
          const size = sizeOfIssuances === 0 ? this.ins.length : sizeOfIssuances;
          const issuancesHashWriter = bufferutils_1.BufferWriter.withCapacity(size);
          this.ins.forEach((txIn) => {
            if (txIn.issuance) {
              issuancesHashWriter.writeSlice(txIn.issuance.assetBlindingNonce);
              issuancesHashWriter.writeSlice(txIn.issuance.assetEntropy);
              issuancesHashWriter.writeSlice(txIn.issuance.assetAmount);
              issuancesHashWriter.writeSlice(txIn.issuance.tokenAmount);
            } else {
              issuancesHashWriter.writeSlice(import_buffer.Buffer.of(0));
            }
          });
          hashIssuances = bcrypto.hash256(issuancesHashWriter.end());
        }
        if ((hashType & 31) !== _Transaction.SIGHASH_SINGLE && (hashType & 31) !== _Transaction.SIGHASH_NONE) {
          const txOutsSize = this.outs.reduce(
            (sum, output) => sum + output.asset.length + output.value.length + output.nonce.length + (0, bufferutils_1.varSliceSize)(output.script),
            0
          );
          const outputsHashWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);
          this.outs.forEach((out) => {
            outputsHashWriter.writeSlice(out.asset);
            outputsHashWriter.writeSlice(out.value);
            outputsHashWriter.writeSlice(out.nonce);
            outputsHashWriter.writeVarSlice(out.script);
          });
          hashOutputs = bcrypto.hash256(outputsHashWriter.end());
        } else if ((hashType & 31) === _Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {
          const output = this.outs[inIndex];
          const size = output.asset.length + output.value.length + output.nonce.length + (0, bufferutils_1.varSliceSize)(output.script);
          const outputsHashWriter = bufferutils_1.BufferWriter.withCapacity(size);
          outputsHashWriter.writeSlice(output.asset);
          outputsHashWriter.writeSlice(output.value);
          outputsHashWriter.writeSlice(output.nonce);
          outputsHashWriter.writeVarSlice(output.script);
          hashOutputs = bcrypto.hash256(outputsHashWriter.end());
        }
        const input = this.ins[inIndex];
        const hasIssuance = input.issuance !== void 0;
        const bufferSize = 4 + // version
        hashPrevouts.length + hashSequence.length + hashIssuances.length + input.hash.length + 4 + // input.index
        (0, bufferutils_1.varSliceSize)(prevOutScript) + value2.length + 4 + // input.sequence
        hashOutputs.length + getIssuanceSize(input) + 4 + // locktime
        4;
        const sigWriter = bufferutils_1.BufferWriter.withCapacity(bufferSize);
        sigWriter.writeUInt32(this.version);
        sigWriter.writeSlice(hashPrevouts);
        sigWriter.writeSlice(hashSequence);
        sigWriter.writeSlice(hashIssuances);
        sigWriter.writeSlice(input.hash);
        sigWriter.writeUInt32(input.index);
        sigWriter.writeVarSlice(prevOutScript);
        sigWriter.writeSlice(value2);
        sigWriter.writeUInt32(input.sequence);
        if (hasIssuance) {
          sigWriter.writeSlice(input.issuance.assetBlindingNonce);
          sigWriter.writeSlice(input.issuance.assetEntropy);
          sigWriter.writeSlice(input.issuance.assetAmount);
          sigWriter.writeSlice(input.issuance.tokenAmount);
        }
        sigWriter.writeSlice(hashOutputs);
        sigWriter.writeUInt32(this.locktime);
        sigWriter.writeUInt32(hashType);
        return bcrypto.hash256(sigWriter.end());
      }
      getHash(forWitness) {
        if (forWitness && this.isCoinbase()) return import_buffer.Buffer.alloc(32, 0);
        return bcrypto.hash256(
          this.__toBuffer(void 0, void 0, forWitness, true)
        );
      }
      getId() {
        return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString(
          "hex"
        );
      }
      toBuffer(buffer2, initialOffset) {
        return this.__toBuffer(buffer2, initialOffset, true, false);
      }
      toHex() {
        return this.toBuffer(void 0, void 0).toString("hex");
      }
      setInputScript(index, scriptSig) {
        typeforce(types.tuple(types.Number, types.Buffer), arguments);
        this.ins[index].script = scriptSig;
      }
      setWitness(index, witness) {
        typeforce(types.tuple(types.Number, [types.Buffer]), arguments);
        this.ins[index].witness = witness;
      }
      setPeginWitness(index, peginWitness) {
        typeforce(types.tuple(types.Number, [types.Buffer]), arguments);
        this.ins[index].peginWitness = peginWitness;
      }
      setInputIssuanceRangeProof(index, issuanceRangeProof) {
        typeforce(types.tuple(types.Buffer), arguments);
        if (this.ins[index].issuance === void 0)
          throw new Error("Issuance not set for input #" + index);
        this.ins[index].issuanceRangeProof = issuanceRangeProof;
      }
      setInputInflationRangeProof(index, inflationRangeProof) {
        typeforce(types.tuple(types.Buffer), arguments);
        if (this.ins[index].issuance === void 0)
          throw new Error("Issuance not set for input #" + index);
        this.ins[index].inflationRangeProof = inflationRangeProof;
      }
      setOutputNonce(index, nonce) {
        typeforce(types.tuple(types.Number, types.Buffer), arguments);
        this.outs[index].nonce = nonce;
      }
      setOutputRangeProof(index, proof) {
        typeforce(types.tuple(types.Number, types.Buffer), arguments);
        this.outs[index].rangeProof = proof;
      }
      setOutputSurjectionProof(index, proof) {
        typeforce(types.tuple(types.Number, types.Buffer), arguments);
        this.outs[index].surjectionProof = proof;
      }
      __byteLength(_ALLOW_WITNESS, forSignature) {
        const extraByte = forSignature ? 0 : 1;
        let size = 8 + extraByte + bufferutils_1.varuint.encodingLength(this.ins.length) + bufferutils_1.varuint.encodingLength(this.outs.length);
        for (const txIn of this.ins) {
          size += 40 + (0, bufferutils_1.varSliceSize)(txIn.script);
          if (txIn.issuance) {
            size += 64 + txIn.issuance.assetAmount.length + txIn.issuance.tokenAmount.length;
          }
        }
        for (const txOut of this.outs) {
          size += txOut.asset.length + txOut.value.length + txOut.nonce.length + (0, bufferutils_1.varSliceSize)(txOut.script);
        }
        if (_ALLOW_WITNESS && this.hasWitnesses()) {
          for (const txIn of this.ins) {
            size += (0, bufferutils_1.varSliceSize)(txIn.issuanceRangeProof);
            size += (0, bufferutils_1.varSliceSize)(txIn.inflationRangeProof);
            size += bufferutils_1.varuint.encodingLength(txIn.witness.length);
            for (const wit of txIn.witness) {
              size += (0, bufferutils_1.varSliceSize)(wit);
            }
            size += bufferutils_1.varuint.encodingLength(
              (txIn.peginWitness || []).length
            );
            for (const wit of txIn.peginWitness || []) {
              size += (0, bufferutils_1.varSliceSize)(wit);
            }
          }
          for (const txOut of this.outs) {
            size += (0, bufferutils_1.varSliceSize)(txOut.surjectionProof);
            size += (0, bufferutils_1.varSliceSize)(txOut.rangeProof);
          }
        }
        return size;
      }
      __toBuffer(buffer2, initialOffset, _ALLOW_WITNESS, forceZeroFlag, forSignature) {
        if (!buffer2)
          buffer2 = import_buffer.Buffer.allocUnsafe(
            this.__byteLength(_ALLOW_WITNESS, forSignature)
          );
        const bufferWriter = new bufferutils_1.BufferWriter(
          buffer2,
          initialOffset || 0
        );
        bufferWriter.writeInt32(this.version);
        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
        if (!forSignature) {
          let flags = 0;
          if (hasWitnesses && !forceZeroFlag) {
            flags |= _Transaction.ADVANCED_TRANSACTION_FLAG;
          }
          bufferWriter.writeUInt8(flags);
        }
        bufferWriter.writeVarInt(this.ins.length);
        this.ins.forEach((txIn) => {
          bufferWriter.writeSlice(txIn.hash);
          let prevIndex = txIn.index;
          if (txIn.issuance) {
            prevIndex = (prevIndex | OUTPOINT_ISSUANCE_FLAG) >>> 0;
          }
          if (txIn.isPegin) {
            prevIndex = (prevIndex | OUTPOINT_PEGIN_FLAG) >>> 0;
          }
          bufferWriter.writeUInt32(prevIndex);
          bufferWriter.writeVarSlice(txIn.script);
          bufferWriter.writeUInt32(txIn.sequence);
          if (txIn.issuance) {
            bufferWriter.writeSlice(txIn.issuance.assetBlindingNonce);
            bufferWriter.writeSlice(txIn.issuance.assetEntropy);
            bufferWriter.writeSlice(txIn.issuance.assetAmount);
            bufferWriter.writeSlice(txIn.issuance.tokenAmount);
          }
        });
        bufferWriter.writeVarInt(this.outs.length);
        this.outs.forEach((txOut) => {
          const val = forSignature && hasWitnesses ? import_buffer.Buffer.alloc(1) : txOut.value;
          bufferWriter.writeSlice(txOut.asset);
          bufferWriter.writeSlice(val);
          bufferWriter.writeSlice(txOut.nonce);
          if (forSignature && hasWitnesses) bufferWriter.writeUInt64(0);
          bufferWriter.writeVarSlice(txOut.script);
        });
        bufferWriter.writeUInt32(this.locktime);
        if (!forSignature && hasWitnesses) {
          this.ins.forEach((input) => {
            bufferWriter.writeConfidentialInFields(input);
          });
          this.outs.forEach((output) => {
            bufferWriter.writeConfidentialOutFields(output);
          });
        }
        if (initialOffset !== void 0)
          return buffer2.slice(initialOffset, bufferWriter.offset);
        return buffer2;
      }
    };
    exports2.Transaction = Transaction2;
    Transaction2.DEFAULT_SEQUENCE = 4294967295;
    Transaction2.SIGHASH_DEFAULT = 0;
    Transaction2.SIGHASH_ALL = 1;
    Transaction2.SIGHASH_NONE = 2;
    Transaction2.SIGHASH_SINGLE = 3;
    Transaction2.SIGHASH_ANYONECANPAY = 128;
    Transaction2.SIGHASH_OUTPUT_MASK = 3;
    Transaction2.SIGHASH_INPUT_MASK = 128;
    Transaction2.ADVANCED_TRANSACTION_FLAG = 1;
    function getOutputWitnessesSHA256(outs) {
      const outProofsSize = (o) => (0, bufferutils_1.varSliceSize)(o.rangeProof || import_buffer.Buffer.alloc(0)) + (0, bufferutils_1.varSliceSize)(o.surjectionProof || import_buffer.Buffer.alloc(0));
      const size = outs.reduce((sum, o) => sum + outProofsSize(o), 0);
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(size);
      for (const out of outs) {
        bufferWriter.writeVarSlice(out.surjectionProof || import_buffer.Buffer.of(0));
        bufferWriter.writeVarSlice(out.rangeProof || import_buffer.Buffer.of(0));
      }
      return bcrypto.sha256(bufferWriter.end());
    }
    function getIssuanceProofsSHA256(ins) {
      const inProofsSize = (i) => (0, bufferutils_1.varSliceSize)(i.issuanceRangeProof || import_buffer.Buffer.alloc(1)) + (0, bufferutils_1.varSliceSize)(i.inflationRangeProof || import_buffer.Buffer.alloc(1));
      const size = ins.reduce((sum, i) => sum + inProofsSize(i), 0);
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(size);
      for (const input of ins) {
        bufferWriter.writeVarSlice(input.issuanceRangeProof || import_buffer.Buffer.of(0));
        bufferWriter.writeVarSlice(input.inflationRangeProof || import_buffer.Buffer.of(0));
      }
      return bcrypto.sha256(bufferWriter.end());
    }
    function getSpentAssetsAmountsSHA256(outs) {
      const size = outs.reduce(
        (sum, o) => sum + o.asset.length + o.value.length,
        0
      );
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(size);
      for (const out of outs) {
        bufferWriter.writeSlice(out.asset);
        bufferWriter.writeSlice(out.value);
      }
      return bcrypto.sha256(bufferWriter.end());
    }
    function getInputFlag(input) {
      const hasIssuance = input.issuance !== void 0;
      return (hasIssuance ? OUTPOINT_ISSUANCE_FLAG >>> 24 : 0) | (input.isPegin ? OUTPOINT_PEGIN_FLAG >>> 24 : 0);
    }
    function getOutpointFlagsSHA256(ins) {
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(ins.length);
      for (const input of ins) {
        bufferWriter.writeUInt8(getInputFlag(input));
      }
      return bcrypto.sha256(bufferWriter.end());
    }
    function getIssuanceSize(txIn) {
      if (txIn.issuance) {
        return txIn.issuance.assetBlindingNonce.length + txIn.issuance.assetEntropy.length + txIn.issuance.assetAmount.length + txIn.issuance.tokenAmount.length;
      }
      return 0;
    }
    function getPrevoutsSHA256(inputs2) {
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        inputs2.length * (32 + 4)
      );
      for (const i of inputs2) {
        bufferWriter.writeSlice(i.hash);
        bufferWriter.writeUInt32(i.index);
      }
      return bcrypto.sha256(bufferWriter.end());
    }
    function getPrevoutScriptsSHA256(scripts) {
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        scripts.map(bufferutils_1.varSliceSize).reduce((a, b) => a + b)
      );
      scripts.forEach((prevOutScript) => bufferWriter.writeVarSlice(prevOutScript));
      return bcrypto.sha256(bufferWriter.end());
    }
    function getSequenceSHA256(inputs2) {
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        4 * inputs2.length
      );
      inputs2.forEach((txIn) => bufferWriter.writeUInt32(txIn.sequence));
      return bcrypto.sha256(bufferWriter.end());
    }
    function getIssuanceSHA256(inputs2) {
      const sizeOfIssuances = inputs2.reduce(
        (sum, txIn) => txIn.issuance ? sum + getIssuanceSize(txIn) : sum + 1,
        0
      );
      const size = sizeOfIssuances === 0 ? inputs2.length : sizeOfIssuances;
      const writer = bufferutils_1.BufferWriter.withCapacity(size);
      inputs2.forEach((txIn) => {
        if (txIn.issuance) {
          writer.writeSlice(txIn.issuance.assetBlindingNonce);
          writer.writeSlice(txIn.issuance.assetEntropy);
          writer.writeSlice(txIn.issuance.assetAmount);
          writer.writeSlice(txIn.issuance.tokenAmount);
        } else {
          writer.writeSlice(import_buffer.Buffer.of(0));
        }
      });
      return bcrypto.sha256(writer.end());
    }
    function getOutputsSHA256(outputs2) {
      const txOutsSize = outputs2.reduce(
        (sum, output) => sum + output.asset.length + output.value.length + output.nonce.length + (0, bufferutils_1.varSliceSize)(output.script),
        0
      );
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);
      outputs2.forEach((out) => {
        bufferWriter.writeSlice(out.asset);
        bufferWriter.writeSlice(out.value);
        bufferWriter.writeSlice(out.nonce);
        bufferWriter.writeVarSlice(out.script);
      });
      return bcrypto.sha256(bufferWriter.end());
    }
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/confidential.js
var require_confidential = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/confidential.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.satoshiToConfidentialValue = exports2.confidentialValueToSatoshi = exports2.Confidential = void 0;
    var crypto2 = __importStar(require_crypto());
    var transaction_1 = require_transaction();
    var value_1 = require_value();
    var Confidential = class {
      constructor(zkp) {
        this.zkp = zkp;
      }
      nonceHash(pubkey, privkey) {
        return crypto2.sha256(import_buffer.Buffer.from(this.zkp.ecdh(pubkey, privkey)));
      }
      valueBlindingFactor(inValues, outValues, inAssetBlinders, outAssetBlinders, inValueBlinders, outValueBlinders) {
        const values = inValues.concat(outValues);
        const nInputs = inValues.length;
        const assetBlinders = inAssetBlinders.concat(outAssetBlinders);
        const valueBlinders = inValueBlinders.concat(outValueBlinders);
        return import_buffer.Buffer.from(
          this.zkp.pedersen.blindGeneratorBlindSum(
            values,
            assetBlinders,
            valueBlinders,
            nInputs
          )
        );
      }
      valueCommitment(value2, generator, blinder) {
        const { pedersen } = this.zkp;
        return import_buffer.Buffer.from(pedersen.commitment(value2, generator, blinder));
      }
      assetCommitment(asset, factor) {
        const { generator } = this.zkp;
        return import_buffer.Buffer.from(generator.generateBlinded(asset, factor));
      }
      unblindOutputWithKey(out, blindingPrivKey) {
        const nonce = this.nonceHash(out.nonce, blindingPrivKey);
        return this.unblindOutputWithNonce(out, nonce);
      }
      unblindOutputWithNonce(out, nonce) {
        if (!out.rangeProof || out.rangeProof.length === 0) {
          throw new Error("Missing rangeproof to rewind");
        }
        const secp = this.zkp;
        const { value: value2, blinder, message } = secp.rangeproof.rewind(
          out.rangeProof,
          out.value,
          out.asset,
          nonce,
          out.script
        );
        return {
          value: value2,
          asset: import_buffer.Buffer.from(message.slice(0, 32)),
          valueBlindingFactor: import_buffer.Buffer.from(blinder),
          assetBlindingFactor: import_buffer.Buffer.from(message.slice(32))
        };
      }
      rangeProofInfo(proof) {
        const { rangeproof } = this.zkp;
        const { exp, mantissa, minValue: minValue3, maxValue: maxValue4 } = rangeproof.info(proof);
        return {
          minValue: parseInt(minValue3, 10),
          maxValue: parseInt(maxValue4, 10),
          ctExp: parseInt(exp, 10),
          ctBits: parseInt(mantissa, 10)
        };
      }
      /**
       *  nonceHash from blinding key + ephemeral key and then rangeProof computation
       */
      rangeProofWithNonceHash(blindingPubkey, ephemeralPrivkey, value2, asset, valueCommitment, assetCommitment, valueBlinder, assetBlinder, scriptPubkey, minValue3, exp, minBits) {
        const nonce = this.nonceHash(blindingPubkey, ephemeralPrivkey);
        return this.rangeProof(
          value2,
          asset,
          valueCommitment,
          assetCommitment,
          valueBlinder,
          assetBlinder,
          nonce,
          scriptPubkey,
          minValue3,
          exp,
          minBits
        );
      }
      rangeProofVerify(proof, valueCommitment, assetCommitment, script) {
        const { rangeproof } = this.zkp;
        return rangeproof.verify(proof, valueCommitment, assetCommitment, script);
      }
      /**
       *  rangeProof computation without nonceHash step.
       */
      rangeProof(value2, asset, valueCommitment, assetCommitment, valueBlinder, assetBlinder, nonce, scriptPubkey, minValue3 = "1", exp = "0", minBits = "52") {
        const { rangeproof } = this.zkp;
        const message = import_buffer.Buffer.concat([asset, assetBlinder]);
        return import_buffer.Buffer.from(
          rangeproof.sign(
            value2,
            valueCommitment,
            assetCommitment,
            valueBlinder,
            nonce,
            parseInt(value2, 10) === 0 ? "0" : minValue3,
            exp,
            minBits,
            message,
            scriptPubkey
          )
        );
      }
      surjectionProof(outputAsset, outputAssetBlindingFactor, inputAssets, inputAssetBlindingFactors, seed) {
        const { generator, surjectionproof } = this.zkp;
        const outputGenerator = generator.generateBlinded(
          outputAsset,
          outputAssetBlindingFactor
        );
        const inputGenerators = inputAssets.map(
          (v, i) => generator.generateBlinded(v, inputAssetBlindingFactors[i])
        );
        const maxIterations = 100;
        const init = surjectionproof.initialize(
          inputAssets,
          outputAsset,
          maxIterations,
          seed
        );
        return import_buffer.Buffer.from(
          surjectionproof.generate(
            init.proof,
            inputGenerators,
            outputGenerator,
            init.inputIndex,
            inputAssetBlindingFactors[init.inputIndex],
            outputAssetBlindingFactor
          )
        );
      }
      surjectionProofVerify(inAssets, inAssetBlinders, outAsset, outAssetBlinder, proof) {
        const { generator, surjectionproof } = this.zkp;
        const inGenerators = inAssets.map(
          (v, i) => generator.generateBlinded(v, inAssetBlinders[i])
        );
        const outGenerator = generator.generateBlinded(outAsset, outAssetBlinder);
        return surjectionproof.verify(proof, inGenerators, outGenerator);
      }
      blindValueProof(value2, valueCommitment, assetCommitment, valueBlinder, nonce) {
        const { rangeproof } = this.zkp;
        return import_buffer.Buffer.from(
          rangeproof.sign(
            value2,
            valueCommitment,
            assetCommitment,
            valueBlinder,
            nonce,
            value2,
            "-1"
          )
        );
      }
      blindAssetProof(asset, assetCommitment, assetBlinder) {
        const { generator, surjectionproof } = this.zkp;
        const maxIterations = 100;
        const gen = generator.generate(asset);
        const init = surjectionproof.initialize(
          [asset],
          asset,
          maxIterations,
          transaction_1.ZERO
        );
        return import_buffer.Buffer.from(
          surjectionproof.generate(
            init.proof,
            [gen],
            assetCommitment,
            init.inputIndex,
            transaction_1.ZERO,
            assetBlinder
          )
        );
      }
      assetBlindProofVerify(asset, assetCommitment, proof) {
        const { generator, surjectionproof } = this.zkp;
        const inGenerators = [generator.generate(asset)];
        const outGenerator = assetCommitment;
        return surjectionproof.verify(proof, inGenerators, outGenerator);
      }
    };
    exports2.Confidential = Confidential;
    function confidentialValueToSatoshi(value2) {
      return value_1.ElementsValue.fromBytes(value2).number;
    }
    exports2.confidentialValueToSatoshi = confidentialValueToSatoshi;
    function satoshiToConfidentialValue(amount) {
      return value_1.ElementsValue.fromNumber(amount).bytes;
    }
    exports2.satoshiToConfidentialValue = satoshiToConfidentialValue;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/asset.js
var require_asset = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/asset.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AssetHash = void 0;
    var AssetHash = class _AssetHash {
      constructor(prefix, value2) {
        this.prefix = prefix;
        this.value = value2;
      }
      static fromHex(hex) {
        const bytes = import_buffer.Buffer.from(hex, "hex");
        if (bytes.length === 32) {
          return this.fromBytes(bytes.reverse());
        }
        return this.fromBytes(bytes);
      }
      static fromBytes(bytes) {
        if (bytes.length === 32) {
          return new _AssetHash(_AssetHash.UNCONFIDENTIAL_PREFIX, bytes);
        }
        const prefix = bytes.length > 0 ? bytes[0] : 0;
        const value2 = bytes.length > 1 ? bytes.slice(1) : import_buffer.Buffer.alloc(0);
        if (prefix !== _AssetHash.UNCONFIDENTIAL_PREFIX && !_AssetHash.CONFIDENTIAL_PREFIXES.includes(prefix)) {
          throw new Error("Invalid asset prefix");
        }
        if (prefix === _AssetHash.UNCONFIDENTIAL_PREFIX && value2.length !== 32) {
          throw new Error("Invalid unconfidential asset length");
        }
        if (_AssetHash.CONFIDENTIAL_PREFIXES.includes(prefix) && value2.length !== 32) {
          throw new Error("Invalid confidential asset length");
        }
        return new _AssetHash(prefix, value2);
      }
      get hex() {
        if (this.prefix === _AssetHash.UNCONFIDENTIAL_PREFIX) {
          return reverseWithoutMutate(this.value).toString("hex");
        }
        return import_buffer.Buffer.concat([import_buffer.Buffer.of(this.prefix), this.value]).toString("hex");
      }
      get bytes() {
        return import_buffer.Buffer.concat([import_buffer.Buffer.of(this.prefix), this.value]);
      }
      get bytesWithoutPrefix() {
        return this.value;
      }
      get isConfidential() {
        return this.prefix !== _AssetHash.UNCONFIDENTIAL_PREFIX;
      }
    };
    exports2.AssetHash = AssetHash;
    AssetHash.UNCONFIDENTIAL_PREFIX = 1;
    AssetHash.CONFIDENTIAL_PREFIXES = [10, 11];
    function reverseWithoutMutate(buf2) {
      return import_buffer.Buffer.from(buf2).reverse();
    }
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/fields.js
var require_fields = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/fields.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OutputProprietaryTypes = exports2.OutputTypes = exports2.InputProprietaryTypes = exports2.InputTypes = exports2.GLOBAL_PROPRIETARY_TYPE_NAMES = exports2.GlobalProprietaryTypes = exports2.GlobalTypes = exports2.separator = void 0;
    exports2.separator = 0;
    var GlobalTypes2;
    (function(GlobalTypes3) {
      GlobalTypes3[GlobalTypes3["XPUB"] = 1] = "XPUB";
      GlobalTypes3[GlobalTypes3["TX_VERSION"] = 2] = "TX_VERSION";
      GlobalTypes3[GlobalTypes3["FALLBACK_LOCKTIME"] = 3] = "FALLBACK_LOCKTIME";
      GlobalTypes3[GlobalTypes3["INPUT_COUNT"] = 4] = "INPUT_COUNT";
      GlobalTypes3[GlobalTypes3["OUTPUT_COUNT"] = 5] = "OUTPUT_COUNT";
      GlobalTypes3[GlobalTypes3["TX_MODIFIABLE"] = 6] = "TX_MODIFIABLE";
      GlobalTypes3[GlobalTypes3["SIGHASH_SINGLE_INPUTS"] = 7] = "SIGHASH_SINGLE_INPUTS";
      GlobalTypes3[GlobalTypes3["VERSION"] = 251] = "VERSION";
      GlobalTypes3[GlobalTypes3["PROPRIETARY"] = 252] = "PROPRIETARY";
    })(GlobalTypes2 = exports2.GlobalTypes || (exports2.GlobalTypes = {}));
    var GlobalProprietaryTypes;
    (function(GlobalProprietaryTypes2) {
      GlobalProprietaryTypes2[GlobalProprietaryTypes2["SCALAR"] = 0] = "SCALAR";
      GlobalProprietaryTypes2[GlobalProprietaryTypes2["TX_MODIFIABLE"] = 1] = "TX_MODIFIABLE";
    })(
      GlobalProprietaryTypes = exports2.GlobalProprietaryTypes || (exports2.GlobalProprietaryTypes = {})
    );
    exports2.GLOBAL_PROPRIETARY_TYPE_NAMES = ["scalar", "txModifiable"];
    var InputTypes2;
    (function(InputTypes3) {
      InputTypes3[InputTypes3["NON_WITNESS_UTXO"] = 0] = "NON_WITNESS_UTXO";
      InputTypes3[InputTypes3["WITNESS_UTXO"] = 1] = "WITNESS_UTXO";
      InputTypes3[InputTypes3["PARTIAL_SIG"] = 2] = "PARTIAL_SIG";
      InputTypes3[InputTypes3["SIGHASH_TYPE"] = 3] = "SIGHASH_TYPE";
      InputTypes3[InputTypes3["REDEEM_SCRIPT"] = 4] = "REDEEM_SCRIPT";
      InputTypes3[InputTypes3["WITNESS_SCRIPT"] = 5] = "WITNESS_SCRIPT";
      InputTypes3[InputTypes3["BIP32_DERIVATION"] = 6] = "BIP32_DERIVATION";
      InputTypes3[InputTypes3["FINAL_SCRIPTSIG"] = 7] = "FINAL_SCRIPTSIG";
      InputTypes3[InputTypes3["FINAL_SCRIPTWITNESS"] = 8] = "FINAL_SCRIPTWITNESS";
      InputTypes3[InputTypes3["POR_COMMITMENT"] = 9] = "POR_COMMITMENT";
      InputTypes3[InputTypes3["RIPEMD_160"] = 10] = "RIPEMD_160";
      InputTypes3[InputTypes3["SHA_256"] = 11] = "SHA_256";
      InputTypes3[InputTypes3["HASH_160"] = 12] = "HASH_160";
      InputTypes3[InputTypes3["HASH_256"] = 13] = "HASH_256";
      InputTypes3[InputTypes3["PREVIOUS_TXID"] = 14] = "PREVIOUS_TXID";
      InputTypes3[InputTypes3["PREVIOUS_TXINDEX"] = 15] = "PREVIOUS_TXINDEX";
      InputTypes3[InputTypes3["SEQUENCE"] = 16] = "SEQUENCE";
      InputTypes3[InputTypes3["REQUIRED_TIME_LOCKTIME"] = 17] = "REQUIRED_TIME_LOCKTIME";
      InputTypes3[InputTypes3["REQUIRED_HEIGHT_LOCKTIME"] = 18] = "REQUIRED_HEIGHT_LOCKTIME";
      InputTypes3[InputTypes3["TAP_KEY_SIG"] = 19] = "TAP_KEY_SIG";
      InputTypes3[InputTypes3["TAP_SCRIPT_SIG"] = 20] = "TAP_SCRIPT_SIG";
      InputTypes3[InputTypes3["TAP_LEAF_SCRIPT"] = 21] = "TAP_LEAF_SCRIPT";
      InputTypes3[InputTypes3["TAP_BIP32_DERIVATION"] = 22] = "TAP_BIP32_DERIVATION";
      InputTypes3[InputTypes3["TAP_INTERNAL_KEY"] = 23] = "TAP_INTERNAL_KEY";
      InputTypes3[InputTypes3["TAP_MERKLE_ROOT"] = 24] = "TAP_MERKLE_ROOT";
      InputTypes3[InputTypes3["PROPRIETARY"] = 252] = "PROPRIETARY";
    })(InputTypes2 = exports2.InputTypes || (exports2.InputTypes = {}));
    var InputProprietaryTypes;
    (function(InputProprietaryTypes2) {
      InputProprietaryTypes2[InputProprietaryTypes2["ISSUANCE_VALUE"] = 0] = "ISSUANCE_VALUE";
      InputProprietaryTypes2[InputProprietaryTypes2["ISSUANCE_VALUE_COMMITMENT"] = 1] = "ISSUANCE_VALUE_COMMITMENT";
      InputProprietaryTypes2[InputProprietaryTypes2["ISSUANCE_VALUE_RANGEPROOF"] = 2] = "ISSUANCE_VALUE_RANGEPROOF";
      InputProprietaryTypes2[InputProprietaryTypes2["ISSUANCE_INFLATION_KEYS_RANGEPROOF"] = 3] = "ISSUANCE_INFLATION_KEYS_RANGEPROOF";
      InputProprietaryTypes2[InputProprietaryTypes2["PEGIN_TX"] = 4] = "PEGIN_TX";
      InputProprietaryTypes2[InputProprietaryTypes2["PEGIN_TXOUT_PROOF"] = 5] = "PEGIN_TXOUT_PROOF";
      InputProprietaryTypes2[InputProprietaryTypes2["PEGIN_GENESIS_HASH"] = 6] = "PEGIN_GENESIS_HASH";
      InputProprietaryTypes2[InputProprietaryTypes2["PEGIN_CLAIM_SCRIPT"] = 7] = "PEGIN_CLAIM_SCRIPT";
      InputProprietaryTypes2[InputProprietaryTypes2["PEGIN_VALUE"] = 8] = "PEGIN_VALUE";
      InputProprietaryTypes2[InputProprietaryTypes2["PEGIN_WITNESS"] = 9] = "PEGIN_WITNESS";
      InputProprietaryTypes2[InputProprietaryTypes2["ISSUANCE_INFLATION_KEYS"] = 10] = "ISSUANCE_INFLATION_KEYS";
      InputProprietaryTypes2[InputProprietaryTypes2["ISSUANCE_INFLATION_KEYS_COMMITMENT"] = 11] = "ISSUANCE_INFLATION_KEYS_COMMITMENT";
      InputProprietaryTypes2[InputProprietaryTypes2["ISSUANCE_BLINDING_NONCE"] = 12] = "ISSUANCE_BLINDING_NONCE";
      InputProprietaryTypes2[InputProprietaryTypes2["ISSUANCE_ASSET_ENTROPY"] = 13] = "ISSUANCE_ASSET_ENTROPY";
      InputProprietaryTypes2[InputProprietaryTypes2["UTXO_RANGEPROOF"] = 14] = "UTXO_RANGEPROOF";
      InputProprietaryTypes2[InputProprietaryTypes2["ISSUANCE_BLIND_VALUE_PROOF"] = 15] = "ISSUANCE_BLIND_VALUE_PROOF";
      InputProprietaryTypes2[InputProprietaryTypes2["ISSUANCE_BLIND_INFLATION_KEYS_PROOF"] = 16] = "ISSUANCE_BLIND_INFLATION_KEYS_PROOF";
      InputProprietaryTypes2[InputProprietaryTypes2["EXPLICIT_VALUE"] = 17] = "EXPLICIT_VALUE";
      InputProprietaryTypes2[InputProprietaryTypes2["VALUE_PROOF"] = 18] = "VALUE_PROOF";
      InputProprietaryTypes2[InputProprietaryTypes2["EXPLICIT_ASSET"] = 19] = "EXPLICIT_ASSET";
      InputProprietaryTypes2[InputProprietaryTypes2["ASSET_PROOF"] = 20] = "ASSET_PROOF";
      InputProprietaryTypes2[InputProprietaryTypes2["BLINDED_ISSUANCE"] = 21] = "BLINDED_ISSUANCE";
    })(
      InputProprietaryTypes = exports2.InputProprietaryTypes || (exports2.InputProprietaryTypes = {})
    );
    var OutputTypes2;
    (function(OutputTypes3) {
      OutputTypes3[OutputTypes3["REDEEM_SCRIPT"] = 0] = "REDEEM_SCRIPT";
      OutputTypes3[OutputTypes3["WITNESS_SCRIPT"] = 1] = "WITNESS_SCRIPT";
      OutputTypes3[OutputTypes3["BIP32_DERIVATION"] = 2] = "BIP32_DERIVATION";
      OutputTypes3[OutputTypes3["AMOUNT"] = 3] = "AMOUNT";
      OutputTypes3[OutputTypes3["SCRIPT"] = 4] = "SCRIPT";
      OutputTypes3[OutputTypes3["TAP_INTERNAL_KEY"] = 5] = "TAP_INTERNAL_KEY";
      OutputTypes3[OutputTypes3["TAP_TREE"] = 6] = "TAP_TREE";
      OutputTypes3[OutputTypes3["TAP_BIP32_DERIVATION"] = 7] = "TAP_BIP32_DERIVATION";
      OutputTypes3[OutputTypes3["PROPRIETARY"] = 252] = "PROPRIETARY";
    })(OutputTypes2 = exports2.OutputTypes || (exports2.OutputTypes = {}));
    var OutputProprietaryTypes;
    (function(OutputProprietaryTypes2) {
      OutputProprietaryTypes2[OutputProprietaryTypes2["VALUE_COMMITMENT"] = 1] = "VALUE_COMMITMENT";
      OutputProprietaryTypes2[OutputProprietaryTypes2["ASSET"] = 2] = "ASSET";
      OutputProprietaryTypes2[OutputProprietaryTypes2["ASSET_COMMITMENT"] = 3] = "ASSET_COMMITMENT";
      OutputProprietaryTypes2[OutputProprietaryTypes2["VALUE_RANGEPROOF"] = 4] = "VALUE_RANGEPROOF";
      OutputProprietaryTypes2[OutputProprietaryTypes2["ASSET_SURJECTION_PROOF"] = 5] = "ASSET_SURJECTION_PROOF";
      OutputProprietaryTypes2[OutputProprietaryTypes2["BLINDING_PUBKEY"] = 6] = "BLINDING_PUBKEY";
      OutputProprietaryTypes2[OutputProprietaryTypes2["ECDH_PUBKEY"] = 7] = "ECDH_PUBKEY";
      OutputProprietaryTypes2[OutputProprietaryTypes2["BLINDER_INDEX"] = 8] = "BLINDER_INDEX";
      OutputProprietaryTypes2[OutputProprietaryTypes2["BLIND_VALUE_PROOF"] = 9] = "BLIND_VALUE_PROOF";
      OutputProprietaryTypes2[OutputProprietaryTypes2["BLIND_ASSET_PROOF"] = 10] = "BLIND_ASSET_PROOF";
    })(
      OutputProprietaryTypes = exports2.OutputProprietaryTypes || (exports2.OutputProprietaryTypes = {})
    );
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/key_pair.js
var require_key_pair = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/key_pair.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyPair = exports2.Key = exports2.ErrEmptyKey = void 0;
    var bufferutils_1 = require_bufferutils();
    exports2.ErrEmptyKey = new Error("no more key pairs");
    var Key = class _Key {
      constructor(keyType, keyData) {
        this.keyType = keyType;
        this.keyData = keyData || import_buffer.Buffer.from([]);
      }
      static fromBuffer(r) {
        const value2 = r.readVarSlice();
        if (value2.length === 0) {
          throw exports2.ErrEmptyKey;
        }
        if (value2.length > 1e4) {
          throw new Error("invalid key size");
        }
        return new _Key(value2[0], value2.slice(1));
      }
      toBuffer() {
        const buf2 = import_buffer.Buffer.concat([import_buffer.Buffer.of(this.keyType), this.keyData]);
        const size = bufferutils_1.varuint.encodingLength(buf2.length) + buf2.length;
        const w = bufferutils_1.BufferWriter.withCapacity(size);
        w.writeVarSlice(buf2);
        return w.buffer;
      }
    };
    exports2.Key = Key;
    var KeyPair = class _KeyPair {
      constructor(key, value2) {
        this.key = key;
        this.value = value2 || import_buffer.Buffer.from([]);
      }
      static fromBuffer(r) {
        const key = Key.fromBuffer(r);
        const value2 = r.readVarSlice();
        return new _KeyPair(key, value2);
      }
      toBuffer() {
        const keyBuf = this.key.toBuffer();
        const size = keyBuf.length + bufferutils_1.varuint.encodingLength(this.value.length) + this.value.length;
        const w = bufferutils_1.BufferWriter.withCapacity(size);
        w.writeSlice(keyBuf);
        w.writeVarSlice(this.value);
        return w.buffer;
      }
    };
    exports2.KeyPair = KeyPair;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/networks.js
var require_networks3 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/networks.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.testnet = exports2.regtest = exports2.bitcoin = void 0;
    exports2.bitcoin = {
      /**
       * The message prefix used for signing Bitcoin messages.
       */
      messagePrefix: "Bitcoin Signed Message:\n",
      /**
       * The Bech32 prefix used for Bitcoin addresses.
       */
      bech32: "bc",
      /**
       * The BIP32 key prefixes for Bitcoin.
       */
      bip32: {
        /**
         * The public key prefix for BIP32 extended public keys.
         */
        public: 76067358,
        /**
         * The private key prefix for BIP32 extended private keys.
         */
        private: 76066276
      },
      /**
       * The prefix for Bitcoin public key hashes.
       */
      pubKeyHash: 0,
      /**
       * The prefix for Bitcoin script hashes.
       */
      scriptHash: 5,
      /**
       * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
       */
      wif: 128
    };
    exports2.regtest = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "bcrt",
      bip32: {
        public: 70617039,
        private: 70615956
      },
      pubKeyHash: 111,
      scriptHash: 196,
      wif: 239
    };
    exports2.testnet = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "tb",
      bip32: {
        public: 70617039,
        private: 70615956
      },
      pubKeyHash: 111,
      scriptHash: 196,
      wif: 239
    };
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/bip66.js
var require_bip662 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/bip66.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encode = exports2.decode = exports2.check = void 0;
    function check15(buffer2) {
      if (buffer2.length < 8) return false;
      if (buffer2.length > 72) return false;
      if (buffer2[0] !== 48) return false;
      if (buffer2[1] !== buffer2.length - 2) return false;
      if (buffer2[2] !== 2) return false;
      const lenR = buffer2[3];
      if (lenR === 0) return false;
      if (5 + lenR >= buffer2.length) return false;
      if (buffer2[4 + lenR] !== 2) return false;
      const lenS = buffer2[5 + lenR];
      if (lenS === 0) return false;
      if (6 + lenR + lenS !== buffer2.length) return false;
      if (buffer2[4] & 128) return false;
      if (lenR > 1 && buffer2[4] === 0 && !(buffer2[5] & 128)) return false;
      if (buffer2[lenR + 6] & 128) return false;
      if (lenS > 1 && buffer2[lenR + 6] === 0 && !(buffer2[lenR + 7] & 128))
        return false;
      return true;
    }
    exports2.check = check15;
    function decode44(buffer2) {
      if (buffer2.length < 8) throw new Error("DER sequence length is too short");
      if (buffer2.length > 72) throw new Error("DER sequence length is too long");
      if (buffer2[0] !== 48) throw new Error("Expected DER sequence");
      if (buffer2[1] !== buffer2.length - 2)
        throw new Error("DER sequence length is invalid");
      if (buffer2[2] !== 2) throw new Error("Expected DER integer");
      const lenR = buffer2[3];
      if (lenR === 0) throw new Error("R length is zero");
      if (5 + lenR >= buffer2.length) throw new Error("R length is too long");
      if (buffer2[4 + lenR] !== 2) throw new Error("Expected DER integer (2)");
      const lenS = buffer2[5 + lenR];
      if (lenS === 0) throw new Error("S length is zero");
      if (6 + lenR + lenS !== buffer2.length) throw new Error("S length is invalid");
      if (buffer2[4] & 128) throw new Error("R value is negative");
      if (lenR > 1 && buffer2[4] === 0 && !(buffer2[5] & 128))
        throw new Error("R value excessively padded");
      if (buffer2[lenR + 6] & 128) throw new Error("S value is negative");
      if (lenS > 1 && buffer2[lenR + 6] === 0 && !(buffer2[lenR + 7] & 128))
        throw new Error("S value excessively padded");
      return {
        r: buffer2.slice(4, 4 + lenR),
        s: buffer2.slice(6 + lenR)
      };
    }
    exports2.decode = decode44;
    function encode42(r, s) {
      const lenR = r.length;
      const lenS = s.length;
      if (lenR === 0) throw new Error("R length is zero");
      if (lenS === 0) throw new Error("S length is zero");
      if (lenR > 33) throw new Error("R length is too long");
      if (lenS > 33) throw new Error("S length is too long");
      if (r[0] & 128) throw new Error("R value is negative");
      if (s[0] & 128) throw new Error("S value is negative");
      if (lenR > 1 && r[0] === 0 && !(r[1] & 128))
        throw new Error("R value excessively padded");
      if (lenS > 1 && s[0] === 0 && !(s[1] & 128))
        throw new Error("S value excessively padded");
      const signature2 = import_buffer.Buffer.allocUnsafe(6 + lenR + lenS);
      signature2[0] = 48;
      signature2[1] = signature2.length - 2;
      signature2[2] = 2;
      signature2[3] = r.length;
      r.copy(signature2, 4);
      signature2[4 + lenR] = 2;
      signature2[5 + lenR] = s.length;
      s.copy(signature2, 6 + lenR);
      return signature2;
    }
    exports2.encode = encode42;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/ops.js
var require_ops2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/ops.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.REVERSE_OPS = exports2.OPS = void 0;
    var OPS10 = {
      OP_FALSE: 0,
      OP_0: 0,
      OP_PUSHDATA1: 76,
      OP_PUSHDATA2: 77,
      OP_PUSHDATA4: 78,
      OP_1NEGATE: 79,
      OP_RESERVED: 80,
      OP_TRUE: 81,
      OP_1: 81,
      OP_2: 82,
      OP_3: 83,
      OP_4: 84,
      OP_5: 85,
      OP_6: 86,
      OP_7: 87,
      OP_8: 88,
      OP_9: 89,
      OP_10: 90,
      OP_11: 91,
      OP_12: 92,
      OP_13: 93,
      OP_14: 94,
      OP_15: 95,
      OP_16: 96,
      OP_NOP: 97,
      OP_VER: 98,
      OP_IF: 99,
      OP_NOTIF: 100,
      OP_VERIF: 101,
      OP_VERNOTIF: 102,
      OP_ELSE: 103,
      OP_ENDIF: 104,
      OP_VERIFY: 105,
      OP_RETURN: 106,
      OP_TOALTSTACK: 107,
      OP_FROMALTSTACK: 108,
      OP_2DROP: 109,
      OP_2DUP: 110,
      OP_3DUP: 111,
      OP_2OVER: 112,
      OP_2ROT: 113,
      OP_2SWAP: 114,
      OP_IFDUP: 115,
      OP_DEPTH: 116,
      OP_DROP: 117,
      OP_DUP: 118,
      OP_NIP: 119,
      OP_OVER: 120,
      OP_PICK: 121,
      OP_ROLL: 122,
      OP_ROT: 123,
      OP_SWAP: 124,
      OP_TUCK: 125,
      OP_CAT: 126,
      OP_SUBSTR: 127,
      OP_LEFT: 128,
      OP_RIGHT: 129,
      OP_SIZE: 130,
      OP_INVERT: 131,
      OP_AND: 132,
      OP_OR: 133,
      OP_XOR: 134,
      OP_EQUAL: 135,
      OP_EQUALVERIFY: 136,
      OP_RESERVED1: 137,
      OP_RESERVED2: 138,
      OP_1ADD: 139,
      OP_1SUB: 140,
      OP_2MUL: 141,
      OP_2DIV: 142,
      OP_NEGATE: 143,
      OP_ABS: 144,
      OP_NOT: 145,
      OP_0NOTEQUAL: 146,
      OP_ADD: 147,
      OP_SUB: 148,
      OP_MUL: 149,
      OP_DIV: 150,
      OP_MOD: 151,
      OP_LSHIFT: 152,
      OP_RSHIFT: 153,
      OP_BOOLAND: 154,
      OP_BOOLOR: 155,
      OP_NUMEQUAL: 156,
      OP_NUMEQUALVERIFY: 157,
      OP_NUMNOTEQUAL: 158,
      OP_LESSTHAN: 159,
      OP_GREATERTHAN: 160,
      OP_LESSTHANOREQUAL: 161,
      OP_GREATERTHANOREQUAL: 162,
      OP_MIN: 163,
      OP_MAX: 164,
      OP_WITHIN: 165,
      OP_RIPEMD160: 166,
      OP_SHA1: 167,
      OP_SHA256: 168,
      OP_HASH160: 169,
      OP_HASH256: 170,
      OP_CODESEPARATOR: 171,
      OP_CHECKSIG: 172,
      OP_CHECKSIGVERIFY: 173,
      OP_CHECKMULTISIG: 174,
      OP_CHECKMULTISIGVERIFY: 175,
      OP_NOP1: 176,
      OP_NOP2: 177,
      OP_CHECKLOCKTIMEVERIFY: 177,
      OP_NOP3: 178,
      OP_CHECKSEQUENCEVERIFY: 178,
      OP_NOP4: 179,
      OP_NOP5: 180,
      OP_NOP6: 181,
      OP_NOP7: 182,
      OP_NOP8: 183,
      OP_NOP9: 184,
      OP_NOP10: 185,
      OP_CHECKSIGADD: 186,
      OP_PUBKEYHASH: 253,
      OP_PUBKEY: 254,
      OP_INVALIDOPCODE: 255
    };
    exports2.OPS = OPS10;
    var REVERSE_OPS = {};
    exports2.REVERSE_OPS = REVERSE_OPS;
    for (const op of Object.keys(OPS10)) {
      const code10 = OPS10[op];
      REVERSE_OPS[code10] = op;
    }
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/push_data.js
var require_push_data2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/push_data.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decode = exports2.encode = exports2.encodingLength = void 0;
    var ops_1 = require_ops2();
    function encodingLength7(i) {
      return i < ops_1.OPS.OP_PUSHDATA1 ? 1 : i <= 255 ? 2 : i <= 65535 ? 3 : 5;
    }
    exports2.encodingLength = encodingLength7;
    function encode42(buffer2, num2, offset) {
      const size = encodingLength7(num2);
      if (size === 1) {
        buffer2.writeUInt8(num2, offset);
      } else if (size === 2) {
        buffer2.writeUInt8(ops_1.OPS.OP_PUSHDATA1, offset);
        buffer2.writeUInt8(num2, offset + 1);
      } else if (size === 3) {
        buffer2.writeUInt8(ops_1.OPS.OP_PUSHDATA2, offset);
        buffer2.writeUInt16LE(num2, offset + 1);
      } else {
        buffer2.writeUInt8(ops_1.OPS.OP_PUSHDATA4, offset);
        buffer2.writeUInt32LE(num2, offset + 1);
      }
      return size;
    }
    exports2.encode = encode42;
    function decode44(buffer2, offset) {
      const opcode = buffer2.readUInt8(offset);
      let num2;
      let size;
      if (opcode < ops_1.OPS.OP_PUSHDATA1) {
        num2 = opcode;
        size = 1;
      } else if (opcode === ops_1.OPS.OP_PUSHDATA1) {
        if (offset + 2 > buffer2.length) return null;
        num2 = buffer2.readUInt8(offset + 1);
        size = 2;
      } else if (opcode === ops_1.OPS.OP_PUSHDATA2) {
        if (offset + 3 > buffer2.length) return null;
        num2 = buffer2.readUInt16LE(offset + 1);
        size = 3;
      } else {
        if (offset + 5 > buffer2.length) return null;
        if (opcode !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
        num2 = buffer2.readUInt32LE(offset + 1);
        size = 5;
      }
      return {
        opcode,
        number: num2,
        size
      };
    }
    exports2.decode = decode44;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script_number.js
var require_script_number2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script_number.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encode = exports2.decode = void 0;
    function decode44(buffer2, maxLength, minimal) {
      maxLength = maxLength || 4;
      minimal = minimal === void 0 ? true : minimal;
      const length6 = buffer2.length;
      if (length6 === 0) return 0;
      if (length6 > maxLength) throw new TypeError("Script number overflow");
      if (minimal) {
        if ((buffer2[length6 - 1] & 127) === 0) {
          if (length6 <= 1 || (buffer2[length6 - 2] & 128) === 0)
            throw new Error("Non-minimally encoded script number");
        }
      }
      if (length6 === 5) {
        const a = buffer2.readUInt32LE(0);
        const b = buffer2.readUInt8(4);
        if (b & 128) return -((b & ~128) * 4294967296 + a);
        return b * 4294967296 + a;
      }
      let result = 0;
      for (let i = 0; i < length6; ++i) {
        result |= buffer2[i] << 8 * i;
      }
      if (buffer2[length6 - 1] & 128)
        return -(result & ~(128 << 8 * (length6 - 1)));
      return result;
    }
    exports2.decode = decode44;
    function scriptNumSize2(i) {
      return i > 2147483647 ? 5 : i > 8388607 ? 4 : i > 32767 ? 3 : i > 127 ? 2 : i > 0 ? 1 : 0;
    }
    function encode42(_number) {
      let value2 = Math.abs(_number);
      const size = scriptNumSize2(value2);
      const buffer2 = import_buffer.Buffer.allocUnsafe(size);
      const negative = _number < 0;
      for (let i = 0; i < size; ++i) {
        buffer2.writeUInt8(value2 & 255, i);
        value2 >>= 8;
      }
      if (buffer2[size - 1] & 128) {
        buffer2.writeUInt8(negative ? 128 : 0, size - 1);
      } else if (negative) {
        buffer2[size - 1] |= 128;
      }
      return buffer2;
    }
    exports2.encode = encode42;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js
var require_types4 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.oneOf = exports2.Null = exports2.BufferN = exports2.Function = exports2.UInt32 = exports2.UInt8 = exports2.tuple = exports2.maybe = exports2.Hex = exports2.Buffer = exports2.String = exports2.Boolean = exports2.Array = exports2.Number = exports2.Hash256bit = exports2.Hash160bit = exports2.Buffer256bit = exports2.isTaptree = exports2.isTapleaf = exports2.TAPLEAF_VERSION_MASK = exports2.Satoshi = exports2.isPoint = exports2.stacksEqual = exports2.typeforce = void 0;
    var buffer_1 = require_buffer();
    exports2.typeforce = require_typeforce();
    var ZERO322 = buffer_1.Buffer.alloc(32, 0);
    var EC_P2 = buffer_1.Buffer.from(
      "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
      "hex"
    );
    function stacksEqual2(a, b) {
      if (a.length !== b.length) return false;
      return a.every((x, i) => {
        return x.equals(b[i]);
      });
    }
    exports2.stacksEqual = stacksEqual2;
    function isPoint3(p) {
      if (!buffer_1.Buffer.isBuffer(p)) return false;
      if (p.length < 33) return false;
      const t = p[0];
      const x = p.slice(1, 33);
      if (x.compare(ZERO322) === 0) return false;
      if (x.compare(EC_P2) >= 0) return false;
      if ((t === 2 || t === 3) && p.length === 33) {
        return true;
      }
      const y = p.slice(33);
      if (y.compare(ZERO322) === 0) return false;
      if (y.compare(EC_P2) >= 0) return false;
      if (t === 4 && p.length === 65) return true;
      return false;
    }
    exports2.isPoint = isPoint3;
    var SATOSHI_MAX = 21 * 1e14;
    function Satoshi(value2) {
      return exports2.typeforce.UInt53(value2) && value2 <= SATOSHI_MAX;
    }
    exports2.Satoshi = Satoshi;
    exports2.TAPLEAF_VERSION_MASK = 254;
    function isTapleaf2(o) {
      if (!o || !("output" in o)) return false;
      if (!buffer_1.Buffer.isBuffer(o.output)) return false;
      if (o.version !== void 0)
        return (o.version & exports2.TAPLEAF_VERSION_MASK) === o.version;
      return true;
    }
    exports2.isTapleaf = isTapleaf2;
    function isTaptree2(scriptTree) {
      if (!(0, exports2.Array)(scriptTree)) return isTapleaf2(scriptTree);
      if (scriptTree.length !== 2) return false;
      return scriptTree.every((t) => isTaptree2(t));
    }
    exports2.isTaptree = isTaptree2;
    exports2.Buffer256bit = exports2.typeforce.BufferN(32);
    exports2.Hash160bit = exports2.typeforce.BufferN(20);
    exports2.Hash256bit = exports2.typeforce.BufferN(32);
    exports2.Number = exports2.typeforce.Number;
    exports2.Array = exports2.typeforce.Array;
    exports2.Boolean = exports2.typeforce.Boolean;
    exports2.String = exports2.typeforce.String;
    exports2.Buffer = exports2.typeforce.Buffer;
    exports2.Hex = exports2.typeforce.Hex;
    exports2.maybe = exports2.typeforce.maybe;
    exports2.tuple = exports2.typeforce.tuple;
    exports2.UInt8 = exports2.typeforce.UInt8;
    exports2.UInt32 = exports2.typeforce.UInt32;
    exports2.Function = exports2.typeforce.Function;
    exports2.BufferN = exports2.typeforce.BufferN;
    exports2.Null = exports2.typeforce.Null;
    exports2.oneOf = exports2.typeforce.oneOf;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script_signature.js
var require_script_signature2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script_signature.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encode = exports2.decode = void 0;
    var bip66 = require_bip662();
    var script_1 = require_script2();
    var types = require_types4();
    var { typeforce } = types;
    var ZERO3 = import_buffer.Buffer.alloc(1, 0);
    function toDER(x) {
      let i = 0;
      while (x[i] === 0) ++i;
      if (i === x.length) return ZERO3;
      x = x.slice(i);
      if (x[0] & 128) return import_buffer.Buffer.concat([ZERO3, x], 1 + x.length);
      return x;
    }
    function fromDER(x) {
      if (x[0] === 0) x = x.slice(1);
      const buffer2 = import_buffer.Buffer.alloc(32, 0);
      const bstart = Math.max(0, 32 - x.length);
      x.copy(buffer2, bstart);
      return buffer2;
    }
    function decode44(buffer2) {
      const hashType = buffer2.readUInt8(buffer2.length - 1);
      if (!(0, script_1.isDefinedHashType)(hashType)) {
        throw new Error("Invalid hashType " + hashType);
      }
      const decoded = bip66.decode(buffer2.slice(0, -1));
      const r = fromDER(decoded.r);
      const s = fromDER(decoded.s);
      const signature2 = import_buffer.Buffer.concat([r, s], 64);
      return { signature: signature2, hashType };
    }
    exports2.decode = decode44;
    function encode42(signature2, hashType) {
      typeforce(
        {
          signature: types.BufferN(64),
          hashType: types.UInt8
        },
        { signature: signature2, hashType }
      );
      if (!(0, script_1.isDefinedHashType)(hashType)) {
        throw new Error("Invalid hashType " + hashType);
      }
      const hashTypeBuffer = import_buffer.Buffer.allocUnsafe(1);
      hashTypeBuffer.writeUInt8(hashType, 0);
      const r = toDER(signature2.slice(0, 32));
      const s = toDER(signature2.slice(32, 64));
      return import_buffer.Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);
    }
    exports2.encode = encode42;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js
var require_script2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signature = exports2.number = exports2.isCanonicalScriptSignature = exports2.isDefinedHashType = exports2.isCanonicalPubKey = exports2.toStack = exports2.fromASM = exports2.toASM = exports2.decompile = exports2.compile = exports2.countNonPushOnlyOPs = exports2.isPushOnly = exports2.OPS = void 0;
    var bip66 = require_bip662();
    var ops_1 = require_ops2();
    Object.defineProperty(exports2, "OPS", {
      enumerable: true,
      get: function() {
        return ops_1.OPS;
      }
    });
    var pushdata = require_push_data2();
    var scriptNumber = require_script_number2();
    var scriptSignature = require_script_signature2();
    var types = require_types4();
    var { typeforce } = types;
    var OP_INT_BASE3 = ops_1.OPS.OP_RESERVED;
    function isOPInt2(value2) {
      return types.Number(value2) && (value2 === ops_1.OPS.OP_0 || value2 >= ops_1.OPS.OP_1 && value2 <= ops_1.OPS.OP_16 || value2 === ops_1.OPS.OP_1NEGATE);
    }
    function isPushOnlyChunk2(value2) {
      return types.Buffer(value2) || isOPInt2(value2);
    }
    function isPushOnly2(value2) {
      return types.Array(value2) && value2.every(isPushOnlyChunk2);
    }
    exports2.isPushOnly = isPushOnly2;
    function countNonPushOnlyOPs2(value2) {
      return value2.length - value2.filter(isPushOnlyChunk2).length;
    }
    exports2.countNonPushOnlyOPs = countNonPushOnlyOPs2;
    function asMinimalOP2(buffer2) {
      if (buffer2.length === 0) return ops_1.OPS.OP_0;
      if (buffer2.length !== 1) return;
      if (buffer2[0] >= 1 && buffer2[0] <= 16) return OP_INT_BASE3 + buffer2[0];
      if (buffer2[0] === 129) return ops_1.OPS.OP_1NEGATE;
    }
    function chunksIsBuffer2(buf2) {
      return import_buffer.Buffer.isBuffer(buf2);
    }
    function chunksIsArray2(buf2) {
      return types.Array(buf2);
    }
    function singleChunkIsBuffer2(buf2) {
      return import_buffer.Buffer.isBuffer(buf2);
    }
    function compile2(chunks) {
      if (chunksIsBuffer2(chunks)) return chunks;
      typeforce(types.Array, chunks);
      const bufferSize = chunks.reduce((accum, chunk) => {
        if (singleChunkIsBuffer2(chunk)) {
          if (chunk.length === 1 && asMinimalOP2(chunk) !== void 0) {
            return accum + 1;
          }
          return accum + pushdata.encodingLength(chunk.length) + chunk.length;
        }
        return accum + 1;
      }, 0);
      const buffer2 = import_buffer.Buffer.allocUnsafe(bufferSize);
      let offset = 0;
      chunks.forEach((chunk) => {
        if (singleChunkIsBuffer2(chunk)) {
          const opcode = asMinimalOP2(chunk);
          if (opcode !== void 0) {
            buffer2.writeUInt8(opcode, offset);
            offset += 1;
            return;
          }
          offset += pushdata.encode(buffer2, chunk.length, offset);
          chunk.copy(buffer2, offset);
          offset += chunk.length;
        } else {
          buffer2.writeUInt8(chunk, offset);
          offset += 1;
        }
      });
      if (offset !== buffer2.length) throw new Error("Could not decode chunks");
      return buffer2;
    }
    exports2.compile = compile2;
    function decompile2(buffer2) {
      if (chunksIsArray2(buffer2)) return buffer2;
      typeforce(types.Buffer, buffer2);
      const chunks = [];
      let i = 0;
      while (i < buffer2.length) {
        const opcode = buffer2[i];
        if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {
          const d = pushdata.decode(buffer2, i);
          if (d === null) return null;
          i += d.size;
          if (i + d.number > buffer2.length) return null;
          const data = buffer2.slice(i, i + d.number);
          i += d.number;
          const op = asMinimalOP2(data);
          if (op !== void 0) {
            chunks.push(op);
          } else {
            chunks.push(data);
          }
        } else {
          chunks.push(opcode);
          i += 1;
        }
      }
      return chunks;
    }
    exports2.decompile = decompile2;
    function toASM2(chunks) {
      if (chunksIsBuffer2(chunks)) {
        chunks = decompile2(chunks);
      }
      if (!chunks) {
        throw new Error("Could not convert invalid chunks to ASM");
      }
      return chunks.map((chunk) => {
        if (singleChunkIsBuffer2(chunk)) {
          const op = asMinimalOP2(chunk);
          if (op === void 0) return chunk.toString("hex");
          chunk = op;
        }
        return ops_1.REVERSE_OPS[chunk];
      }).join(" ");
    }
    exports2.toASM = toASM2;
    function fromASM(asm) {
      typeforce(types.String, asm);
      return compile2(
        asm.split(" ").map((chunkStr) => {
          if (ops_1.OPS[chunkStr] !== void 0) return ops_1.OPS[chunkStr];
          typeforce(types.Hex, chunkStr);
          return import_buffer.Buffer.from(chunkStr, "hex");
        })
      );
    }
    exports2.fromASM = fromASM;
    function toStack2(chunks) {
      chunks = decompile2(chunks);
      typeforce(isPushOnly2, chunks);
      return chunks.map((op) => {
        if (singleChunkIsBuffer2(op)) return op;
        if (op === ops_1.OPS.OP_0) return import_buffer.Buffer.allocUnsafe(0);
        return scriptNumber.encode(op - OP_INT_BASE3);
      });
    }
    exports2.toStack = toStack2;
    function isCanonicalPubKey2(buffer2) {
      return types.isPoint(buffer2);
    }
    exports2.isCanonicalPubKey = isCanonicalPubKey2;
    function isDefinedHashType2(hashType) {
      const hashTypeMod = hashType & ~128;
      return hashTypeMod > 0 && hashTypeMod < 4;
    }
    exports2.isDefinedHashType = isDefinedHashType2;
    function isCanonicalScriptSignature2(buffer2) {
      if (!import_buffer.Buffer.isBuffer(buffer2)) return false;
      if (!isDefinedHashType2(buffer2[buffer2.length - 1])) return false;
      return bip66.check(buffer2.slice(0, -1));
    }
    exports2.isCanonicalScriptSignature = isCanonicalScriptSignature2;
    exports2.number = scriptNumber;
    exports2.signature = scriptSignature;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/lazy.js
var require_lazy2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/lazy.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.value = exports2.prop = void 0;
    function prop2(object3, name10, f) {
      Object.defineProperty(object3, name10, {
        configurable: true,
        enumerable: true,
        get() {
          const _value = f.call(this);
          this[name10] = _value;
          return _value;
        },
        set(_value) {
          Object.defineProperty(this, name10, {
            configurable: true,
            enumerable: true,
            value: _value,
            writable: true
          });
        }
      });
    }
    exports2.prop = prop2;
    function value2(f) {
      let _value;
      return () => {
        if (_value !== void 0) return _value;
        _value = f();
        return _value;
      };
    }
    exports2.value = value2;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/embed.js
var require_embed2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/embed.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2data = void 0;
    var networks_1 = require_networks3();
    var bscript = require_script2();
    var types_1 = require_types4();
    var lazy = require_lazy2();
    var OPS10 = bscript.OPS;
    function p2data2(a, opts) {
      if (!a.data && !a.output) throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          data: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a
      );
      const network = a.network || networks_1.bitcoin;
      const o = { name: "embed", network };
      lazy.prop(o, "output", () => {
        if (!a.data) return;
        return bscript.compile([OPS10.OP_RETURN].concat(a.data));
      });
      lazy.prop(o, "data", () => {
        if (!a.output) return;
        return bscript.decompile(a.output).slice(1);
      });
      if (opts.validate) {
        if (a.output) {
          const chunks = bscript.decompile(a.output);
          if (chunks[0] !== OPS10.OP_RETURN) throw new TypeError("Output is invalid");
          if (!chunks.slice(1).every(types_1.typeforce.Buffer))
            throw new TypeError("Output is invalid");
          if (a.data && !(0, types_1.stacksEqual)(a.data, o.data))
            throw new TypeError("Data mismatch");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2data = p2data2;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2ms.js
var require_p2ms2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2ms.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2ms = void 0;
    var networks_1 = require_networks3();
    var bscript = require_script2();
    var types_1 = require_types4();
    var lazy = require_lazy2();
    var OPS10 = bscript.OPS;
    var OP_INT_BASE3 = OPS10.OP_RESERVED;
    function p2ms2(a, opts) {
      if (!a.input && !a.output && !(a.pubkeys && a.m !== void 0) && !a.signatures)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      function isAcceptableSignature(x) {
        return bscript.isCanonicalScriptSignature(x) || (opts.allowIncomplete && x === OPS10.OP_0) !== void 0;
      }
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          m: types_1.typeforce.maybe(types_1.typeforce.Number),
          n: types_1.typeforce.maybe(types_1.typeforce.Number),
          output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          pubkeys: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.isPoint)
          ),
          signatures: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(isAcceptableSignature)
          ),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer)
        },
        a
      );
      const network = a.network || networks_1.bitcoin;
      const o = { network };
      let chunks = [];
      let decoded = false;
      function decode44(output) {
        if (decoded) return;
        decoded = true;
        chunks = bscript.decompile(output);
        o.m = chunks[0] - OP_INT_BASE3;
        o.n = chunks[chunks.length - 2] - OP_INT_BASE3;
        o.pubkeys = chunks.slice(1, -2);
      }
      lazy.prop(o, "output", () => {
        if (!a.m) return;
        if (!o.n) return;
        if (!a.pubkeys) return;
        return bscript.compile(
          [].concat(
            OP_INT_BASE3 + a.m,
            a.pubkeys,
            OP_INT_BASE3 + o.n,
            OPS10.OP_CHECKMULTISIG
          )
        );
      });
      lazy.prop(o, "m", () => {
        if (!o.output) return;
        decode44(o.output);
        return o.m;
      });
      lazy.prop(o, "n", () => {
        if (!o.pubkeys) return;
        return o.pubkeys.length;
      });
      lazy.prop(o, "pubkeys", () => {
        if (!a.output) return;
        decode44(a.output);
        return o.pubkeys;
      });
      lazy.prop(o, "signatures", () => {
        if (!a.input) return;
        return bscript.decompile(a.input).slice(1);
      });
      lazy.prop(o, "input", () => {
        if (!a.signatures) return;
        return bscript.compile([OPS10.OP_0].concat(a.signatures));
      });
      lazy.prop(o, "witness", () => {
        if (!o.input) return;
        return [];
      });
      lazy.prop(o, "name", () => {
        if (!o.m || !o.n) return;
        return `p2ms(${o.m} of ${o.n})`;
      });
      if (opts.validate) {
        if (a.output) {
          decode44(a.output);
          if (!types_1.typeforce.Number(chunks[0]))
            throw new TypeError("Output is invalid");
          if (!types_1.typeforce.Number(chunks[chunks.length - 2]))
            throw new TypeError("Output is invalid");
          if (chunks[chunks.length - 1] !== OPS10.OP_CHECKMULTISIG)
            throw new TypeError("Output is invalid");
          if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)
            throw new TypeError("Output is invalid");
          if (!o.pubkeys.every((x) => (0, types_1.isPoint)(x)))
            throw new TypeError("Output is invalid");
          if (a.m !== void 0 && a.m !== o.m) throw new TypeError("m mismatch");
          if (a.n !== void 0 && a.n !== o.n) throw new TypeError("n mismatch");
          if (a.pubkeys && !(0, types_1.stacksEqual)(a.pubkeys, o.pubkeys))
            throw new TypeError("Pubkeys mismatch");
        }
        if (a.pubkeys) {
          if (a.n !== void 0 && a.n !== a.pubkeys.length)
            throw new TypeError("Pubkey count mismatch");
          o.n = a.pubkeys.length;
          if (o.n < o.m) throw new TypeError("Pubkey count cannot be less than m");
        }
        if (a.signatures) {
          if (a.signatures.length < o.m)
            throw new TypeError("Not enough signatures provided");
          if (a.signatures.length > o.m)
            throw new TypeError("Too many signatures provided");
        }
        if (a.input) {
          if (a.input[0] !== OPS10.OP_0) throw new TypeError("Input is invalid");
          if (o.signatures.length === 0 || !o.signatures.every(isAcceptableSignature))
            throw new TypeError("Input has invalid signature(s)");
          if (a.signatures && !(0, types_1.stacksEqual)(a.signatures, o.signatures))
            throw new TypeError("Signature mismatch");
          if (a.m !== void 0 && a.m !== a.signatures.length)
            throw new TypeError("Signature count mismatch");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2ms = p2ms2;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2pk.js
var require_p2pk2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2pk.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2pk = void 0;
    var networks_1 = require_networks3();
    var bscript = require_script2();
    var types_1 = require_types4();
    var lazy = require_lazy2();
    var OPS10 = bscript.OPS;
    function p2pk2(a, opts) {
      if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          pubkey: types_1.typeforce.maybe(types_1.isPoint),
          signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer)
        },
        a
      );
      const _chunks = lazy.value(() => {
        return bscript.decompile(a.input);
      });
      const network = a.network || networks_1.bitcoin;
      const o = { name: "p2pk", network };
      lazy.prop(o, "output", () => {
        if (!a.pubkey) return;
        return bscript.compile([a.pubkey, OPS10.OP_CHECKSIG]);
      });
      lazy.prop(o, "pubkey", () => {
        if (!a.output) return;
        return a.output.slice(1, -1);
      });
      lazy.prop(o, "signature", () => {
        if (!a.input) return;
        return _chunks()[0];
      });
      lazy.prop(o, "input", () => {
        if (!a.signature) return;
        return bscript.compile([a.signature]);
      });
      lazy.prop(o, "witness", () => {
        if (!o.input) return;
        return [];
      });
      if (opts.validate) {
        if (a.output) {
          if (a.output[a.output.length - 1] !== OPS10.OP_CHECKSIG)
            throw new TypeError("Output is invalid");
          if (!(0, types_1.isPoint)(o.pubkey))
            throw new TypeError("Output pubkey is invalid");
          if (a.pubkey && !a.pubkey.equals(o.pubkey))
            throw new TypeError("Pubkey mismatch");
        }
        if (a.signature) {
          if (a.input && !a.input.equals(o.input))
            throw new TypeError("Signature mismatch");
        }
        if (a.input) {
          if (_chunks().length !== 1) throw new TypeError("Input is invalid");
          if (!bscript.isCanonicalScriptSignature(o.signature))
            throw new TypeError("Input has invalid signature");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2pk = p2pk2;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/crypto.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.crypto = void 0;
    exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js
var require_utils5 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.Hash = exports2.nextTick = exports2.swap32IfBE = exports2.byteSwapIfBE = exports2.swap8IfBE = exports2.isLE = void 0;
    exports2.isBytes = isBytes5;
    exports2.anumber = anumber4;
    exports2.abytes = abytes3;
    exports2.ahash = ahash3;
    exports2.aexists = aexists3;
    exports2.aoutput = aoutput3;
    exports2.u8 = u8;
    exports2.u32 = u32;
    exports2.clean = clean3;
    exports2.createView = createView3;
    exports2.rotr = rotr3;
    exports2.rotl = rotl2;
    exports2.byteSwap = byteSwap;
    exports2.byteSwap32 = byteSwap32;
    exports2.bytesToHex = bytesToHex2;
    exports2.hexToBytes = hexToBytes2;
    exports2.asyncLoop = asyncLoop;
    exports2.utf8ToBytes = utf8ToBytes3;
    exports2.bytesToUtf8 = bytesToUtf8;
    exports2.toBytes = toBytes4;
    exports2.kdfInputToBytes = kdfInputToBytes;
    exports2.concatBytes = concatBytes2;
    exports2.checkOpts = checkOpts;
    exports2.createHasher = createHasher3;
    exports2.createOptHasher = createOptHasher;
    exports2.createXOFer = createXOFer;
    exports2.randomBytes = randomBytes2;
    var crypto_1 = require_crypto2();
    function isBytes5(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function anumber4(n2) {
      if (!Number.isSafeInteger(n2) || n2 < 0)
        throw new Error("positive integer expected, got " + n2);
    }
    function abytes3(b, ...lengths) {
      if (!isBytes5(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function ahash3(h3) {
      if (typeof h3 !== "function" || typeof h3.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber4(h3.outputLen);
      anumber4(h3.blockLen);
    }
    function aexists3(instance3, checkFinished = true) {
      if (instance3.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance3.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput3(out, instance3) {
      abytes3(out);
      const min = instance3.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean3(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView3(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr3(word, shift) {
      return word << 32 - shift | word >>> shift;
    }
    function rotl2(word, shift) {
      return word << shift | word >>> 32 - shift >>> 0;
    }
    exports2.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap(word) {
      return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    }
    exports2.swap8IfBE = exports2.isLE ? (n2) => n2 : (n2) => byteSwap(n2);
    exports2.byteSwapIfBE = exports2.swap8IfBE;
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
      }
      return arr;
    }
    exports2.swap32IfBE = exports2.isLE ? (u) => u : byteSwap32;
    var hasHexBuiltin2 = /* @__PURE__ */ (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    var hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex2(bytes) {
      abytes3(bytes);
      if (hasHexBuiltin2)
        return bytes.toHex();
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes2[bytes[i]];
      }
      return hex;
    }
    var asciis2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase162(ch) {
      if (ch >= asciis2._0 && ch <= asciis2._9)
        return ch - asciis2._0;
      if (ch >= asciis2.A && ch <= asciis2.F)
        return ch - (asciis2.A - 10);
      if (ch >= asciis2.a && ch <= asciis2.f)
        return ch - (asciis2.a - 10);
      return;
    }
    function hexToBytes2(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hasHexBuiltin2)
        return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array2 = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase162(hex.charCodeAt(hi));
        const n2 = asciiToBase162(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array2[ai] = n1 * 16 + n2;
      }
      return array2;
    }
    var nextTick = async () => {
    };
    exports2.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports2.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes3(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bytesToUtf8(bytes) {
      return new TextDecoder().decode(bytes);
    }
    function toBytes4(data) {
      if (typeof data === "string")
        data = utf8ToBytes3(data);
      abytes3(data);
      return data;
    }
    function kdfInputToBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes3(data);
      abytes3(data);
      return data;
    }
    function concatBytes2(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes3(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    var Hash2 = class {
    };
    exports2.Hash = Hash2;
    function createHasher3(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes4(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function createOptHasher(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes4(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function createXOFer(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes4(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports2.wrapConstructor = createHasher3;
    exports2.wrapConstructorWithOpts = createOptHasher;
    exports2.wrapXOFConstructorWithOpts = createXOFer;
    function randomBytes2(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SHA512_IV = exports2.SHA384_IV = exports2.SHA224_IV = exports2.SHA256_IV = exports2.HashMD = void 0;
    exports2.setBigUint64 = setBigUint642;
    exports2.Chi = Chi3;
    exports2.Maj = Maj3;
    var utils_ts_1 = require_utils5();
    function setBigUint642(view, byteOffset, value2, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value2, isLE);
      const _32n2 = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value2 >> _32n2 & _u32_max);
      const wl = Number(value2 & _u32_max);
      const h3 = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h3, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    function Chi3(a, b, c) {
      return a & b ^ ~a & c;
    }
    function Maj3(a, b, c) {
      return a & b ^ a & c ^ b & c;
    }
    var HashMD3 = class extends utils_ts_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
      }
      update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer: buffer2, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView2 = (0, utils_ts_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView2, pos);
            continue;
          }
          buffer2.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        const { buffer: buffer2, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer2[pos++] = 128;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer2[i] = 0;
        setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer: buffer2, outputLen } = this;
        this.digestInto(buffer2);
        const res = buffer2.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer: buffer2, length: length6, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length6;
        to.pos = pos;
        if (length6 % blockLen)
          to.buffer.set(buffer2);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
    };
    exports2.HashMD = HashMD3;
    exports2.SHA256_IV = Uint32Array.from([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    exports2.SHA224_IV = Uint32Array.from([
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ]);
    exports2.SHA384_IV = Uint32Array.from([
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ]);
    exports2.SHA512_IV = Uint32Array.from([
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ]);
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/legacy.js
var require_legacy2 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/legacy.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ripemd160 = exports2.RIPEMD160 = exports2.md5 = exports2.MD5 = exports2.sha1 = exports2.SHA1 = void 0;
    var _md_ts_1 = require_md();
    var utils_ts_1 = require_utils5();
    var SHA1_IV = /* @__PURE__ */ Uint32Array.from([
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ]);
    var SHA1_W = /* @__PURE__ */ new Uint32Array(80);
    var SHA1 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 20, 8, false);
        this.A = SHA1_IV[0] | 0;
        this.B = SHA1_IV[1] | 0;
        this.C = SHA1_IV[2] | 0;
        this.D = SHA1_IV[3] | 0;
        this.E = SHA1_IV[4] | 0;
      }
      get() {
        const { A, B, C, D, E } = this;
        return [A, B, C, D, E];
      }
      set(A, B, C, D, E) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA1_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 80; i++)
          SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
        let { A, B, C, D, E } = this;
        for (let i = 0; i < 80; i++) {
          let F, K2;
          if (i < 20) {
            F = (0, _md_ts_1.Chi)(B, C, D);
            K2 = 1518500249;
          } else if (i < 40) {
            F = B ^ C ^ D;
            K2 = 1859775393;
          } else if (i < 60) {
            F = (0, _md_ts_1.Maj)(B, C, D);
            K2 = 2400959708;
          } else {
            F = B ^ C ^ D;
            K2 = 3395469782;
          }
          const T = (0, utils_ts_1.rotl)(A, 5) + F + E + K2 + SHA1_W[i] | 0;
          E = D;
          D = C;
          C = (0, utils_ts_1.rotl)(B, 30);
          B = A;
          A = T;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        this.set(A, B, C, D, E);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA1_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports2.SHA1 = SHA1;
    exports2.sha1 = (0, utils_ts_1.createHasher)(() => new SHA1());
    var p32 = /* @__PURE__ */ Math.pow(2, 32);
    var K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));
    var MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);
    var MD5_W = /* @__PURE__ */ new Uint32Array(16);
    var MD5 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 16, 8, true);
        this.A = MD5_IV[0] | 0;
        this.B = MD5_IV[1] | 0;
        this.C = MD5_IV[2] | 0;
        this.D = MD5_IV[3] | 0;
      }
      get() {
        const { A, B, C, D } = this;
        return [A, B, C, D];
      }
      set(A, B, C, D) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          MD5_W[i] = view.getUint32(offset, true);
        let { A, B, C, D } = this;
        for (let i = 0; i < 64; i++) {
          let F, g, s;
          if (i < 16) {
            F = (0, _md_ts_1.Chi)(B, C, D);
            g = i;
            s = [7, 12, 17, 22];
          } else if (i < 32) {
            F = (0, _md_ts_1.Chi)(D, B, C);
            g = (5 * i + 1) % 16;
            s = [5, 9, 14, 20];
          } else if (i < 48) {
            F = B ^ C ^ D;
            g = (3 * i + 5) % 16;
            s = [4, 11, 16, 23];
          } else {
            F = C ^ (B | ~D);
            g = 7 * i % 16;
            s = [6, 10, 15, 21];
          }
          F = F + A + K[i] + MD5_W[g];
          A = D;
          D = C;
          C = B;
          B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        this.set(A, B, C, D);
      }
      roundClean() {
        (0, utils_ts_1.clean)(MD5_W);
      }
      destroy() {
        this.set(0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports2.MD5 = MD5;
    exports2.md5 = (0, utils_ts_1.createHasher)(() => new MD5());
    var Rho1602 = /* @__PURE__ */ Uint8Array.from([
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8
    ]);
    var Id1602 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
    var Pi1602 = /* @__PURE__ */ (() => Id1602.map((i) => (9 * i + 5) % 16))();
    var idxLR2 = /* @__PURE__ */ (() => {
      const L = [Id1602];
      const R = [Pi1602];
      const res = [L, R];
      for (let i = 0; i < 4; i++)
        for (let j of res)
          j.push(j[i].map((k) => Rho1602[k]));
      return res;
    })();
    var idxL2 = /* @__PURE__ */ (() => idxLR2[0])();
    var idxR2 = /* @__PURE__ */ (() => idxLR2[1])();
    var shifts1602 = /* @__PURE__ */ [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i) => Uint8Array.from(i));
    var shiftsL1602 = /* @__PURE__ */ idxL2.map((idx, i) => idx.map((j) => shifts1602[i][j]));
    var shiftsR1602 = /* @__PURE__ */ idxR2.map((idx, i) => idx.map((j) => shifts1602[i][j]));
    var Kl1602 = /* @__PURE__ */ Uint32Array.from([
      0,
      1518500249,
      1859775393,
      2400959708,
      2840853838
    ]);
    var Kr1602 = /* @__PURE__ */ Uint32Array.from([
      1352829926,
      1548603684,
      1836072691,
      2053994217,
      0
    ]);
    function ripemd_f2(group, x, y, z) {
      if (group === 0)
        return x ^ y ^ z;
      if (group === 1)
        return x & y | ~x & z;
      if (group === 2)
        return (x | ~y) ^ z;
      if (group === 3)
        return x & z | y & ~z;
      return x ^ (y | ~z);
    }
    var BUF_1602 = /* @__PURE__ */ new Uint32Array(16);
    var RIPEMD1602 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2: h22, h3, h4 } = this;
        return [h0, h1, h22, h3, h4];
      }
      set(h0, h1, h22, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h22 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          BUF_1602[i] = view.getUint32(offset, true);
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl1602[group], hbr = Kr1602[group];
          const rl = idxL2[group], rr = idxR2[group];
          const sl = shiftsL1602[group], sr = shiftsR1602[group];
          for (let i = 0; i < 16; i++) {
            const tl = (0, utils_ts_1.rotl)(al + ripemd_f2(group, bl, cl, dl) + BUF_1602[rl[i]] + hbl, sl[i]) + el | 0;
            al = el, el = dl, dl = (0, utils_ts_1.rotl)(cl, 10) | 0, cl = bl, bl = tl;
          }
          for (let i = 0; i < 16; i++) {
            const tr = (0, utils_ts_1.rotl)(ar + ripemd_f2(rGroup, br, cr, dr) + BUF_1602[rr[i]] + hbr, sr[i]) + er | 0;
            ar = er, er = dr, dr = (0, utils_ts_1.rotl)(cr, 10) | 0, cr = br, br = tr;
          }
        }
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
      roundClean() {
        (0, utils_ts_1.clean)(BUF_1602);
      }
      destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0);
      }
    };
    exports2.RIPEMD160 = RIPEMD1602;
    exports2.ripemd160 = (0, utils_ts_1.createHasher)(() => new RIPEMD1602());
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/ripemd160.js
var require_ripemd1602 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/ripemd160.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ripemd160 = exports2.RIPEMD160 = void 0;
    var legacy_ts_1 = require_legacy2();
    exports2.RIPEMD160 = legacy_ts_1.RIPEMD160;
    exports2.ripemd160 = legacy_ts_1.ripemd160;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha1.js
var require_sha12 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha1.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha1 = exports2.SHA1 = void 0;
    var legacy_ts_1 = require_legacy2();
    exports2.SHA1 = legacy_ts_1.SHA1;
    exports2.sha1 = legacy_ts_1.sha1;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toBig = exports2.shrSL = exports2.shrSH = exports2.rotrSL = exports2.rotrSH = exports2.rotrBL = exports2.rotrBH = exports2.rotr32L = exports2.rotr32H = exports2.rotlSL = exports2.rotlSH = exports2.rotlBL = exports2.rotlBH = exports2.add5L = exports2.add5H = exports2.add4L = exports2.add4H = exports2.add3L = exports2.add3H = void 0;
    exports2.add = add2;
    exports2.fromBig = fromBig2;
    exports2.split = split2;
    var U32_MASK642 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    var _32n2 = /* @__PURE__ */ BigInt(32);
    function fromBig2(n2, le = false) {
      if (le)
        return { h: Number(n2 & U32_MASK642), l: Number(n2 >> _32n2 & U32_MASK642) };
      return { h: Number(n2 >> _32n2 & U32_MASK642) | 0, l: Number(n2 & U32_MASK642) | 0 };
    }
    function split2(lst, le = false) {
      const len = lst.length;
      let Ah = new Uint32Array(len);
      let Al = new Uint32Array(len);
      for (let i = 0; i < len; i++) {
        const { h: h3, l } = fromBig2(lst[i], le);
        [Ah[i], Al[i]] = [h3, l];
      }
      return [Ah, Al];
    }
    var toBig = (h3, l) => BigInt(h3 >>> 0) << _32n2 | BigInt(l >>> 0);
    exports2.toBig = toBig;
    var shrSH2 = (h3, _l, s) => h3 >>> s;
    exports2.shrSH = shrSH2;
    var shrSL2 = (h3, l, s) => h3 << 32 - s | l >>> s;
    exports2.shrSL = shrSL2;
    var rotrSH2 = (h3, l, s) => h3 >>> s | l << 32 - s;
    exports2.rotrSH = rotrSH2;
    var rotrSL2 = (h3, l, s) => h3 << 32 - s | l >>> s;
    exports2.rotrSL = rotrSL2;
    var rotrBH2 = (h3, l, s) => h3 << 64 - s | l >>> s - 32;
    exports2.rotrBH = rotrBH2;
    var rotrBL2 = (h3, l, s) => h3 >>> s - 32 | l << 64 - s;
    exports2.rotrBL = rotrBL2;
    var rotr32H = (_h, l) => l;
    exports2.rotr32H = rotr32H;
    var rotr32L = (h3, _l) => h3;
    exports2.rotr32L = rotr32L;
    var rotlSH = (h3, l, s) => h3 << s | l >>> 32 - s;
    exports2.rotlSH = rotlSH;
    var rotlSL = (h3, l, s) => l << s | h3 >>> 32 - s;
    exports2.rotlSL = rotlSL;
    var rotlBH = (h3, l, s) => l << s - 32 | h3 >>> 64 - s;
    exports2.rotlBH = rotlBH;
    var rotlBL = (h3, l, s) => h3 << s - 32 | l >>> 64 - s;
    exports2.rotlBL = rotlBL;
    function add2(Ah, Al, Bh, Bl2) {
      const l = (Al >>> 0) + (Bl2 >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    var add3L2 = (Al, Bl2, Cl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0);
    exports2.add3L = add3L2;
    var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports2.add3H = add3H2;
    var add4L2 = (Al, Bl2, Cl, Dl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports2.add4L = add4L2;
    var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports2.add4H = add4H2;
    var add5L2 = (Al, Bl2, Cl, Dl, El) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports2.add5L = add5L2;
    var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports2.add5H = add5H2;
    var u64 = {
      fromBig: fromBig2,
      split: split2,
      toBig,
      shrSH: shrSH2,
      shrSL: shrSL2,
      rotrSH: rotrSH2,
      rotrSL: rotrSL2,
      rotrBH: rotrBH2,
      rotrBL: rotrBL2,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add: add2,
      add3L: add3L2,
      add3H: add3H2,
      add4L: add4L2,
      add4H: add4H2,
      add5H: add5H2,
      add5L: add5L2
    };
    exports2.default = u64;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js
var require_sha22 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha512_224 = exports2.sha512_256 = exports2.sha384 = exports2.sha512 = exports2.sha224 = exports2.sha256 = exports2.SHA512_256 = exports2.SHA512_224 = exports2.SHA384 = exports2.SHA512 = exports2.SHA224 = exports2.SHA256 = void 0;
    var _md_ts_1 = require_md();
    var u64 = require_u64();
    var utils_ts_1 = require_utils5();
    var SHA256_K3 = /* @__PURE__ */ Uint32Array.from([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_W3 = /* @__PURE__ */ new Uint32Array(64);
    var SHA2562 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G: G2, H } = this;
        return [A, B, C, D, E, F, G2, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G2, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G2 | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W3[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W3[i - 15];
          const W2 = SHA256_W3[i - 2];
          const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W3[i] = s1 + SHA256_W3[i - 7] + s0 + SHA256_W3[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G: G2, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
          const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G2) + SHA256_K3[i] + SHA256_W3[i] | 0;
          const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
          const T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;
          H = G2;
          G2 = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G2 = G2 + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G2, H);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA256_W3);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports2.SHA256 = SHA2562;
    var SHA2242 = class extends SHA2562 {
      constructor() {
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
      }
    };
    exports2.SHA224 = SHA2242;
    var K5122 = /* @__PURE__ */ (() => u64.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n2) => BigInt(n2))))();
    var SHA512_Kh2 = /* @__PURE__ */ (() => K5122[0])();
    var SHA512_Kl2 = /* @__PURE__ */ (() => K5122[1])();
    var SHA512_W_H2 = /* @__PURE__ */ new Uint32Array(80);
    var SHA512_W_L2 = /* @__PURE__ */ new Uint32Array(80);
    var SHA5122 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl: Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl2 | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H2[i] = view.getUint32(offset);
          SHA512_W_L2[i] = view.getUint32(offset += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H2[i - 15] | 0;
          const W15l = SHA512_W_L2[i - 15] | 0;
          const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
          const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H2[i - 2] | 0;
          const W2l = SHA512_W_L2[i - 2] | 0;
          const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
          const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
          const SUMl = u64.add4L(s0l, s1l, SHA512_W_L2[i - 7], SHA512_W_L2[i - 16]);
          const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H2[i - 7], SHA512_W_H2[i - 16]);
          SHA512_W_H2[i] = SUMh | 0;
          SHA512_W_L2[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl: Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
          const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl2[i], SHA512_W_L2[i]);
          const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i], SHA512_W_H2[i]);
          const T1l = T1ll | 0;
          const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
          const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl2 ^ Al & Cl ^ Bl2 & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl2 | 0;
          Bh = Ah | 0;
          Bl2 = Al | 0;
          const All = u64.add3L(T1l, sigma0l, MAJl);
          Ah = u64.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl2 } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl2 | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H2, SHA512_W_L2);
      }
      destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports2.SHA512 = SHA5122;
    var SHA3842 = class extends SHA5122 {
      constructor() {
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
      }
    };
    exports2.SHA384 = SHA3842;
    var T224_IV = /* @__PURE__ */ Uint32Array.from([
      2352822216,
      424955298,
      1944164710,
      2312950998,
      502970286,
      855612546,
      1738396948,
      1479516111,
      258812777,
      2077511080,
      2011393907,
      79989058,
      1067287976,
      1780299464,
      286451373,
      2446758561
    ]);
    var T256_IV = /* @__PURE__ */ Uint32Array.from([
      573645204,
      4230739756,
      2673172387,
      3360449730,
      596883563,
      1867755857,
      2520282905,
      1497426621,
      2519219938,
      2827943907,
      3193839141,
      1401305490,
      721525244,
      746961066,
      246885852,
      2177182882
    ]);
    var SHA512_2242 = class extends SHA5122 {
      constructor() {
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
      }
    };
    exports2.SHA512_224 = SHA512_2242;
    var SHA512_2562 = class extends SHA5122 {
      constructor() {
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
      }
    };
    exports2.SHA512_256 = SHA512_2562;
    exports2.sha256 = (0, utils_ts_1.createHasher)(() => new SHA2562());
    exports2.sha224 = (0, utils_ts_1.createHasher)(() => new SHA2242());
    exports2.sha512 = (0, utils_ts_1.createHasher)(() => new SHA5122());
    exports2.sha384 = (0, utils_ts_1.createHasher)(() => new SHA3842());
    exports2.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_2562());
    exports2.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_2242());
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha256.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha224 = exports2.SHA224 = exports2.sha256 = exports2.SHA256 = void 0;
    var sha2_ts_1 = require_sha22();
    exports2.SHA256 = sha2_ts_1.SHA256;
    exports2.sha256 = sha2_ts_1.sha256;
    exports2.SHA224 = sha2_ts_1.SHA224;
    exports2.sha224 = sha2_ts_1.sha224;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/crypto.js
var require_crypto3 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/crypto.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.taggedHash = exports2.TAGGED_HASH_PREFIXES = exports2.TAGS = exports2.hash256 = exports2.hash160 = exports2.sha256 = exports2.sha1 = exports2.ripemd160 = void 0;
    var ripemd160_1 = require_ripemd1602();
    var sha1_1 = require_sha12();
    var sha256_1 = require_sha2562();
    function ripemd1603(buffer2) {
      return import_buffer.Buffer.from((0, ripemd160_1.ripemd160)(Uint8Array.from(buffer2)));
    }
    exports2.ripemd160 = ripemd1603;
    function sha1(buffer2) {
      return import_buffer.Buffer.from((0, sha1_1.sha1)(Uint8Array.from(buffer2)));
    }
    exports2.sha1 = sha1;
    function sha2567(buffer2) {
      return import_buffer.Buffer.from((0, sha256_1.sha256)(Uint8Array.from(buffer2)));
    }
    exports2.sha256 = sha2567;
    function hash1603(buffer2) {
      return import_buffer.Buffer.from(
        (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(Uint8Array.from(buffer2)))
      );
    }
    exports2.hash160 = hash1603;
    function hash2562(buffer2) {
      return import_buffer.Buffer.from(
        (0, sha256_1.sha256)((0, sha256_1.sha256)(Uint8Array.from(buffer2)))
      );
    }
    exports2.hash256 = hash2562;
    exports2.TAGS = [
      "BIP0340/challenge",
      "BIP0340/aux",
      "BIP0340/nonce",
      "TapLeaf",
      "TapBranch",
      "TapSighash",
      "TapTweak",
      "KeyAgg list",
      "KeyAgg coefficient"
    ];
    exports2.TAGGED_HASH_PREFIXES = {
      "BIP0340/challenge": import_buffer.Buffer.from([
        123,
        181,
        45,
        122,
        159,
        239,
        88,
        50,
        62,
        177,
        191,
        122,
        64,
        125,
        179,
        130,
        210,
        243,
        242,
        216,
        27,
        177,
        34,
        79,
        73,
        254,
        81,
        143,
        109,
        72,
        211,
        124,
        123,
        181,
        45,
        122,
        159,
        239,
        88,
        50,
        62,
        177,
        191,
        122,
        64,
        125,
        179,
        130,
        210,
        243,
        242,
        216,
        27,
        177,
        34,
        79,
        73,
        254,
        81,
        143,
        109,
        72,
        211,
        124
      ]),
      "BIP0340/aux": import_buffer.Buffer.from([
        241,
        239,
        78,
        94,
        192,
        99,
        202,
        218,
        109,
        148,
        202,
        250,
        157,
        152,
        126,
        160,
        105,
        38,
        88,
        57,
        236,
        193,
        31,
        151,
        45,
        119,
        165,
        46,
        216,
        193,
        204,
        144,
        241,
        239,
        78,
        94,
        192,
        99,
        202,
        218,
        109,
        148,
        202,
        250,
        157,
        152,
        126,
        160,
        105,
        38,
        88,
        57,
        236,
        193,
        31,
        151,
        45,
        119,
        165,
        46,
        216,
        193,
        204,
        144
      ]),
      "BIP0340/nonce": import_buffer.Buffer.from([
        7,
        73,
        119,
        52,
        167,
        155,
        203,
        53,
        91,
        155,
        140,
        125,
        3,
        79,
        18,
        28,
        244,
        52,
        215,
        62,
        247,
        45,
        218,
        25,
        135,
        0,
        97,
        251,
        82,
        191,
        235,
        47,
        7,
        73,
        119,
        52,
        167,
        155,
        203,
        53,
        91,
        155,
        140,
        125,
        3,
        79,
        18,
        28,
        244,
        52,
        215,
        62,
        247,
        45,
        218,
        25,
        135,
        0,
        97,
        251,
        82,
        191,
        235,
        47
      ]),
      TapLeaf: import_buffer.Buffer.from([
        174,
        234,
        143,
        220,
        66,
        8,
        152,
        49,
        5,
        115,
        75,
        88,
        8,
        29,
        30,
        38,
        56,
        211,
        95,
        28,
        181,
        64,
        8,
        212,
        211,
        87,
        202,
        3,
        190,
        120,
        233,
        238,
        174,
        234,
        143,
        220,
        66,
        8,
        152,
        49,
        5,
        115,
        75,
        88,
        8,
        29,
        30,
        38,
        56,
        211,
        95,
        28,
        181,
        64,
        8,
        212,
        211,
        87,
        202,
        3,
        190,
        120,
        233,
        238
      ]),
      TapBranch: import_buffer.Buffer.from([
        25,
        65,
        161,
        242,
        229,
        110,
        185,
        95,
        162,
        169,
        241,
        148,
        190,
        92,
        1,
        247,
        33,
        111,
        51,
        237,
        130,
        176,
        145,
        70,
        52,
        144,
        208,
        91,
        245,
        22,
        160,
        21,
        25,
        65,
        161,
        242,
        229,
        110,
        185,
        95,
        162,
        169,
        241,
        148,
        190,
        92,
        1,
        247,
        33,
        111,
        51,
        237,
        130,
        176,
        145,
        70,
        52,
        144,
        208,
        91,
        245,
        22,
        160,
        21
      ]),
      TapSighash: import_buffer.Buffer.from([
        244,
        10,
        72,
        223,
        75,
        42,
        112,
        200,
        180,
        146,
        75,
        242,
        101,
        70,
        97,
        237,
        61,
        149,
        253,
        102,
        163,
        19,
        235,
        135,
        35,
        117,
        151,
        198,
        40,
        228,
        160,
        49,
        244,
        10,
        72,
        223,
        75,
        42,
        112,
        200,
        180,
        146,
        75,
        242,
        101,
        70,
        97,
        237,
        61,
        149,
        253,
        102,
        163,
        19,
        235,
        135,
        35,
        117,
        151,
        198,
        40,
        228,
        160,
        49
      ]),
      TapTweak: import_buffer.Buffer.from([
        232,
        15,
        225,
        99,
        156,
        156,
        160,
        80,
        227,
        175,
        27,
        57,
        193,
        67,
        198,
        62,
        66,
        156,
        188,
        235,
        21,
        217,
        64,
        251,
        181,
        197,
        161,
        244,
        175,
        87,
        197,
        233,
        232,
        15,
        225,
        99,
        156,
        156,
        160,
        80,
        227,
        175,
        27,
        57,
        193,
        67,
        198,
        62,
        66,
        156,
        188,
        235,
        21,
        217,
        64,
        251,
        181,
        197,
        161,
        244,
        175,
        87,
        197,
        233
      ]),
      "KeyAgg list": import_buffer.Buffer.from([
        72,
        28,
        151,
        28,
        60,
        11,
        70,
        215,
        240,
        178,
        117,
        174,
        89,
        141,
        78,
        44,
        126,
        215,
        49,
        156,
        89,
        74,
        92,
        110,
        199,
        158,
        160,
        212,
        153,
        2,
        148,
        240,
        72,
        28,
        151,
        28,
        60,
        11,
        70,
        215,
        240,
        178,
        117,
        174,
        89,
        141,
        78,
        44,
        126,
        215,
        49,
        156,
        89,
        74,
        92,
        110,
        199,
        158,
        160,
        212,
        153,
        2,
        148,
        240
      ]),
      "KeyAgg coefficient": import_buffer.Buffer.from([
        191,
        201,
        4,
        3,
        77,
        28,
        136,
        232,
        200,
        14,
        34,
        229,
        61,
        36,
        86,
        109,
        100,
        130,
        78,
        214,
        66,
        114,
        129,
        192,
        145,
        0,
        249,
        77,
        205,
        82,
        201,
        129,
        191,
        201,
        4,
        3,
        77,
        28,
        136,
        232,
        200,
        14,
        34,
        229,
        61,
        36,
        86,
        109,
        100,
        130,
        78,
        214,
        66,
        114,
        129,
        192,
        145,
        0,
        249,
        77,
        205,
        82,
        201,
        129
      ])
    };
    function taggedHash3(prefix, data) {
      return sha2567(import_buffer.Buffer.concat([exports2.TAGGED_HASH_PREFIXES[prefix], data]));
    }
    exports2.taggedHash = taggedHash3;
  }
});

// node_modules/.pnpm/base-x@4.0.1/node_modules/base-x/src/index.js
var require_src4 = __commonJS({
  "node_modules/.pnpm/base-x@4.0.1/node_modules/base-x/src/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    function base5(ALPHABET2) {
      if (ALPHABET2.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET2.length; i++) {
        var x = ALPHABET2.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET2.length;
      var LEADER = ALPHABET2.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode42(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length6 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length6) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length6 = i2;
          pbegin++;
        }
        var it2 = size - length6;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET2.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        var zeroes = 0;
        var length6 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          var carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length6) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length6 = i2;
          psz++;
        }
        var it4 = size - length6;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode44(string5) {
        var buffer2 = decodeUnsafe(string5);
        if (buffer2) {
          return buffer2;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode42,
        decodeUnsafe,
        decode: decode44
      };
    }
    module2.exports = base5;
  }
});

// node_modules/.pnpm/bs58@5.0.0/node_modules/bs58/index.js
var require_bs582 = __commonJS({
  "node_modules/.pnpm/bs58@5.0.0/node_modules/bs58/index.js"(exports2, module2) {
    init_buffer_polyfill();
    var basex = require_src4();
    var ALPHABET2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module2.exports = basex(ALPHABET2);
  }
});

// node_modules/.pnpm/bs58check@3.0.1/node_modules/bs58check/base.js
var require_base4 = __commonJS({
  "node_modules/.pnpm/bs58check@3.0.1/node_modules/bs58check/base.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var base582 = require_bs582();
    module2.exports = function(checksumFn) {
      function encode42(payload) {
        var payloadU8 = Uint8Array.from(payload);
        var checksum2 = checksumFn(payloadU8);
        var length6 = payloadU8.length + 4;
        var both = new Uint8Array(length6);
        both.set(payloadU8, 0);
        both.set(checksum2.subarray(0, 4), payloadU8.length);
        return base582.encode(both, length6);
      }
      function decodeRaw(buffer2) {
        var payload = buffer2.slice(0, -4);
        var checksum2 = buffer2.slice(-4);
        var newChecksum = checksumFn(payload);
        if (checksum2[0] ^ newChecksum[0] | checksum2[1] ^ newChecksum[1] | checksum2[2] ^ newChecksum[2] | checksum2[3] ^ newChecksum[3]) return;
        return payload;
      }
      function decodeUnsafe(string5) {
        var buffer2 = base582.decodeUnsafe(string5);
        if (!buffer2) return;
        return decodeRaw(buffer2);
      }
      function decode44(string5) {
        var buffer2 = base582.decode(string5);
        var payload = decodeRaw(buffer2, checksumFn);
        if (!payload) throw new Error("Invalid checksum");
        return payload;
      }
      return {
        encode: encode42,
        decode: decode44,
        decodeUnsafe
      };
    };
  }
});

// node_modules/.pnpm/bs58check@3.0.1/node_modules/bs58check/index.js
var require_bs58check2 = __commonJS({
  "node_modules/.pnpm/bs58check@3.0.1/node_modules/bs58check/index.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var { sha256: sha2567 } = require_sha2562();
    var bs58checkBase = require_base4();
    function sha256x22(buffer2) {
      return sha2567(sha2567(buffer2));
    }
    module2.exports = bs58checkBase(sha256x22);
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2pkh.js
var require_p2pkh2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2pkh.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2pkh = void 0;
    var bcrypto = require_crypto3();
    var networks_1 = require_networks3();
    var bscript = require_script2();
    var types_1 = require_types4();
    var lazy = require_lazy2();
    var bs58check2 = require_bs58check2();
    var OPS10 = bscript.OPS;
    function p2pkh2(a, opts) {
      if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(25)),
          pubkey: types_1.typeforce.maybe(types_1.isPoint),
          signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer)
        },
        a
      );
      const _address = lazy.value(() => {
        const payload = import_buffer.Buffer.from(bs58check2.decode(a.address));
        const version = payload.readUInt8(0);
        const hash = payload.slice(1);
        return { version, hash };
      });
      const _chunks = lazy.value(() => {
        return bscript.decompile(a.input);
      });
      const network = a.network || networks_1.bitcoin;
      const o = { name: "p2pkh", network };
      lazy.prop(o, "address", () => {
        if (!o.hash) return;
        const payload = import_buffer.Buffer.allocUnsafe(21);
        payload.writeUInt8(network.pubKeyHash, 0);
        o.hash.copy(payload, 1);
        return bs58check2.encode(payload);
      });
      lazy.prop(o, "hash", () => {
        if (a.output) return a.output.slice(3, 23);
        if (a.address) return _address().hash;
        if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
      });
      lazy.prop(o, "output", () => {
        if (!o.hash) return;
        return bscript.compile([
          OPS10.OP_DUP,
          OPS10.OP_HASH160,
          o.hash,
          OPS10.OP_EQUALVERIFY,
          OPS10.OP_CHECKSIG
        ]);
      });
      lazy.prop(o, "pubkey", () => {
        if (!a.input) return;
        return _chunks()[1];
      });
      lazy.prop(o, "signature", () => {
        if (!a.input) return;
        return _chunks()[0];
      });
      lazy.prop(o, "input", () => {
        if (!a.pubkey) return;
        if (!a.signature) return;
        return bscript.compile([a.signature, a.pubkey]);
      });
      lazy.prop(o, "witness", () => {
        if (!o.input) return;
        return [];
      });
      if (opts.validate) {
        let hash = import_buffer.Buffer.from([]);
        if (a.address) {
          if (_address().version !== network.pubKeyHash)
            throw new TypeError("Invalid version or Network mismatch");
          if (_address().hash.length !== 20) throw new TypeError("Invalid address");
          hash = _address().hash;
        }
        if (a.hash) {
          if (hash.length > 0 && !hash.equals(a.hash))
            throw new TypeError("Hash mismatch");
          else hash = a.hash;
        }
        if (a.output) {
          if (a.output.length !== 25 || a.output[0] !== OPS10.OP_DUP || a.output[1] !== OPS10.OP_HASH160 || a.output[2] !== 20 || a.output[23] !== OPS10.OP_EQUALVERIFY || a.output[24] !== OPS10.OP_CHECKSIG)
            throw new TypeError("Output is invalid");
          const hash2 = a.output.slice(3, 23);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        if (a.pubkey) {
          const pkh = bcrypto.hash160(a.pubkey);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
          else hash = pkh;
        }
        if (a.input) {
          const chunks = _chunks();
          if (chunks.length !== 2) throw new TypeError("Input is invalid");
          if (!bscript.isCanonicalScriptSignature(chunks[0]))
            throw new TypeError("Input has invalid signature");
          if (!(0, types_1.isPoint)(chunks[1]))
            throw new TypeError("Input has invalid pubkey");
          if (a.signature && !a.signature.equals(chunks[0]))
            throw new TypeError("Signature mismatch");
          if (a.pubkey && !a.pubkey.equals(chunks[1]))
            throw new TypeError("Pubkey mismatch");
          const pkh = bcrypto.hash160(chunks[1]);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2pkh = p2pkh2;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2sh.js
var require_p2sh2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2sh.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2sh = void 0;
    var bcrypto = require_crypto3();
    var networks_1 = require_networks3();
    var bscript = require_script2();
    var types_1 = require_types4();
    var lazy = require_lazy2();
    var bs58check2 = require_bs58check2();
    var OPS10 = bscript.OPS;
    function p2sh2(a, opts) {
      if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(23)),
          redeem: types_1.typeforce.maybe({
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          }),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a
      );
      let network = a.network;
      if (!network) {
        network = a.redeem && a.redeem.network || networks_1.bitcoin;
      }
      const o = { network };
      const _address = lazy.value(() => {
        const payload = import_buffer.Buffer.from(bs58check2.decode(a.address));
        const version = payload.readUInt8(0);
        const hash = payload.slice(1);
        return { version, hash };
      });
      const _chunks = lazy.value(() => {
        return bscript.decompile(a.input);
      });
      const _redeem = lazy.value(() => {
        const chunks = _chunks();
        const lastChunk = chunks[chunks.length - 1];
        return {
          network,
          output: lastChunk === OPS10.OP_FALSE ? import_buffer.Buffer.from([]) : lastChunk,
          input: bscript.compile(chunks.slice(0, -1)),
          witness: a.witness || []
        };
      });
      lazy.prop(o, "address", () => {
        if (!o.hash) return;
        const payload = import_buffer.Buffer.allocUnsafe(21);
        payload.writeUInt8(o.network.scriptHash, 0);
        o.hash.copy(payload, 1);
        return bs58check2.encode(payload);
      });
      lazy.prop(o, "hash", () => {
        if (a.output) return a.output.slice(2, 22);
        if (a.address) return _address().hash;
        if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);
      });
      lazy.prop(o, "output", () => {
        if (!o.hash) return;
        return bscript.compile([OPS10.OP_HASH160, o.hash, OPS10.OP_EQUAL]);
      });
      lazy.prop(o, "redeem", () => {
        if (!a.input) return;
        return _redeem();
      });
      lazy.prop(o, "input", () => {
        if (!a.redeem || !a.redeem.input || !a.redeem.output) return;
        return bscript.compile(
          [].concat(bscript.decompile(a.redeem.input), a.redeem.output)
        );
      });
      lazy.prop(o, "witness", () => {
        if (o.redeem && o.redeem.witness) return o.redeem.witness;
        if (o.input) return [];
      });
      lazy.prop(o, "name", () => {
        const nameParts = ["p2sh"];
        if (o.redeem !== void 0 && o.redeem.name !== void 0)
          nameParts.push(o.redeem.name);
        return nameParts.join("-");
      });
      if (opts.validate) {
        let hash = import_buffer.Buffer.from([]);
        if (a.address) {
          if (_address().version !== network.scriptHash)
            throw new TypeError("Invalid version or Network mismatch");
          if (_address().hash.length !== 20) throw new TypeError("Invalid address");
          hash = _address().hash;
        }
        if (a.hash) {
          if (hash.length > 0 && !hash.equals(a.hash))
            throw new TypeError("Hash mismatch");
          else hash = a.hash;
        }
        if (a.output) {
          if (a.output.length !== 23 || a.output[0] !== OPS10.OP_HASH160 || a.output[1] !== 20 || a.output[22] !== OPS10.OP_EQUAL)
            throw new TypeError("Output is invalid");
          const hash2 = a.output.slice(2, 22);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        const checkRedeem = (redeem) => {
          if (redeem.output) {
            const decompile2 = bscript.decompile(redeem.output);
            if (!decompile2 || decompile2.length < 1)
              throw new TypeError("Redeem.output too short");
            if (redeem.output.byteLength > 520)
              throw new TypeError(
                "Redeem.output unspendable if larger than 520 bytes"
              );
            if (bscript.countNonPushOnlyOPs(decompile2) > 201)
              throw new TypeError(
                "Redeem.output unspendable with more than 201 non-push ops"
              );
            const hash2 = bcrypto.hash160(redeem.output);
            if (hash.length > 0 && !hash.equals(hash2))
              throw new TypeError("Hash mismatch");
            else hash = hash2;
          }
          if (redeem.input) {
            const hasInput = redeem.input.length > 0;
            const hasWitness = redeem.witness && redeem.witness.length > 0;
            if (!hasInput && !hasWitness) throw new TypeError("Empty input");
            if (hasInput && hasWitness)
              throw new TypeError("Input and witness provided");
            if (hasInput) {
              const richunks = bscript.decompile(redeem.input);
              if (!bscript.isPushOnly(richunks))
                throw new TypeError("Non push-only scriptSig");
            }
          }
        };
        if (a.input) {
          const chunks = _chunks();
          if (!chunks || chunks.length < 1) throw new TypeError("Input too short");
          if (!import_buffer.Buffer.isBuffer(_redeem().output))
            throw new TypeError("Input is invalid");
          checkRedeem(_redeem());
        }
        if (a.redeem) {
          if (a.redeem.network && a.redeem.network !== network)
            throw new TypeError("Network mismatch");
          if (a.input) {
            const redeem = _redeem();
            if (a.redeem.output && !a.redeem.output.equals(redeem.output))
              throw new TypeError("Redeem.output mismatch");
            if (a.redeem.input && !a.redeem.input.equals(redeem.input))
              throw new TypeError("Redeem.input mismatch");
          }
          checkRedeem(a.redeem);
        }
        if (a.witness) {
          if (a.redeem && a.redeem.witness && !(0, types_1.stacksEqual)(a.redeem.witness, a.witness))
            throw new TypeError("Witness and redeem.witness mismatch");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2sh = p2sh2;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2wpkh.js
var require_p2wpkh2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2wpkh.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2wpkh = void 0;
    var bcrypto = require_crypto3();
    var networks_1 = require_networks3();
    var bscript = require_script2();
    var types_1 = require_types4();
    var lazy = require_lazy2();
    var bech32_1 = require_dist();
    var OPS10 = bscript.OPS;
    var EMPTY_BUFFER4 = import_buffer.Buffer.alloc(0);
    function p2wpkh2(a, opts) {
      if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
          input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(22)),
          pubkey: types_1.typeforce.maybe(types_1.isPoint),
          signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a
      );
      const _address = lazy.value(() => {
        const result = bech32_1.bech32.decode(a.address);
        const version = result.words.shift();
        const data = bech32_1.bech32.fromWords(result.words);
        return {
          version,
          prefix: result.prefix,
          data: import_buffer.Buffer.from(data)
        };
      });
      const network = a.network || networks_1.bitcoin;
      const o = { name: "p2wpkh", network };
      lazy.prop(o, "address", () => {
        if (!o.hash) return;
        const words = bech32_1.bech32.toWords(o.hash);
        words.unshift(0);
        return bech32_1.bech32.encode(network.bech32, words);
      });
      lazy.prop(o, "hash", () => {
        if (a.output) return a.output.slice(2, 22);
        if (a.address) return _address().data;
        if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
      });
      lazy.prop(o, "output", () => {
        if (!o.hash) return;
        return bscript.compile([OPS10.OP_0, o.hash]);
      });
      lazy.prop(o, "pubkey", () => {
        if (a.pubkey) return a.pubkey;
        if (!a.witness) return;
        return a.witness[1];
      });
      lazy.prop(o, "signature", () => {
        if (!a.witness) return;
        return a.witness[0];
      });
      lazy.prop(o, "input", () => {
        if (!o.witness) return;
        return EMPTY_BUFFER4;
      });
      lazy.prop(o, "witness", () => {
        if (!a.pubkey) return;
        if (!a.signature) return;
        return [a.signature, a.pubkey];
      });
      if (opts.validate) {
        let hash = import_buffer.Buffer.from([]);
        if (a.address) {
          if (network && network.bech32 !== _address().prefix)
            throw new TypeError("Invalid prefix or Network mismatch");
          if (_address().version !== 0)
            throw new TypeError("Invalid address version");
          if (_address().data.length !== 20)
            throw new TypeError("Invalid address data");
          hash = _address().data;
        }
        if (a.hash) {
          if (hash.length > 0 && !hash.equals(a.hash))
            throw new TypeError("Hash mismatch");
          else hash = a.hash;
        }
        if (a.output) {
          if (a.output.length !== 22 || a.output[0] !== OPS10.OP_0 || a.output[1] !== 20)
            throw new TypeError("Output is invalid");
          if (hash.length > 0 && !hash.equals(a.output.slice(2)))
            throw new TypeError("Hash mismatch");
          else hash = a.output.slice(2);
        }
        if (a.pubkey) {
          const pkh = bcrypto.hash160(a.pubkey);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
          else hash = pkh;
          if (!(0, types_1.isPoint)(a.pubkey) || a.pubkey.length !== 33)
            throw new TypeError("Invalid pubkey for p2wpkh");
        }
        if (a.witness) {
          if (a.witness.length !== 2) throw new TypeError("Witness is invalid");
          if (!bscript.isCanonicalScriptSignature(a.witness[0]))
            throw new TypeError("Witness has invalid signature");
          if (!(0, types_1.isPoint)(a.witness[1]) || a.witness[1].length !== 33)
            throw new TypeError("Witness has invalid pubkey");
          if (a.signature && !a.signature.equals(a.witness[0]))
            throw new TypeError("Signature mismatch");
          if (a.pubkey && !a.pubkey.equals(a.witness[1]))
            throw new TypeError("Pubkey mismatch");
          const pkh = bcrypto.hash160(a.witness[1]);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2wpkh = p2wpkh2;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2wsh.js
var require_p2wsh2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2wsh.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2wsh = void 0;
    var bcrypto = require_crypto3();
    var networks_1 = require_networks3();
    var bscript = require_script2();
    var types_1 = require_types4();
    var lazy = require_lazy2();
    var bech32_1 = require_dist();
    var OPS10 = bscript.OPS;
    var EMPTY_BUFFER4 = import_buffer.Buffer.alloc(0);
    function chunkHasUncompressedPubkey2(chunk) {
      if (import_buffer.Buffer.isBuffer(chunk) && chunk.length === 65 && chunk[0] === 4 && (0, types_1.isPoint)(chunk)) {
        return true;
      } else {
        return false;
      }
    }
    function p2wsh2(a, opts) {
      if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
          redeem: types_1.typeforce.maybe({
            input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          }),
          input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a
      );
      const _address = lazy.value(() => {
        const result = bech32_1.bech32.decode(a.address);
        const version = result.words.shift();
        const data = bech32_1.bech32.fromWords(result.words);
        return {
          version,
          prefix: result.prefix,
          data: import_buffer.Buffer.from(data)
        };
      });
      const _rchunks = lazy.value(() => {
        return bscript.decompile(a.redeem.input);
      });
      let network = a.network;
      if (!network) {
        network = a.redeem && a.redeem.network || networks_1.bitcoin;
      }
      const o = { network };
      lazy.prop(o, "address", () => {
        if (!o.hash) return;
        const words = bech32_1.bech32.toWords(o.hash);
        words.unshift(0);
        return bech32_1.bech32.encode(network.bech32, words);
      });
      lazy.prop(o, "hash", () => {
        if (a.output) return a.output.slice(2);
        if (a.address) return _address().data;
        if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);
      });
      lazy.prop(o, "output", () => {
        if (!o.hash) return;
        return bscript.compile([OPS10.OP_0, o.hash]);
      });
      lazy.prop(o, "redeem", () => {
        if (!a.witness) return;
        return {
          output: a.witness[a.witness.length - 1],
          input: EMPTY_BUFFER4,
          witness: a.witness.slice(0, -1)
        };
      });
      lazy.prop(o, "input", () => {
        if (!o.witness) return;
        return EMPTY_BUFFER4;
      });
      lazy.prop(o, "witness", () => {
        if (a.redeem && a.redeem.input && a.redeem.input.length > 0 && a.redeem.output && a.redeem.output.length > 0) {
          const stack = bscript.toStack(_rchunks());
          o.redeem = Object.assign({ witness: stack }, a.redeem);
          o.redeem.input = EMPTY_BUFFER4;
          return [].concat(stack, a.redeem.output);
        }
        if (!a.redeem) return;
        if (!a.redeem.output) return;
        if (!a.redeem.witness) return;
        return [].concat(a.redeem.witness, a.redeem.output);
      });
      lazy.prop(o, "name", () => {
        const nameParts = ["p2wsh"];
        if (o.redeem !== void 0 && o.redeem.name !== void 0)
          nameParts.push(o.redeem.name);
        return nameParts.join("-");
      });
      if (opts.validate) {
        let hash = import_buffer.Buffer.from([]);
        if (a.address) {
          if (_address().prefix !== network.bech32)
            throw new TypeError("Invalid prefix or Network mismatch");
          if (_address().version !== 0)
            throw new TypeError("Invalid address version");
          if (_address().data.length !== 32)
            throw new TypeError("Invalid address data");
          hash = _address().data;
        }
        if (a.hash) {
          if (hash.length > 0 && !hash.equals(a.hash))
            throw new TypeError("Hash mismatch");
          else hash = a.hash;
        }
        if (a.output) {
          if (a.output.length !== 34 || a.output[0] !== OPS10.OP_0 || a.output[1] !== 32)
            throw new TypeError("Output is invalid");
          const hash2 = a.output.slice(2);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        if (a.redeem) {
          if (a.redeem.network && a.redeem.network !== network)
            throw new TypeError("Network mismatch");
          if (a.redeem.input && a.redeem.input.length > 0 && a.redeem.witness && a.redeem.witness.length > 0)
            throw new TypeError("Ambiguous witness source");
          if (a.redeem.output) {
            const decompile2 = bscript.decompile(a.redeem.output);
            if (!decompile2 || decompile2.length < 1)
              throw new TypeError("Redeem.output is invalid");
            if (a.redeem.output.byteLength > 3600)
              throw new TypeError(
                "Redeem.output unspendable if larger than 3600 bytes"
              );
            if (bscript.countNonPushOnlyOPs(decompile2) > 201)
              throw new TypeError(
                "Redeem.output unspendable with more than 201 non-push ops"
              );
            const hash2 = bcrypto.sha256(a.redeem.output);
            if (hash.length > 0 && !hash.equals(hash2))
              throw new TypeError("Hash mismatch");
            else hash = hash2;
          }
          if (a.redeem.input && !bscript.isPushOnly(_rchunks()))
            throw new TypeError("Non push-only scriptSig");
          if (a.witness && a.redeem.witness && !(0, types_1.stacksEqual)(a.witness, a.redeem.witness))
            throw new TypeError("Witness and redeem.witness mismatch");
          if (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey2) || a.redeem.output && (bscript.decompile(a.redeem.output) || []).some(
            chunkHasUncompressedPubkey2
          )) {
            throw new TypeError(
              "redeem.input or redeem.output contains uncompressed pubkey"
            );
          }
        }
        if (a.witness && a.witness.length > 0) {
          const wScript = a.witness[a.witness.length - 1];
          if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))
            throw new TypeError("Witness and redeem.output mismatch");
          if (a.witness.some(chunkHasUncompressedPubkey2) || (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey2))
            throw new TypeError("Witness contains uncompressed pubkey");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2wsh = p2wsh2;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/ecc_lib.js
var require_ecc_lib = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/ecc_lib.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEccLib = exports2.initEccLib = void 0;
    var _ECCLIB_CACHE2 = {};
    function initEccLib2(eccLib, opts) {
      if (!eccLib) {
        _ECCLIB_CACHE2.eccLib = eccLib;
      } else if (eccLib !== _ECCLIB_CACHE2.eccLib) {
        if (!opts?.DANGER_DO_NOT_VERIFY_ECCLIB)
          verifyEcc2(eccLib);
        _ECCLIB_CACHE2.eccLib = eccLib;
      }
    }
    exports2.initEccLib = initEccLib2;
    function getEccLib2() {
      if (!_ECCLIB_CACHE2.eccLib)
        throw new Error(
          "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
        );
      return _ECCLIB_CACHE2.eccLib;
    }
    exports2.getEccLib = getEccLib2;
    var h3 = (hex) => import_buffer.Buffer.from(hex, "hex");
    function verifyEcc2(ecc2) {
      assert3(typeof ecc2.isXOnlyPoint === "function");
      assert3(
        ecc2.isXOnlyPoint(
          h3("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
        )
      );
      assert3(
        ecc2.isXOnlyPoint(
          h3("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
        )
      );
      assert3(
        ecc2.isXOnlyPoint(
          h3("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
        )
      );
      assert3(
        ecc2.isXOnlyPoint(
          h3("0000000000000000000000000000000000000000000000000000000000000001")
        )
      );
      assert3(
        !ecc2.isXOnlyPoint(
          h3("0000000000000000000000000000000000000000000000000000000000000000")
        )
      );
      assert3(
        !ecc2.isXOnlyPoint(
          h3("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
        )
      );
      assert3(typeof ecc2.xOnlyPointAddTweak === "function");
      tweakAddVectors2.forEach((t) => {
        const r = ecc2.xOnlyPointAddTweak(h3(t.pubkey), h3(t.tweak));
        if (t.result === null) {
          assert3(r === null);
        } else {
          assert3(r !== null);
          assert3(r.parity === t.parity);
          assert3(import_buffer.Buffer.from(r.xOnlyPubkey).equals(h3(t.result)));
        }
      });
    }
    function assert3(bool) {
      if (!bool) throw new Error("ecc library invalid");
    }
    var tweakAddVectors2 = [
      {
        pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
        parity: -1,
        result: null
      },
      {
        pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
        tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
        parity: 1,
        result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
      },
      {
        pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
        tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
        parity: 0,
        result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
      }
    ];
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/bufferutils.js
var require_bufferutils2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/bufferutils.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BufferReader = exports2.BufferWriter = exports2.cloneBuffer = exports2.reverseBuffer = exports2.writeUInt64LE = exports2.readUInt64LE = exports2.varuint = void 0;
    var types = require_types4();
    var { typeforce } = types;
    var varuint = require_varuint_bitcoin();
    exports2.varuint = varuint;
    function verifuint(value2, max) {
      if (typeof value2 !== "number")
        throw new Error("cannot write a non-number as a number");
      if (value2 < 0)
        throw new Error("specified a negative value for writing an unsigned value");
      if (value2 > max) throw new Error("RangeError: value out of range");
      if (Math.floor(value2) !== value2)
        throw new Error("value has a fractional component");
    }
    function readUInt64LE(buffer2, offset) {
      const a = buffer2.readUInt32LE(offset);
      let b = buffer2.readUInt32LE(offset + 4);
      b *= 4294967296;
      verifuint(b + a, 9007199254740991);
      return b + a;
    }
    exports2.readUInt64LE = readUInt64LE;
    function writeUInt64LE(buffer2, value2, offset) {
      verifuint(value2, 9007199254740991);
      buffer2.writeInt32LE(value2 & -1, offset);
      buffer2.writeUInt32LE(Math.floor(value2 / 4294967296), offset + 4);
      return offset + 8;
    }
    exports2.writeUInt64LE = writeUInt64LE;
    function reverseBuffer2(buffer2) {
      if (buffer2.length < 1) return buffer2;
      let j = buffer2.length - 1;
      let tmp = 0;
      for (let i = 0; i < buffer2.length / 2; i++) {
        tmp = buffer2[i];
        buffer2[i] = buffer2[j];
        buffer2[j] = tmp;
        j--;
      }
      return buffer2;
    }
    exports2.reverseBuffer = reverseBuffer2;
    function cloneBuffer2(buffer2) {
      const clone = import_buffer.Buffer.allocUnsafe(buffer2.length);
      buffer2.copy(clone);
      return clone;
    }
    exports2.cloneBuffer = cloneBuffer2;
    var BufferWriter2 = class _BufferWriter {
      static withCapacity(size) {
        return new _BufferWriter(import_buffer.Buffer.alloc(size));
      }
      constructor(buffer2, offset = 0) {
        this.buffer = buffer2;
        this.offset = offset;
        typeforce(types.tuple(types.Buffer, types.UInt32), [buffer2, offset]);
      }
      writeUInt8(i) {
        this.offset = this.buffer.writeUInt8(i, this.offset);
      }
      writeInt32(i) {
        this.offset = this.buffer.writeInt32LE(i, this.offset);
      }
      writeUInt32(i) {
        this.offset = this.buffer.writeUInt32LE(i, this.offset);
      }
      writeUInt64(i) {
        this.offset = writeUInt64LE(this.buffer, i, this.offset);
      }
      writeVarInt(i) {
        varuint.encode(i, this.buffer, this.offset);
        this.offset += varuint.encode.bytes;
      }
      writeSlice(slice2) {
        if (this.buffer.length < this.offset + slice2.length) {
          throw new Error("Cannot write slice out of bounds");
        }
        this.offset += slice2.copy(this.buffer, this.offset);
      }
      writeVarSlice(slice2) {
        this.writeVarInt(slice2.length);
        this.writeSlice(slice2);
      }
      writeVector(vector) {
        this.writeVarInt(vector.length);
        vector.forEach((buf2) => this.writeVarSlice(buf2));
      }
      end() {
        if (this.buffer.length === this.offset) {
          return this.buffer;
        }
        throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
      }
    };
    exports2.BufferWriter = BufferWriter2;
    var BufferReader2 = class {
      constructor(buffer2, offset = 0) {
        this.buffer = buffer2;
        this.offset = offset;
        typeforce(types.tuple(types.Buffer, types.UInt32), [buffer2, offset]);
      }
      readUInt8() {
        const result = this.buffer.readUInt8(this.offset);
        this.offset++;
        return result;
      }
      readInt32() {
        const result = this.buffer.readInt32LE(this.offset);
        this.offset += 4;
        return result;
      }
      readUInt32() {
        const result = this.buffer.readUInt32LE(this.offset);
        this.offset += 4;
        return result;
      }
      readUInt64() {
        const result = readUInt64LE(this.buffer, this.offset);
        this.offset += 8;
        return result;
      }
      readVarInt() {
        const vi = varuint.decode(this.buffer, this.offset);
        this.offset += varuint.decode.bytes;
        return vi;
      }
      readSlice(n2) {
        if (this.buffer.length < this.offset + n2) {
          throw new Error("Cannot read slice out of bounds");
        }
        const result = this.buffer.slice(this.offset, this.offset + n2);
        this.offset += n2;
        return result;
      }
      readVarSlice() {
        return this.readSlice(this.readVarInt());
      }
      readVector() {
        const count = this.readVarInt();
        const vector = [];
        for (let i = 0; i < count; i++) vector.push(this.readVarSlice());
        return vector;
      }
    };
    exports2.BufferReader = BufferReader2;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/bip341.js
var require_bip3412 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/bip341.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tweakKey = exports2.tapTweakHash = exports2.tapleafHash = exports2.findScriptPath = exports2.toHashTree = exports2.rootHashFromPath = exports2.MAX_TAPTREE_DEPTH = exports2.LEAF_VERSION_TAPSCRIPT = void 0;
    var buffer_1 = require_buffer();
    var ecc_lib_1 = require_ecc_lib();
    var bcrypto = require_crypto3();
    var bufferutils_1 = require_bufferutils2();
    var types_1 = require_types4();
    exports2.LEAF_VERSION_TAPSCRIPT = 192;
    exports2.MAX_TAPTREE_DEPTH = 128;
    var isHashBranch2 = (ht) => "left" in ht && "right" in ht;
    function rootHashFromPath2(controlBlock, leafHash) {
      if (controlBlock.length < 33)
        throw new TypeError(
          `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`
        );
      const m = (controlBlock.length - 33) / 32;
      let kj = leafHash;
      for (let j = 0; j < m; j++) {
        const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);
        if (kj.compare(ej) < 0) {
          kj = tapBranchHash2(kj, ej);
        } else {
          kj = tapBranchHash2(ej, kj);
        }
      }
      return kj;
    }
    exports2.rootHashFromPath = rootHashFromPath2;
    function toHashTree2(scriptTree) {
      if ((0, types_1.isTapleaf)(scriptTree))
        return { hash: tapleafHash2(scriptTree) };
      const hashes4 = [toHashTree2(scriptTree[0]), toHashTree2(scriptTree[1])];
      hashes4.sort((a, b) => a.hash.compare(b.hash));
      const [left, right] = hashes4;
      return {
        hash: tapBranchHash2(left.hash, right.hash),
        left,
        right
      };
    }
    exports2.toHashTree = toHashTree2;
    function findScriptPath2(node, hash) {
      if (isHashBranch2(node)) {
        const leftPath = findScriptPath2(node.left, hash);
        if (leftPath !== void 0) return [...leftPath, node.right.hash];
        const rightPath = findScriptPath2(node.right, hash);
        if (rightPath !== void 0) return [...rightPath, node.left.hash];
      } else if (node.hash.equals(hash)) {
        return [];
      }
      return void 0;
    }
    exports2.findScriptPath = findScriptPath2;
    function tapleafHash2(leaf) {
      const version = leaf.version || exports2.LEAF_VERSION_TAPSCRIPT;
      return bcrypto.taggedHash(
        "TapLeaf",
        buffer_1.Buffer.concat([
          buffer_1.Buffer.from([version]),
          serializeScript2(leaf.output)
        ])
      );
    }
    exports2.tapleafHash = tapleafHash2;
    function tapTweakHash2(pubKey, h3) {
      return bcrypto.taggedHash(
        "TapTweak",
        buffer_1.Buffer.concat(h3 ? [pubKey, h3] : [pubKey])
      );
    }
    exports2.tapTweakHash = tapTweakHash2;
    function tweakKey2(pubKey, h3) {
      if (!buffer_1.Buffer.isBuffer(pubKey)) return null;
      if (pubKey.length !== 32) return null;
      if (h3 && h3.length !== 32) return null;
      const tweakHash = tapTweakHash2(pubKey, h3);
      const res = (0, ecc_lib_1.getEccLib)().xOnlyPointAddTweak(pubKey, tweakHash);
      if (!res || res.xOnlyPubkey === null) return null;
      return {
        parity: res.parity,
        x: buffer_1.Buffer.from(res.xOnlyPubkey)
      };
    }
    exports2.tweakKey = tweakKey2;
    function tapBranchHash2(a, b) {
      return bcrypto.taggedHash("TapBranch", buffer_1.Buffer.concat([a, b]));
    }
    function serializeScript2(s) {
      const varintLen = bufferutils_1.varuint.encodingLength(s.length);
      const buffer2 = buffer_1.Buffer.allocUnsafe(varintLen);
      bufferutils_1.varuint.encode(s.length, buffer2);
      return buffer_1.Buffer.concat([buffer2, s]);
    }
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2tr.js
var require_p2tr = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2tr.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2tr = void 0;
    var buffer_1 = require_buffer();
    var networks_1 = require_networks3();
    var bscript = require_script2();
    var types_1 = require_types4();
    var ecc_lib_1 = require_ecc_lib();
    var bip341_1 = require_bip3412();
    var lazy = require_lazy2();
    var bech32_1 = require_dist();
    var address_1 = require_address2();
    var OPS10 = bscript.OPS;
    var TAPROOT_WITNESS_VERSION2 = 1;
    var ANNEX_PREFIX2 = 80;
    function p2tr2(a, opts) {
      if (!a.address && !a.output && !a.pubkey && !a.internalPubkey && !(a.witness && a.witness.length > 1))
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
          internalPubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
          pubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
          signature: types_1.typeforce.maybe(
            types_1.typeforce.anyOf(
              types_1.typeforce.BufferN(64),
              types_1.typeforce.BufferN(65)
            )
          ),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          ),
          scriptTree: types_1.typeforce.maybe(types_1.isTaptree),
          redeem: types_1.typeforce.maybe({
            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          }),
          redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number)
        },
        a
      );
      const _address = lazy.value(() => {
        return (0, address_1.fromBech32)(a.address);
      });
      const _witness = lazy.value(() => {
        if (!a.witness || !a.witness.length) return;
        if (a.witness.length >= 2 && a.witness[a.witness.length - 1][0] === ANNEX_PREFIX2) {
          return a.witness.slice(0, -1);
        }
        return a.witness.slice();
      });
      const _hashTree = lazy.value(() => {
        if (a.scriptTree) return (0, bip341_1.toHashTree)(a.scriptTree);
        if (a.hash) return { hash: a.hash };
        return;
      });
      const network = a.network || networks_1.bitcoin;
      const o = { name: "p2tr", network };
      lazy.prop(o, "address", () => {
        if (!o.pubkey) return;
        const words = bech32_1.bech32m.toWords(o.pubkey);
        words.unshift(TAPROOT_WITNESS_VERSION2);
        return bech32_1.bech32m.encode(network.bech32, words);
      });
      lazy.prop(o, "hash", () => {
        const hashTree = _hashTree();
        if (hashTree) return hashTree.hash;
        const w = _witness();
        if (w && w.length > 1) {
          const controlBlock = w[w.length - 1];
          const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;
          const script = w[w.length - 2];
          const leafHash = (0, bip341_1.tapleafHash)({
            output: script,
            version: leafVersion
          });
          return (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);
        }
        return null;
      });
      lazy.prop(o, "output", () => {
        if (!o.pubkey) return;
        return bscript.compile([OPS10.OP_1, o.pubkey]);
      });
      lazy.prop(o, "redeemVersion", () => {
        if (a.redeemVersion) return a.redeemVersion;
        if (a.redeem && a.redeem.redeemVersion !== void 0 && a.redeem.redeemVersion !== null) {
          return a.redeem.redeemVersion;
        }
        return bip341_1.LEAF_VERSION_TAPSCRIPT;
      });
      lazy.prop(o, "redeem", () => {
        const witness = _witness();
        if (!witness || witness.length < 2) return;
        return {
          output: witness[witness.length - 2],
          witness: witness.slice(0, -2),
          redeemVersion: witness[witness.length - 1][0] & types_1.TAPLEAF_VERSION_MASK
        };
      });
      lazy.prop(o, "pubkey", () => {
        if (a.pubkey) return a.pubkey;
        if (a.output) return a.output.slice(2);
        if (a.address) return _address().data;
        if (o.internalPubkey) {
          const tweakedKey = (0, bip341_1.tweakKey)(o.internalPubkey, o.hash);
          if (tweakedKey) return tweakedKey.x;
        }
      });
      lazy.prop(o, "internalPubkey", () => {
        if (a.internalPubkey) return a.internalPubkey;
        const witness = _witness();
        if (witness && witness.length > 1)
          return witness[witness.length - 1].slice(1, 33);
      });
      lazy.prop(o, "signature", () => {
        if (a.signature) return a.signature;
        const witness = _witness();
        if (!witness || witness.length !== 1) return;
        return witness[0];
      });
      lazy.prop(o, "witness", () => {
        if (a.witness) return a.witness;
        const hashTree = _hashTree();
        if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {
          const leafHash = (0, bip341_1.tapleafHash)({
            output: a.redeem.output,
            version: o.redeemVersion
          });
          const path = (0, bip341_1.findScriptPath)(hashTree, leafHash);
          if (!path) return;
          const outputKey = (0, bip341_1.tweakKey)(a.internalPubkey, hashTree.hash);
          if (!outputKey) return;
          const controlBock = buffer_1.Buffer.concat(
            [
              buffer_1.Buffer.from([o.redeemVersion | outputKey.parity]),
              a.internalPubkey
            ].concat(path)
          );
          return [a.redeem.output, controlBock];
        }
        if (a.signature) return [a.signature];
      });
      if (opts.validate) {
        let pubkey = buffer_1.Buffer.from([]);
        if (a.address) {
          if (network && network.bech32 !== _address().prefix)
            throw new TypeError("Invalid prefix or Network mismatch");
          if (_address().version !== TAPROOT_WITNESS_VERSION2)
            throw new TypeError("Invalid address version");
          if (_address().data.length !== 32)
            throw new TypeError("Invalid address data");
          pubkey = _address().data;
        }
        if (a.pubkey) {
          if (pubkey.length > 0 && !pubkey.equals(a.pubkey))
            throw new TypeError("Pubkey mismatch");
          else pubkey = a.pubkey;
        }
        if (a.output) {
          if (a.output.length !== 34 || a.output[0] !== OPS10.OP_1 || a.output[1] !== 32)
            throw new TypeError("Output is invalid");
          if (pubkey.length > 0 && !pubkey.equals(a.output.slice(2)))
            throw new TypeError("Pubkey mismatch");
          else pubkey = a.output.slice(2);
        }
        if (a.internalPubkey) {
          const tweakedKey = (0, bip341_1.tweakKey)(a.internalPubkey, o.hash);
          if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x))
            throw new TypeError("Pubkey mismatch");
          else pubkey = tweakedKey.x;
        }
        if (pubkey && pubkey.length) {
          if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(pubkey))
            throw new TypeError("Invalid pubkey for p2tr");
        }
        const hashTree = _hashTree();
        if (a.hash && hashTree) {
          if (!a.hash.equals(hashTree.hash)) throw new TypeError("Hash mismatch");
        }
        if (a.redeem && a.redeem.output && hashTree) {
          const leafHash = (0, bip341_1.tapleafHash)({
            output: a.redeem.output,
            version: o.redeemVersion
          });
          if (!(0, bip341_1.findScriptPath)(hashTree, leafHash))
            throw new TypeError("Redeem script not in tree");
        }
        const witness = _witness();
        if (a.redeem && o.redeem) {
          if (a.redeem.redeemVersion) {
            if (a.redeem.redeemVersion !== o.redeem.redeemVersion)
              throw new TypeError("Redeem.redeemVersion and witness mismatch");
          }
          if (a.redeem.output) {
            if (bscript.decompile(a.redeem.output).length === 0)
              throw new TypeError("Redeem.output is invalid");
            if (o.redeem.output && !a.redeem.output.equals(o.redeem.output))
              throw new TypeError("Redeem.output and witness mismatch");
          }
          if (a.redeem.witness) {
            if (o.redeem.witness && !(0, types_1.stacksEqual)(a.redeem.witness, o.redeem.witness))
              throw new TypeError("Redeem.witness and witness mismatch");
          }
        }
        if (witness && witness.length) {
          if (witness.length === 1) {
            if (a.signature && !a.signature.equals(witness[0]))
              throw new TypeError("Signature mismatch");
          } else {
            const controlBlock = witness[witness.length - 1];
            if (controlBlock.length < 33)
              throw new TypeError(
                `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`
              );
            if ((controlBlock.length - 33) % 32 !== 0)
              throw new TypeError(
                `The control-block length of ${controlBlock.length} is incorrect!`
              );
            const m = (controlBlock.length - 33) / 32;
            if (m > 128)
              throw new TypeError(
                `The script path is too long. Got ${m}, expected max 128.`
              );
            const internalPubkey = controlBlock.slice(1, 33);
            if (a.internalPubkey && !a.internalPubkey.equals(internalPubkey))
              throw new TypeError("Internal pubkey mismatch");
            if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(internalPubkey))
              throw new TypeError("Invalid internalPubkey for p2tr witness");
            const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;
            const script = witness[witness.length - 2];
            const leafHash = (0, bip341_1.tapleafHash)({
              output: script,
              version: leafVersion
            });
            const hash = (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);
            const outputKey = (0, bip341_1.tweakKey)(internalPubkey, hash);
            if (!outputKey)
              throw new TypeError("Invalid outputKey for p2tr witness");
            if (pubkey.length && !pubkey.equals(outputKey.x))
              throw new TypeError("Pubkey mismatch for p2tr witness");
            if (outputKey.parity !== (controlBlock[0] & 1))
              throw new Error("Incorrect parity");
          }
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2tr = p2tr2;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/index.js
var require_payments2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/index.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2tr = exports2.p2wsh = exports2.p2wpkh = exports2.p2sh = exports2.p2pkh = exports2.p2pk = exports2.p2ms = exports2.embed = void 0;
    var embed_1 = require_embed2();
    Object.defineProperty(exports2, "embed", {
      enumerable: true,
      get: function() {
        return embed_1.p2data;
      }
    });
    var p2ms_1 = require_p2ms2();
    Object.defineProperty(exports2, "p2ms", {
      enumerable: true,
      get: function() {
        return p2ms_1.p2ms;
      }
    });
    var p2pk_1 = require_p2pk2();
    Object.defineProperty(exports2, "p2pk", {
      enumerable: true,
      get: function() {
        return p2pk_1.p2pk;
      }
    });
    var p2pkh_1 = require_p2pkh2();
    Object.defineProperty(exports2, "p2pkh", {
      enumerable: true,
      get: function() {
        return p2pkh_1.p2pkh;
      }
    });
    var p2sh_1 = require_p2sh2();
    Object.defineProperty(exports2, "p2sh", {
      enumerable: true,
      get: function() {
        return p2sh_1.p2sh;
      }
    });
    var p2wpkh_1 = require_p2wpkh2();
    Object.defineProperty(exports2, "p2wpkh", {
      enumerable: true,
      get: function() {
        return p2wpkh_1.p2wpkh;
      }
    });
    var p2wsh_1 = require_p2wsh2();
    Object.defineProperty(exports2, "p2wsh", {
      enumerable: true,
      get: function() {
        return p2wsh_1.p2wsh;
      }
    });
    var p2tr_1 = require_p2tr();
    Object.defineProperty(exports2, "p2tr", {
      enumerable: true,
      get: function() {
        return p2tr_1.p2tr;
      }
    });
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/address.js
var require_address2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/address.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toOutputScript = exports2.fromOutputScript = exports2.toBech32 = exports2.toBase58Check = exports2.fromBech32 = exports2.fromBase58Check = void 0;
    var networks2 = require_networks3();
    var payments = require_payments2();
    var bscript = require_script2();
    var types_1 = require_types4();
    var bech32_1 = require_dist();
    var bs58check2 = require_bs58check2();
    var FUTURE_SEGWIT_MAX_SIZE = 40;
    var FUTURE_SEGWIT_MIN_SIZE = 2;
    var FUTURE_SEGWIT_MAX_VERSION = 16;
    var FUTURE_SEGWIT_MIN_VERSION = 2;
    var FUTURE_SEGWIT_VERSION_DIFF = 80;
    var FUTURE_SEGWIT_VERSION_WARNING = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
    function _toFutureSegwitAddress(output, network) {
      const data = output.slice(2);
      if (data.length < FUTURE_SEGWIT_MIN_SIZE || data.length > FUTURE_SEGWIT_MAX_SIZE)
        throw new TypeError("Invalid program length for segwit address");
      const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;
      if (version < FUTURE_SEGWIT_MIN_VERSION || version > FUTURE_SEGWIT_MAX_VERSION)
        throw new TypeError("Invalid version for segwit address");
      if (output[1] !== data.length)
        throw new TypeError("Invalid script for segwit address");
      console.warn(FUTURE_SEGWIT_VERSION_WARNING);
      return toBech32(data, version, network.bech32);
    }
    function fromBase58Check(address) {
      const payload = import_buffer.Buffer.from(bs58check2.decode(address));
      if (payload.length < 21) throw new TypeError(address + " is too short");
      if (payload.length > 21) throw new TypeError(address + " is too long");
      const version = payload.readUInt8(0);
      const hash = payload.slice(1);
      return { version, hash };
    }
    exports2.fromBase58Check = fromBase58Check;
    function fromBech322(address) {
      let result;
      let version;
      try {
        result = bech32_1.bech32.decode(address);
      } catch (e) {
      }
      if (result) {
        version = result.words[0];
        if (version !== 0) throw new TypeError(address + " uses wrong encoding");
      } else {
        result = bech32_1.bech32m.decode(address);
        version = result.words[0];
        if (version === 0) throw new TypeError(address + " uses wrong encoding");
      }
      const data = bech32_1.bech32.fromWords(result.words.slice(1));
      return {
        version,
        prefix: result.prefix,
        data: import_buffer.Buffer.from(data)
      };
    }
    exports2.fromBech32 = fromBech322;
    function toBase58Check(hash, version) {
      (0, types_1.typeforce)(
        (0, types_1.tuple)(types_1.Hash160bit, types_1.UInt8),
        arguments
      );
      const payload = import_buffer.Buffer.allocUnsafe(21);
      payload.writeUInt8(version, 0);
      hash.copy(payload, 1);
      return bs58check2.encode(payload);
    }
    exports2.toBase58Check = toBase58Check;
    function toBech32(data, version, prefix) {
      const words = bech32_1.bech32.toWords(data);
      words.unshift(version);
      return version === 0 ? bech32_1.bech32.encode(prefix, words) : bech32_1.bech32m.encode(prefix, words);
    }
    exports2.toBech32 = toBech32;
    function fromOutputScript2(output, network) {
      network = network || networks2.bitcoin;
      try {
        return payments.p2pkh({ output, network }).address;
      } catch (e) {
      }
      try {
        return payments.p2sh({ output, network }).address;
      } catch (e) {
      }
      try {
        return payments.p2wpkh({ output, network }).address;
      } catch (e) {
      }
      try {
        return payments.p2wsh({ output, network }).address;
      } catch (e) {
      }
      try {
        return payments.p2tr({ output, network }).address;
      } catch (e) {
      }
      try {
        return _toFutureSegwitAddress(output, network);
      } catch (e) {
      }
      throw new Error(bscript.toASM(output) + " has no matching Address");
    }
    exports2.fromOutputScript = fromOutputScript2;
    function toOutputScript2(address, network) {
      network = network || networks2.bitcoin;
      let decodeBase58;
      let decodeBech32;
      try {
        decodeBase58 = fromBase58Check(address);
      } catch (e) {
      }
      if (decodeBase58) {
        if (decodeBase58.version === network.pubKeyHash)
          return payments.p2pkh({ hash: decodeBase58.hash }).output;
        if (decodeBase58.version === network.scriptHash)
          return payments.p2sh({ hash: decodeBase58.hash }).output;
      } else {
        try {
          decodeBech32 = fromBech322(address);
        } catch (e) {
        }
        if (decodeBech32) {
          if (decodeBech32.prefix !== network.bech32)
            throw new Error(address + " has an invalid prefix");
          if (decodeBech32.version === 0) {
            if (decodeBech32.data.length === 20)
              return payments.p2wpkh({ hash: decodeBech32.data }).output;
            if (decodeBech32.data.length === 32)
              return payments.p2wsh({ hash: decodeBech32.data }).output;
          } else if (decodeBech32.version === 1) {
            if (decodeBech32.data.length === 32)
              return payments.p2tr({ pubkey: decodeBech32.data }).output;
          } else if (decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION && decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION && decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE && decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE) {
            console.warn(FUTURE_SEGWIT_VERSION_WARNING);
            return bscript.compile([
              decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,
              decodeBech32.data
            ]);
          }
        }
      }
      throw new Error(address + " has no matching Script");
    }
    exports2.toOutputScript = toOutputScript2;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/merkle.js
var require_merkle = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/merkle.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fastMerkleRoot = void 0;
    function fastMerkleRoot2(values, digestFn) {
      if (!Array.isArray(values)) throw TypeError("Expected values Array");
      if (typeof digestFn !== "function")
        throw TypeError("Expected digest Function");
      let length6 = values.length;
      const results = values.concat();
      while (length6 > 1) {
        let j = 0;
        for (let i = 0; i < length6; i += 2, ++j) {
          const left = results[i];
          const right = i + 1 === length6 ? left : results[i + 1];
          const data = import_buffer.Buffer.concat([left, right]);
          results[j] = digestFn(data);
        }
        length6 = j;
      }
      return results[0];
    }
    exports2.fastMerkleRoot = fastMerkleRoot2;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/transaction.js
var require_transaction2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/transaction.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Transaction = void 0;
    var bufferutils_1 = require_bufferutils2();
    var bcrypto = require_crypto3();
    var bscript = require_script2();
    var script_1 = require_script2();
    var types = require_types4();
    var { typeforce } = types;
    function varSliceSize(someScript) {
      const length6 = someScript.length;
      return bufferutils_1.varuint.encodingLength(length6) + length6;
    }
    function vectorSize(someVector) {
      const length6 = someVector.length;
      return bufferutils_1.varuint.encodingLength(length6) + someVector.reduce((sum, witness) => {
        return sum + varSliceSize(witness);
      }, 0);
    }
    var EMPTY_BUFFER4 = import_buffer.Buffer.allocUnsafe(0);
    var EMPTY_WITNESS = [];
    var ZERO3 = import_buffer.Buffer.from(
      "0000000000000000000000000000000000000000000000000000000000000000",
      "hex"
    );
    var ONE2 = import_buffer.Buffer.from(
      "0000000000000000000000000000000000000000000000000000000000000001",
      "hex"
    );
    var VALUE_UINT64_MAX2 = import_buffer.Buffer.from("ffffffffffffffff", "hex");
    var BLANK_OUTPUT = {
      script: EMPTY_BUFFER4,
      valueBuffer: VALUE_UINT64_MAX2
    };
    function isOutput(out) {
      return out.value !== void 0;
    }
    var Transaction2 = class _Transaction {
      constructor() {
        this.version = 1;
        this.locktime = 0;
        this.ins = [];
        this.outs = [];
      }
      static fromBuffer(buffer2, _NO_STRICT) {
        const bufferReader = new bufferutils_1.BufferReader(buffer2);
        const tx = new _Transaction();
        tx.version = bufferReader.readInt32();
        const marker = bufferReader.readUInt8();
        const flag = bufferReader.readUInt8();
        let hasWitnesses = false;
        if (marker === _Transaction.ADVANCED_TRANSACTION_MARKER && flag === _Transaction.ADVANCED_TRANSACTION_FLAG) {
          hasWitnesses = true;
        } else {
          bufferReader.offset -= 2;
        }
        const vinLen = bufferReader.readVarInt();
        for (let i = 0; i < vinLen; ++i) {
          tx.ins.push({
            hash: bufferReader.readSlice(32),
            index: bufferReader.readUInt32(),
            script: bufferReader.readVarSlice(),
            sequence: bufferReader.readUInt32(),
            witness: EMPTY_WITNESS
          });
        }
        const voutLen = bufferReader.readVarInt();
        for (let i = 0; i < voutLen; ++i) {
          tx.outs.push({
            value: bufferReader.readUInt64(),
            script: bufferReader.readVarSlice()
          });
        }
        if (hasWitnesses) {
          for (let i = 0; i < vinLen; ++i) {
            tx.ins[i].witness = bufferReader.readVector();
          }
          if (!tx.hasWitnesses())
            throw new Error("Transaction has superfluous witness data");
        }
        tx.locktime = bufferReader.readUInt32();
        if (_NO_STRICT) return tx;
        if (bufferReader.offset !== buffer2.length)
          throw new Error("Transaction has unexpected data");
        return tx;
      }
      static fromHex(hex) {
        return _Transaction.fromBuffer(import_buffer.Buffer.from(hex, "hex"), false);
      }
      static isCoinbaseHash(buffer2) {
        typeforce(types.Hash256bit, buffer2);
        for (let i = 0; i < 32; ++i) {
          if (buffer2[i] !== 0) return false;
        }
        return true;
      }
      isCoinbase() {
        return this.ins.length === 1 && _Transaction.isCoinbaseHash(this.ins[0].hash);
      }
      addInput(hash, index, sequence, scriptSig) {
        typeforce(
          types.tuple(
            types.Hash256bit,
            types.UInt32,
            types.maybe(types.UInt32),
            types.maybe(types.Buffer)
          ),
          arguments
        );
        if (types.Null(sequence)) {
          sequence = _Transaction.DEFAULT_SEQUENCE;
        }
        return this.ins.push({
          hash,
          index,
          script: scriptSig || EMPTY_BUFFER4,
          sequence,
          witness: EMPTY_WITNESS
        }) - 1;
      }
      addOutput(scriptPubKey, value2) {
        typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);
        return this.outs.push({
          script: scriptPubKey,
          value: value2
        }) - 1;
      }
      hasWitnesses() {
        return this.ins.some((x) => {
          return x.witness.length !== 0;
        });
      }
      stripWitnesses() {
        this.ins.forEach((input) => {
          input.witness = EMPTY_WITNESS;
        });
      }
      weight() {
        const base5 = this.byteLength(false);
        const total = this.byteLength(true);
        return base5 * 3 + total;
      }
      virtualSize() {
        return Math.ceil(this.weight() / 4);
      }
      byteLength(_ALLOW_WITNESS = true) {
        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
        return (hasWitnesses ? 10 : 8) + bufferutils_1.varuint.encodingLength(this.ins.length) + bufferutils_1.varuint.encodingLength(this.outs.length) + this.ins.reduce((sum, input) => {
          return sum + 40 + varSliceSize(input.script);
        }, 0) + this.outs.reduce((sum, output) => {
          return sum + 8 + varSliceSize(output.script);
        }, 0) + (hasWitnesses ? this.ins.reduce((sum, input) => {
          return sum + vectorSize(input.witness);
        }, 0) : 0);
      }
      clone() {
        const newTx = new _Transaction();
        newTx.version = this.version;
        newTx.locktime = this.locktime;
        newTx.ins = this.ins.map((txIn) => {
          return {
            hash: txIn.hash,
            index: txIn.index,
            script: txIn.script,
            sequence: txIn.sequence,
            witness: txIn.witness
          };
        });
        newTx.outs = this.outs.map((txOut) => {
          return {
            script: txOut.script,
            value: txOut.value
          };
        });
        return newTx;
      }
      /**
       * Hash transaction for signing a specific input.
       *
       * Bitcoin uses a different hash for each signed transaction input.
       * This method copies the transaction, makes the necessary changes based on the
       * hashType, and then hashes the result.
       * This hash can then be used to sign the provided transaction input.
       */
      hashForSignature(inIndex, prevOutScript, hashType) {
        typeforce(
          types.tuple(
            types.UInt32,
            types.Buffer,
            /* types.UInt8 */
            types.Number
          ),
          arguments
        );
        if (inIndex >= this.ins.length) return ONE2;
        const ourScript = bscript.compile(
          bscript.decompile(prevOutScript).filter((x) => {
            return x !== script_1.OPS.OP_CODESEPARATOR;
          })
        );
        const txTmp = this.clone();
        if ((hashType & 31) === _Transaction.SIGHASH_NONE) {
          txTmp.outs = [];
          txTmp.ins.forEach((input, i) => {
            if (i === inIndex) return;
            input.sequence = 0;
          });
        } else if ((hashType & 31) === _Transaction.SIGHASH_SINGLE) {
          if (inIndex >= this.outs.length) return ONE2;
          txTmp.outs.length = inIndex + 1;
          for (let i = 0; i < inIndex; i++) {
            txTmp.outs[i] = BLANK_OUTPUT;
          }
          txTmp.ins.forEach((input, y) => {
            if (y === inIndex) return;
            input.sequence = 0;
          });
        }
        if (hashType & _Transaction.SIGHASH_ANYONECANPAY) {
          txTmp.ins = [txTmp.ins[inIndex]];
          txTmp.ins[0].script = ourScript;
        } else {
          txTmp.ins.forEach((input) => {
            input.script = EMPTY_BUFFER4;
          });
          txTmp.ins[inIndex].script = ourScript;
        }
        const buffer2 = import_buffer.Buffer.allocUnsafe(txTmp.byteLength(false) + 4);
        buffer2.writeInt32LE(hashType, buffer2.length - 4);
        txTmp.__toBuffer(buffer2, 0, false);
        return bcrypto.hash256(buffer2);
      }
      hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {
        typeforce(
          types.tuple(
            types.UInt32,
            typeforce.arrayOf(types.Buffer),
            typeforce.arrayOf(types.Satoshi),
            types.UInt32
          ),
          arguments
        );
        if (values.length !== this.ins.length || prevOutScripts.length !== this.ins.length) {
          throw new Error("Must supply prevout script and value for all inputs");
        }
        const outputType = hashType === _Transaction.SIGHASH_DEFAULT ? _Transaction.SIGHASH_ALL : hashType & _Transaction.SIGHASH_OUTPUT_MASK;
        const inputType = hashType & _Transaction.SIGHASH_INPUT_MASK;
        const isAnyoneCanPay = inputType === _Transaction.SIGHASH_ANYONECANPAY;
        const isNone = outputType === _Transaction.SIGHASH_NONE;
        const isSingle = outputType === _Transaction.SIGHASH_SINGLE;
        let hashPrevouts = EMPTY_BUFFER4;
        let hashAmounts = EMPTY_BUFFER4;
        let hashScriptPubKeys = EMPTY_BUFFER4;
        let hashSequences = EMPTY_BUFFER4;
        let hashOutputs = EMPTY_BUFFER4;
        if (!isAnyoneCanPay) {
          let bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            36 * this.ins.length
          );
          this.ins.forEach((txIn) => {
            bufferWriter.writeSlice(txIn.hash);
            bufferWriter.writeUInt32(txIn.index);
          });
          hashPrevouts = bcrypto.sha256(bufferWriter.end());
          bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            8 * this.ins.length
          );
          values.forEach((value2) => bufferWriter.writeUInt64(value2));
          hashAmounts = bcrypto.sha256(bufferWriter.end());
          bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            prevOutScripts.map(varSliceSize).reduce((a, b) => a + b)
          );
          prevOutScripts.forEach(
            (prevOutScript) => bufferWriter.writeVarSlice(prevOutScript)
          );
          hashScriptPubKeys = bcrypto.sha256(bufferWriter.end());
          bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            4 * this.ins.length
          );
          this.ins.forEach((txIn) => bufferWriter.writeUInt32(txIn.sequence));
          hashSequences = bcrypto.sha256(bufferWriter.end());
        }
        if (!(isNone || isSingle)) {
          const txOutsSize = this.outs.map((output) => 8 + varSliceSize(output.script)).reduce((a, b) => a + b);
          const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);
          this.outs.forEach((out) => {
            bufferWriter.writeUInt64(out.value);
            bufferWriter.writeVarSlice(out.script);
          });
          hashOutputs = bcrypto.sha256(bufferWriter.end());
        } else if (isSingle && inIndex < this.outs.length) {
          const output = this.outs[inIndex];
          const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            8 + varSliceSize(output.script)
          );
          bufferWriter.writeUInt64(output.value);
          bufferWriter.writeVarSlice(output.script);
          hashOutputs = bcrypto.sha256(bufferWriter.end());
        }
        const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);
        const sigMsgSize = 174 - (isAnyoneCanPay ? 49 : 0) - (isNone ? 32 : 0) + (annex ? 32 : 0) + (leafHash ? 37 : 0);
        const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);
        sigMsgWriter.writeUInt8(hashType);
        sigMsgWriter.writeInt32(this.version);
        sigMsgWriter.writeUInt32(this.locktime);
        sigMsgWriter.writeSlice(hashPrevouts);
        sigMsgWriter.writeSlice(hashAmounts);
        sigMsgWriter.writeSlice(hashScriptPubKeys);
        sigMsgWriter.writeSlice(hashSequences);
        if (!(isNone || isSingle)) {
          sigMsgWriter.writeSlice(hashOutputs);
        }
        sigMsgWriter.writeUInt8(spendType);
        if (isAnyoneCanPay) {
          const input = this.ins[inIndex];
          sigMsgWriter.writeSlice(input.hash);
          sigMsgWriter.writeUInt32(input.index);
          sigMsgWriter.writeUInt64(values[inIndex]);
          sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);
          sigMsgWriter.writeUInt32(input.sequence);
        } else {
          sigMsgWriter.writeUInt32(inIndex);
        }
        if (annex) {
          const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            varSliceSize(annex)
          );
          bufferWriter.writeVarSlice(annex);
          sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));
        }
        if (isSingle) {
          sigMsgWriter.writeSlice(hashOutputs);
        }
        if (leafHash) {
          sigMsgWriter.writeSlice(leafHash);
          sigMsgWriter.writeUInt8(0);
          sigMsgWriter.writeUInt32(4294967295);
        }
        return bcrypto.taggedHash(
          "TapSighash",
          import_buffer.Buffer.concat([import_buffer.Buffer.from([0]), sigMsgWriter.end()])
        );
      }
      hashForWitnessV0(inIndex, prevOutScript, value2, hashType) {
        typeforce(
          types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),
          arguments
        );
        let tbuffer = import_buffer.Buffer.from([]);
        let bufferWriter;
        let hashOutputs = ZERO3;
        let hashPrevouts = ZERO3;
        let hashSequence = ZERO3;
        if (!(hashType & _Transaction.SIGHASH_ANYONECANPAY)) {
          tbuffer = import_buffer.Buffer.allocUnsafe(36 * this.ins.length);
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          this.ins.forEach((txIn) => {
            bufferWriter.writeSlice(txIn.hash);
            bufferWriter.writeUInt32(txIn.index);
          });
          hashPrevouts = bcrypto.hash256(tbuffer);
        }
        if (!(hashType & _Transaction.SIGHASH_ANYONECANPAY) && (hashType & 31) !== _Transaction.SIGHASH_SINGLE && (hashType & 31) !== _Transaction.SIGHASH_NONE) {
          tbuffer = import_buffer.Buffer.allocUnsafe(4 * this.ins.length);
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          this.ins.forEach((txIn) => {
            bufferWriter.writeUInt32(txIn.sequence);
          });
          hashSequence = bcrypto.hash256(tbuffer);
        }
        if ((hashType & 31) !== _Transaction.SIGHASH_SINGLE && (hashType & 31) !== _Transaction.SIGHASH_NONE) {
          const txOutsSize = this.outs.reduce((sum, output) => {
            return sum + 8 + varSliceSize(output.script);
          }, 0);
          tbuffer = import_buffer.Buffer.allocUnsafe(txOutsSize);
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          this.outs.forEach((out) => {
            bufferWriter.writeUInt64(out.value);
            bufferWriter.writeVarSlice(out.script);
          });
          hashOutputs = bcrypto.hash256(tbuffer);
        } else if ((hashType & 31) === _Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {
          const output = this.outs[inIndex];
          tbuffer = import_buffer.Buffer.allocUnsafe(8 + varSliceSize(output.script));
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          bufferWriter.writeUInt64(output.value);
          bufferWriter.writeVarSlice(output.script);
          hashOutputs = bcrypto.hash256(tbuffer);
        }
        tbuffer = import_buffer.Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));
        bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
        const input = this.ins[inIndex];
        bufferWriter.writeInt32(this.version);
        bufferWriter.writeSlice(hashPrevouts);
        bufferWriter.writeSlice(hashSequence);
        bufferWriter.writeSlice(input.hash);
        bufferWriter.writeUInt32(input.index);
        bufferWriter.writeVarSlice(prevOutScript);
        bufferWriter.writeUInt64(value2);
        bufferWriter.writeUInt32(input.sequence);
        bufferWriter.writeSlice(hashOutputs);
        bufferWriter.writeUInt32(this.locktime);
        bufferWriter.writeUInt32(hashType);
        return bcrypto.hash256(tbuffer);
      }
      getHash(forWitness) {
        if (forWitness && this.isCoinbase()) return import_buffer.Buffer.alloc(32, 0);
        return bcrypto.hash256(this.__toBuffer(void 0, void 0, forWitness));
      }
      getId() {
        return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString(
          "hex"
        );
      }
      toBuffer(buffer2, initialOffset) {
        return this.__toBuffer(buffer2, initialOffset, true);
      }
      toHex() {
        return this.toBuffer(void 0, void 0).toString("hex");
      }
      setInputScript(index, scriptSig) {
        typeforce(types.tuple(types.Number, types.Buffer), arguments);
        this.ins[index].script = scriptSig;
      }
      setWitness(index, witness) {
        typeforce(types.tuple(types.Number, [types.Buffer]), arguments);
        this.ins[index].witness = witness;
      }
      __toBuffer(buffer2, initialOffset, _ALLOW_WITNESS = false) {
        if (!buffer2) buffer2 = import_buffer.Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));
        const bufferWriter = new bufferutils_1.BufferWriter(
          buffer2,
          initialOffset || 0
        );
        bufferWriter.writeInt32(this.version);
        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
        if (hasWitnesses) {
          bufferWriter.writeUInt8(_Transaction.ADVANCED_TRANSACTION_MARKER);
          bufferWriter.writeUInt8(_Transaction.ADVANCED_TRANSACTION_FLAG);
        }
        bufferWriter.writeVarInt(this.ins.length);
        this.ins.forEach((txIn) => {
          bufferWriter.writeSlice(txIn.hash);
          bufferWriter.writeUInt32(txIn.index);
          bufferWriter.writeVarSlice(txIn.script);
          bufferWriter.writeUInt32(txIn.sequence);
        });
        bufferWriter.writeVarInt(this.outs.length);
        this.outs.forEach((txOut) => {
          if (isOutput(txOut)) {
            bufferWriter.writeUInt64(txOut.value);
          } else {
            bufferWriter.writeSlice(txOut.valueBuffer);
          }
          bufferWriter.writeVarSlice(txOut.script);
        });
        if (hasWitnesses) {
          this.ins.forEach((input) => {
            bufferWriter.writeVector(input.witness);
          });
        }
        bufferWriter.writeUInt32(this.locktime);
        if (initialOffset !== void 0)
          return buffer2.slice(initialOffset, bufferWriter.offset);
        return buffer2;
      }
    };
    exports2.Transaction = Transaction2;
    Transaction2.DEFAULT_SEQUENCE = 4294967295;
    Transaction2.SIGHASH_DEFAULT = 0;
    Transaction2.SIGHASH_ALL = 1;
    Transaction2.SIGHASH_NONE = 2;
    Transaction2.SIGHASH_SINGLE = 3;
    Transaction2.SIGHASH_ANYONECANPAY = 128;
    Transaction2.SIGHASH_OUTPUT_MASK = 3;
    Transaction2.SIGHASH_INPUT_MASK = 128;
    Transaction2.ADVANCED_TRANSACTION_MARKER = 0;
    Transaction2.ADVANCED_TRANSACTION_FLAG = 1;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/block.js
var require_block = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/block.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Block = void 0;
    var bufferutils_1 = require_bufferutils2();
    var bcrypto = require_crypto3();
    var merkle_1 = require_merkle();
    var transaction_1 = require_transaction2();
    var types = require_types4();
    var { typeforce } = types;
    var errorMerkleNoTxes2 = new TypeError(
      "Cannot compute merkle root for zero transactions"
    );
    var errorWitnessNotSegwit2 = new TypeError(
      "Cannot compute witness commit for non-segwit block"
    );
    var Block2 = class _Block {
      constructor() {
        this.version = 1;
        this.prevHash = void 0;
        this.merkleRoot = void 0;
        this.timestamp = 0;
        this.witnessCommit = void 0;
        this.bits = 0;
        this.nonce = 0;
        this.transactions = void 0;
      }
      static fromBuffer(buffer2) {
        if (buffer2.length < 80) throw new Error("Buffer too small (< 80 bytes)");
        const bufferReader = new bufferutils_1.BufferReader(buffer2);
        const block = new _Block();
        block.version = bufferReader.readInt32();
        block.prevHash = bufferReader.readSlice(32);
        block.merkleRoot = bufferReader.readSlice(32);
        block.timestamp = bufferReader.readUInt32();
        block.bits = bufferReader.readUInt32();
        block.nonce = bufferReader.readUInt32();
        if (buffer2.length === 80) return block;
        const readTransaction = () => {
          const tx = transaction_1.Transaction.fromBuffer(
            bufferReader.buffer.slice(bufferReader.offset),
            true
          );
          bufferReader.offset += tx.byteLength();
          return tx;
        };
        const nTransactions = bufferReader.readVarInt();
        block.transactions = [];
        for (let i = 0; i < nTransactions; ++i) {
          const tx = readTransaction();
          block.transactions.push(tx);
        }
        const witnessCommit = block.getWitnessCommit();
        if (witnessCommit) block.witnessCommit = witnessCommit;
        return block;
      }
      static fromHex(hex) {
        return _Block.fromBuffer(import_buffer.Buffer.from(hex, "hex"));
      }
      static calculateTarget(bits) {
        const exponent = ((bits & 4278190080) >> 24) - 3;
        const mantissa = bits & 8388607;
        const target = import_buffer.Buffer.alloc(32, 0);
        target.writeUIntBE(mantissa, 29 - exponent, 3);
        return target;
      }
      static calculateMerkleRoot(transactions, forWitness) {
        typeforce([{ getHash: types.Function }], transactions);
        if (transactions.length === 0) throw errorMerkleNoTxes2;
        if (forWitness && !txesHaveWitnessCommit(transactions))
          throw errorWitnessNotSegwit2;
        const hashes4 = transactions.map(
          (transaction) => transaction.getHash(forWitness)
        );
        const rootHash = (0, merkle_1.fastMerkleRoot)(hashes4, bcrypto.hash256);
        return forWitness ? bcrypto.hash256(
          import_buffer.Buffer.concat([rootHash, transactions[0].ins[0].witness[0]])
        ) : rootHash;
      }
      getWitnessCommit() {
        if (!txesHaveWitnessCommit(this.transactions)) return null;
        const witnessCommits = this.transactions[0].outs.filter(
          (out) => out.script.slice(0, 6).equals(import_buffer.Buffer.from("6a24aa21a9ed", "hex"))
        ).map((out) => out.script.slice(6, 38));
        if (witnessCommits.length === 0) return null;
        const result = witnessCommits[witnessCommits.length - 1];
        if (!(result instanceof import_buffer.Buffer && result.length === 32)) return null;
        return result;
      }
      hasWitnessCommit() {
        if (this.witnessCommit instanceof import_buffer.Buffer && this.witnessCommit.length === 32)
          return true;
        if (this.getWitnessCommit() !== null) return true;
        return false;
      }
      hasWitness() {
        return anyTxHasWitness(this.transactions);
      }
      weight() {
        const base5 = this.byteLength(false, false);
        const total = this.byteLength(false, true);
        return base5 * 3 + total;
      }
      byteLength(headersOnly, allowWitness = true) {
        if (headersOnly || !this.transactions) return 80;
        return 80 + bufferutils_1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0);
      }
      getHash() {
        return bcrypto.hash256(this.toBuffer(true));
      }
      getId() {
        return (0, bufferutils_1.reverseBuffer)(this.getHash()).toString("hex");
      }
      getUTCDate() {
        const date = /* @__PURE__ */ new Date(0);
        date.setUTCSeconds(this.timestamp);
        return date;
      }
      // TODO: buffer, offset compatibility
      toBuffer(headersOnly) {
        const buffer2 = import_buffer.Buffer.allocUnsafe(this.byteLength(headersOnly));
        const bufferWriter = new bufferutils_1.BufferWriter(buffer2);
        bufferWriter.writeInt32(this.version);
        bufferWriter.writeSlice(this.prevHash);
        bufferWriter.writeSlice(this.merkleRoot);
        bufferWriter.writeUInt32(this.timestamp);
        bufferWriter.writeUInt32(this.bits);
        bufferWriter.writeUInt32(this.nonce);
        if (headersOnly || !this.transactions) return buffer2;
        bufferutils_1.varuint.encode(
          this.transactions.length,
          buffer2,
          bufferWriter.offset
        );
        bufferWriter.offset += bufferutils_1.varuint.encode.bytes;
        this.transactions.forEach((tx) => {
          const txSize = tx.byteLength();
          tx.toBuffer(buffer2, bufferWriter.offset);
          bufferWriter.offset += txSize;
        });
        return buffer2;
      }
      toHex(headersOnly) {
        return this.toBuffer(headersOnly).toString("hex");
      }
      checkTxRoots() {
        const hasWitnessCommit = this.hasWitnessCommit();
        if (!hasWitnessCommit && this.hasWitness()) return false;
        return this.__checkMerkleRoot() && (hasWitnessCommit ? this.__checkWitnessCommit() : true);
      }
      checkProofOfWork() {
        const hash = (0, bufferutils_1.reverseBuffer)(this.getHash());
        const target = _Block.calculateTarget(this.bits);
        return hash.compare(target) <= 0;
      }
      __checkMerkleRoot() {
        if (!this.transactions) throw errorMerkleNoTxes2;
        const actualMerkleRoot = _Block.calculateMerkleRoot(this.transactions);
        return this.merkleRoot.compare(actualMerkleRoot) === 0;
      }
      __checkWitnessCommit() {
        if (!this.transactions) throw errorMerkleNoTxes2;
        if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit2;
        const actualWitnessCommit = _Block.calculateMerkleRoot(
          this.transactions,
          true
        );
        return this.witnessCommit.compare(actualWitnessCommit) === 0;
      }
    };
    exports2.Block = Block2;
    function txesHaveWitnessCommit(transactions) {
      return transactions instanceof Array && transactions[0] && transactions[0].ins && transactions[0].ins instanceof Array && transactions[0].ins[0] && transactions[0].ins[0].witness && transactions[0].ins[0].witness instanceof Array && transactions[0].ins[0].witness.length > 0;
    }
    function anyTxHasWitness(transactions) {
      return transactions instanceof Array && transactions.some(
        (tx) => typeof tx === "object" && tx.ins instanceof Array && tx.ins.some(
          (input) => typeof input === "object" && input.witness instanceof Array && input.witness.length > 0
        )
      );
    }
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/typeFields.js
var require_typeFields = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/typeFields.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var GlobalTypes2;
    (function(GlobalTypes3) {
      GlobalTypes3[GlobalTypes3["UNSIGNED_TX"] = 0] = "UNSIGNED_TX";
      GlobalTypes3[GlobalTypes3["GLOBAL_XPUB"] = 1] = "GLOBAL_XPUB";
    })(GlobalTypes2 = exports2.GlobalTypes || (exports2.GlobalTypes = {}));
    exports2.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"];
    var InputTypes2;
    (function(InputTypes3) {
      InputTypes3[InputTypes3["NON_WITNESS_UTXO"] = 0] = "NON_WITNESS_UTXO";
      InputTypes3[InputTypes3["WITNESS_UTXO"] = 1] = "WITNESS_UTXO";
      InputTypes3[InputTypes3["PARTIAL_SIG"] = 2] = "PARTIAL_SIG";
      InputTypes3[InputTypes3["SIGHASH_TYPE"] = 3] = "SIGHASH_TYPE";
      InputTypes3[InputTypes3["REDEEM_SCRIPT"] = 4] = "REDEEM_SCRIPT";
      InputTypes3[InputTypes3["WITNESS_SCRIPT"] = 5] = "WITNESS_SCRIPT";
      InputTypes3[InputTypes3["BIP32_DERIVATION"] = 6] = "BIP32_DERIVATION";
      InputTypes3[InputTypes3["FINAL_SCRIPTSIG"] = 7] = "FINAL_SCRIPTSIG";
      InputTypes3[InputTypes3["FINAL_SCRIPTWITNESS"] = 8] = "FINAL_SCRIPTWITNESS";
      InputTypes3[InputTypes3["POR_COMMITMENT"] = 9] = "POR_COMMITMENT";
      InputTypes3[InputTypes3["TAP_KEY_SIG"] = 19] = "TAP_KEY_SIG";
      InputTypes3[InputTypes3["TAP_SCRIPT_SIG"] = 20] = "TAP_SCRIPT_SIG";
      InputTypes3[InputTypes3["TAP_LEAF_SCRIPT"] = 21] = "TAP_LEAF_SCRIPT";
      InputTypes3[InputTypes3["TAP_BIP32_DERIVATION"] = 22] = "TAP_BIP32_DERIVATION";
      InputTypes3[InputTypes3["TAP_INTERNAL_KEY"] = 23] = "TAP_INTERNAL_KEY";
      InputTypes3[InputTypes3["TAP_MERKLE_ROOT"] = 24] = "TAP_MERKLE_ROOT";
    })(InputTypes2 = exports2.InputTypes || (exports2.InputTypes = {}));
    exports2.INPUT_TYPE_NAMES = [
      "nonWitnessUtxo",
      "witnessUtxo",
      "partialSig",
      "sighashType",
      "redeemScript",
      "witnessScript",
      "bip32Derivation",
      "finalScriptSig",
      "finalScriptWitness",
      "porCommitment",
      "tapKeySig",
      "tapScriptSig",
      "tapLeafScript",
      "tapBip32Derivation",
      "tapInternalKey",
      "tapMerkleRoot"
    ];
    var OutputTypes2;
    (function(OutputTypes3) {
      OutputTypes3[OutputTypes3["REDEEM_SCRIPT"] = 0] = "REDEEM_SCRIPT";
      OutputTypes3[OutputTypes3["WITNESS_SCRIPT"] = 1] = "WITNESS_SCRIPT";
      OutputTypes3[OutputTypes3["BIP32_DERIVATION"] = 2] = "BIP32_DERIVATION";
      OutputTypes3[OutputTypes3["TAP_INTERNAL_KEY"] = 5] = "TAP_INTERNAL_KEY";
      OutputTypes3[OutputTypes3["TAP_TREE"] = 6] = "TAP_TREE";
      OutputTypes3[OutputTypes3["TAP_BIP32_DERIVATION"] = 7] = "TAP_BIP32_DERIVATION";
    })(OutputTypes2 = exports2.OutputTypes || (exports2.OutputTypes = {}));
    exports2.OUTPUT_TYPE_NAMES = [
      "redeemScript",
      "witnessScript",
      "bip32Derivation",
      "tapInternalKey",
      "tapTree",
      "tapBip32Derivation"
    ];
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/global/globalXpub.js
var require_globalXpub = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/global/globalXpub.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var range4 = (n2) => [...Array(n2).keys()];
    function decode44(keyVal) {
      if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {
        throw new Error(
          "Decode Error: could not decode globalXpub with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {
        throw new Error(
          "Decode Error: globalXpub has invalid extended pubkey in key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.value.length / 4 % 1 !== 0) {
        throw new Error(
          "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
        );
      }
      const extendedPubkey = keyVal.key.slice(1);
      const data = {
        masterFingerprint: keyVal.value.slice(0, 4),
        extendedPubkey,
        path: "m"
      };
      for (const i of range4(keyVal.value.length / 4 - 1)) {
        const val = keyVal.value.readUInt32LE(i * 4 + 4);
        const isHard = !!(val & 2147483648);
        const idx = val & 2147483647;
        data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
      }
      return data;
    }
    exports2.decode = decode44;
    function encode42(data) {
      const head = import_buffer.Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);
      const key = import_buffer.Buffer.concat([head, data.extendedPubkey]);
      const splitPath = data.path.split("/");
      const value2 = import_buffer.Buffer.allocUnsafe(splitPath.length * 4);
      data.masterFingerprint.copy(value2, 0);
      let offset = 4;
      splitPath.slice(1).forEach((level) => {
        const isHard = level.slice(-1) === "'";
        let num2 = 2147483647 & parseInt(isHard ? level.slice(0, -1) : level, 10);
        if (isHard) num2 += 2147483648;
        value2.writeUInt32LE(num2, offset);
        offset += 4;
      });
      return {
        key,
        value: value2
      };
    }
    exports2.encode = encode42;
    exports2.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
    function check15(data) {
      const epk = data.extendedPubkey;
      const mfp = data.masterFingerprint;
      const p = data.path;
      return import_buffer.Buffer.isBuffer(epk) && epk.length === 78 && [2, 3].indexOf(epk[45]) > -1 && import_buffer.Buffer.isBuffer(mfp) && mfp.length === 4 && typeof p === "string" && !!p.match(/^m(\/\d+'?)*$/);
    }
    exports2.check = check15;
    function canAddToArray5(array2, item, dupeSet) {
      const dupeString = item.extendedPubkey.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array2.filter((v) => v.extendedPubkey.equals(item.extendedPubkey)).length === 0;
    }
    exports2.canAddToArray = canAddToArray5;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/global/unsignedTx.js
var require_unsignedTx = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/global/unsignedTx.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function encode42(data) {
      return {
        key: import_buffer.Buffer.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),
        value: data.toBuffer()
      };
    }
    exports2.encode = encode42;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/finalScriptSig.js
var require_finalScriptSig = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/finalScriptSig.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode44(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {
        throw new Error(
          "Decode Error: could not decode finalScriptSig with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value;
    }
    exports2.decode = decode44;
    function encode42(data) {
      const key = import_buffer.Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);
      return {
        key,
        value: data
      };
    }
    exports2.encode = encode42;
    exports2.expected = "Buffer";
    function check15(data) {
      return import_buffer.Buffer.isBuffer(data);
    }
    exports2.check = check15;
    function canAdd10(currentData, newData) {
      return !!currentData && !!newData && currentData.finalScriptSig === void 0;
    }
    exports2.canAdd = canAdd10;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/finalScriptWitness.js
var require_finalScriptWitness = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/finalScriptWitness.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode44(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {
        throw new Error(
          "Decode Error: could not decode finalScriptWitness with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value;
    }
    exports2.decode = decode44;
    function encode42(data) {
      const key = import_buffer.Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);
      return {
        key,
        value: data
      };
    }
    exports2.encode = encode42;
    exports2.expected = "Buffer";
    function check15(data) {
      return import_buffer.Buffer.isBuffer(data);
    }
    exports2.check = check15;
    function canAdd10(currentData, newData) {
      return !!currentData && !!newData && currentData.finalScriptWitness === void 0;
    }
    exports2.canAdd = canAdd10;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js
var require_nonWitnessUtxo = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode44(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {
        throw new Error(
          "Decode Error: could not decode nonWitnessUtxo with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value;
    }
    exports2.decode = decode44;
    function encode42(data) {
      return {
        key: import_buffer.Buffer.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),
        value: data
      };
    }
    exports2.encode = encode42;
    exports2.expected = "Buffer";
    function check15(data) {
      return import_buffer.Buffer.isBuffer(data);
    }
    exports2.check = check15;
    function canAdd10(currentData, newData) {
      return !!currentData && !!newData && currentData.nonWitnessUtxo === void 0;
    }
    exports2.canAdd = canAdd10;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/partialSig.js
var require_partialSig = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/partialSig.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode44(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {
        throw new Error(
          "Decode Error: could not decode partialSig with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (!(keyVal.key.length === 34 || keyVal.key.length === 66) || ![2, 3, 4].includes(keyVal.key[1])) {
        throw new Error(
          "Decode Error: partialSig has invalid pubkey in key 0x" + keyVal.key.toString("hex")
        );
      }
      const pubkey = keyVal.key.slice(1);
      return {
        pubkey,
        signature: keyVal.value
      };
    }
    exports2.decode = decode44;
    function encode42(pSig) {
      const head = import_buffer.Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);
      return {
        key: import_buffer.Buffer.concat([head, pSig.pubkey]),
        value: pSig.signature
      };
    }
    exports2.encode = encode42;
    exports2.expected = "{ pubkey: Buffer; signature: Buffer; }";
    function check15(data) {
      return import_buffer.Buffer.isBuffer(data.pubkey) && import_buffer.Buffer.isBuffer(data.signature) && [33, 65].includes(data.pubkey.length) && [2, 3, 4].includes(data.pubkey[0]) && isDerSigWithSighash2(data.signature);
    }
    exports2.check = check15;
    function isDerSigWithSighash2(buf2) {
      if (!import_buffer.Buffer.isBuffer(buf2) || buf2.length < 9) return false;
      if (buf2[0] !== 48) return false;
      if (buf2.length !== buf2[1] + 3) return false;
      if (buf2[2] !== 2) return false;
      const rLen = buf2[3];
      if (rLen > 33 || rLen < 1) return false;
      if (buf2[3 + rLen + 1] !== 2) return false;
      const sLen = buf2[3 + rLen + 2];
      if (sLen > 33 || sLen < 1) return false;
      if (buf2.length !== 3 + rLen + 2 + sLen + 2) return false;
      return true;
    }
    function canAddToArray5(array2, item, dupeSet) {
      const dupeString = item.pubkey.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array2.filter((v) => v.pubkey.equals(item.pubkey)).length === 0;
    }
    exports2.canAddToArray = canAddToArray5;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/porCommitment.js
var require_porCommitment = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/porCommitment.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode44(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {
        throw new Error(
          "Decode Error: could not decode porCommitment with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value.toString("utf8");
    }
    exports2.decode = decode44;
    function encode42(data) {
      const key = import_buffer.Buffer.from([typeFields_1.InputTypes.POR_COMMITMENT]);
      return {
        key,
        value: import_buffer.Buffer.from(data, "utf8")
      };
    }
    exports2.encode = encode42;
    exports2.expected = "string";
    function check15(data) {
      return typeof data === "string";
    }
    exports2.check = check15;
    function canAdd10(currentData, newData) {
      return !!currentData && !!newData && currentData.porCommitment === void 0;
    }
    exports2.canAdd = canAdd10;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/sighashType.js
var require_sighashType = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/sighashType.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode44(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {
        throw new Error(
          "Decode Error: could not decode sighashType with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value.readUInt32LE(0);
    }
    exports2.decode = decode44;
    function encode42(data) {
      const key = import_buffer.Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);
      const value2 = import_buffer.Buffer.allocUnsafe(4);
      value2.writeUInt32LE(data, 0);
      return {
        key,
        value: value2
      };
    }
    exports2.encode = encode42;
    exports2.expected = "number";
    function check15(data) {
      return typeof data === "number";
    }
    exports2.check = check15;
    function canAdd10(currentData, newData) {
      return !!currentData && !!newData && currentData.sighashType === void 0;
    }
    exports2.canAdd = canAdd10;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/tapKeySig.js
var require_tapKeySig = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/tapKeySig.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode44(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_KEY_SIG || keyVal.key.length !== 1) {
        throw new Error(
          "Decode Error: could not decode tapKeySig with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (!check15(keyVal.value)) {
        throw new Error(
          "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
        );
      }
      return keyVal.value;
    }
    exports2.decode = decode44;
    function encode42(value2) {
      const key = import_buffer.Buffer.from([typeFields_1.InputTypes.TAP_KEY_SIG]);
      return { key, value: value2 };
    }
    exports2.encode = encode42;
    exports2.expected = "Buffer";
    function check15(data) {
      return import_buffer.Buffer.isBuffer(data) && (data.length === 64 || data.length === 65);
    }
    exports2.check = check15;
    function canAdd10(currentData, newData) {
      return !!currentData && !!newData && currentData.tapKeySig === void 0;
    }
    exports2.canAdd = canAdd10;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/tapLeafScript.js
var require_tapLeafScript = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/tapLeafScript.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode44(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_LEAF_SCRIPT) {
        throw new Error(
          "Decode Error: could not decode tapLeafScript with key 0x" + keyVal.key.toString("hex")
        );
      }
      if ((keyVal.key.length - 2) % 32 !== 0) {
        throw new Error(
          "Decode Error: tapLeafScript has invalid control block in key 0x" + keyVal.key.toString("hex")
        );
      }
      const leafVersion = keyVal.value[keyVal.value.length - 1];
      if ((keyVal.key[1] & 254) !== leafVersion) {
        throw new Error(
          "Decode Error: tapLeafScript bad leaf version in key 0x" + keyVal.key.toString("hex")
        );
      }
      const script = keyVal.value.slice(0, -1);
      const controlBlock = keyVal.key.slice(1);
      return { controlBlock, script, leafVersion };
    }
    exports2.decode = decode44;
    function encode42(tScript) {
      const head = import_buffer.Buffer.from([typeFields_1.InputTypes.TAP_LEAF_SCRIPT]);
      const verBuf = import_buffer.Buffer.from([tScript.leafVersion]);
      return {
        key: import_buffer.Buffer.concat([head, tScript.controlBlock]),
        value: import_buffer.Buffer.concat([tScript.script, verBuf])
      };
    }
    exports2.encode = encode42;
    exports2.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
    function check15(data) {
      return import_buffer.Buffer.isBuffer(data.controlBlock) && (data.controlBlock.length - 1) % 32 === 0 && (data.controlBlock[0] & 254) === data.leafVersion && import_buffer.Buffer.isBuffer(data.script);
    }
    exports2.check = check15;
    function canAddToArray5(array2, item, dupeSet) {
      const dupeString = item.controlBlock.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array2.filter((v) => v.controlBlock.equals(item.controlBlock)).length === 0;
    }
    exports2.canAddToArray = canAddToArray5;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js
var require_tapMerkleRoot = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode44(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_MERKLE_ROOT || keyVal.key.length !== 1) {
        throw new Error(
          "Decode Error: could not decode tapMerkleRoot with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (!check15(keyVal.value)) {
        throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
      }
      return keyVal.value;
    }
    exports2.decode = decode44;
    function encode42(value2) {
      const key = import_buffer.Buffer.from([typeFields_1.InputTypes.TAP_MERKLE_ROOT]);
      return { key, value: value2 };
    }
    exports2.encode = encode42;
    exports2.expected = "Buffer";
    function check15(data) {
      return import_buffer.Buffer.isBuffer(data) && data.length === 32;
    }
    exports2.check = check15;
    function canAdd10(currentData, newData) {
      return !!currentData && !!newData && currentData.tapMerkleRoot === void 0;
    }
    exports2.canAdd = canAdd10;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/tapScriptSig.js
var require_tapScriptSig = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/tapScriptSig.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode44(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_SCRIPT_SIG) {
        throw new Error(
          "Decode Error: could not decode tapScriptSig with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.key.length !== 65) {
        throw new Error(
          "Decode Error: tapScriptSig has invalid key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {
        throw new Error(
          "Decode Error: tapScriptSig has invalid signature in key 0x" + keyVal.key.toString("hex")
        );
      }
      const pubkey = keyVal.key.slice(1, 33);
      const leafHash = keyVal.key.slice(33);
      return {
        pubkey,
        leafHash,
        signature: keyVal.value
      };
    }
    exports2.decode = decode44;
    function encode42(tSig) {
      const head = import_buffer.Buffer.from([typeFields_1.InputTypes.TAP_SCRIPT_SIG]);
      return {
        key: import_buffer.Buffer.concat([head, tSig.pubkey, tSig.leafHash]),
        value: tSig.signature
      };
    }
    exports2.encode = encode42;
    exports2.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
    function check15(data) {
      return import_buffer.Buffer.isBuffer(data.pubkey) && import_buffer.Buffer.isBuffer(data.leafHash) && import_buffer.Buffer.isBuffer(data.signature) && data.pubkey.length === 32 && data.leafHash.length === 32 && (data.signature.length === 64 || data.signature.length === 65);
    }
    exports2.check = check15;
    function canAddToArray5(array2, item, dupeSet) {
      const dupeString = item.pubkey.toString("hex") + item.leafHash.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array2.filter(
        (v) => v.pubkey.equals(item.pubkey) && v.leafHash.equals(item.leafHash)
      ).length === 0;
    }
    exports2.canAddToArray = canAddToArray5;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/varint.js
var require_varint2 = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/varint.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var MAX_SAFE_INTEGER = 9007199254740991;
    function checkUInt532(n2) {
      if (n2 < 0 || n2 > MAX_SAFE_INTEGER || n2 % 1 !== 0)
        throw new RangeError("value out of range");
    }
    function encode42(_number, buffer2, offset) {
      checkUInt532(_number);
      if (!buffer2) buffer2 = import_buffer.Buffer.allocUnsafe(encodingLength7(_number));
      if (!import_buffer.Buffer.isBuffer(buffer2))
        throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      if (_number < 253) {
        buffer2.writeUInt8(_number, offset);
        Object.assign(encode42, { bytes: 1 });
      } else if (_number <= 65535) {
        buffer2.writeUInt8(253, offset);
        buffer2.writeUInt16LE(_number, offset + 1);
        Object.assign(encode42, { bytes: 3 });
      } else if (_number <= 4294967295) {
        buffer2.writeUInt8(254, offset);
        buffer2.writeUInt32LE(_number, offset + 1);
        Object.assign(encode42, { bytes: 5 });
      } else {
        buffer2.writeUInt8(255, offset);
        buffer2.writeUInt32LE(_number >>> 0, offset + 1);
        buffer2.writeUInt32LE(_number / 4294967296 | 0, offset + 5);
        Object.assign(encode42, { bytes: 9 });
      }
      return buffer2;
    }
    exports2.encode = encode42;
    function decode44(buffer2, offset) {
      if (!import_buffer.Buffer.isBuffer(buffer2))
        throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      const first2 = buffer2.readUInt8(offset);
      if (first2 < 253) {
        Object.assign(decode44, { bytes: 1 });
        return first2;
      } else if (first2 === 253) {
        Object.assign(decode44, { bytes: 3 });
        return buffer2.readUInt16LE(offset + 1);
      } else if (first2 === 254) {
        Object.assign(decode44, { bytes: 5 });
        return buffer2.readUInt32LE(offset + 1);
      } else {
        Object.assign(decode44, { bytes: 9 });
        const lo = buffer2.readUInt32LE(offset + 1);
        const hi = buffer2.readUInt32LE(offset + 5);
        const _number = hi * 4294967296 + lo;
        checkUInt532(_number);
        return _number;
      }
    }
    exports2.decode = decode44;
    function encodingLength7(_number) {
      checkUInt532(_number);
      return _number < 253 ? 1 : _number <= 65535 ? 3 : _number <= 4294967295 ? 5 : 9;
    }
    exports2.encodingLength = encodingLength7;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/tools.js
var require_tools = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/tools.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var varuint = require_varint2();
    exports2.range = (n2) => [...Array(n2).keys()];
    function reverseBuffer2(buffer2) {
      if (buffer2.length < 1) return buffer2;
      let j = buffer2.length - 1;
      let tmp = 0;
      for (let i = 0; i < buffer2.length / 2; i++) {
        tmp = buffer2[i];
        buffer2[i] = buffer2[j];
        buffer2[j] = tmp;
        j--;
      }
      return buffer2;
    }
    exports2.reverseBuffer = reverseBuffer2;
    function keyValsToBuffer2(keyVals) {
      const buffers = keyVals.map(keyValToBuffer);
      buffers.push(import_buffer.Buffer.from([0]));
      return import_buffer.Buffer.concat(buffers);
    }
    exports2.keyValsToBuffer = keyValsToBuffer2;
    function keyValToBuffer(keyVal) {
      const keyLen = keyVal.key.length;
      const valLen = keyVal.value.length;
      const keyVarIntLen = varuint.encodingLength(keyLen);
      const valVarIntLen = varuint.encodingLength(valLen);
      const buffer2 = import_buffer.Buffer.allocUnsafe(
        keyVarIntLen + keyLen + valVarIntLen + valLen
      );
      varuint.encode(keyLen, buffer2, 0);
      keyVal.key.copy(buffer2, keyVarIntLen);
      varuint.encode(valLen, buffer2, keyVarIntLen + keyLen);
      keyVal.value.copy(buffer2, keyVarIntLen + keyLen + valVarIntLen);
      return buffer2;
    }
    exports2.keyValToBuffer = keyValToBuffer;
    function verifuint(value2, max) {
      if (typeof value2 !== "number")
        throw new Error("cannot write a non-number as a number");
      if (value2 < 0)
        throw new Error("specified a negative value for writing an unsigned value");
      if (value2 > max) throw new Error("RangeError: value out of range");
      if (Math.floor(value2) !== value2)
        throw new Error("value has a fractional component");
    }
    function readUInt64LE(buffer2, offset) {
      const a = buffer2.readUInt32LE(offset);
      let b = buffer2.readUInt32LE(offset + 4);
      b *= 4294967296;
      verifuint(b + a, 9007199254740991);
      return b + a;
    }
    exports2.readUInt64LE = readUInt64LE;
    function writeUInt64LE(buffer2, value2, offset) {
      verifuint(value2, 9007199254740991);
      buffer2.writeInt32LE(value2 & -1, offset);
      buffer2.writeUInt32LE(Math.floor(value2 / 4294967296), offset + 4);
      return offset + 8;
    }
    exports2.writeUInt64LE = writeUInt64LE;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/witnessUtxo.js
var require_witnessUtxo = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/input/witnessUtxo.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var tools_1 = require_tools();
    var varuint = require_varint2();
    function decode44(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {
        throw new Error(
          "Decode Error: could not decode witnessUtxo with key 0x" + keyVal.key.toString("hex")
        );
      }
      const value2 = tools_1.readUInt64LE(keyVal.value, 0);
      let _offset = 8;
      const scriptLen = varuint.decode(keyVal.value, _offset);
      _offset += varuint.encodingLength(scriptLen);
      const script = keyVal.value.slice(_offset);
      if (script.length !== scriptLen) {
        throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
      }
      return {
        script,
        value: value2
      };
    }
    exports2.decode = decode44;
    function encode42(data) {
      const { script, value: value2 } = data;
      const varintLen = varuint.encodingLength(script.length);
      const result = import_buffer.Buffer.allocUnsafe(8 + varintLen + script.length);
      tools_1.writeUInt64LE(result, value2, 0);
      varuint.encode(script.length, result, 8);
      script.copy(result, 8 + varintLen);
      return {
        key: import_buffer.Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),
        value: result
      };
    }
    exports2.encode = encode42;
    exports2.expected = "{ script: Buffer; value: number; }";
    function check15(data) {
      return import_buffer.Buffer.isBuffer(data.script) && typeof data.value === "number";
    }
    exports2.check = check15;
    function canAdd10(currentData, newData) {
      return !!currentData && !!newData && currentData.witnessUtxo === void 0;
    }
    exports2.canAdd = canAdd10;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/output/tapTree.js
var require_tapTree = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/output/tapTree.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var varuint = require_varint2();
    function decode44(keyVal) {
      if (keyVal.key[0] !== typeFields_1.OutputTypes.TAP_TREE || keyVal.key.length !== 1) {
        throw new Error(
          "Decode Error: could not decode tapTree with key 0x" + keyVal.key.toString("hex")
        );
      }
      let _offset = 0;
      const data = [];
      while (_offset < keyVal.value.length) {
        const depth = keyVal.value[_offset++];
        const leafVersion = keyVal.value[_offset++];
        const scriptLen = varuint.decode(keyVal.value, _offset);
        _offset += varuint.encodingLength(scriptLen);
        data.push({
          depth,
          leafVersion,
          script: keyVal.value.slice(_offset, _offset + scriptLen)
        });
        _offset += scriptLen;
      }
      return { leaves: data };
    }
    exports2.decode = decode44;
    function encode42(tree) {
      const key = import_buffer.Buffer.from([typeFields_1.OutputTypes.TAP_TREE]);
      const bufs = [].concat(
        ...tree.leaves.map((tapLeaf) => [
          import_buffer.Buffer.of(tapLeaf.depth, tapLeaf.leafVersion),
          varuint.encode(tapLeaf.script.length),
          tapLeaf.script
        ])
      );
      return {
        key,
        value: import_buffer.Buffer.concat(bufs)
      };
    }
    exports2.encode = encode42;
    exports2.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
    function check15(data) {
      return Array.isArray(data.leaves) && data.leaves.every(
        (tapLeaf) => tapLeaf.depth >= 0 && tapLeaf.depth <= 128 && (tapLeaf.leafVersion & 254) === tapLeaf.leafVersion && import_buffer.Buffer.isBuffer(tapLeaf.script)
      );
    }
    exports2.check = check15;
    function canAdd10(currentData, newData) {
      return !!currentData && !!newData && currentData.tapTree === void 0;
    }
    exports2.canAdd = canAdd10;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/shared/bip32Derivation.js
var require_bip32Derivation = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/shared/bip32Derivation.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var range4 = (n2) => [...Array(n2).keys()];
    var isValidDERKey2 = (pubkey) => pubkey.length === 33 && [2, 3].includes(pubkey[0]) || pubkey.length === 65 && 4 === pubkey[0];
    function makeConverter6(TYPE_BYTE, isValidPubkey = isValidDERKey2) {
      function decode44(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) {
          throw new Error(
            "Decode Error: could not decode bip32Derivation with key 0x" + keyVal.key.toString("hex")
          );
        }
        const pubkey = keyVal.key.slice(1);
        if (!isValidPubkey(pubkey)) {
          throw new Error(
            "Decode Error: bip32Derivation has invalid pubkey in key 0x" + keyVal.key.toString("hex")
          );
        }
        if (keyVal.value.length / 4 % 1 !== 0) {
          throw new Error(
            "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
          );
        }
        const data = {
          masterFingerprint: keyVal.value.slice(0, 4),
          pubkey,
          path: "m"
        };
        for (const i of range4(keyVal.value.length / 4 - 1)) {
          const val = keyVal.value.readUInt32LE(i * 4 + 4);
          const isHard = !!(val & 2147483648);
          const idx = val & 2147483647;
          data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
        }
        return data;
      }
      function encode42(data) {
        const head = import_buffer.Buffer.from([TYPE_BYTE]);
        const key = import_buffer.Buffer.concat([head, data.pubkey]);
        const splitPath = data.path.split("/");
        const value2 = import_buffer.Buffer.allocUnsafe(splitPath.length * 4);
        data.masterFingerprint.copy(value2, 0);
        let offset = 4;
        splitPath.slice(1).forEach((level) => {
          const isHard = level.slice(-1) === "'";
          let num2 = 2147483647 & parseInt(isHard ? level.slice(0, -1) : level, 10);
          if (isHard) num2 += 2147483648;
          value2.writeUInt32LE(num2, offset);
          offset += 4;
        });
        return {
          key,
          value: value2
        };
      }
      const expected14 = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
      function check15(data) {
        return import_buffer.Buffer.isBuffer(data.pubkey) && import_buffer.Buffer.isBuffer(data.masterFingerprint) && typeof data.path === "string" && isValidPubkey(data.pubkey) && data.masterFingerprint.length === 4;
      }
      function canAddToArray5(array2, item, dupeSet) {
        const dupeString = item.pubkey.toString("hex");
        if (dupeSet.has(dupeString)) return false;
        dupeSet.add(dupeString);
        return array2.filter((v) => v.pubkey.equals(item.pubkey)).length === 0;
      }
      return {
        decode: decode44,
        encode: encode42,
        check: check15,
        expected: expected14,
        canAddToArray: canAddToArray5
      };
    }
    exports2.makeConverter = makeConverter6;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/shared/checkPubkey.js
var require_checkPubkey = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/shared/checkPubkey.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function makeChecker2(pubkeyTypes) {
      return checkPubkey;
      function checkPubkey(keyVal) {
        let pubkey;
        if (pubkeyTypes.includes(keyVal.key[0])) {
          pubkey = keyVal.key.slice(1);
          if (!(pubkey.length === 33 || pubkey.length === 65) || ![2, 3, 4].includes(pubkey[0])) {
            throw new Error(
              "Format Error: invalid pubkey in key 0x" + keyVal.key.toString("hex")
            );
          }
        }
        return pubkey;
      }
    }
    exports2.makeChecker = makeChecker2;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/shared/redeemScript.js
var require_redeemScript = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/shared/redeemScript.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function makeConverter6(TYPE_BYTE) {
      function decode44(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) {
          throw new Error(
            "Decode Error: could not decode redeemScript with key 0x" + keyVal.key.toString("hex")
          );
        }
        return keyVal.value;
      }
      function encode42(data) {
        const key = import_buffer.Buffer.from([TYPE_BYTE]);
        return {
          key,
          value: data
        };
      }
      const expected14 = "Buffer";
      function check15(data) {
        return import_buffer.Buffer.isBuffer(data);
      }
      function canAdd10(currentData, newData) {
        return !!currentData && !!newData && currentData.redeemScript === void 0;
      }
      return {
        decode: decode44,
        encode: encode42,
        check: check15,
        expected: expected14,
        canAdd: canAdd10
      };
    }
    exports2.makeConverter = makeConverter6;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js
var require_tapBip32Derivation = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var varuint = require_varint2();
    var bip32Derivation = require_bip32Derivation();
    var isValidBIP340Key2 = (pubkey) => pubkey.length === 32;
    function makeConverter6(TYPE_BYTE) {
      const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key2);
      function decode44(keyVal) {
        const nHashes = varuint.decode(keyVal.value);
        const nHashesLen = varuint.encodingLength(nHashes);
        const base5 = parent.decode({
          key: keyVal.key,
          value: keyVal.value.slice(nHashesLen + nHashes * 32)
        });
        const leafHashes = new Array(nHashes);
        for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {
          leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);
        }
        return Object.assign({}, base5, { leafHashes });
      }
      function encode42(data) {
        const base5 = parent.encode(data);
        const nHashesLen = varuint.encodingLength(data.leafHashes.length);
        const nHashesBuf = import_buffer.Buffer.allocUnsafe(nHashesLen);
        varuint.encode(data.leafHashes.length, nHashesBuf);
        const value2 = import_buffer.Buffer.concat([nHashesBuf, ...data.leafHashes, base5.value]);
        return Object.assign({}, base5, { value: value2 });
      }
      const expected14 = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
      function check15(data) {
        return Array.isArray(data.leafHashes) && data.leafHashes.every(
          (leafHash) => import_buffer.Buffer.isBuffer(leafHash) && leafHash.length === 32
        ) && parent.check(data);
      }
      return {
        decode: decode44,
        encode: encode42,
        check: check15,
        expected: expected14,
        canAddToArray: parent.canAddToArray
      };
    }
    exports2.makeConverter = makeConverter6;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/shared/tapInternalKey.js
var require_tapInternalKey = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/shared/tapInternalKey.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function makeConverter6(TYPE_BYTE) {
      function decode44(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {
          throw new Error(
            "Decode Error: could not decode tapInternalKey with key 0x" + keyVal.key.toString("hex")
          );
        }
        if (keyVal.value.length !== 32) {
          throw new Error(
            "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
          );
        }
        return keyVal.value;
      }
      function encode42(value2) {
        const key = import_buffer.Buffer.from([TYPE_BYTE]);
        return { key, value: value2 };
      }
      const expected14 = "Buffer";
      function check15(data) {
        return import_buffer.Buffer.isBuffer(data) && data.length === 32;
      }
      function canAdd10(currentData, newData) {
        return !!currentData && !!newData && currentData.tapInternalKey === void 0;
      }
      return {
        decode: decode44,
        encode: encode42,
        check: check15,
        expected: expected14,
        canAdd: canAdd10
      };
    }
    exports2.makeConverter = makeConverter6;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/shared/witnessScript.js
var require_witnessScript = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/shared/witnessScript.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function makeConverter6(TYPE_BYTE) {
      function decode44(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) {
          throw new Error(
            "Decode Error: could not decode witnessScript with key 0x" + keyVal.key.toString("hex")
          );
        }
        return keyVal.value;
      }
      function encode42(data) {
        const key = import_buffer.Buffer.from([TYPE_BYTE]);
        return {
          key,
          value: data
        };
      }
      const expected14 = "Buffer";
      function check15(data) {
        return import_buffer.Buffer.isBuffer(data);
      }
      function canAdd10(currentData, newData) {
        return !!currentData && !!newData && currentData.witnessScript === void 0;
      }
      return {
        decode: decode44,
        encode: encode42,
        check: check15,
        expected: expected14,
        canAdd: canAdd10
      };
    }
    exports2.makeConverter = makeConverter6;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/index.js
var require_converter = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/index.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var globalXpub = require_globalXpub();
    var unsignedTx = require_unsignedTx();
    var finalScriptSig = require_finalScriptSig();
    var finalScriptWitness = require_finalScriptWitness();
    var nonWitnessUtxo = require_nonWitnessUtxo();
    var partialSig = require_partialSig();
    var porCommitment = require_porCommitment();
    var sighashType = require_sighashType();
    var tapKeySig = require_tapKeySig();
    var tapLeafScript = require_tapLeafScript();
    var tapMerkleRoot = require_tapMerkleRoot();
    var tapScriptSig = require_tapScriptSig();
    var witnessUtxo = require_witnessUtxo();
    var tapTree = require_tapTree();
    var bip32Derivation = require_bip32Derivation();
    var checkPubkey = require_checkPubkey();
    var redeemScript = require_redeemScript();
    var tapBip32Derivation = require_tapBip32Derivation();
    var tapInternalKey = require_tapInternalKey();
    var witnessScript = require_witnessScript();
    var globals3 = {
      unsignedTx,
      globalXpub,
      // pass an Array of key bytes that require pubkey beside the key
      checkPubkey: checkPubkey.makeChecker([])
    };
    exports2.globals = globals3;
    var inputs2 = {
      nonWitnessUtxo,
      partialSig,
      sighashType,
      finalScriptSig,
      finalScriptWitness,
      porCommitment,
      witnessUtxo,
      bip32Derivation: bip32Derivation.makeConverter(
        typeFields_1.InputTypes.BIP32_DERIVATION
      ),
      redeemScript: redeemScript.makeConverter(
        typeFields_1.InputTypes.REDEEM_SCRIPT
      ),
      witnessScript: witnessScript.makeConverter(
        typeFields_1.InputTypes.WITNESS_SCRIPT
      ),
      checkPubkey: checkPubkey.makeChecker([
        typeFields_1.InputTypes.PARTIAL_SIG,
        typeFields_1.InputTypes.BIP32_DERIVATION
      ]),
      tapKeySig,
      tapScriptSig,
      tapLeafScript,
      tapBip32Derivation: tapBip32Derivation.makeConverter(
        typeFields_1.InputTypes.TAP_BIP32_DERIVATION
      ),
      tapInternalKey: tapInternalKey.makeConverter(
        typeFields_1.InputTypes.TAP_INTERNAL_KEY
      ),
      tapMerkleRoot
    };
    exports2.inputs = inputs2;
    var outputs2 = {
      bip32Derivation: bip32Derivation.makeConverter(
        typeFields_1.OutputTypes.BIP32_DERIVATION
      ),
      redeemScript: redeemScript.makeConverter(
        typeFields_1.OutputTypes.REDEEM_SCRIPT
      ),
      witnessScript: witnessScript.makeConverter(
        typeFields_1.OutputTypes.WITNESS_SCRIPT
      ),
      checkPubkey: checkPubkey.makeChecker([
        typeFields_1.OutputTypes.BIP32_DERIVATION
      ]),
      tapBip32Derivation: tapBip32Derivation.makeConverter(
        typeFields_1.OutputTypes.TAP_BIP32_DERIVATION
      ),
      tapTree,
      tapInternalKey: tapInternalKey.makeConverter(
        typeFields_1.OutputTypes.TAP_INTERNAL_KEY
      )
    };
    exports2.outputs = outputs2;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/parser/fromBuffer.js
var require_fromBuffer = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/parser/fromBuffer.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var convert = require_converter();
    var tools_1 = require_tools();
    var varuint = require_varint2();
    var typeFields_1 = require_typeFields();
    function psbtFromBuffer2(buffer2, txGetter) {
      let offset = 0;
      function varSlice() {
        const keyLen = varuint.decode(buffer2, offset);
        offset += varuint.encodingLength(keyLen);
        const key = buffer2.slice(offset, offset + keyLen);
        offset += keyLen;
        return key;
      }
      function readUInt32BE() {
        const num2 = buffer2.readUInt32BE(offset);
        offset += 4;
        return num2;
      }
      function readUInt82() {
        const num2 = buffer2.readUInt8(offset);
        offset += 1;
        return num2;
      }
      function getKeyValue() {
        const key = varSlice();
        const value2 = varSlice();
        return {
          key,
          value: value2
        };
      }
      function checkEndOfKeyValPairs() {
        if (offset >= buffer2.length) {
          throw new Error("Format Error: Unexpected End of PSBT");
        }
        const isEnd = buffer2.readUInt8(offset) === 0;
        if (isEnd) {
          offset++;
        }
        return isEnd;
      }
      if (readUInt32BE() !== 1886610036) {
        throw new Error("Format Error: Invalid Magic Number");
      }
      if (readUInt82() !== 255) {
        throw new Error(
          "Format Error: Magic Number must be followed by 0xff separator"
        );
      }
      const globalMapKeyVals = [];
      const globalKeyIndex = {};
      while (!checkEndOfKeyValPairs()) {
        const keyVal = getKeyValue();
        const hexKey = keyVal.key.toString("hex");
        if (globalKeyIndex[hexKey]) {
          throw new Error(
            "Format Error: Keys must be unique for global keymap: key " + hexKey
          );
        }
        globalKeyIndex[hexKey] = 1;
        globalMapKeyVals.push(keyVal);
      }
      const unsignedTxMaps = globalMapKeyVals.filter(
        (keyVal) => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX
      );
      if (unsignedTxMaps.length !== 1) {
        throw new Error("Format Error: Only one UNSIGNED_TX allowed");
      }
      const unsignedTx = txGetter(unsignedTxMaps[0].value);
      const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();
      const inputKeyVals = [];
      const outputKeyVals = [];
      for (const index of tools_1.range(inputCount)) {
        const inputKeyIndex = {};
        const input = [];
        while (!checkEndOfKeyValPairs()) {
          const keyVal = getKeyValue();
          const hexKey = keyVal.key.toString("hex");
          if (inputKeyIndex[hexKey]) {
            throw new Error(
              "Format Error: Keys must be unique for each input: input index " + index + " key " + hexKey
            );
          }
          inputKeyIndex[hexKey] = 1;
          input.push(keyVal);
        }
        inputKeyVals.push(input);
      }
      for (const index of tools_1.range(outputCount)) {
        const outputKeyIndex = {};
        const output = [];
        while (!checkEndOfKeyValPairs()) {
          const keyVal = getKeyValue();
          const hexKey = keyVal.key.toString("hex");
          if (outputKeyIndex[hexKey]) {
            throw new Error(
              "Format Error: Keys must be unique for each output: output index " + index + " key " + hexKey
            );
          }
          outputKeyIndex[hexKey] = 1;
          output.push(keyVal);
        }
        outputKeyVals.push(output);
      }
      return psbtFromKeyVals2(unsignedTx, {
        globalMapKeyVals,
        inputKeyVals,
        outputKeyVals
      });
    }
    exports2.psbtFromBuffer = psbtFromBuffer2;
    function checkKeyBuffer(type, keyBuf, keyNum) {
      if (!keyBuf.equals(import_buffer.Buffer.from([keyNum]))) {
        throw new Error(
          `Format Error: Invalid ${type} key: ${keyBuf.toString("hex")}`
        );
      }
    }
    exports2.checkKeyBuffer = checkKeyBuffer;
    function psbtFromKeyVals2(unsignedTx, { globalMapKeyVals, inputKeyVals, outputKeyVals }) {
      const globalMap = {
        unsignedTx
      };
      let txCount = 0;
      for (const keyVal of globalMapKeyVals) {
        switch (keyVal.key[0]) {
          case typeFields_1.GlobalTypes.UNSIGNED_TX:
            checkKeyBuffer(
              "global",
              keyVal.key,
              typeFields_1.GlobalTypes.UNSIGNED_TX
            );
            if (txCount > 0) {
              throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
            }
            txCount++;
            break;
          case typeFields_1.GlobalTypes.GLOBAL_XPUB:
            if (globalMap.globalXpub === void 0) {
              globalMap.globalXpub = [];
            }
            globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));
            break;
          default:
            if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];
            globalMap.unknownKeyVals.push(keyVal);
        }
      }
      const inputCount = inputKeyVals.length;
      const outputCount = outputKeyVals.length;
      const inputs2 = [];
      const outputs2 = [];
      for (const index of tools_1.range(inputCount)) {
        const input = {};
        for (const keyVal of inputKeyVals[index]) {
          convert.inputs.checkPubkey(keyVal);
          switch (keyVal.key[0]) {
            case typeFields_1.InputTypes.NON_WITNESS_UTXO:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.NON_WITNESS_UTXO
              );
              if (input.nonWitnessUtxo !== void 0) {
                throw new Error(
                  "Format Error: Input has multiple NON_WITNESS_UTXO"
                );
              }
              input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);
              break;
            case typeFields_1.InputTypes.WITNESS_UTXO:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.WITNESS_UTXO
              );
              if (input.witnessUtxo !== void 0) {
                throw new Error("Format Error: Input has multiple WITNESS_UTXO");
              }
              input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);
              break;
            case typeFields_1.InputTypes.PARTIAL_SIG:
              if (input.partialSig === void 0) {
                input.partialSig = [];
              }
              input.partialSig.push(convert.inputs.partialSig.decode(keyVal));
              break;
            case typeFields_1.InputTypes.SIGHASH_TYPE:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.SIGHASH_TYPE
              );
              if (input.sighashType !== void 0) {
                throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
              }
              input.sighashType = convert.inputs.sighashType.decode(keyVal);
              break;
            case typeFields_1.InputTypes.REDEEM_SCRIPT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.REDEEM_SCRIPT
              );
              if (input.redeemScript !== void 0) {
                throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
              }
              input.redeemScript = convert.inputs.redeemScript.decode(keyVal);
              break;
            case typeFields_1.InputTypes.WITNESS_SCRIPT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.WITNESS_SCRIPT
              );
              if (input.witnessScript !== void 0) {
                throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
              }
              input.witnessScript = convert.inputs.witnessScript.decode(keyVal);
              break;
            case typeFields_1.InputTypes.BIP32_DERIVATION:
              if (input.bip32Derivation === void 0) {
                input.bip32Derivation = [];
              }
              input.bip32Derivation.push(
                convert.inputs.bip32Derivation.decode(keyVal)
              );
              break;
            case typeFields_1.InputTypes.FINAL_SCRIPTSIG:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.FINAL_SCRIPTSIG
              );
              input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);
              break;
            case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.FINAL_SCRIPTWITNESS
              );
              input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(
                keyVal
              );
              break;
            case typeFields_1.InputTypes.POR_COMMITMENT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.POR_COMMITMENT
              );
              input.porCommitment = convert.inputs.porCommitment.decode(keyVal);
              break;
            case typeFields_1.InputTypes.TAP_KEY_SIG:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.TAP_KEY_SIG
              );
              input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);
              break;
            case typeFields_1.InputTypes.TAP_SCRIPT_SIG:
              if (input.tapScriptSig === void 0) {
                input.tapScriptSig = [];
              }
              input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));
              break;
            case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:
              if (input.tapLeafScript === void 0) {
                input.tapLeafScript = [];
              }
              input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));
              break;
            case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:
              if (input.tapBip32Derivation === void 0) {
                input.tapBip32Derivation = [];
              }
              input.tapBip32Derivation.push(
                convert.inputs.tapBip32Derivation.decode(keyVal)
              );
              break;
            case typeFields_1.InputTypes.TAP_INTERNAL_KEY:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.TAP_INTERNAL_KEY
              );
              input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);
              break;
            case typeFields_1.InputTypes.TAP_MERKLE_ROOT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.TAP_MERKLE_ROOT
              );
              input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);
              break;
            default:
              if (!input.unknownKeyVals) input.unknownKeyVals = [];
              input.unknownKeyVals.push(keyVal);
          }
        }
        inputs2.push(input);
      }
      for (const index of tools_1.range(outputCount)) {
        const output = {};
        for (const keyVal of outputKeyVals[index]) {
          convert.outputs.checkPubkey(keyVal);
          switch (keyVal.key[0]) {
            case typeFields_1.OutputTypes.REDEEM_SCRIPT:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.REDEEM_SCRIPT
              );
              if (output.redeemScript !== void 0) {
                throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
              }
              output.redeemScript = convert.outputs.redeemScript.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.WITNESS_SCRIPT:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.WITNESS_SCRIPT
              );
              if (output.witnessScript !== void 0) {
                throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
              }
              output.witnessScript = convert.outputs.witnessScript.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.BIP32_DERIVATION:
              if (output.bip32Derivation === void 0) {
                output.bip32Derivation = [];
              }
              output.bip32Derivation.push(
                convert.outputs.bip32Derivation.decode(keyVal)
              );
              break;
            case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.TAP_INTERNAL_KEY
              );
              output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.TAP_TREE:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.TAP_TREE
              );
              output.tapTree = convert.outputs.tapTree.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:
              if (output.tapBip32Derivation === void 0) {
                output.tapBip32Derivation = [];
              }
              output.tapBip32Derivation.push(
                convert.outputs.tapBip32Derivation.decode(keyVal)
              );
              break;
            default:
              if (!output.unknownKeyVals) output.unknownKeyVals = [];
              output.unknownKeyVals.push(keyVal);
          }
        }
        outputs2.push(output);
      }
      return { globalMap, inputs: inputs2, outputs: outputs2 };
    }
    exports2.psbtFromKeyVals = psbtFromKeyVals2;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/parser/toBuffer.js
var require_toBuffer = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/parser/toBuffer.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var convert = require_converter();
    var tools_1 = require_tools();
    function psbtToBuffer2({ globalMap, inputs: inputs2, outputs: outputs2 }) {
      const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals2({
        globalMap,
        inputs: inputs2,
        outputs: outputs2
      });
      const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);
      const keyValsOrEmptyToBuffer = (keyVals) => keyVals.length === 0 ? [import_buffer.Buffer.from([0])] : keyVals.map(tools_1.keyValsToBuffer);
      const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);
      const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);
      const header = import_buffer.Buffer.allocUnsafe(5);
      header.writeUIntBE(482972169471, 0, 5);
      return import_buffer.Buffer.concat(
        [header, globalBuffer].concat(inputBuffers, outputBuffers)
      );
    }
    exports2.psbtToBuffer = psbtToBuffer2;
    var sortKeyVals = (a, b) => {
      return a.key.compare(b.key);
    };
    function keyValsFromMap(keyValMap, converterFactory) {
      const keyHexSet = /* @__PURE__ */ new Set();
      const keyVals = Object.entries(keyValMap).reduce((result, [key, value2]) => {
        if (key === "unknownKeyVals") return result;
        const converter = converterFactory[key];
        if (converter === void 0) return result;
        const encodedKeyVals = (Array.isArray(value2) ? value2 : [value2]).map(
          converter.encode
        );
        const keyHexes = encodedKeyVals.map((kv) => kv.key.toString("hex"));
        keyHexes.forEach((hex) => {
          if (keyHexSet.has(hex))
            throw new Error("Serialize Error: Duplicate key: " + hex);
          keyHexSet.add(hex);
        });
        return result.concat(encodedKeyVals);
      }, []);
      const otherKeyVals = keyValMap.unknownKeyVals ? keyValMap.unknownKeyVals.filter((keyVal) => {
        return !keyHexSet.has(keyVal.key.toString("hex"));
      }) : [];
      return keyVals.concat(otherKeyVals).sort(sortKeyVals);
    }
    function psbtToKeyVals2({ globalMap, inputs: inputs2, outputs: outputs2 }) {
      return {
        globalKeyVals: keyValsFromMap(globalMap, convert.globals),
        inputKeyVals: inputs2.map((i) => keyValsFromMap(i, convert.inputs)),
        outputKeyVals: outputs2.map((o) => keyValsFromMap(o, convert.outputs))
      };
    }
    exports2.psbtToKeyVals = psbtToKeyVals2;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/parser/index.js
var require_parser = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/parser/index.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    function __export2(m) {
      for (var p in m) if (!exports2.hasOwnProperty(p)) exports2[p] = m[p];
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    __export2(require_fromBuffer());
    __export2(require_toBuffer());
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/combiner/index.js
var require_combiner = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/combiner/index.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var parser_1 = require_parser();
    function combine2(psbts) {
      const self2 = psbts[0];
      const selfKeyVals = parser_1.psbtToKeyVals(self2);
      const others = psbts.slice(1);
      if (others.length === 0) throw new Error("Combine: Nothing to combine");
      const selfTx = getTx(self2);
      if (selfTx === void 0) {
        throw new Error("Combine: Self missing transaction");
      }
      const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);
      const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);
      const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);
      for (const other of others) {
        const otherTx = getTx(other);
        if (otherTx === void 0 || !otherTx.toBuffer().equals(selfTx.toBuffer())) {
          throw new Error(
            "Combine: One of the Psbts does not have the same transaction."
          );
        }
        const otherKeyVals = parser_1.psbtToKeyVals(other);
        const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);
        otherGlobalSet.forEach(
          keyPusher(
            selfGlobalSet,
            selfKeyVals.globalKeyVals,
            otherKeyVals.globalKeyVals
          )
        );
        const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);
        otherInputSets.forEach(
          (inputSet, idx) => inputSet.forEach(
            keyPusher(
              selfInputSets[idx],
              selfKeyVals.inputKeyVals[idx],
              otherKeyVals.inputKeyVals[idx]
            )
          )
        );
        const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);
        otherOutputSets.forEach(
          (outputSet, idx) => outputSet.forEach(
            keyPusher(
              selfOutputSets[idx],
              selfKeyVals.outputKeyVals[idx],
              otherKeyVals.outputKeyVals[idx]
            )
          )
        );
      }
      return parser_1.psbtFromKeyVals(selfTx, {
        globalMapKeyVals: selfKeyVals.globalKeyVals,
        inputKeyVals: selfKeyVals.inputKeyVals,
        outputKeyVals: selfKeyVals.outputKeyVals
      });
    }
    exports2.combine = combine2;
    function keyPusher(selfSet, selfKeyVals, otherKeyVals) {
      return (key) => {
        if (selfSet.has(key)) return;
        const newKv = otherKeyVals.filter((kv) => kv.key.toString("hex") === key)[0];
        selfKeyVals.push(newKv);
        selfSet.add(key);
      };
    }
    function getTx(psbt) {
      return psbt.globalMap.unsignedTx;
    }
    function getKeySet(keyVals) {
      const set = /* @__PURE__ */ new Set();
      keyVals.forEach((keyVal) => {
        const hex = keyVal.key.toString("hex");
        if (set.has(hex))
          throw new Error("Combine: KeyValue Map keys should be unique");
        set.add(hex);
      });
      return set;
    }
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/utils.js
var require_utils6 = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/utils.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var converter = require_converter();
    function checkForInput2(inputs2, inputIndex) {
      const input = inputs2[inputIndex];
      if (input === void 0) throw new Error(`No input #${inputIndex}`);
      return input;
    }
    exports2.checkForInput = checkForInput2;
    function checkForOutput2(outputs2, outputIndex) {
      const output = outputs2[outputIndex];
      if (output === void 0) throw new Error(`No output #${outputIndex}`);
      return output;
    }
    exports2.checkForOutput = checkForOutput2;
    function checkHasKey2(checkKeyVal, keyVals, enumLength) {
      if (checkKeyVal.key[0] < enumLength) {
        throw new Error(
          `Use the method for your specific key instead of addUnknownKeyVal*`
        );
      }
      if (keyVals && keyVals.filter((kv) => kv.key.equals(checkKeyVal.key)).length !== 0) {
        throw new Error(`Duplicate Key: ${checkKeyVal.key.toString("hex")}`);
      }
    }
    exports2.checkHasKey = checkHasKey2;
    function getEnumLength2(myenum) {
      let count = 0;
      Object.keys(myenum).forEach((val) => {
        if (Number(isNaN(Number(val)))) {
          count++;
        }
      });
      return count;
    }
    exports2.getEnumLength = getEnumLength2;
    function inputCheckUncleanFinalized2(inputIndex, input) {
      let result = false;
      if (input.nonWitnessUtxo || input.witnessUtxo) {
        const needScriptSig = !!input.redeemScript;
        const needWitnessScript = !!input.witnessScript;
        const scriptSigOK = !needScriptSig || !!input.finalScriptSig;
        const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;
        const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;
        result = scriptSigOK && witnessScriptOK && hasOneFinal;
      }
      if (result === false) {
        throw new Error(
          `Input #${inputIndex} has too much or too little data to clean`
        );
      }
    }
    exports2.inputCheckUncleanFinalized = inputCheckUncleanFinalized2;
    function throwForUpdateMaker2(typeName, name10, expected14, data) {
      throw new Error(
        `Data for ${typeName} key ${name10} is incorrect: Expected ${expected14} and got ${JSON.stringify(data)}`
      );
    }
    function updateMaker2(typeName) {
      return (updateData, mainData) => {
        for (const name10 of Object.keys(updateData)) {
          const data = updateData[name10];
          const { canAdd: canAdd10, canAddToArray: canAddToArray5, check: check15, expected: expected14 } = (
            // @ts-ignore
            converter[typeName + "s"][name10] || {}
          );
          const isArray = !!canAddToArray5;
          if (check15) {
            if (isArray) {
              if (!Array.isArray(data) || // @ts-ignore
              mainData[name10] && !Array.isArray(mainData[name10])) {
                throw new Error(`Key type ${name10} must be an array`);
              }
              if (!data.every(check15)) {
                throwForUpdateMaker2(typeName, name10, expected14, data);
              }
              const arr = mainData[name10] || [];
              const dupeCheckSet = /* @__PURE__ */ new Set();
              if (!data.every((v) => canAddToArray5(arr, v, dupeCheckSet))) {
                throw new Error("Can not add duplicate data to array");
              }
              mainData[name10] = arr.concat(data);
            } else {
              if (!check15(data)) {
                throwForUpdateMaker2(typeName, name10, expected14, data);
              }
              if (!canAdd10(mainData, data)) {
                throw new Error(`Can not add duplicate data to ${typeName}`);
              }
              mainData[name10] = data;
            }
          }
        }
      };
    }
    exports2.updateGlobal = updateMaker2("global");
    exports2.updateInput = updateMaker2("input");
    exports2.updateOutput = updateMaker2("output");
    function addInputAttributes2(inputs2, data) {
      const index = inputs2.length - 1;
      const input = checkForInput2(inputs2, index);
      exports2.updateInput(data, input);
    }
    exports2.addInputAttributes = addInputAttributes2;
    function addOutputAttributes2(outputs2, data) {
      const index = outputs2.length - 1;
      const output = checkForOutput2(outputs2, index);
      exports2.updateOutput(data, output);
    }
    exports2.addOutputAttributes = addOutputAttributes2;
    function defaultVersionSetter(version, txBuf) {
      if (!import_buffer.Buffer.isBuffer(txBuf) || txBuf.length < 4) {
        throw new Error("Set Version: Invalid Transaction");
      }
      txBuf.writeUInt32LE(version, 0);
      return txBuf;
    }
    exports2.defaultVersionSetter = defaultVersionSetter;
    function defaultLocktimeSetter(locktime, txBuf) {
      if (!import_buffer.Buffer.isBuffer(txBuf) || txBuf.length < 4) {
        throw new Error("Set Locktime: Invalid Transaction");
      }
      txBuf.writeUInt32LE(locktime, txBuf.length - 4);
      return txBuf;
    }
    exports2.defaultLocktimeSetter = defaultLocktimeSetter;
  }
});

// node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/psbt.js
var require_psbt = __commonJS({
  "node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/psbt.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var combiner_1 = require_combiner();
    var parser_1 = require_parser();
    var typeFields_1 = require_typeFields();
    var utils_1 = require_utils6();
    var Psbt3 = class {
      constructor(tx) {
        this.inputs = [];
        this.outputs = [];
        this.globalMap = {
          unsignedTx: tx
        };
      }
      static fromBase64(data, txFromBuffer) {
        const buffer2 = import_buffer.Buffer.from(data, "base64");
        return this.fromBuffer(buffer2, txFromBuffer);
      }
      static fromHex(data, txFromBuffer) {
        const buffer2 = import_buffer.Buffer.from(data, "hex");
        return this.fromBuffer(buffer2, txFromBuffer);
      }
      static fromBuffer(buffer2, txFromBuffer) {
        const results = parser_1.psbtFromBuffer(buffer2, txFromBuffer);
        const psbt = new this(results.globalMap.unsignedTx);
        Object.assign(psbt, results);
        return psbt;
      }
      toBase64() {
        const buffer2 = this.toBuffer();
        return buffer2.toString("base64");
      }
      toHex() {
        const buffer2 = this.toBuffer();
        return buffer2.toString("hex");
      }
      toBuffer() {
        return parser_1.psbtToBuffer(this);
      }
      updateGlobal(updateData) {
        utils_1.updateGlobal(updateData, this.globalMap);
        return this;
      }
      updateInput(inputIndex, updateData) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.updateInput(updateData, input);
        return this;
      }
      updateOutput(outputIndex, updateData) {
        const output = utils_1.checkForOutput(this.outputs, outputIndex);
        utils_1.updateOutput(updateData, output);
        return this;
      }
      addUnknownKeyValToGlobal(keyVal) {
        utils_1.checkHasKey(
          keyVal,
          this.globalMap.unknownKeyVals,
          utils_1.getEnumLength(typeFields_1.GlobalTypes)
        );
        if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];
        this.globalMap.unknownKeyVals.push(keyVal);
        return this;
      }
      addUnknownKeyValToInput(inputIndex, keyVal) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.checkHasKey(
          keyVal,
          input.unknownKeyVals,
          utils_1.getEnumLength(typeFields_1.InputTypes)
        );
        if (!input.unknownKeyVals) input.unknownKeyVals = [];
        input.unknownKeyVals.push(keyVal);
        return this;
      }
      addUnknownKeyValToOutput(outputIndex, keyVal) {
        const output = utils_1.checkForOutput(this.outputs, outputIndex);
        utils_1.checkHasKey(
          keyVal,
          output.unknownKeyVals,
          utils_1.getEnumLength(typeFields_1.OutputTypes)
        );
        if (!output.unknownKeyVals) output.unknownKeyVals = [];
        output.unknownKeyVals.push(keyVal);
        return this;
      }
      addInput(inputData) {
        this.globalMap.unsignedTx.addInput(inputData);
        this.inputs.push({
          unknownKeyVals: []
        });
        const addKeyVals = inputData.unknownKeyVals || [];
        const inputIndex = this.inputs.length - 1;
        if (!Array.isArray(addKeyVals)) {
          throw new Error("unknownKeyVals must be an Array");
        }
        addKeyVals.forEach(
          (keyVal) => this.addUnknownKeyValToInput(inputIndex, keyVal)
        );
        utils_1.addInputAttributes(this.inputs, inputData);
        return this;
      }
      addOutput(outputData) {
        this.globalMap.unsignedTx.addOutput(outputData);
        this.outputs.push({
          unknownKeyVals: []
        });
        const addKeyVals = outputData.unknownKeyVals || [];
        const outputIndex = this.outputs.length - 1;
        if (!Array.isArray(addKeyVals)) {
          throw new Error("unknownKeyVals must be an Array");
        }
        addKeyVals.forEach(
          (keyVal) => this.addUnknownKeyValToOutput(outputIndex, keyVal)
        );
        utils_1.addOutputAttributes(this.outputs, outputData);
        return this;
      }
      clearFinalizedInput(inputIndex) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.inputCheckUncleanFinalized(inputIndex, input);
        for (const key of Object.keys(input)) {
          if (![
            "witnessUtxo",
            "nonWitnessUtxo",
            "finalScriptSig",
            "finalScriptWitness",
            "unknownKeyVals"
          ].includes(key)) {
            delete input[key];
          }
        }
        return this;
      }
      combine(...those) {
        const result = combiner_1.combine([this].concat(those));
        Object.assign(this, result);
        return this;
      }
      getTransaction() {
        return this.globalMap.unsignedTx.toBuffer();
      }
    };
    exports2.Psbt = Psbt3;
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt/psbtutils.js
var require_psbtutils = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt/psbtutils.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signatureBlocksAction = exports2.checkInputForSig = exports2.pubkeyInScript = exports2.pubkeyPositionInScript = exports2.witnessStackToScriptWitness = exports2.isP2TR = exports2.isP2SHScript = exports2.isP2WSHScript = exports2.isP2WPKH = exports2.isP2PKH = exports2.isP2PK = exports2.isP2MS = void 0;
    var varuint = require_varint2();
    var bscript = require_script2();
    var transaction_1 = require_transaction2();
    var crypto_1 = require_crypto3();
    var payments = require_payments2();
    function isPaymentFactory2(payment) {
      return (script) => {
        try {
          payment({ output: script });
          return true;
        } catch (err) {
          return false;
        }
      };
    }
    exports2.isP2MS = isPaymentFactory2(payments.p2ms);
    exports2.isP2PK = isPaymentFactory2(payments.p2pk);
    exports2.isP2PKH = isPaymentFactory2(payments.p2pkh);
    exports2.isP2WPKH = isPaymentFactory2(payments.p2wpkh);
    exports2.isP2WSHScript = isPaymentFactory2(payments.p2wsh);
    exports2.isP2SHScript = isPaymentFactory2(payments.p2sh);
    exports2.isP2TR = isPaymentFactory2(payments.p2tr);
    function witnessStackToScriptWitness2(witness) {
      let buffer2 = import_buffer.Buffer.allocUnsafe(0);
      function writeSlice(slice2) {
        buffer2 = import_buffer.Buffer.concat([buffer2, import_buffer.Buffer.from(slice2)]);
      }
      function writeVarInt(i) {
        const currentLen = buffer2.length;
        const varintLen = varuint.encodingLength(i);
        buffer2 = import_buffer.Buffer.concat([buffer2, import_buffer.Buffer.allocUnsafe(varintLen)]);
        varuint.encode(i, buffer2, currentLen);
      }
      function writeVarSlice(slice2) {
        writeVarInt(slice2.length);
        writeSlice(slice2);
      }
      function writeVector(vector) {
        writeVarInt(vector.length);
        vector.forEach(writeVarSlice);
      }
      writeVector(witness);
      return buffer2;
    }
    exports2.witnessStackToScriptWitness = witnessStackToScriptWitness2;
    function pubkeyPositionInScript2(pubkey, script) {
      const pubkeyHash = (0, crypto_1.hash160)(pubkey);
      const pubkeyXOnly = pubkey.slice(1, 33);
      const decompiled = bscript.decompile(script);
      if (decompiled === null) throw new Error("Unknown script error");
      return decompiled.findIndex((element) => {
        if (typeof element === "number") return false;
        return element.equals(pubkey) || element.equals(pubkeyHash) || element.equals(pubkeyXOnly);
      });
    }
    exports2.pubkeyPositionInScript = pubkeyPositionInScript2;
    function pubkeyInScript2(pubkey, script) {
      return pubkeyPositionInScript2(pubkey, script) !== -1;
    }
    exports2.pubkeyInScript = pubkeyInScript2;
    function checkInputForSig2(input, action) {
      const pSigs = extractPartialSigs(input);
      return pSigs.some(
        (pSig) => signatureBlocksAction2(pSig, bscript.signature.decode, action)
      );
    }
    exports2.checkInputForSig = checkInputForSig2;
    function signatureBlocksAction2(signature2, signatureDecodeFn, action) {
      const { hashType } = signatureDecodeFn(signature2);
      const whitelist = [];
      const isAnyoneCanPay = hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;
      if (isAnyoneCanPay) whitelist.push("addInput");
      const hashMod = hashType & 31;
      switch (hashMod) {
        case transaction_1.Transaction.SIGHASH_ALL:
          break;
        case transaction_1.Transaction.SIGHASH_SINGLE:
        case transaction_1.Transaction.SIGHASH_NONE:
          whitelist.push("addOutput");
          whitelist.push("setInputSequence");
          break;
      }
      if (whitelist.indexOf(action) === -1) {
        return true;
      }
      return false;
    }
    exports2.signatureBlocksAction = signatureBlocksAction2;
    function extractPartialSigs(input) {
      let pSigs = [];
      if ((input.partialSig || []).length === 0) {
        if (!input.finalScriptSig && !input.finalScriptWitness) return [];
        pSigs = getPsigsFromInputFinalScripts(input);
      } else {
        pSigs = input.partialSig;
      }
      return pSigs.map((p) => p.signature);
    }
    function getPsigsFromInputFinalScripts(input) {
      const scriptItems = !input.finalScriptSig ? [] : bscript.decompile(input.finalScriptSig) || [];
      const witnessItems = !input.finalScriptWitness ? [] : bscript.decompile(input.finalScriptWitness) || [];
      return scriptItems.concat(witnessItems).filter((item) => {
        return import_buffer.Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);
      }).map((sig) => ({ signature: sig }));
    }
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt/bip371.js
var require_bip371 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt/bip371.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkTaprootInputForSigs = exports2.tapTreeFromList = exports2.tapTreeToList = exports2.tweakInternalPubKey = exports2.checkTaprootOutputFields = exports2.checkTaprootInputFields = exports2.isTaprootOutput = exports2.isTaprootInput = exports2.serializeTaprootSignature = exports2.tapScriptFinalizer = exports2.toXOnly = void 0;
    var types_1 = require_types4();
    var transaction_1 = require_transaction2();
    var psbtutils_1 = require_psbtutils();
    var bip341_1 = require_bip3412();
    var payments_1 = require_payments2();
    var psbtutils_2 = require_psbtutils();
    var toXOnly2 = (pubKey) => pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
    exports2.toXOnly = toXOnly2;
    function tapScriptFinalizer2(inputIndex, input, tapLeafHashToFinalize) {
      const tapLeaf = findTapLeafToFinalize(
        input,
        inputIndex,
        tapLeafHashToFinalize
      );
      try {
        const sigs = sortSignatures(input, tapLeaf);
        const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);
        return {
          finalScriptWitness: (0, psbtutils_1.witnessStackToScriptWitness)(witness)
        };
      } catch (err) {
        throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);
      }
    }
    exports2.tapScriptFinalizer = tapScriptFinalizer2;
    function serializeTaprootSignature2(sig, sighashType) {
      const sighashTypeByte = sighashType ? import_buffer.Buffer.from([sighashType]) : import_buffer.Buffer.from([]);
      return import_buffer.Buffer.concat([sig, sighashTypeByte]);
    }
    exports2.serializeTaprootSignature = serializeTaprootSignature2;
    function isTaprootInput2(input) {
      return input && !!(input.tapInternalKey || input.tapMerkleRoot || input.tapLeafScript && input.tapLeafScript.length || input.tapBip32Derivation && input.tapBip32Derivation.length || input.witnessUtxo && (0, psbtutils_1.isP2TR)(input.witnessUtxo.script));
    }
    exports2.isTaprootInput = isTaprootInput2;
    function isTaprootOutput(output, script) {
      return output && !!(output.tapInternalKey || output.tapTree || output.tapBip32Derivation && output.tapBip32Derivation.length || script && (0, psbtutils_1.isP2TR)(script));
    }
    exports2.isTaprootOutput = isTaprootOutput;
    function checkTaprootInputFields2(inputData, newInputData, action) {
      checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);
      checkIfTapLeafInTree(inputData, newInputData, action);
    }
    exports2.checkTaprootInputFields = checkTaprootInputFields2;
    function checkTaprootOutputFields2(outputData, newOutputData, action) {
      checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);
      checkTaprootScriptPubkey(outputData, newOutputData);
    }
    exports2.checkTaprootOutputFields = checkTaprootOutputFields2;
    function checkTaprootScriptPubkey(outputData, newOutputData) {
      if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;
      const tapInternalKey = newOutputData.tapInternalKey || outputData.tapInternalKey;
      const tapTree = newOutputData.tapTree || outputData.tapTree;
      if (tapInternalKey) {
        const { script: scriptPubkey } = outputData;
        const script = getTaprootScripPubkey(tapInternalKey, tapTree);
        if (scriptPubkey && !scriptPubkey.equals(script))
          throw new Error("Error adding output. Script or address missmatch.");
      }
    }
    function getTaprootScripPubkey(tapInternalKey, tapTree) {
      const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);
      const { output } = (0, payments_1.p2tr)({
        internalPubkey: tapInternalKey,
        scriptTree
      });
      return output;
    }
    function tweakInternalPubKey(inputIndex, input) {
      const tapInternalKey = input.tapInternalKey;
      const outputKey = tapInternalKey && (0, bip341_1.tweakKey)(tapInternalKey, input.tapMerkleRoot);
      if (!outputKey)
        throw new Error(
          `Cannot tweak tap internal key for input #${inputIndex}. Public key: ${tapInternalKey && tapInternalKey.toString("hex")}`
        );
      return outputKey.x;
    }
    exports2.tweakInternalPubKey = tweakInternalPubKey;
    function tapTreeToList(tree) {
      if (!(0, types_1.isTaptree)(tree))
        throw new Error(
          "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
        );
      return _tapTreeToList(tree);
    }
    exports2.tapTreeToList = tapTreeToList;
    function tapTreeFromList(leaves = []) {
      if (leaves.length === 1 && leaves[0].depth === 0)
        return {
          output: leaves[0].script,
          version: leaves[0].leafVersion
        };
      return instertLeavesInTree(leaves);
    }
    exports2.tapTreeFromList = tapTreeFromList;
    function checkTaprootInputForSigs2(input, action) {
      const sigs = extractTaprootSigs(input);
      return sigs.some(
        (sig) => (0, psbtutils_2.signatureBlocksAction)(sig, decodeSchnorrSignature, action)
      );
    }
    exports2.checkTaprootInputForSigs = checkTaprootInputForSigs2;
    function decodeSchnorrSignature(signature2) {
      return {
        signature: signature2.slice(0, 64),
        hashType: signature2.slice(64)[0] || transaction_1.Transaction.SIGHASH_DEFAULT
      };
    }
    function extractTaprootSigs(input) {
      const sigs = [];
      if (input.tapKeySig) sigs.push(input.tapKeySig);
      if (input.tapScriptSig)
        sigs.push(...input.tapScriptSig.map((s) => s.signature));
      if (!sigs.length) {
        const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);
        if (finalTapKeySig) sigs.push(finalTapKeySig);
      }
      return sigs;
    }
    function getTapKeySigFromWithness(finalScriptWitness) {
      if (!finalScriptWitness) return;
      const witness = finalScriptWitness.slice(2);
      if (witness.length === 64 || witness.length === 65) return witness;
    }
    function _tapTreeToList(tree, leaves = [], depth = 0) {
      if (depth > bip341_1.MAX_TAPTREE_DEPTH)
        throw new Error("Max taptree depth exceeded.");
      if (!tree) return [];
      if ((0, types_1.isTapleaf)(tree)) {
        leaves.push({
          depth,
          leafVersion: tree.version || bip341_1.LEAF_VERSION_TAPSCRIPT,
          script: tree.output
        });
        return leaves;
      }
      if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);
      if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);
      return leaves;
    }
    function instertLeavesInTree(leaves) {
      let tree;
      for (const leaf of leaves) {
        tree = instertLeafInTree(leaf, tree);
        if (!tree) throw new Error(`No room left to insert tapleaf in tree`);
      }
      return tree;
    }
    function instertLeafInTree(leaf, tree, depth = 0) {
      if (depth > bip341_1.MAX_TAPTREE_DEPTH)
        throw new Error("Max taptree depth exceeded.");
      if (leaf.depth === depth) {
        if (!tree)
          return {
            output: leaf.script,
            version: leaf.leafVersion
          };
        return;
      }
      if ((0, types_1.isTapleaf)(tree)) return;
      const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);
      if (leftSide) return [leftSide, tree && tree[1]];
      const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);
      if (rightSide) return [tree && tree[0], rightSide];
    }
    function checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action) {
      const isBadTaprootUpdate = isTaprootInput2(inputData) && hasNonTaprootFields(newInputData);
      const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootInput2(newInputData);
      const hasMixedFields = inputData === newInputData && isTaprootInput2(newInputData) && hasNonTaprootFields(newInputData);
      if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
        throw new Error(
          `Invalid arguments for Psbt.${action}. Cannot use both taproot and non-taproot fields.`
        );
    }
    function checkMixedTaprootAndNonTaprootOutputFields(inputData, newInputData, action) {
      const isBadTaprootUpdate = isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);
      const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);
      const hasMixedFields = inputData === newInputData && isTaprootOutput(newInputData) && hasNonTaprootFields(newInputData);
      if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
        throw new Error(
          `Invalid arguments for Psbt.${action}. Cannot use both taproot and non-taproot fields.`
        );
    }
    function checkIfTapLeafInTree(inputData, newInputData, action) {
      if (newInputData.tapMerkleRoot) {
        const newLeafsInTree = (newInputData.tapLeafScript || []).every(
          (l) => isTapLeafInTree(l, newInputData.tapMerkleRoot)
        );
        const oldLeafsInTree = (inputData.tapLeafScript || []).every(
          (l) => isTapLeafInTree(l, newInputData.tapMerkleRoot)
        );
        if (!newLeafsInTree || !oldLeafsInTree)
          throw new Error(
            `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`
          );
      } else if (inputData.tapMerkleRoot) {
        const newLeafsInTree = (newInputData.tapLeafScript || []).every(
          (l) => isTapLeafInTree(l, inputData.tapMerkleRoot)
        );
        if (!newLeafsInTree)
          throw new Error(
            `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`
          );
      }
    }
    function isTapLeafInTree(tapLeaf, merkleRoot) {
      if (!merkleRoot) return true;
      const leafHash = (0, bip341_1.tapleafHash)({
        output: tapLeaf.script,
        version: tapLeaf.leafVersion
      });
      const rootHash = (0, bip341_1.rootHashFromPath)(
        tapLeaf.controlBlock,
        leafHash
      );
      return rootHash.equals(merkleRoot);
    }
    function sortSignatures(input, tapLeaf) {
      const leafHash = (0, bip341_1.tapleafHash)({
        output: tapLeaf.script,
        version: tapLeaf.leafVersion
      });
      return (input.tapScriptSig || []).filter((tss) => tss.leafHash.equals(leafHash)).map((tss) => addPubkeyPositionInScript(tapLeaf.script, tss)).sort((t1, t2) => t2.positionInScript - t1.positionInScript).map((t) => t.signature);
    }
    function addPubkeyPositionInScript(script, tss) {
      return Object.assign(
        {
          positionInScript: (0, psbtutils_1.pubkeyPositionInScript)(
            tss.pubkey,
            script
          )
        },
        tss
      );
    }
    function findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {
      if (!input.tapScriptSig || !input.tapScriptSig.length)
        throw new Error(
          `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`
        );
      const tapLeaf = (input.tapLeafScript || []).sort((a, b) => a.controlBlock.length - b.controlBlock.length).find(
        (leaf) => canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize)
      );
      if (!tapLeaf)
        throw new Error(
          `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`
        );
      return tapLeaf;
    }
    function canFinalizeLeaf(leaf, tapScriptSig, hash) {
      const leafHash = (0, bip341_1.tapleafHash)({
        output: leaf.script,
        version: leaf.leafVersion
      });
      const whiteListedHash = !hash || hash.equals(leafHash);
      return whiteListedHash && tapScriptSig.find((tss) => tss.leafHash.equals(leafHash)) !== void 0;
    }
    function hasNonTaprootFields(io) {
      return io && !!(io.redeemScript || io.witnessScript || io.bip32Derivation && io.bip32Derivation.length);
    }
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt.js
var require_psbt2 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Psbt = void 0;
    var bip174_1 = require_psbt();
    var varuint = require_varint2();
    var utils_1 = require_utils6();
    var address_1 = require_address2();
    var bufferutils_1 = require_bufferutils2();
    var networks_1 = require_networks3();
    var payments = require_payments2();
    var bip341_1 = require_bip3412();
    var bscript = require_script2();
    var transaction_1 = require_transaction2();
    var bip371_1 = require_bip371();
    var psbtutils_1 = require_psbtutils();
    var DEFAULT_OPTS = {
      /**
       * A bitcoinjs Network object. This is only used if you pass an `address`
       * parameter to addOutput. Otherwise it is not needed and can be left default.
       */
      network: networks_1.bitcoin,
      /**
       * When extractTransaction is called, the fee rate is checked.
       * THIS IS NOT TO BE RELIED ON.
       * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
       */
      maximumFeeRate: 5e3
      // satoshi per byte
    };
    var Psbt3 = class _Psbt {
      static fromBase64(data, opts = {}) {
        const buffer2 = import_buffer.Buffer.from(data, "base64");
        return this.fromBuffer(buffer2, opts);
      }
      static fromHex(data, opts = {}) {
        const buffer2 = import_buffer.Buffer.from(data, "hex");
        return this.fromBuffer(buffer2, opts);
      }
      static fromBuffer(buffer2, opts = {}) {
        const psbtBase = bip174_1.Psbt.fromBuffer(buffer2, transactionFromBuffer);
        const psbt = new _Psbt(opts, psbtBase);
        checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);
        return psbt;
      }
      constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {
        this.data = data;
        this.opts = Object.assign({}, DEFAULT_OPTS, opts);
        this.__CACHE = {
          __NON_WITNESS_UTXO_TX_CACHE: [],
          __NON_WITNESS_UTXO_BUF_CACHE: [],
          __TX_IN_CACHE: {},
          __TX: this.data.globalMap.unsignedTx.tx,
          // Psbt's predecessor (TransactionBuilder - now removed) behavior
          // was to not confirm input values  before signing.
          // Even though we highly encourage people to get
          // the full parent transaction to verify values, the ability to
          // sign non-segwit inputs without the full transaction was often
          // requested. So the only way to activate is to use @ts-ignore.
          // We will disable exporting the Psbt when unsafe sign is active.
          // because it is not BIP174 compliant.
          __UNSAFE_SIGN_NONSEGWIT: false
        };
        if (this.data.inputs.length === 0) this.setVersion(2);
        const dpew = (obj, attr, enumerable, writable) => Object.defineProperty(obj, attr, {
          enumerable,
          writable
        });
        dpew(this, "__CACHE", false, true);
        dpew(this, "opts", false, true);
      }
      get inputCount() {
        return this.data.inputs.length;
      }
      get version() {
        return this.__CACHE.__TX.version;
      }
      set version(version) {
        this.setVersion(version);
      }
      get locktime() {
        return this.__CACHE.__TX.locktime;
      }
      set locktime(locktime) {
        this.setLocktime(locktime);
      }
      get txInputs() {
        return this.__CACHE.__TX.ins.map((input) => ({
          hash: (0, bufferutils_1.cloneBuffer)(input.hash),
          index: input.index,
          sequence: input.sequence
        }));
      }
      get txOutputs() {
        return this.__CACHE.__TX.outs.map((output) => {
          let address;
          try {
            address = (0, address_1.fromOutputScript)(
              output.script,
              this.opts.network
            );
          } catch (_) {
          }
          return {
            script: (0, bufferutils_1.cloneBuffer)(output.script),
            value: output.value,
            address
          };
        });
      }
      combine(...those) {
        this.data.combine(...those.map((o) => o.data));
        return this;
      }
      clone() {
        const res = _Psbt.fromBuffer(this.data.toBuffer());
        res.opts = JSON.parse(JSON.stringify(this.opts));
        return res;
      }
      setMaximumFeeRate(satoshiPerByte) {
        check32Bit(satoshiPerByte);
        this.opts.maximumFeeRate = satoshiPerByte;
      }
      setVersion(version) {
        check32Bit(version);
        checkInputsForPartialSig(this.data.inputs, "setVersion");
        const c = this.__CACHE;
        c.__TX.version = version;
        c.__EXTRACTED_TX = void 0;
        return this;
      }
      setLocktime(locktime) {
        check32Bit(locktime);
        checkInputsForPartialSig(this.data.inputs, "setLocktime");
        const c = this.__CACHE;
        c.__TX.locktime = locktime;
        c.__EXTRACTED_TX = void 0;
        return this;
      }
      setInputSequence(inputIndex, sequence) {
        check32Bit(sequence);
        checkInputsForPartialSig(this.data.inputs, "setInputSequence");
        const c = this.__CACHE;
        if (c.__TX.ins.length <= inputIndex) {
          throw new Error("Input index too high");
        }
        c.__TX.ins[inputIndex].sequence = sequence;
        c.__EXTRACTED_TX = void 0;
        return this;
      }
      addInputs(inputDatas) {
        inputDatas.forEach((inputData) => this.addInput(inputData));
        return this;
      }
      addInput(inputData) {
        if (arguments.length > 1 || !inputData || inputData.hash === void 0 || inputData.index === void 0) {
          throw new Error(
            `Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]`
          );
        }
        (0, bip371_1.checkTaprootInputFields)(inputData, inputData, "addInput");
        checkInputsForPartialSig(this.data.inputs, "addInput");
        if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);
        const c = this.__CACHE;
        this.data.addInput(inputData);
        const txIn = c.__TX.ins[c.__TX.ins.length - 1];
        checkTxInputCache(c, txIn);
        const inputIndex = this.data.inputs.length - 1;
        const input = this.data.inputs[inputIndex];
        if (input.nonWitnessUtxo) {
          addNonWitnessTxCache(this.__CACHE, input, inputIndex);
        }
        c.__FEE = void 0;
        c.__FEE_RATE = void 0;
        c.__EXTRACTED_TX = void 0;
        return this;
      }
      addOutputs(outputDatas) {
        outputDatas.forEach((outputData) => this.addOutput(outputData));
        return this;
      }
      addOutput(outputData) {
        if (arguments.length > 1 || !outputData || outputData.value === void 0 || outputData.address === void 0 && outputData.script === void 0) {
          throw new Error(
            `Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]`
          );
        }
        checkInputsForPartialSig(this.data.inputs, "addOutput");
        const { address } = outputData;
        if (typeof address === "string") {
          const { network } = this.opts;
          const script = (0, address_1.toOutputScript)(address, network);
          outputData = Object.assign({}, outputData, { script });
        }
        (0, bip371_1.checkTaprootOutputFields)(outputData, outputData, "addOutput");
        const c = this.__CACHE;
        this.data.addOutput(outputData);
        c.__FEE = void 0;
        c.__FEE_RATE = void 0;
        c.__EXTRACTED_TX = void 0;
        return this;
      }
      extractTransaction(disableFeeCheck) {
        if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
        const c = this.__CACHE;
        if (!disableFeeCheck) {
          checkFees(this, c, this.opts);
        }
        if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;
        const tx = c.__TX.clone();
        inputFinalizeGetAmts(this.data.inputs, tx, c, true);
        return tx;
      }
      getFeeRate() {
        return getTxCacheValue(
          "__FEE_RATE",
          "fee rate",
          this.data.inputs,
          this.__CACHE
        );
      }
      getFee() {
        return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
      }
      finalizeAllInputs() {
        (0, utils_1.checkForInput)(this.data.inputs, 0);
        range4(this.data.inputs.length).forEach((idx) => this.finalizeInput(idx));
        return this;
      }
      finalizeInput(inputIndex, finalScriptsFunc) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if ((0, bip371_1.isTaprootInput)(input))
          return this._finalizeTaprootInput(
            inputIndex,
            input,
            void 0,
            finalScriptsFunc
          );
        return this._finalizeInput(inputIndex, input, finalScriptsFunc);
      }
      finalizeTaprootInput(inputIndex, tapLeafHashToFinalize, finalScriptsFunc = bip371_1.tapScriptFinalizer) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if ((0, bip371_1.isTaprootInput)(input))
          return this._finalizeTaprootInput(
            inputIndex,
            input,
            tapLeafHashToFinalize,
            finalScriptsFunc
          );
        throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);
      }
      _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {
        const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(
          inputIndex,
          input,
          this.__CACHE
        );
        if (!script) throw new Error(`No script found for input #${inputIndex}`);
        checkPartialSigSighashes(input);
        const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(
          inputIndex,
          input,
          script,
          isSegwit,
          isP2SH,
          isP2WSH
        );
        if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });
        if (finalScriptWitness)
          this.data.updateInput(inputIndex, { finalScriptWitness });
        if (!finalScriptSig && !finalScriptWitness)
          throw new Error(`Unknown error finalizing input #${inputIndex}`);
        this.data.clearFinalizedInput(inputIndex);
        return this;
      }
      _finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc = bip371_1.tapScriptFinalizer) {
        if (!input.witnessUtxo)
          throw new Error(
            `Cannot finalize input #${inputIndex}. Missing withness utxo.`
          );
        if (input.tapKeySig) {
          const payment = payments.p2tr({
            output: input.witnessUtxo.script,
            signature: input.tapKeySig
          });
          const finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
            payment.witness
          );
          this.data.updateInput(inputIndex, { finalScriptWitness });
        } else {
          const { finalScriptWitness } = finalScriptsFunc(
            inputIndex,
            input,
            tapLeafHashToFinalize
          );
          this.data.updateInput(inputIndex, { finalScriptWitness });
        }
        this.data.clearFinalizedInput(inputIndex);
        return this;
      }
      getInputType(inputIndex) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);
        const result = getMeaningfulScript(
          script,
          inputIndex,
          "input",
          input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),
          input.witnessScript || redeemFromFinalWitnessScript(input.finalScriptWitness)
        );
        const type = result.type === "raw" ? "" : result.type + "-";
        const mainType = classifyScript(result.meaningfulScript);
        return type + mainType;
      }
      inputHasPubkey(inputIndex, pubkey) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);
      }
      inputHasHDKey(inputIndex, root) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        const derivationIsMine = bip32DerivationIsMine(root);
        return !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine);
      }
      outputHasPubkey(outputIndex, pubkey) {
        const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
        return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);
      }
      outputHasHDKey(outputIndex, root) {
        const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
        const derivationIsMine = bip32DerivationIsMine(root);
        return !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine);
      }
      validateSignaturesOfAllInputs(validator) {
        (0, utils_1.checkForInput)(this.data.inputs, 0);
        const results = range4(this.data.inputs.length).map(
          (idx) => this.validateSignaturesOfInput(idx, validator)
        );
        return results.reduce((final, res) => res === true && final, true);
      }
      validateSignaturesOfInput(inputIndex, validator, pubkey) {
        const input = this.data.inputs[inputIndex];
        if ((0, bip371_1.isTaprootInput)(input))
          return this.validateSignaturesOfTaprootInput(
            inputIndex,
            validator,
            pubkey
          );
        return this._validateSignaturesOfInput(inputIndex, validator, pubkey);
      }
      _validateSignaturesOfInput(inputIndex, validator, pubkey) {
        const input = this.data.inputs[inputIndex];
        const partialSig = (input || {}).partialSig;
        if (!input || !partialSig || partialSig.length < 1)
          throw new Error("No signatures to validate");
        if (typeof validator !== "function")
          throw new Error("Need validator function to validate signatures");
        const mySigs = pubkey ? partialSig.filter((sig) => sig.pubkey.equals(pubkey)) : partialSig;
        if (mySigs.length < 1) throw new Error("No signatures for this pubkey");
        const results = [];
        let hashCache;
        let scriptCache;
        let sighashCache;
        for (const pSig of mySigs) {
          const sig = bscript.signature.decode(pSig.signature);
          const { hash, script } = sighashCache !== sig.hashType ? getHashForSig(
            inputIndex,
            Object.assign({}, input, { sighashType: sig.hashType }),
            this.__CACHE,
            true
          ) : { hash: hashCache, script: scriptCache };
          sighashCache = sig.hashType;
          hashCache = hash;
          scriptCache = script;
          checkScriptForPubkey(pSig.pubkey, script, "verify");
          results.push(validator(pSig.pubkey, hash, sig.signature));
        }
        return results.every((res) => res === true);
      }
      validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {
        const input = this.data.inputs[inputIndex];
        const tapKeySig = (input || {}).tapKeySig;
        const tapScriptSig = (input || {}).tapScriptSig;
        if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))
          throw new Error("No signatures to validate");
        if (typeof validator !== "function")
          throw new Error("Need validator function to validate signatures");
        pubkey = pubkey && (0, bip371_1.toXOnly)(pubkey);
        const allHashses = pubkey ? getTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          pubkey,
          this.__CACHE
        ) : getAllTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          this.__CACHE
        );
        if (!allHashses.length) throw new Error("No signatures for this pubkey");
        const tapKeyHash = allHashses.find((h3) => !h3.leafHash);
        let validationResultCount = 0;
        if (tapKeySig && tapKeyHash) {
          const isValidTapkeySig = validator(
            tapKeyHash.pubkey,
            tapKeyHash.hash,
            trimTaprootSig(tapKeySig)
          );
          if (!isValidTapkeySig) return false;
          validationResultCount++;
        }
        if (tapScriptSig) {
          for (const tapSig of tapScriptSig) {
            const tapSigHash = allHashses.find((h3) => tapSig.pubkey.equals(h3.pubkey));
            if (tapSigHash) {
              const isValidTapScriptSig = validator(
                tapSig.pubkey,
                tapSigHash.hash,
                trimTaprootSig(tapSig.signature)
              );
              if (!isValidTapScriptSig) return false;
              validationResultCount++;
            }
          }
        }
        return validationResultCount > 0;
      }
      signAllInputsHD(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
          throw new Error("Need HDSigner to sign input");
        }
        const results = [];
        for (const i of range4(this.data.inputs.length)) {
          try {
            this.signInputHD(i, hdKeyPair, sighashTypes);
            results.push(true);
          } catch (err) {
            results.push(false);
          }
        }
        if (results.every((v) => v === false)) {
          throw new Error("No inputs were signed");
        }
        return this;
      }
      signAllInputsHDAsync(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        return new Promise((resolve2, reject) => {
          if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            return reject(new Error("Need HDSigner to sign input"));
          }
          const results = [];
          const promises = [];
          for (const i of range4(this.data.inputs.length)) {
            promises.push(
              this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(
                () => {
                  results.push(true);
                },
                () => {
                  results.push(false);
                }
              )
            );
          }
          return Promise.all(promises).then(() => {
            if (results.every((v) => v === false)) {
              return reject(new Error("No inputs were signed"));
            }
            resolve2();
          });
        });
      }
      signInputHD(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
          throw new Error("Need HDSigner to sign input");
        }
        const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
        signers.forEach((signer) => this.signInput(inputIndex, signer, sighashTypes));
        return this;
      }
      signInputHDAsync(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        return new Promise((resolve2, reject) => {
          if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            return reject(new Error("Need HDSigner to sign input"));
          }
          const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
          const promises = signers.map(
            (signer) => this.signInputAsync(inputIndex, signer, sighashTypes)
          );
          return Promise.all(promises).then(() => {
            resolve2();
          }).catch(reject);
        });
      }
      signAllInputs(keyPair, sighashTypes) {
        if (!keyPair || !keyPair.publicKey)
          throw new Error("Need Signer to sign input");
        const results = [];
        for (const i of range4(this.data.inputs.length)) {
          try {
            this.signInput(i, keyPair, sighashTypes);
            results.push(true);
          } catch (err) {
            results.push(false);
          }
        }
        if (results.every((v) => v === false)) {
          throw new Error("No inputs were signed");
        }
        return this;
      }
      signAllInputsAsync(keyPair, sighashTypes) {
        return new Promise((resolve2, reject) => {
          if (!keyPair || !keyPair.publicKey)
            return reject(new Error("Need Signer to sign input"));
          const results = [];
          const promises = [];
          for (const [i] of this.data.inputs.entries()) {
            promises.push(
              this.signInputAsync(i, keyPair, sighashTypes).then(
                () => {
                  results.push(true);
                },
                () => {
                  results.push(false);
                }
              )
            );
          }
          return Promise.all(promises).then(() => {
            if (results.every((v) => v === false)) {
              return reject(new Error("No inputs were signed"));
            }
            resolve2();
          });
        });
      }
      signInput(inputIndex, keyPair, sighashTypes) {
        if (!keyPair || !keyPair.publicKey)
          throw new Error("Need Signer to sign input");
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if ((0, bip371_1.isTaprootInput)(input)) {
          return this._signTaprootInput(
            inputIndex,
            input,
            keyPair,
            void 0,
            sighashTypes
          );
        }
        return this._signInput(inputIndex, keyPair, sighashTypes);
      }
      signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {
        if (!keyPair || !keyPair.publicKey)
          throw new Error("Need Signer to sign input");
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if ((0, bip371_1.isTaprootInput)(input))
          return this._signTaprootInput(
            inputIndex,
            input,
            keyPair,
            tapLeafHashToSign,
            sighashTypes
          );
        throw new Error(`Input #${inputIndex} is not of type Taproot.`);
      }
      _signInput(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        const { hash, sighashType } = getHashAndSighashType(
          this.data.inputs,
          inputIndex,
          keyPair.publicKey,
          this.__CACHE,
          sighashTypes
        );
        const partialSig = [
          {
            pubkey: keyPair.publicKey,
            signature: bscript.signature.encode(keyPair.sign(hash), sighashType)
          }
        ];
        this.data.updateInput(inputIndex, { partialSig });
        return this;
      }
      _signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
        const hashesForSig = this.checkTaprootHashesForSig(
          inputIndex,
          input,
          keyPair,
          tapLeafHashToSign,
          allowedSighashTypes
        );
        const tapKeySig = hashesForSig.filter((h3) => !h3.leafHash).map(
          (h3) => (0, bip371_1.serializeTaprootSignature)(
            keyPair.signSchnorr(h3.hash),
            input.sighashType
          )
        )[0];
        const tapScriptSig = hashesForSig.filter((h3) => !!h3.leafHash).map((h3) => ({
          pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),
          signature: (0, bip371_1.serializeTaprootSignature)(
            keyPair.signSchnorr(h3.hash),
            input.sighashType
          ),
          leafHash: h3.leafHash
        }));
        if (tapKeySig) {
          this.data.updateInput(inputIndex, { tapKeySig });
        }
        if (tapScriptSig.length) {
          this.data.updateInput(inputIndex, { tapScriptSig });
        }
        return this;
      }
      signInputAsync(inputIndex, keyPair, sighashTypes) {
        return Promise.resolve().then(() => {
          if (!keyPair || !keyPair.publicKey)
            throw new Error("Need Signer to sign input");
          const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
          if ((0, bip371_1.isTaprootInput)(input))
            return this._signTaprootInputAsync(
              inputIndex,
              input,
              keyPair,
              void 0,
              sighashTypes
            );
          return this._signInputAsync(inputIndex, keyPair, sighashTypes);
        });
      }
      signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {
        return Promise.resolve().then(() => {
          if (!keyPair || !keyPair.publicKey)
            throw new Error("Need Signer to sign input");
          const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
          if ((0, bip371_1.isTaprootInput)(input))
            return this._signTaprootInputAsync(
              inputIndex,
              input,
              keyPair,
              tapLeafHash,
              sighashTypes
            );
          throw new Error(`Input #${inputIndex} is not of type Taproot.`);
        });
      }
      _signInputAsync(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        const { hash, sighashType } = getHashAndSighashType(
          this.data.inputs,
          inputIndex,
          keyPair.publicKey,
          this.__CACHE,
          sighashTypes
        );
        return Promise.resolve(keyPair.sign(hash)).then((signature2) => {
          const partialSig = [
            {
              pubkey: keyPair.publicKey,
              signature: bscript.signature.encode(signature2, sighashType)
            }
          ];
          this.data.updateInput(inputIndex, { partialSig });
        });
      }
      async _signTaprootInputAsync(inputIndex, input, keyPair, tapLeafHash, sighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
        const hashesForSig = this.checkTaprootHashesForSig(
          inputIndex,
          input,
          keyPair,
          tapLeafHash,
          sighashTypes
        );
        const signaturePromises = [];
        const tapKeyHash = hashesForSig.filter((h3) => !h3.leafHash)[0];
        if (tapKeyHash) {
          const tapKeySigPromise = Promise.resolve(
            keyPair.signSchnorr(tapKeyHash.hash)
          ).then((sig) => {
            return {
              tapKeySig: (0, bip371_1.serializeTaprootSignature)(
                sig,
                input.sighashType
              )
            };
          });
          signaturePromises.push(tapKeySigPromise);
        }
        const tapScriptHashes = hashesForSig.filter((h3) => !!h3.leafHash);
        if (tapScriptHashes.length) {
          const tapScriptSigPromises = tapScriptHashes.map((tsh) => {
            return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(
              (signature2) => {
                const tapScriptSig = [
                  {
                    pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),
                    signature: (0, bip371_1.serializeTaprootSignature)(
                      signature2,
                      input.sighashType
                    ),
                    leafHash: tsh.leafHash
                  }
                ];
                return { tapScriptSig };
              }
            );
          });
          signaturePromises.push(...tapScriptSigPromises);
        }
        return Promise.all(signaturePromises).then((results) => {
          results.forEach((v) => this.data.updateInput(inputIndex, v));
        });
      }
      checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes) {
        if (typeof keyPair.signSchnorr !== "function")
          throw new Error(
            `Need Schnorr Signer to sign taproot input #${inputIndex}.`
          );
        const hashesForSig = getTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          keyPair.publicKey,
          this.__CACHE,
          tapLeafHashToSign,
          allowedSighashTypes
        );
        if (!hashesForSig || !hashesForSig.length)
          throw new Error(
            `Can not sign for input #${inputIndex} with the key ${keyPair.publicKey.toString(
              "hex"
            )}`
          );
        return hashesForSig;
      }
      toBuffer() {
        checkCache(this.__CACHE);
        return this.data.toBuffer();
      }
      toHex() {
        checkCache(this.__CACHE);
        return this.data.toHex();
      }
      toBase64() {
        checkCache(this.__CACHE);
        return this.data.toBase64();
      }
      updateGlobal(updateData) {
        this.data.updateGlobal(updateData);
        return this;
      }
      updateInput(inputIndex, updateData) {
        if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);
        (0, bip371_1.checkTaprootInputFields)(
          this.data.inputs[inputIndex],
          updateData,
          "updateInput"
        );
        this.data.updateInput(inputIndex, updateData);
        if (updateData.nonWitnessUtxo) {
          addNonWitnessTxCache(
            this.__CACHE,
            this.data.inputs[inputIndex],
            inputIndex
          );
        }
        return this;
      }
      updateOutput(outputIndex, updateData) {
        const outputData = this.data.outputs[outputIndex];
        (0, bip371_1.checkTaprootOutputFields)(
          outputData,
          updateData,
          "updateOutput"
        );
        this.data.updateOutput(outputIndex, updateData);
        return this;
      }
      addUnknownKeyValToGlobal(keyVal) {
        this.data.addUnknownKeyValToGlobal(keyVal);
        return this;
      }
      addUnknownKeyValToInput(inputIndex, keyVal) {
        this.data.addUnknownKeyValToInput(inputIndex, keyVal);
        return this;
      }
      addUnknownKeyValToOutput(outputIndex, keyVal) {
        this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
        return this;
      }
      clearFinalizedInput(inputIndex) {
        this.data.clearFinalizedInput(inputIndex);
        return this;
      }
    };
    exports2.Psbt = Psbt3;
    var transactionFromBuffer = (buffer2) => new PsbtTransaction(buffer2);
    var PsbtTransaction = class {
      constructor(buffer2 = import_buffer.Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
        this.tx = transaction_1.Transaction.fromBuffer(buffer2);
        checkTxEmpty(this.tx);
        Object.defineProperty(this, "tx", {
          enumerable: false,
          writable: true
        });
      }
      getInputOutputCounts() {
        return {
          inputCount: this.tx.ins.length,
          outputCount: this.tx.outs.length
        };
      }
      addInput(input) {
        if (input.hash === void 0 || input.index === void 0 || !import_buffer.Buffer.isBuffer(input.hash) && typeof input.hash !== "string" || typeof input.index !== "number") {
          throw new Error("Error adding input.");
        }
        const hash = typeof input.hash === "string" ? (0, bufferutils_1.reverseBuffer)(import_buffer.Buffer.from(input.hash, "hex")) : input.hash;
        this.tx.addInput(hash, input.index, input.sequence);
      }
      addOutput(output) {
        if (output.script === void 0 || output.value === void 0 || !import_buffer.Buffer.isBuffer(output.script) || typeof output.value !== "number") {
          throw new Error("Error adding output.");
        }
        this.tx.addOutput(output.script, output.value);
      }
      toBuffer() {
        return this.tx.toBuffer();
      }
    };
    function canFinalize(input, script, scriptType) {
      switch (scriptType) {
        case "pubkey":
        case "pubkeyhash":
        case "witnesspubkeyhash":
          return hasSigs(1, input.partialSig);
        case "multisig":
          const p2ms2 = payments.p2ms({ output: script });
          return hasSigs(p2ms2.m, input.partialSig, p2ms2.pubkeys);
        default:
          return false;
      }
    }
    function checkCache(cache4) {
      if (cache4.__UNSAFE_SIGN_NONSEGWIT !== false) {
        throw new Error("Not BIP174 compliant, can not export");
      }
    }
    function hasSigs(neededSigs, partialSig, pubkeys) {
      if (!partialSig) return false;
      let sigs;
      if (pubkeys) {
        sigs = pubkeys.map((pkey) => {
          const pubkey = compressPubkey(pkey);
          return partialSig.find((pSig) => pSig.pubkey.equals(pubkey));
        }).filter((v) => !!v);
      } else {
        sigs = partialSig;
      }
      if (sigs.length > neededSigs) throw new Error("Too many signatures");
      return sigs.length === neededSigs;
    }
    function isFinalized(input) {
      return !!input.finalScriptSig || !!input.finalScriptWitness;
    }
    function bip32DerivationIsMine(root) {
      return (d) => {
        if (!d.masterFingerprint.equals(root.fingerprint)) return false;
        if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;
        return true;
      };
    }
    function check32Bit(num2) {
      if (typeof num2 !== "number" || num2 !== Math.floor(num2) || num2 > 4294967295 || num2 < 0) {
        throw new Error("Invalid 32 bit integer");
      }
    }
    function checkFees(psbt, cache4, opts) {
      const feeRate = cache4.__FEE_RATE || psbt.getFeeRate();
      const vsize = cache4.__EXTRACTED_TX.virtualSize();
      const satoshis = feeRate * vsize;
      if (feeRate >= opts.maximumFeeRate) {
        throw new Error(
          `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in fees, which is ${feeRate} satoshi per byte for a transaction with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
        );
      }
    }
    function checkInputsForPartialSig(inputs2, action) {
      inputs2.forEach((input) => {
        const throws = (0, bip371_1.isTaprootInput)(input) ? (0, bip371_1.checkTaprootInputForSigs)(input, action) : (0, psbtutils_1.checkInputForSig)(input, action);
        if (throws)
          throw new Error("Can not modify transaction, signatures exist.");
      });
    }
    function checkPartialSigSighashes(input) {
      if (!input.sighashType || !input.partialSig) return;
      const { partialSig, sighashType } = input;
      partialSig.forEach((pSig) => {
        const { hashType } = bscript.signature.decode(pSig.signature);
        if (sighashType !== hashType) {
          throw new Error("Signature sighash does not match input sighash type");
        }
      });
    }
    function checkScriptForPubkey(pubkey, script, action) {
      if (!(0, psbtutils_1.pubkeyInScript)(pubkey, script)) {
        throw new Error(
          `Can not ${action} for this input with the key ${pubkey.toString("hex")}`
        );
      }
    }
    function checkTxEmpty(tx) {
      const isEmpty = tx.ins.every(
        (input) => input.script && input.script.length === 0 && input.witness && input.witness.length === 0
      );
      if (!isEmpty) {
        throw new Error("Format Error: Transaction ScriptSigs are not empty");
      }
    }
    function checkTxForDupeIns(tx, cache4) {
      tx.ins.forEach((input) => {
        checkTxInputCache(cache4, input);
      });
    }
    function checkTxInputCache(cache4, input) {
      const key = (0, bufferutils_1.reverseBuffer)(import_buffer.Buffer.from(input.hash)).toString("hex") + ":" + input.index;
      if (cache4.__TX_IN_CACHE[key]) throw new Error("Duplicate input detected.");
      cache4.__TX_IN_CACHE[key] = 1;
    }
    function scriptCheckerFactory2(payment, paymentScriptName) {
      return (inputIndex, scriptPubKey, redeemScript, ioType) => {
        const redeemScriptOutput = payment({
          redeem: { output: redeemScript }
        }).output;
        if (!scriptPubKey.equals(redeemScriptOutput)) {
          throw new Error(
            `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`
          );
        }
      };
    }
    var checkRedeemScript2 = scriptCheckerFactory2(payments.p2sh, "Redeem script");
    var checkWitnessScript2 = scriptCheckerFactory2(
      payments.p2wsh,
      "Witness script"
    );
    function getTxCacheValue(key, name10, inputs2, c) {
      if (!inputs2.every(isFinalized))
        throw new Error(`PSBT must be finalized to calculate ${name10}`);
      if (key === "__FEE_RATE" && c.__FEE_RATE) return c.__FEE_RATE;
      if (key === "__FEE" && c.__FEE) return c.__FEE;
      let tx;
      let mustFinalize = true;
      if (c.__EXTRACTED_TX) {
        tx = c.__EXTRACTED_TX;
        mustFinalize = false;
      } else {
        tx = c.__TX.clone();
      }
      inputFinalizeGetAmts(inputs2, tx, c, mustFinalize);
      if (key === "__FEE_RATE") return c.__FEE_RATE;
      else if (key === "__FEE") return c.__FEE;
    }
    function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {
      const scriptType = classifyScript(script);
      if (!canFinalize(input, script, scriptType))
        throw new Error(`Can not finalize input #${inputIndex}`);
      return prepareFinalScripts(
        script,
        scriptType,
        input.partialSig,
        isSegwit,
        isP2SH,
        isP2WSH
      );
    }
    function prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH) {
      let finalScriptSig;
      let finalScriptWitness;
      const payment = getPayment(script, scriptType, partialSig);
      const p2wsh2 = !isP2WSH ? null : payments.p2wsh({ redeem: payment });
      const p2sh2 = !isP2SH ? null : payments.p2sh({ redeem: p2wsh2 || payment });
      if (isSegwit) {
        if (p2wsh2) {
          finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
            p2wsh2.witness
          );
        } else {
          finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
            payment.witness
          );
        }
        if (p2sh2) {
          finalScriptSig = p2sh2.input;
        }
      } else {
        if (p2sh2) {
          finalScriptSig = p2sh2.input;
        } else {
          finalScriptSig = payment.input;
        }
      }
      return {
        finalScriptSig,
        finalScriptWitness
      };
    }
    function getHashAndSighashType(inputs2, inputIndex, pubkey, cache4, sighashTypes) {
      const input = (0, utils_1.checkForInput)(inputs2, inputIndex);
      const { hash, sighashType, script } = getHashForSig(
        inputIndex,
        input,
        cache4,
        false,
        sighashTypes
      );
      checkScriptForPubkey(pubkey, script, "sign");
      return {
        hash,
        sighashType
      };
    }
    function getHashForSig(inputIndex, input, cache4, forValidate, sighashTypes) {
      const unsignedTx = cache4.__TX;
      const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_ALL;
      checkSighashTypeAllowed(sighashType, sighashTypes);
      let hash;
      let prevout;
      if (input.nonWitnessUtxo) {
        const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
          cache4,
          input,
          inputIndex
        );
        const prevoutHash = unsignedTx.ins[inputIndex].hash;
        const utxoHash = nonWitnessUtxoTx.getHash();
        if (!prevoutHash.equals(utxoHash)) {
          throw new Error(
            `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`
          );
        }
        const prevoutIndex = unsignedTx.ins[inputIndex].index;
        prevout = nonWitnessUtxoTx.outs[prevoutIndex];
      } else if (input.witnessUtxo) {
        prevout = input.witnessUtxo;
      } else {
        throw new Error("Need a Utxo input item for signing");
      }
      const { meaningfulScript, type } = getMeaningfulScript(
        prevout.script,
        inputIndex,
        "input",
        input.redeemScript,
        input.witnessScript
      );
      if (["p2sh-p2wsh", "p2wsh"].indexOf(type) >= 0) {
        hash = unsignedTx.hashForWitnessV0(
          inputIndex,
          meaningfulScript,
          prevout.value,
          sighashType
        );
      } else if ((0, psbtutils_1.isP2WPKH)(meaningfulScript)) {
        const signingScript = payments.p2pkh({
          hash: meaningfulScript.slice(2)
        }).output;
        hash = unsignedTx.hashForWitnessV0(
          inputIndex,
          signingScript,
          prevout.value,
          sighashType
        );
      } else {
        if (input.nonWitnessUtxo === void 0 && cache4.__UNSAFE_SIGN_NONSEGWIT === false)
          throw new Error(
            `Input #${inputIndex} has witnessUtxo but non-segwit script: ${meaningfulScript.toString("hex")}`
          );
        if (!forValidate && cache4.__UNSAFE_SIGN_NONSEGWIT !== false)
          console.warn(
            "Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n*********************"
          );
        hash = unsignedTx.hashForSignature(
          inputIndex,
          meaningfulScript,
          sighashType
        );
      }
      return {
        script: meaningfulScript,
        sighashType,
        hash
      };
    }
    function getAllTaprootHashesForSig(inputIndex, input, inputs2, cache4) {
      const allPublicKeys = [];
      if (input.tapInternalKey) {
        const key = getPrevoutTaprootKey(inputIndex, input, cache4);
        if (key) {
          allPublicKeys.push(key);
        }
      }
      if (input.tapScriptSig) {
        const tapScriptPubkeys = input.tapScriptSig.map((tss) => tss.pubkey);
        allPublicKeys.push(...tapScriptPubkeys);
      }
      const allHashes = allPublicKeys.map(
        (pubicKey) => getTaprootHashesForSig(inputIndex, input, inputs2, pubicKey, cache4)
      );
      return allHashes.flat();
    }
    function getPrevoutTaprootKey(inputIndex, input, cache4) {
      const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache4);
      return (0, psbtutils_1.isP2TR)(script) ? script.subarray(2, 34) : null;
    }
    function trimTaprootSig(signature2) {
      return signature2.length === 64 ? signature2 : signature2.subarray(0, 64);
    }
    function getTaprootHashesForSig(inputIndex, input, inputs2, pubkey, cache4, tapLeafHashToSign, allowedSighashTypes) {
      const unsignedTx = cache4.__TX;
      const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
      checkSighashTypeAllowed(sighashType, allowedSighashTypes);
      const prevOuts = inputs2.map(
        (i, index) => getScriptAndAmountFromUtxo(index, i, cache4)
      );
      const signingScripts = prevOuts.map((o) => o.script);
      const values = prevOuts.map((o) => o.value);
      const hashes4 = [];
      if (input.tapInternalKey && !tapLeafHashToSign) {
        const outputKey = getPrevoutTaprootKey(inputIndex, input, cache4) || import_buffer.Buffer.from([]);
        if ((0, bip371_1.toXOnly)(pubkey).equals(outputKey)) {
          const tapKeyHash = unsignedTx.hashForWitnessV1(
            inputIndex,
            signingScripts,
            values,
            sighashType
          );
          hashes4.push({ pubkey, hash: tapKeyHash });
        }
      }
      const tapLeafHashes = (input.tapLeafScript || []).filter((tapLeaf) => (0, psbtutils_1.pubkeyInScript)(pubkey, tapLeaf.script)).map((tapLeaf) => {
        const hash = (0, bip341_1.tapleafHash)({
          output: tapLeaf.script,
          version: tapLeaf.leafVersion
        });
        return Object.assign({ hash }, tapLeaf);
      }).filter(
        (tapLeaf) => !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash)
      ).map((tapLeaf) => {
        const tapScriptHash = unsignedTx.hashForWitnessV1(
          inputIndex,
          signingScripts,
          values,
          sighashType,
          tapLeaf.hash
        );
        return {
          pubkey,
          hash: tapScriptHash,
          leafHash: tapLeaf.hash
        };
      });
      return hashes4.concat(tapLeafHashes);
    }
    function checkSighashTypeAllowed(sighashType, sighashTypes) {
      if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
        const str = sighashTypeToString(sighashType);
        throw new Error(
          `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${str}`
        );
      }
    }
    function getPayment(script, scriptType, partialSig) {
      let payment;
      switch (scriptType) {
        case "multisig":
          const sigs = getSortedSigs(script, partialSig);
          payment = payments.p2ms({
            output: script,
            signatures: sigs
          });
          break;
        case "pubkey":
          payment = payments.p2pk({
            output: script,
            signature: partialSig[0].signature
          });
          break;
        case "pubkeyhash":
          payment = payments.p2pkh({
            output: script,
            pubkey: partialSig[0].pubkey,
            signature: partialSig[0].signature
          });
          break;
        case "witnesspubkeyhash":
          payment = payments.p2wpkh({
            output: script,
            pubkey: partialSig[0].pubkey,
            signature: partialSig[0].signature
          });
          break;
      }
      return payment;
    }
    function getScriptFromInput(inputIndex, input, cache4) {
      const unsignedTx = cache4.__TX;
      const res = {
        script: null,
        isSegwit: false,
        isP2SH: false,
        isP2WSH: false
      };
      res.isP2SH = !!input.redeemScript;
      res.isP2WSH = !!input.witnessScript;
      if (input.witnessScript) {
        res.script = input.witnessScript;
      } else if (input.redeemScript) {
        res.script = input.redeemScript;
      } else {
        if (input.nonWitnessUtxo) {
          const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
            cache4,
            input,
            inputIndex
          );
          const prevoutIndex = unsignedTx.ins[inputIndex].index;
          res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
        } else if (input.witnessUtxo) {
          res.script = input.witnessUtxo.script;
        }
      }
      if (input.witnessScript || (0, psbtutils_1.isP2WPKH)(res.script)) {
        res.isSegwit = true;
      }
      return res;
    }
    function getSignersFromHD(inputIndex, inputs2, hdKeyPair) {
      const input = (0, utils_1.checkForInput)(inputs2, inputIndex);
      if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
        throw new Error("Need bip32Derivation to sign with HD");
      }
      const myDerivations = input.bip32Derivation.map((bipDv) => {
        if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
          return bipDv;
        } else {
          return;
        }
      }).filter((v) => !!v);
      if (myDerivations.length === 0) {
        throw new Error(
          "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
        );
      }
      const signers = myDerivations.map((bipDv) => {
        const node = hdKeyPair.derivePath(bipDv.path);
        if (!bipDv.pubkey.equals(node.publicKey)) {
          throw new Error("pubkey did not match bip32Derivation");
        }
        return node;
      });
      return signers;
    }
    function getSortedSigs(script, partialSig) {
      const p2ms2 = payments.p2ms({ output: script });
      return p2ms2.pubkeys.map((pk) => {
        return (partialSig.filter((ps) => {
          return ps.pubkey.equals(pk);
        })[0] || {}).signature;
      }).filter((v) => !!v);
    }
    function scriptWitnessToWitnessStack(buffer2) {
      let offset = 0;
      function readSlice(n2) {
        offset += n2;
        return buffer2.slice(offset - n2, offset);
      }
      function readVarInt() {
        const vi = varuint.decode(buffer2, offset);
        offset += varuint.decode.bytes;
        return vi;
      }
      function readVarSlice() {
        return readSlice(readVarInt());
      }
      function readVector() {
        const count = readVarInt();
        const vector = [];
        for (let i = 0; i < count; i++) vector.push(readVarSlice());
        return vector;
      }
      return readVector();
    }
    function sighashTypeToString(sighashType) {
      let text = sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
      const sigMod = sighashType & 31;
      switch (sigMod) {
        case transaction_1.Transaction.SIGHASH_ALL:
          text += "SIGHASH_ALL";
          break;
        case transaction_1.Transaction.SIGHASH_SINGLE:
          text += "SIGHASH_SINGLE";
          break;
        case transaction_1.Transaction.SIGHASH_NONE:
          text += "SIGHASH_NONE";
          break;
      }
      return text;
    }
    function addNonWitnessTxCache(cache4, input, inputIndex) {
      cache4.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;
      const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);
      cache4.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;
      const self2 = cache4;
      const selfIndex = inputIndex;
      delete input.nonWitnessUtxo;
      Object.defineProperty(input, "nonWitnessUtxo", {
        enumerable: true,
        get() {
          const buf2 = self2.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];
          const txCache = self2.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];
          if (buf2 !== void 0) {
            return buf2;
          } else {
            const newBuf = txCache.toBuffer();
            self2.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;
            return newBuf;
          }
        },
        set(data) {
          self2.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;
        }
      });
    }
    function inputFinalizeGetAmts(inputs2, tx, cache4, mustFinalize) {
      let inputAmount = 0;
      inputs2.forEach((input, idx) => {
        if (mustFinalize && input.finalScriptSig)
          tx.ins[idx].script = input.finalScriptSig;
        if (mustFinalize && input.finalScriptWitness) {
          tx.ins[idx].witness = scriptWitnessToWitnessStack(
            input.finalScriptWitness
          );
        }
        if (input.witnessUtxo) {
          inputAmount += input.witnessUtxo.value;
        } else if (input.nonWitnessUtxo) {
          const nwTx = nonWitnessUtxoTxFromCache(cache4, input, idx);
          const vout = tx.ins[idx].index;
          const out = nwTx.outs[vout];
          inputAmount += out.value;
        }
      });
      const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);
      const fee = inputAmount - outputAmount;
      if (fee < 0) {
        throw new Error("Outputs are spending more than Inputs");
      }
      const bytes = tx.virtualSize();
      cache4.__FEE = fee;
      cache4.__EXTRACTED_TX = tx;
      cache4.__FEE_RATE = Math.floor(fee / bytes);
    }
    function nonWitnessUtxoTxFromCache(cache4, input, inputIndex) {
      const c = cache4.__NON_WITNESS_UTXO_TX_CACHE;
      if (!c[inputIndex]) {
        addNonWitnessTxCache(cache4, input, inputIndex);
      }
      return c[inputIndex];
    }
    function getScriptFromUtxo(inputIndex, input, cache4) {
      const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache4);
      return script;
    }
    function getScriptAndAmountFromUtxo(inputIndex, input, cache4) {
      if (input.witnessUtxo !== void 0) {
        return {
          script: input.witnessUtxo.script,
          value: input.witnessUtxo.value
        };
      } else if (input.nonWitnessUtxo !== void 0) {
        const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
          cache4,
          input,
          inputIndex
        );
        const o = nonWitnessUtxoTx.outs[cache4.__TX.ins[inputIndex].index];
        return { script: o.script, value: o.value };
      } else {
        throw new Error("Can't find pubkey in input without Utxo data");
      }
    }
    function pubkeyInInput(pubkey, input, inputIndex, cache4) {
      const script = getScriptFromUtxo(inputIndex, input, cache4);
      const { meaningfulScript } = getMeaningfulScript(
        script,
        inputIndex,
        "input",
        input.redeemScript,
        input.witnessScript
      );
      return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);
    }
    function pubkeyInOutput(pubkey, output, outputIndex, cache4) {
      const script = cache4.__TX.outs[outputIndex].script;
      const { meaningfulScript } = getMeaningfulScript(
        script,
        outputIndex,
        "output",
        output.redeemScript,
        output.witnessScript
      );
      return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);
    }
    function redeemFromFinalScriptSig(finalScript) {
      if (!finalScript) return;
      const decomp = bscript.decompile(finalScript);
      if (!decomp) return;
      const lastItem = decomp[decomp.length - 1];
      if (!import_buffer.Buffer.isBuffer(lastItem) || isPubkeyLike(lastItem) || isSigLike(lastItem))
        return;
      const sDecomp = bscript.decompile(lastItem);
      if (!sDecomp) return;
      return lastItem;
    }
    function redeemFromFinalWitnessScript(finalScript) {
      if (!finalScript) return;
      const decomp = scriptWitnessToWitnessStack(finalScript);
      const lastItem = decomp[decomp.length - 1];
      if (isPubkeyLike(lastItem)) return;
      const sDecomp = bscript.decompile(lastItem);
      if (!sDecomp) return;
      return lastItem;
    }
    function compressPubkey(pubkey) {
      if (pubkey.length === 65) {
        const parity = pubkey[64] & 1;
        const newKey = pubkey.slice(0, 33);
        newKey[0] = 2 | parity;
        return newKey;
      }
      return pubkey.slice();
    }
    function isPubkeyLike(buf2) {
      return buf2.length === 33 && bscript.isCanonicalPubKey(buf2);
    }
    function isSigLike(buf2) {
      return bscript.isCanonicalScriptSignature(buf2);
    }
    function getMeaningfulScript(script, index, ioType, redeemScript, witnessScript) {
      const isP2SH = (0, psbtutils_1.isP2SHScript)(script);
      const isP2SHP2WSH = isP2SH && redeemScript && (0, psbtutils_1.isP2WSHScript)(redeemScript);
      const isP2WSH = (0, psbtutils_1.isP2WSHScript)(script);
      if (isP2SH && redeemScript === void 0)
        throw new Error("scriptPubkey is P2SH but redeemScript missing");
      if ((isP2WSH || isP2SHP2WSH) && witnessScript === void 0)
        throw new Error(
          "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
        );
      let meaningfulScript;
      if (isP2SHP2WSH) {
        meaningfulScript = witnessScript;
        checkRedeemScript2(index, script, redeemScript, ioType);
        checkWitnessScript2(index, redeemScript, witnessScript, ioType);
        checkInvalidP2WSH(meaningfulScript);
      } else if (isP2WSH) {
        meaningfulScript = witnessScript;
        checkWitnessScript2(index, script, witnessScript, ioType);
        checkInvalidP2WSH(meaningfulScript);
      } else if (isP2SH) {
        meaningfulScript = redeemScript;
        checkRedeemScript2(index, script, redeemScript, ioType);
      } else {
        meaningfulScript = script;
      }
      return {
        meaningfulScript,
        type: isP2SHP2WSH ? "p2sh-p2wsh" : isP2SH ? "p2sh" : isP2WSH ? "p2wsh" : "raw"
      };
    }
    function checkInvalidP2WSH(script) {
      if ((0, psbtutils_1.isP2WPKH)(script) || (0, psbtutils_1.isP2SHScript)(script)) {
        throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
      }
    }
    function classifyScript(script) {
      if ((0, psbtutils_1.isP2WPKH)(script)) return "witnesspubkeyhash";
      if ((0, psbtutils_1.isP2PKH)(script)) return "pubkeyhash";
      if ((0, psbtutils_1.isP2MS)(script)) return "multisig";
      if ((0, psbtutils_1.isP2PK)(script)) return "pubkey";
      return "nonstandard";
    }
    function range4(n2) {
      return [...Array(n2).keys()];
    }
  }
});

// node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/index.js
var require_src5 = __commonJS({
  "node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/index.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initEccLib = exports2.Transaction = exports2.opcodes = exports2.Psbt = exports2.Block = exports2.script = exports2.payments = exports2.networks = exports2.crypto = exports2.address = void 0;
    var address = require_address2();
    exports2.address = address;
    var crypto2 = require_crypto3();
    exports2.crypto = crypto2;
    var networks2 = require_networks3();
    exports2.networks = networks2;
    var payments = require_payments2();
    exports2.payments = payments;
    var script = require_script2();
    exports2.script = script;
    var block_1 = require_block();
    Object.defineProperty(exports2, "Block", {
      enumerable: true,
      get: function() {
        return block_1.Block;
      }
    });
    var psbt_1 = require_psbt2();
    Object.defineProperty(exports2, "Psbt", {
      enumerable: true,
      get: function() {
        return psbt_1.Psbt;
      }
    });
    var ops_1 = require_ops2();
    Object.defineProperty(exports2, "opcodes", {
      enumerable: true,
      get: function() {
        return ops_1.OPS;
      }
    });
    var transaction_1 = require_transaction2();
    Object.defineProperty(exports2, "Transaction", {
      enumerable: true,
      get: function() {
        return transaction_1.Transaction;
      }
    });
    var ecc_lib_1 = require_ecc_lib();
    Object.defineProperty(exports2, "initEccLib", {
      enumerable: true,
      get: function() {
        return ecc_lib_1.initEccLib;
      }
    });
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/bip32.js
var require_bip32 = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/bip32.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeBIP32Derivation = exports2.decodeBip32Derivation = exports2.hardenedKeyStart = void 0;
    exports2.hardenedKeyStart = 2147483648;
    function decodeBip32Derivation(buf2) {
      if (buf2.length % 4 !== 0 || buf2.length / 4 - 1 < 1) {
        throw new Error("invalid BIP32 derivation format");
      }
      const masterFingerprint = buf2.slice(0, 4);
      const steps = [];
      for (let i = 4; i < buf2.length; i += 4) {
        steps.push(buf2.slice(i, i + 4).readUInt32LE());
      }
      const path = stepsToString(steps);
      return { masterFingerprint, path };
    }
    exports2.decodeBip32Derivation = decodeBip32Derivation;
    function encodeBIP32Derivation(masterFingerprint, path) {
      const steps = path.split("/");
      const buf2 = import_buffer.Buffer.allocUnsafe(4 + 4 * steps.length);
      masterFingerprint.copy(buf2, 0);
      let offset = 4;
      steps.forEach((step) => {
        const isHardened = step.slice(-1) === "'";
        let num2 = 2147483647 & parseInt(isHardened ? step.slice(0, -1) : step, 10);
        if (isHardened) num2 += exports2.hardenedKeyStart;
        buf2.writeUInt32LE(num2, offset);
        offset += 4;
      });
      return buf2;
    }
    exports2.encodeBIP32Derivation = encodeBIP32Derivation;
    function stepsToString(steps) {
      const stepsStr = steps.map((step) => stepToString(step));
      return stepsStr.join("/");
    }
    function stepToString(step) {
      if (step < exports2.hardenedKeyStart) {
        return step.toString();
      }
      step -= exports2.hardenedKeyStart;
      return step.toString() + "'";
    }
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/utils.js
var require_utils7 = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/utils.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.randomBytes = exports2.pubkeyPositionInScript = exports2.isP2TR = exports2.isP2SH = exports2.isP2WSH = exports2.isP2WPKH = exports2.isP2PKH = exports2.isP2PK = exports2.isP2MS = exports2.classifyScript = exports2.scriptWitnessToWitnessStack = exports2.witnessStackToScriptWitness = exports2.hasSigs = exports2.getPayment = void 0;
    var randombytes = __importStar(require_browser2());
    var __1 = require_src6();
    var bufferutils_1 = require_bufferutils();
    var crypto_1 = require_crypto();
    var ops_1 = require_ops();
    var bscript = __importStar(require_script());
    function getPayment(script, scriptType, partialSig) {
      switch (scriptType) {
        case "multisig":
          const sigs = getSortedSigs(script, partialSig);
          return __1.payments.p2ms({
            output: script,
            signatures: sigs
          });
        case "pubkey":
          return __1.payments.p2pk({
            output: script,
            signature: partialSig[0].signature
          });
        case "pubkeyhash":
          return __1.payments.p2pkh({
            output: script,
            pubkey: partialSig[0].pubkey,
            signature: partialSig[0].signature
          });
        case "witnesspubkeyhash":
          return __1.payments.p2wpkh({
            output: script,
            pubkey: partialSig[0].pubkey,
            signature: partialSig[0].signature
          });
        default:
          throw new Error("unknown script");
      }
    }
    exports2.getPayment = getPayment;
    function hasSigs(neededSigs, partialSig, pubkeys) {
      if (!partialSig) return false;
      let sigs;
      if (pubkeys) {
        sigs = pubkeys.map((pkey) => {
          const pubkey = compressPubkey(pkey);
          return partialSig.find((pSig) => pSig.pubkey.equals(pubkey));
        }).filter((v) => !!v);
      } else {
        sigs = partialSig;
      }
      if (sigs.length > neededSigs)
        throw new Error(
          `Too many signatures, needs ${neededSigs} has ${sigs.length}`
        );
      return sigs.length === neededSigs;
    }
    exports2.hasSigs = hasSigs;
    function getSortedSigs(script, partialSig) {
      const p2ms2 = __1.payments.p2ms({ output: script });
      return p2ms2.pubkeys.map((pk) => {
        return (partialSig.filter((ps) => {
          return ps.pubkey.equals(pk);
        })[0] || {}).signature;
      }).filter((v) => !!v);
    }
    function witnessStackToScriptWitness2(witness) {
      let buffer2 = import_buffer.Buffer.allocUnsafe(0);
      function writeSlice(slice2) {
        buffer2 = import_buffer.Buffer.concat([buffer2, import_buffer.Buffer.from(slice2)]);
      }
      function writeVarInt(i) {
        const currentLen = buffer2.length;
        const varintLen = bufferutils_1.varuint.encodingLength(i);
        buffer2 = import_buffer.Buffer.concat([buffer2, import_buffer.Buffer.allocUnsafe(varintLen)]);
        bufferutils_1.varuint.encode(i, buffer2, currentLen);
      }
      function writeVarSlice(slice2) {
        writeVarInt(slice2.length);
        writeSlice(slice2);
      }
      function writeVector(vector) {
        writeVarInt(vector.length);
        vector.forEach(writeVarSlice);
      }
      writeVector(witness);
      return buffer2;
    }
    exports2.witnessStackToScriptWitness = witnessStackToScriptWitness2;
    function scriptWitnessToWitnessStack(buffer2) {
      let offset = 0;
      function readSlice(n2) {
        offset += n2;
        return buffer2.slice(offset - n2, offset);
      }
      function readVarInt() {
        const vi = bufferutils_1.varuint.decode(buffer2, offset);
        offset += bufferutils_1.varuint.decode.bytes;
        return vi;
      }
      function readVarSlice() {
        return readSlice(readVarInt());
      }
      function readVector() {
        const count = readVarInt();
        const vector = [];
        for (let i = 0; i < count; i++) vector.push(readVarSlice());
        return vector;
      }
      return readVector();
    }
    exports2.scriptWitnessToWitnessStack = scriptWitnessToWitnessStack;
    function compressPubkey(pubkey) {
      if (pubkey.length === 65) {
        const parity = pubkey[64] & 1;
        const newKey = pubkey.slice(0, 33);
        newKey[0] = 2 | parity;
        return newKey;
      }
      return pubkey.slice();
    }
    function classifyScript(script) {
      if ((0, exports2.isP2WPKH)(script)) return "witnesspubkeyhash";
      if ((0, exports2.isP2PKH)(script)) return "pubkeyhash";
      if ((0, exports2.isP2MS)(script)) return "multisig";
      if ((0, exports2.isP2PK)(script)) return "pubkey";
      return "nonstandard";
    }
    exports2.classifyScript = classifyScript;
    function isPaymentFactory2(payment) {
      return (script) => {
        try {
          payment({ output: script });
          return true;
        } catch (err) {
          return false;
        }
      };
    }
    exports2.isP2MS = isPaymentFactory2(__1.payments.p2ms);
    exports2.isP2PK = isPaymentFactory2(__1.payments.p2pk);
    exports2.isP2PKH = isPaymentFactory2(__1.payments.p2pkh);
    exports2.isP2WPKH = isPaymentFactory2(__1.payments.p2wpkh);
    exports2.isP2WSH = isPaymentFactory2(__1.payments.p2wsh);
    exports2.isP2SH = isPaymentFactory2(__1.payments.p2sh);
    var isP2TR2 = (script) => script[0] === ops_1.OPS.OP_1;
    exports2.isP2TR = isP2TR2;
    function pubkeyPositionInScript2(pubkey, script) {
      const pubkeyHash = (0, crypto_1.hash160)(pubkey);
      const pubkeyXOnly = pubkey.slice(1, 33);
      const decompiled = bscript.decompile(script);
      if (decompiled === null) throw new Error("Unknown script error");
      return decompiled.findIndex((element) => {
        if (typeof element === "number") return false;
        return element.equals(pubkey) || element.equals(pubkeyHash) || element.equals(pubkeyXOnly);
      });
    }
    exports2.pubkeyPositionInScript = pubkeyPositionInScript2;
    function randomBytes2(options) {
      if (options === void 0) options = {};
      const rng = options.rng || randombytes.default;
      return rng(32);
    }
    exports2.randomBytes = randomBytes2;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/input.js
var require_input = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/input.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PsetInput = exports2.InputDuplicateFieldError = void 0;
    var bitcoinjs_lib_1 = require_src5();
    var bufferutils_1 = require_bufferutils();
    var issuance_1 = require_issuance();
    var transaction_1 = require_transaction();
    var bip32_1 = require_bip32();
    var fields_1 = require_fields();
    var key_pair_1 = require_key_pair();
    var proprietary_data_1 = require_proprietary_data();
    var pset_1 = require_pset();
    var bscript = __importStar(require_script());
    var utils_1 = require_utils7();
    var asset_1 = require_asset();
    var value_1 = require_value();
    var InputDuplicateFieldError = class extends Error {
      constructor(message) {
        if (message) {
          message = "Duplicated input " + message;
        }
        super(message);
      }
    };
    exports2.InputDuplicateFieldError = InputDuplicateFieldError;
    var PsetInput = class _PsetInput {
      constructor(previousTxid, previousTxIndex, sequence) {
        this.previousTxid = previousTxid || import_buffer.Buffer.from([]);
        this.previousTxIndex = previousTxIndex || 0;
        this.sequence = sequence;
      }
      static fromBuffer(r) {
        let kp;
        const input = new _PsetInput();
        while (true) {
          try {
            kp = key_pair_1.KeyPair.fromBuffer(r);
          } catch (e) {
            if (e instanceof Error && e === key_pair_1.ErrEmptyKey) {
              input.sanityCheck();
              return input;
            }
            throw e;
          }
          switch (kp.key.keyType) {
            case fields_1.InputTypes.NON_WITNESS_UTXO:
              if (input.nonWitnessUtxo) {
                throw new InputDuplicateFieldError("non-witness utxo");
              }
              input.nonWitnessUtxo = transaction_1.Transaction.fromBuffer(kp.value);
              break;
            case fields_1.InputTypes.WITNESS_UTXO:
              if (input.witnessUtxo) {
                throw new InputDuplicateFieldError("witness utxo");
              }
              input.witnessUtxo = deserializeOutput(kp.value);
              break;
            case fields_1.InputTypes.PARTIAL_SIG:
              if (!input.partialSigs) {
                input.partialSigs = [];
              }
              const pk = kp.key.keyData;
              if (pk.length !== 33) {
                throw new Error(`Invalid partial sig's pubkey length`);
              }
              if (input.partialSigs.find((ps) => ps.pubkey.equals(pk))) {
                throw new InputDuplicateFieldError("partial sig");
              }
              const signature2 = kp.value;
              bscript.signature.decode(signature2);
              input.partialSigs.push({ pubkey: pk, signature: signature2 });
              break;
            case fields_1.InputTypes.SIGHASH_TYPE:
              if (input.sighashType !== void 0) {
                throw new InputDuplicateFieldError("sighash type");
              }
              if (kp.value.length !== 4) {
                throw new Error("Invalid input sighash type length");
              }
              input.sighashType = kp.value.readUInt32LE();
              break;
            case fields_1.InputTypes.REDEEM_SCRIPT:
              if (input.redeemScript && input.redeemScript.length > 0) {
                throw new InputDuplicateFieldError("redeem script");
              }
              input.redeemScript = kp.value;
              break;
            case fields_1.InputTypes.WITNESS_SCRIPT:
              if (input.witnessScript && input.witnessScript.length > 0) {
                throw new InputDuplicateFieldError("witness script");
              }
              input.witnessScript = kp.value;
              break;
            case fields_1.InputTypes.BIP32_DERIVATION:
              const pubkey = kp.key.keyData;
              if (pubkey.length !== 33) {
                throw new Error("Invalid input bip32 derivation pubkey length");
              }
              if (!input.bip32Derivation) {
                input.bip32Derivation = [];
              }
              if (input.bip32Derivation.find((d) => d.pubkey.equals(pubkey))) {
                throw new InputDuplicateFieldError("bip32 derivation");
              }
              const { masterFingerprint, path } = (0, bip32_1.decodeBip32Derivation)(kp.value);
              input.bip32Derivation.push({ pubkey, masterFingerprint, path });
              break;
            case fields_1.InputTypes.FINAL_SCRIPTSIG:
              if (input.finalScriptSig && input.finalScriptSig.length > 0) {
                throw new InputDuplicateFieldError("final scriptsig");
              }
              input.finalScriptSig = kp.value;
              break;
            case fields_1.InputTypes.FINAL_SCRIPTWITNESS:
              if (input.finalScriptWitness && input.finalScriptWitness.length > 0) {
                throw new InputDuplicateFieldError("final script witness");
              }
              input.finalScriptWitness = kp.value;
              break;
            case fields_1.InputTypes.RIPEMD_160:
              const ripemd160Key = kp.key.keyData.toString("hex");
              if (ripemd160Key.length !== 20) {
                throw new Error("Invalid length for key of ripemd160 preimages");
              }
              if (!input.ripemd160Preimages) {
                input.ripemd160Preimages = {};
              }
              input.ripemd160Preimages[ripemd160Key] = kp.value;
              break;
            case fields_1.InputTypes.SHA_256:
              const sha256Key = kp.key.keyData.toString("hex");
              if (sha256Key.length !== 32) {
                throw new Error("Invalid length for key of sha256 preimages");
              }
              if (!input.sha256Preimages) {
                input.sha256Preimages = {};
              }
              input.sha256Preimages[sha256Key] = kp.value;
              break;
            case fields_1.InputTypes.HASH_160:
              const hash160Key = kp.key.keyData.toString("hex");
              if (hash160Key.length !== 20) {
                throw new Error("Invalid length for key of hash160 preimages");
              }
              if (!input.hash160Preimages) {
                input.hash160Preimages = {};
              }
              input.hash160Preimages[hash160Key] = kp.value;
              break;
            case fields_1.InputTypes.HASH_256:
              const hash256Key = kp.key.keyData.toString("hex");
              if (hash256Key.length !== 32) {
                throw new Error("Invalid length for key of hash256 preimages");
              }
              if (!input.hash256Preimages) {
                input.hash256Preimages = {};
              }
              input.hash256Preimages[hash256Key] = kp.value;
              break;
            case fields_1.InputTypes.PREVIOUS_TXID:
              if (input.previousTxid && input.previousTxid.length > 0) {
                throw new InputDuplicateFieldError("previous txid");
              }
              if (kp.value.length !== 32) {
                throw new Error("Invalid input previous txid length");
              }
              input.previousTxid = kp.value;
              break;
            case fields_1.InputTypes.PREVIOUS_TXINDEX:
              if (input.previousTxIndex > 0) {
                throw new InputDuplicateFieldError("previous txindex");
              }
              if (kp.value.length !== 4) {
                throw new Error("Invalid input previous tx index length");
              }
              input.previousTxIndex = kp.value.readUInt32LE();
              break;
            case fields_1.InputTypes.SEQUENCE:
              if (input.sequence !== void 0) {
                throw new InputDuplicateFieldError("sequence");
              }
              if (kp.value.length !== 4) {
                throw new Error("Invalid input sequence length");
              }
              input.sequence = kp.value.readUInt32LE();
              break;
            case fields_1.InputTypes.REQUIRED_TIME_LOCKTIME:
              if (input.requiredTimeLocktime !== void 0) {
                throw new InputDuplicateFieldError("time locktime");
              }
              if (kp.value.length !== 4) {
                throw new Error("Invalid input time-based locktime length");
              }
              input.requiredTimeLocktime = kp.value.readUInt32LE();
              break;
            case fields_1.InputTypes.REQUIRED_HEIGHT_LOCKTIME:
              if (input.requiredHeightLocktime !== void 0) {
                throw new InputDuplicateFieldError("height locktime");
              }
              if (kp.value.length !== 4) {
                throw new Error("Invalid input height-based locktime length");
              }
              input.requiredHeightLocktime = kp.value.readUInt32LE();
              break;
            case fields_1.InputTypes.TAP_KEY_SIG:
              if (input.tapKeySig && input.tapKeySig.length > 0) {
                throw new InputDuplicateFieldError("taproot keysig");
              }
              if (kp.value.length !== 64 && kp.value.length !== 65) {
                throw new Error("Invalid input taproot key signature length");
              }
              input.tapKeySig = kp.value;
              break;
            case fields_1.InputTypes.TAP_SCRIPT_SIG:
              if (!input.tapScriptSig) {
                input.tapScriptSig = [];
              }
              if (kp.key.keyData.length !== 64) {
                throw new Error("Invalid input TAP_SCRIPT_SIG key data length");
              }
              const tapPubkey = kp.key.keyData.slice(0, 32);
              const leafHash = kp.key.keyData.slice(32);
              if (input.tapScriptSig.find((ps) => ps.pubkey.equals(tapPubkey))) {
                throw new InputDuplicateFieldError("taproot scriptsig");
              }
              if (kp.value.length !== 64 && kp.value.length !== 65) {
                throw new Error("Invalid input taproot key signature length");
              }
              input.tapScriptSig.push({
                pubkey: tapPubkey,
                leafHash,
                signature: kp.value
              });
              break;
            case fields_1.InputTypes.TAP_LEAF_SCRIPT:
              if (!input.tapLeafScript) {
                input.tapLeafScript = [];
              }
              if ((kp.key.keyData.length - 1) % 32 !== 0) {
                throw new Error("Invalid input TAP_LEAF_SCRIPT key data length");
              }
              const controlBlock = kp.key.keyData;
              const leafVersion = kp.value.slice(-1)[0];
              if ((controlBlock[0] & 254) !== leafVersion) {
                throw new Error("Invalid input taproot leaf script version");
              }
              input.tapLeafScript.push({
                controlBlock,
                leafVersion,
                script: kp.value.slice(0, -1)
              });
              break;
            case fields_1.InputTypes.TAP_BIP32_DERIVATION:
              const tapKey = kp.key.keyData;
              if (tapKey.length !== 33) {
                throw new Error("Invalid input bip32 derivation pubkey length");
              }
              if (!input.tapBip32Derivation) {
                input.tapBip32Derivation = [];
              }
              const tapBip32Pubkey = kp.key.keyData;
              if (input.tapBip32Derivation.find(
                (d) => d.pubkey.equals(tapBip32Pubkey)
              )) {
                throw new InputDuplicateFieldError("taproot bip32 derivation");
              }
              const nHashes = bufferutils_1.varuint.decode(kp.value);
              const nHashesLen = bufferutils_1.varuint.encodingLength(nHashes);
              const bip32Deriv = (0, bip32_1.decodeBip32Derivation)(
                kp.value.slice(nHashesLen + nHashes * 32)
              );
              const leafHashes = new Array(nHashes);
              for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {
                leafHashes[i] = kp.value.slice(_offset, _offset + 32);
              }
              input.tapBip32Derivation.push({
                pubkey: tapBip32Pubkey,
                masterFingerprint: bip32Deriv.masterFingerprint,
                path: bip32Deriv.path,
                leafHashes
              });
              break;
            case fields_1.InputTypes.TAP_INTERNAL_KEY:
              if (input.tapInternalKey && input.tapInternalKey.length > 0) {
                throw new InputDuplicateFieldError("taproot internal key");
              }
              if (kp.value.length !== 32) {
                throw new Error("Invalid input taproot internal key length");
              }
              input.tapInternalKey = kp.value;
              break;
            case fields_1.InputTypes.TAP_MERKLE_ROOT:
              if (input.tapMerkleRoot && input.tapMerkleRoot.length > 0) {
                throw new InputDuplicateFieldError("taproot merkle root");
              }
              if (kp.value.length !== 32) {
                throw new Error("Invalid input taproot merkle root length");
              }
              input.tapMerkleRoot = kp.value;
              break;
            case fields_1.InputTypes.PROPRIETARY:
              const data = proprietary_data_1.ProprietaryData.fromKeyPair(kp);
              if (import_buffer.Buffer.compare(data.identifier, pset_1.magicPrefix) === 0) {
                switch (data.subType) {
                  case fields_1.InputProprietaryTypes.ISSUANCE_VALUE:
                    if (input.issuanceValue > 0) {
                      throw new InputDuplicateFieldError("issuance value");
                    }
                    if (kp.value.length !== 8) {
                      throw new Error("Invalid input issuance value length");
                    }
                    input.issuanceValue = (0, bufferutils_1.readUInt64LE)(
                      kp.value,
                      0
                    );
                    break;
                  case fields_1.InputProprietaryTypes.ISSUANCE_VALUE_COMMITMENT:
                    if (input.issuanceValueCommitment && input.issuanceValueCommitment.length > 0) {
                      throw new InputDuplicateFieldError(
                        "issuance value commitment"
                      );
                    }
                    if (kp.value.length !== 33) {
                      throw new Error(
                        "Invalid input issuance value commitment length"
                      );
                    }
                    input.issuanceValueCommitment = kp.value;
                    break;
                  case fields_1.InputProprietaryTypes.ISSUANCE_VALUE_RANGEPROOF:
                    if (input.issuanceValueRangeproof && input.issuanceValueRangeproof.length > 0) {
                      throw new InputDuplicateFieldError(
                        "issuance value range proof"
                      );
                    }
                    input.issuanceValueRangeproof = kp.value;
                    break;
                  case fields_1.InputProprietaryTypes.ISSUANCE_INFLATION_KEYS_RANGEPROOF:
                    if (input.issuanceInflationKeysRangeproof && input.issuanceInflationKeysRangeproof.length > 0) {
                      throw new InputDuplicateFieldError(
                        "issuance inflation keys range proof"
                      );
                    }
                    input.issuanceInflationKeysRangeproof = kp.value;
                    break;
                  case fields_1.InputProprietaryTypes.PEGIN_TX:
                    if (input.peginTx !== void 0) {
                      throw new InputDuplicateFieldError("pegin tx");
                    }
                    try {
                      input.peginTx = bitcoinjs_lib_1.Transaction.fromBuffer(
                        kp.value
                      );
                    } catch (ignore) {
                      throw new Error("Invalid input pegin tx");
                    }
                    break;
                  case fields_1.InputProprietaryTypes.PEGIN_TXOUT_PROOF:
                    if (input.peginTxoutProof && input.peginTxoutProof.length > 0) {
                      throw new InputDuplicateFieldError("pegin txout proof");
                    }
                    input.peginTxoutProof = kp.value;
                    break;
                  case fields_1.InputProprietaryTypes.PEGIN_GENESIS_HASH:
                    if (input.peginGenesisHash && input.peginGenesisHash.length > 0) {
                      throw new InputDuplicateFieldError("pegin genesis hash");
                    }
                    if (kp.value.length !== 32) {
                      throw new Error("Invalid input pegin genesis hash length");
                    }
                    input.peginGenesisHash = kp.value;
                    break;
                  case fields_1.InputProprietaryTypes.PEGIN_CLAIM_SCRIPT:
                    if (input.peginClaimScript && input.peginClaimScript.length > 0) {
                      throw new InputDuplicateFieldError("pegin claim script");
                    }
                    input.peginClaimScript = kp.value;
                    break;
                  case fields_1.InputProprietaryTypes.PEGIN_VALUE:
                    if (input.peginValue > 0) {
                      throw new InputDuplicateFieldError("pegin value");
                    }
                    if (kp.value.length !== 8) {
                      throw new Error("Invalid input pegin value length");
                    }
                    input.peginValue = (0, bufferutils_1.readUInt64LE)(kp.value, 0);
                    break;
                  case fields_1.InputProprietaryTypes.PEGIN_WITNESS:
                    if (input.peginWitness && input.peginWitness.length > 0) {
                      throw new InputDuplicateFieldError("pegin witness");
                    }
                    const pwr = new bufferutils_1.BufferReader(kp.value);
                    try {
                      input.peginWitness = pwr.readVector();
                    } catch (ignore) {
                      throw new Error("Invalid input pegin witness");
                    }
                    break;
                  case fields_1.InputProprietaryTypes.ISSUANCE_INFLATION_KEYS:
                    if (input.issuanceInflationKeys > 0) {
                      throw new InputDuplicateFieldError("issuance inflation keys");
                    }
                    if (kp.value.length !== 8) {
                      throw new Error(
                        "Invalid input issuance inflation keys length"
                      );
                    }
                    input.issuanceInflationKeys = (0, bufferutils_1.readUInt64LE)(
                      kp.value,
                      0
                    );
                    break;
                  case fields_1.InputProprietaryTypes.ISSUANCE_INFLATION_KEYS_COMMITMENT:
                    if (input.issuanceInflationKeysCommitment && input.issuanceInflationKeysCommitment.length > 0) {
                      throw new InputDuplicateFieldError(
                        "issuance inflation keys commitment"
                      );
                    }
                    if (kp.value.length !== 33) {
                      throw new Error(
                        "Invalid input issuance inflation keys commitment length"
                      );
                    }
                    input.issuanceInflationKeysCommitment = kp.value;
                    break;
                  case fields_1.InputProprietaryTypes.ISSUANCE_BLINDING_NONCE:
                    if (input.issuanceBlindingNonce && input.issuanceBlindingNonce.length > 0) {
                      throw new InputDuplicateFieldError("issuance blinding nonce");
                    }
                    if (kp.value.length !== 32) {
                      throw new Error(
                        "Invalid input issuance blinding nonce length"
                      );
                    }
                    input.issuanceBlindingNonce = kp.value;
                    break;
                  case fields_1.InputProprietaryTypes.ISSUANCE_ASSET_ENTROPY:
                    if (input.issuanceAssetEntropy && input.issuanceAssetEntropy.length > 0) {
                      throw new InputDuplicateFieldError("issuance asset entropy");
                    }
                    if (kp.value.length !== 32) {
                      throw new Error(
                        "Invalid input issuance asset entropy length"
                      );
                    }
                    input.issuanceAssetEntropy = kp.value;
                    break;
                  case fields_1.InputProprietaryTypes.UTXO_RANGEPROOF:
                    if (input.utxoRangeProof && input.utxoRangeProof.length > 0) {
                      throw new InputDuplicateFieldError("utxo range proof");
                    }
                    input.utxoRangeProof = kp.value;
                    break;
                  case fields_1.InputProprietaryTypes.ISSUANCE_BLIND_VALUE_PROOF:
                    if (input.issuanceBlindValueProof && input.issuanceBlindValueProof.length > 0) {
                      throw new InputDuplicateFieldError(
                        "issuance blind value proof"
                      );
                    }
                    input.issuanceBlindValueProof = kp.value;
                    break;
                  case fields_1.InputProprietaryTypes.ISSUANCE_BLIND_INFLATION_KEYS_PROOF:
                    if (input.issuanceBlindInflationKeysProof && input.issuanceBlindInflationKeysProof.length > 0) {
                      throw new InputDuplicateFieldError(
                        "issuance blind inflation keys proof"
                      );
                    }
                    input.issuanceBlindInflationKeysProof = kp.value;
                    break;
                  case fields_1.InputProprietaryTypes.EXPLICIT_VALUE:
                    if (input.explicitValue !== void 0) {
                      throw new InputDuplicateFieldError("explicit value");
                    }
                    if (kp.value.length !== 8) {
                      throw new Error("Invalid input explicit value length");
                    }
                    input.explicitValue = (0, bufferutils_1.readUInt64LE)(
                      kp.value,
                      0
                    );
                    break;
                  case fields_1.InputProprietaryTypes.VALUE_PROOF:
                    if (input.explicitValueProof && input.explicitValueProof.length > 0) {
                      throw new InputDuplicateFieldError("explicit value proof");
                    }
                    input.explicitValueProof = kp.value;
                    break;
                  case fields_1.InputProprietaryTypes.EXPLICIT_ASSET:
                    if (input.explicitAsset && input.explicitAsset.length > 0) {
                      throw new InputDuplicateFieldError("explicit asset");
                    }
                    input.explicitAsset = kp.value;
                    break;
                  case fields_1.InputProprietaryTypes.ASSET_PROOF:
                    if (input.explicitAssetProof && input.explicitAssetProof.length > 0) {
                      throw new InputDuplicateFieldError("explicit asset proof");
                    }
                    input.explicitAssetProof = kp.value;
                    break;
                  case fields_1.InputProprietaryTypes.BLINDED_ISSUANCE:
                    if (input.blindedIssuance !== void 0) {
                      throw new InputDuplicateFieldError("blinded issuance");
                    }
                    if (kp.value.length !== 1) {
                      throw new Error("invalid blinded issuance length");
                    }
                    input.blindedIssuance = kp.value.equals(import_buffer.Buffer.of(1));
                    break;
                  default:
                    if (!input.proprietaryData) {
                      input.proprietaryData = [];
                    }
                    input.proprietaryData.push(data);
                }
              }
              break;
            default:
              if (!input.unknowns) {
                input.unknowns = [];
              }
              input.unknowns.push(kp);
          }
        }
      }
      sanityCheck() {
        if (this.previousTxid.length === 0) {
          throw new Error("Missing input previous txid");
        }
        if (this.previousTxIndex < 0) {
          throw new Error("Missing input previous tx index");
        }
        if (!this.witnessUtxo && this.witnessScript && this.witnessScript.length > 0) {
          throw new Error(
            "Input witness script cannot be set if witness utxo is unset"
          );
        }
        if (!this.witnessUtxo && this.finalScriptWitness && this.finalScriptWitness.length > 0) {
          throw new Error(
            "Input final script witness cannot be set if witness utxo is unset"
          );
        }
        const issuanceValueCommitSet = this.issuanceValueCommitment && this.issuanceValueCommitment.length > 0;
        const issuanceBlindValueProofSet = this.issuanceBlindValueProof && this.issuanceBlindValueProof.length > 0;
        if (this.issuanceValue && issuanceValueCommitSet !== issuanceBlindValueProofSet) {
          throw new Error("Missing input issuance value commitment or blind proof");
        }
        const issuanceInflationKeysCommitSet = this.issuanceInflationKeysCommitment && this.issuanceInflationKeysCommitment.length > 0;
        const issuanceBlindInflationKeysProofSet = this.issuanceBlindInflationKeysProof && this.issuanceBlindInflationKeysProof.length > 0;
        if (this.issuanceInflationKeys && issuanceInflationKeysCommitSet !== issuanceBlindInflationKeysProofSet) {
          throw new Error(
            "Missing input issuance inflation keys commitment or blind proof"
          );
        }
        if (this.sighashType !== void 0 && this.sighashType < 0) {
          throw new Error("Invalid sighash type");
        }
        if (this.explicitValue && !this.explicitValueProof) {
          throw new Error(
            "Explicit value proof is required if explicit value is set"
          );
        }
        if (this.explicitValueProof && !this.explicitValue) {
          throw new Error("Explicit value is required if value proof is set");
        }
        if (this.explicitAsset && !this.explicitAssetProof) {
          throw new Error("Explicit asset proof is required if explicit asset set");
        }
        if (this.explicitAssetProof && !this.explicitAsset) {
          throw new Error("Explicit asset is required if asset proof is set");
        }
        if (this.explicitAsset) {
          const asset = asset_1.AssetHash.fromBytes(this.explicitAsset);
          if (asset.isConfidential) {
            throw new Error(`Explicit asset must be unconfidential`);
          }
        }
        const utxo = this.getUtxo();
        if (utxo && this.explicitAsset) {
          if (!asset_1.AssetHash.fromBytes(utxo.asset).isConfidential) {
            throw new Error(
              "Explicit asset must be undefined if previous utxo is unconfidential"
            );
          }
        }
        if (utxo && this.explicitValue !== void 0) {
          if (!value_1.ElementsValue.fromBytes(utxo.value).isConfidential) {
            throw new Error(
              "Explicit value must be undefined if previout utxo is unconfidential"
            );
          }
        }
        return this;
      }
      hasIssuance() {
        if (!this.issuanceBlindingNonce) return false;
        return this.issuanceBlindingNonce.equals(transaction_1.ZERO);
      }
      hasIssuanceBlinded() {
        return this.issuanceValueCommitment.length > 0;
      }
      hasReissuance() {
        if (!this.issuanceBlindingNonce) return false;
        return !this.issuanceBlindingNonce.equals(transaction_1.ZERO);
      }
      isFinalized() {
        return this.finalScriptSig && this.finalScriptSig.length > 0 && !import_buffer.Buffer.alloc(1).equals(this.finalScriptSig) || this.finalScriptWitness && this.finalScriptWitness.length > 0 && !import_buffer.Buffer.alloc(1).equals(this.finalScriptWitness);
      }
      isTaproot() {
        return this.tapInternalKey && this.tapInternalKey.length > 0 || this.tapMerkleRoot && this.tapMerkleRoot.length > 0 || this.tapLeafScript && this.tapLeafScript.length > 0 || this.tapBip32Derivation && this.tapBip32Derivation.length > 0 || this.witnessUtxo && (0, utils_1.isP2TR)(this.witnessUtxo.script);
      }
      getIssuanceAssetHash() {
        if (!this.hasIssuance() && !this.hasReissuance()) {
          return void 0;
        }
        if (!this.issuanceAssetEntropy) {
          throw new Error("missing issuance asset entropy");
        }
        let entropy = this.issuanceAssetEntropy;
        if (!this.hasReissuance()) {
          entropy = (0, issuance_1.generateEntropy)(
            { txHash: this.previousTxid, vout: this.previousTxIndex },
            this.issuanceAssetEntropy
          );
        }
        return (0, issuance_1.calculateAsset)(entropy);
      }
      getIssuanceEntropy() {
        if (!this.hasIssuance() && !this.hasReissuance()) {
          throw new Error("input is not an (re)issuance");
        }
        if (!this.issuanceAssetEntropy) {
          throw new Error("missing issuance asset entropy");
        }
        let entropy = this.issuanceAssetEntropy;
        if (this.hasIssuance()) {
          entropy = (0, issuance_1.generateEntropy)(
            { txHash: this.previousTxid, vout: this.previousTxIndex },
            this.issuanceAssetEntropy
          );
        }
        return entropy;
      }
      getUtxo() {
        if (!this.witnessUtxo && !this.nonWitnessUtxo) {
          return void 0;
        }
        if (!this.nonWitnessUtxo) {
          const utxo = this.witnessUtxo;
          utxo.rangeProof = this.utxoRangeProof;
          return utxo;
        }
        return this.nonWitnessUtxo.outs[this.previousTxIndex];
      }
      toBuffer() {
        const keyPairs = this.getKeyPairs();
        const kpBuf = keyPairs.map((kp) => kp.toBuffer());
        let size = 0;
        kpBuf.forEach((buf2) => {
          size += buf2.length;
        });
        const w = bufferutils_1.BufferWriter.withCapacity(size);
        kpBuf.forEach((buf2) => w.writeSlice(buf2));
        return w.buffer;
      }
      getKeyPairs() {
        const keyPairs = [];
        if (this.nonWitnessUtxo) {
          const key = new key_pair_1.Key(fields_1.InputTypes.NON_WITNESS_UTXO);
          const value2 = this.nonWitnessUtxo.toBuffer();
          keyPairs.push(new key_pair_1.KeyPair(key, value2));
        }
        if (this.witnessUtxo) {
          const key = new key_pair_1.Key(fields_1.InputTypes.WITNESS_UTXO);
          const value2 = serializeOutput(this.witnessUtxo);
          keyPairs.push(new key_pair_1.KeyPair(key, value2));
        }
        if (this.partialSigs && this.partialSigs.length > 0) {
          this.partialSigs.forEach(({ pubkey, signature: signature2 }) => {
            const key = new key_pair_1.Key(fields_1.InputTypes.PARTIAL_SIG, pubkey);
            keyPairs.push(new key_pair_1.KeyPair(key, signature2));
          });
        }
        if (this.sighashType !== void 0) {
          const key = new key_pair_1.Key(fields_1.InputTypes.SIGHASH_TYPE);
          const value2 = import_buffer.Buffer.allocUnsafe(4);
          value2.writeUInt32LE(this.sighashType);
          keyPairs.push(new key_pair_1.KeyPair(key, value2));
        }
        if (this.redeemScript && this.redeemScript.length > 0) {
          const key = new key_pair_1.Key(fields_1.InputTypes.REDEEM_SCRIPT);
          keyPairs.push(new key_pair_1.KeyPair(key, this.redeemScript));
        }
        if (this.witnessScript && this.witnessScript.length > 0) {
          const key = new key_pair_1.Key(fields_1.InputTypes.WITNESS_SCRIPT);
          keyPairs.push(new key_pair_1.KeyPair(key, this.witnessScript));
        }
        if (this.bip32Derivation && this.bip32Derivation.length > 0) {
          this.bip32Derivation.forEach(({ pubkey, masterFingerprint, path }) => {
            const key = new key_pair_1.Key(
              fields_1.InputTypes.BIP32_DERIVATION,
              pubkey
            );
            const value2 = (0, bip32_1.encodeBIP32Derivation)(
              masterFingerprint,
              path
            );
            keyPairs.push(new key_pair_1.KeyPair(key, value2));
          });
        }
        if (this.finalScriptSig && this.finalScriptSig.length > 0) {
          const key = new key_pair_1.Key(fields_1.InputTypes.FINAL_SCRIPTSIG);
          keyPairs.push(new key_pair_1.KeyPair(key, this.finalScriptSig));
        }
        if (this.finalScriptWitness && this.finalScriptWitness.length > 0) {
          const key = new key_pair_1.Key(fields_1.InputTypes.FINAL_SCRIPTWITNESS);
          keyPairs.push(new key_pair_1.KeyPair(key, this.finalScriptWitness));
        }
        if (this.ripemd160Preimages && Object.keys(this.ripemd160Preimages).length > 0) {
          Object.entries(this.ripemd160Preimages).forEach(([k, v]) => {
            const key = new key_pair_1.Key(
              fields_1.InputTypes.RIPEMD_160,
              import_buffer.Buffer.from(k, "hex")
            );
            keyPairs.push(new key_pair_1.KeyPair(key, v));
          });
        }
        if (this.sha256Preimages && Object.keys(this.sha256Preimages).length > 0) {
          Object.entries(this.sha256Preimages).forEach(([k, v]) => {
            const key = new key_pair_1.Key(
              fields_1.InputTypes.SHA_256,
              import_buffer.Buffer.from(k, "hex")
            );
            keyPairs.push(new key_pair_1.KeyPair(key, v));
          });
        }
        if (this.hash160Preimages && Object.keys(this.hash160Preimages).length > 0) {
          Object.entries(this.hash160Preimages).forEach(([k, v]) => {
            const key = new key_pair_1.Key(
              fields_1.InputTypes.HASH_160,
              import_buffer.Buffer.from(k, "hex")
            );
            keyPairs.push(new key_pair_1.KeyPair(key, v));
          });
        }
        if (this.hash256Preimages && Object.keys(this.hash256Preimages).length > 0) {
          Object.entries(this.hash256Preimages).forEach(([k, v]) => {
            const key = new key_pair_1.Key(
              fields_1.InputTypes.HASH_256,
              import_buffer.Buffer.from(k, "hex")
            );
            keyPairs.push(new key_pair_1.KeyPair(key, v));
          });
        }
        const preivousTxidKey = new key_pair_1.Key(
          fields_1.InputTypes.PREVIOUS_TXID
        );
        keyPairs.push(new key_pair_1.KeyPair(preivousTxidKey, this.previousTxid));
        const prevTxIndexKey = new key_pair_1.Key(
          fields_1.InputTypes.PREVIOUS_TXINDEX
        );
        const prevTxIndex = import_buffer.Buffer.allocUnsafe(4);
        prevTxIndex.writeUInt32LE(this.previousTxIndex);
        keyPairs.push(new key_pair_1.KeyPair(prevTxIndexKey, prevTxIndex));
        if (this.sequence !== void 0) {
          const sequenceKey = new key_pair_1.Key(fields_1.InputTypes.SEQUENCE);
          const sequence = import_buffer.Buffer.allocUnsafe(4);
          sequence.writeUInt32LE(this.sequence);
          keyPairs.push(new key_pair_1.KeyPair(sequenceKey, sequence));
        }
        if (this.requiredTimeLocktime !== void 0) {
          const key = new key_pair_1.Key(
            fields_1.InputTypes.REQUIRED_TIME_LOCKTIME
          );
          const value2 = import_buffer.Buffer.allocUnsafe(4);
          value2.writeUInt32LE(this.requiredTimeLocktime);
          keyPairs.push(new key_pair_1.KeyPair(key, value2));
        }
        if (this.requiredHeightLocktime !== void 0) {
          const key = new key_pair_1.Key(
            fields_1.InputTypes.REQUIRED_HEIGHT_LOCKTIME
          );
          const value2 = import_buffer.Buffer.allocUnsafe(4);
          value2.writeUInt32LE(this.requiredHeightLocktime);
          keyPairs.push(new key_pair_1.KeyPair(key, value2));
        }
        if (this.tapKeySig && this.tapKeySig.length > 0) {
          const key = new key_pair_1.Key(fields_1.InputTypes.TAP_KEY_SIG);
          keyPairs.push(new key_pair_1.KeyPair(key, this.tapKeySig));
        }
        if (this.tapScriptSig && this.tapScriptSig.length > 0) {
          this.tapScriptSig.forEach(({ pubkey, signature: signature2, leafHash }) => {
            const keyData = import_buffer.Buffer.concat([pubkey, leafHash]);
            const key = new key_pair_1.Key(
              fields_1.InputTypes.TAP_SCRIPT_SIG,
              keyData
            );
            keyPairs.push(new key_pair_1.KeyPair(key, signature2));
          });
        }
        if (this.tapLeafScript && this.tapLeafScript.length > 0) {
          this.tapLeafScript.forEach(({ leafVersion, script, controlBlock }) => {
            const key = new key_pair_1.Key(
              fields_1.InputTypes.TAP_LEAF_SCRIPT,
              controlBlock
            );
            const value2 = import_buffer.Buffer.concat([script, import_buffer.Buffer.of(leafVersion)]);
            keyPairs.push(new key_pair_1.KeyPair(key, value2));
          });
        }
        if (this.tapBip32Derivation && this.tapBip32Derivation.length > 0) {
          this.tapBip32Derivation.forEach(
            ({ pubkey, masterFingerprint, path, leafHashes }) => {
              const key = new key_pair_1.Key(
                fields_1.InputTypes.TAP_BIP32_DERIVATION,
                pubkey
              );
              const nHashesLen = bufferutils_1.varuint.encodingLength(
                leafHashes.length
              );
              const nHashesBuf = import_buffer.Buffer.allocUnsafe(nHashesLen);
              bufferutils_1.varuint.encode(leafHashes.length, nHashesBuf);
              const value2 = import_buffer.Buffer.concat([
                nHashesBuf,
                ...leafHashes,
                (0, bip32_1.encodeBIP32Derivation)(masterFingerprint, path)
              ]);
              keyPairs.push(new key_pair_1.KeyPair(key, value2));
            }
          );
        }
        if (this.tapInternalKey && this.tapInternalKey.length > 0) {
          const key = new key_pair_1.Key(fields_1.InputTypes.TAP_INTERNAL_KEY);
          keyPairs.push(new key_pair_1.KeyPair(key, this.tapInternalKey));
        }
        if (this.tapMerkleRoot && this.tapMerkleRoot.length > 0) {
          const key = new key_pair_1.Key(fields_1.InputTypes.TAP_MERKLE_ROOT);
          keyPairs.push(new key_pair_1.KeyPair(key, this.tapMerkleRoot));
        }
        if (this.issuanceValue > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.ISSUANCE_VALUE
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          const value2 = import_buffer.Buffer.allocUnsafe(8);
          (0, bufferutils_1.writeUInt64LE)(value2, this.issuanceValue, 0);
          keyPairs.push(new key_pair_1.KeyPair(key, value2));
        }
        if (this.issuanceValueCommitment && this.issuanceValueCommitment.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.ISSUANCE_VALUE_COMMITMENT
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.issuanceValueCommitment));
        }
        if (this.issuanceValueRangeproof && this.issuanceValueRangeproof.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.ISSUANCE_VALUE_RANGEPROOF
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.issuanceValueRangeproof));
        }
        if (this.issuanceInflationKeysRangeproof && this.issuanceInflationKeysRangeproof.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.ISSUANCE_INFLATION_KEYS_RANGEPROOF
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          keyPairs.push(
            new key_pair_1.KeyPair(key, this.issuanceInflationKeysRangeproof)
          );
        }
        if (this.peginTx) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.PEGIN_TX
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.peginTx.toBuffer()));
        }
        if (this.peginTxoutProof && this.peginTxoutProof.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.PEGIN_TXOUT_PROOF
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.peginTxoutProof));
        }
        if (this.peginGenesisHash && this.peginGenesisHash.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.PEGIN_GENESIS_HASH
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.peginGenesisHash));
        }
        if (this.peginClaimScript && this.peginClaimScript.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.PEGIN_CLAIM_SCRIPT
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.peginClaimScript));
        }
        if (this.peginValue > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.PEGIN_VALUE
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          const value2 = import_buffer.Buffer.allocUnsafe(8);
          (0, bufferutils_1.writeUInt64LE)(value2, this.peginValue, 0);
          keyPairs.push(new key_pair_1.KeyPair(key, value2));
        }
        if (this.peginWitness && this.peginWitness.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.PEGIN_WITNESS
          );
          const w = new bufferutils_1.BufferWriter(import_buffer.Buffer.allocUnsafe(0));
          w.writeVector(this.peginWitness);
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, w.buffer));
        }
        if (this.issuanceInflationKeys > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.ISSUANCE_INFLATION_KEYS
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          const value2 = import_buffer.Buffer.allocUnsafe(8);
          (0, bufferutils_1.writeUInt64LE)(value2, this.issuanceInflationKeys, 0);
          keyPairs.push(new key_pair_1.KeyPair(key, value2));
        }
        if (this.issuanceInflationKeysCommitment && this.issuanceInflationKeysCommitment.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.ISSUANCE_INFLATION_KEYS_COMMITMENT
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          keyPairs.push(
            new key_pair_1.KeyPair(key, this.issuanceInflationKeysCommitment)
          );
        }
        if (this.issuanceBlindingNonce && this.issuanceBlindingNonce.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.ISSUANCE_BLINDING_NONCE
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.issuanceBlindingNonce));
        }
        if (this.issuanceAssetEntropy && this.issuanceAssetEntropy.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.ISSUANCE_ASSET_ENTROPY
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.issuanceAssetEntropy));
        }
        if (this.utxoRangeProof && this.utxoRangeProof.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.UTXO_RANGEPROOF
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.utxoRangeProof));
        }
        if (this.issuanceBlindValueProof && this.issuanceBlindValueProof.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.ISSUANCE_BLIND_VALUE_PROOF
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.issuanceBlindValueProof));
        }
        if (this.issuanceBlindInflationKeysProof && this.issuanceBlindInflationKeysProof.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.ISSUANCE_BLIND_INFLATION_KEYS_PROOF
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          keyPairs.push(
            new key_pair_1.KeyPair(key, this.issuanceBlindInflationKeysProof)
          );
        }
        if (this.explicitValue && this.explicitValue >= 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.EXPLICIT_VALUE
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          const value2 = import_buffer.Buffer.allocUnsafe(8);
          (0, bufferutils_1.writeUInt64LE)(value2, this.explicitValue, 0);
          keyPairs.push(new key_pair_1.KeyPair(key, value2));
        }
        if (this.explicitValueProof && this.explicitValueProof.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.VALUE_PROOF
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.explicitValueProof));
        }
        if (this.explicitAsset && this.explicitAsset.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.EXPLICIT_ASSET
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.explicitAsset));
        }
        if (this.explicitAssetProof && this.explicitAssetProof.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.ASSET_PROOF
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.explicitAssetProof));
        }
        if (this.blindedIssuance !== void 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.InputProprietaryTypes.BLINDED_ISSUANCE
          );
          const key = new key_pair_1.Key(fields_1.InputTypes.PROPRIETARY, keyData);
          const value2 = import_buffer.Buffer.of(this.blindedIssuance ? 1 : 0);
          keyPairs.push(new key_pair_1.KeyPair(key, value2));
        }
        if (this.proprietaryData && this.proprietaryData.length > 0) {
          this.proprietaryData.forEach((data) => {
            const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
              data.subType,
              data.keyData
            );
            const key = new key_pair_1.Key(
              fields_1.InputTypes.PROPRIETARY,
              keyData
            );
            keyPairs.push(new key_pair_1.KeyPair(key, data.value));
          });
        }
        keyPairs.concat(this.unknowns || []);
        return keyPairs;
      }
    };
    exports2.PsetInput = PsetInput;
    function serializeOutput(out) {
      const size = out.asset.length + out.value.length + bufferutils_1.varuint.encodingLength(out.script.length) + out.script.length + out.nonce.length;
      const buf2 = import_buffer.Buffer.allocUnsafe(size);
      const w = new bufferutils_1.BufferWriter(buf2, 0);
      w.writeSlice(out.asset);
      w.writeSlice(out.value);
      w.writeSlice(out.nonce);
      w.writeVarSlice(out.script);
      return buf2;
    }
    function deserializeOutput(buf2) {
      if (buf2.length < 45) {
        throw new Error("Invalid input witness utxo length");
      }
      const r = new bufferutils_1.BufferReader(buf2);
      const asset = r.readSlice(33);
      const value2 = r.readConfidentialValue();
      const nonce = r.readConfidentialNonce();
      const script = r.readVarSlice();
      return { asset, value: value2, nonce, script };
    }
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/output.js
var require_output = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/output.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PsetOutput = exports2.OutputDuplicateFieldError = void 0;
    var bufferutils_1 = require_bufferutils();
    var bip32_1 = require_bip32();
    var fields_1 = require_fields();
    var key_pair_1 = require_key_pair();
    var proprietary_data_1 = require_proprietary_data();
    var pset_1 = require_pset();
    var utils_1 = require_utils7();
    var OutputDuplicateFieldError = class extends Error {
      constructor(message) {
        if (message) {
          message = "Duplicated output " + message;
        }
        super(message);
      }
    };
    exports2.OutputDuplicateFieldError = OutputDuplicateFieldError;
    var PsetOutput = class _PsetOutput {
      constructor(value2, asset, script) {
        this.value = value2 || 0;
        this.asset = asset || import_buffer.Buffer.from([]);
        this.script = script;
      }
      static fromBuffer(r) {
        let kp;
        const output = new _PsetOutput();
        while (true) {
          try {
            kp = key_pair_1.KeyPair.fromBuffer(r);
          } catch (e) {
            if (e instanceof Error && e === key_pair_1.ErrEmptyKey) {
              output.sanityCheck();
              return output;
            }
            throw e;
          }
          switch (kp.key.keyType) {
            case fields_1.OutputTypes.REDEEM_SCRIPT:
              if (output.redeemScript && output.redeemScript.length > 0) {
                throw new OutputDuplicateFieldError("redeem script");
              }
              output.redeemScript = kp.value;
              break;
            case fields_1.OutputTypes.WITNESS_SCRIPT:
              if (output.witnessScript && output.witnessScript.length > 0) {
                throw new OutputDuplicateFieldError("witness script");
              }
              output.witnessScript = kp.value;
              break;
            case fields_1.OutputTypes.BIP32_DERIVATION:
              const pubkey = kp.key.keyData;
              if (pubkey.length !== 33) {
                throw new Error("Invalid output bip32 pubkey length");
              }
              if (!output.bip32Derivation) {
                output.bip32Derivation = [];
              }
              if (output.bip32Derivation.find((d) => d.pubkey.equals(pubkey))) {
                throw new OutputDuplicateFieldError("bip32 derivation");
              }
              const { masterFingerprint, path } = (0, bip32_1.decodeBip32Derivation)(kp.value);
              output.bip32Derivation.push({ pubkey, masterFingerprint, path });
              break;
            case fields_1.OutputTypes.AMOUNT:
              if (output.value > 0) {
                throw new OutputDuplicateFieldError("value");
              }
              if (kp.value.length !== 8) {
                throw new Error("Invalid output amount length");
              }
              output.value = (0, bufferutils_1.readUInt64LE)(kp.value, 0);
              break;
            case fields_1.OutputTypes.SCRIPT:
              if (output.script && output.script.length > 0) {
                throw new OutputDuplicateFieldError("script");
              }
              output.script = kp.value;
              break;
            case fields_1.OutputTypes.TAP_BIP32_DERIVATION:
              const tapKey = kp.key.keyData;
              if (tapKey.length !== 33) {
                throw new Error("Invalid output bip32 derivation pubkey length");
              }
              if (!output.tapBip32Derivation) {
                output.tapBip32Derivation = [];
              }
              const tapBip32Pubkey = kp.key.keyData;
              if (output.tapBip32Derivation.find(
                (d) => d.pubkey.equals(tapBip32Pubkey)
              )) {
                throw new OutputDuplicateFieldError("taproot bip32 derivation");
              }
              const nHashes = bufferutils_1.varuint.decode(kp.value);
              const nHashesLen = bufferutils_1.varuint.encodingLength(nHashes);
              const bip32Deriv = (0, bip32_1.decodeBip32Derivation)(
                kp.value.slice(nHashesLen + nHashes * 32)
              );
              const leafHashes = new Array(nHashes);
              for (let i = 0, _ofs = nHashesLen; i < nHashes; i++, _ofs += 32) {
                leafHashes[i] = kp.value.slice(_ofs, _ofs + 32);
              }
              output.tapBip32Derivation.push({
                pubkey: tapBip32Pubkey,
                masterFingerprint: bip32Deriv.masterFingerprint,
                path: bip32Deriv.path,
                leafHashes
              });
              break;
            case fields_1.OutputTypes.TAP_TREE:
              if (output.tapTree) {
                throw new OutputDuplicateFieldError("taproot tree");
              }
              let _offset = 0;
              const leaves = [];
              while (_offset < kp.value.length) {
                const depth = kp.value[_offset++];
                const leafVersion = kp.value[_offset++];
                const scriptLen = bufferutils_1.varuint.decode(kp.value, _offset);
                _offset += bufferutils_1.varuint.encodingLength(scriptLen);
                leaves.push({
                  depth,
                  leafVersion,
                  script: kp.value.slice(_offset, _offset + scriptLen)
                });
                _offset += scriptLen;
              }
              output.tapTree = { leaves };
              break;
            case fields_1.OutputTypes.TAP_INTERNAL_KEY:
              if (output.tapInternalKey && output.tapInternalKey.length > 0) {
                throw new OutputDuplicateFieldError("taproot internal key");
              }
              if (kp.value.length !== 32) {
                throw new Error("Invalid output taproot internal key length");
              }
              output.tapInternalKey = kp.value;
              break;
            case fields_1.OutputTypes.PROPRIETARY:
              const data = proprietary_data_1.ProprietaryData.fromKeyPair(kp);
              if (import_buffer.Buffer.compare(data.identifier, pset_1.magicPrefix) === 0) {
                switch (data.subType) {
                  case fields_1.OutputProprietaryTypes.VALUE_COMMITMENT:
                    if (output.valueCommitment && output.valueCommitment.length > 0) {
                      throw new OutputDuplicateFieldError("value commitment");
                    }
                    if (kp.value.length !== 33) {
                      throw new Error("Invalid output value commitment length");
                    }
                    output.valueCommitment = kp.value;
                    break;
                  case fields_1.OutputProprietaryTypes.ASSET:
                    if (output.asset && output.asset.length > 0) {
                      throw new OutputDuplicateFieldError("asset");
                    }
                    if (kp.value.length !== 32) {
                      throw new Error("Invalid output asset length");
                    }
                    output.asset = kp.value;
                    break;
                  case fields_1.OutputProprietaryTypes.ASSET_COMMITMENT:
                    if (output.assetCommitment && output.assetCommitment.length > 0) {
                      throw new OutputDuplicateFieldError("asset commitment");
                    }
                    if (kp.value.length !== 33) {
                      throw new Error("Invalid output asset commitment length");
                    }
                    output.assetCommitment = kp.value;
                    break;
                  case fields_1.OutputProprietaryTypes.VALUE_RANGEPROOF:
                    if (output.valueRangeproof && output.valueRangeproof.length > 0) {
                      throw new OutputDuplicateFieldError("value range proof");
                    }
                    output.valueRangeproof = kp.value;
                    break;
                  case fields_1.OutputProprietaryTypes.ASSET_SURJECTION_PROOF:
                    if (output.assetSurjectionProof && output.assetSurjectionProof.length > 0) {
                      throw new OutputDuplicateFieldError("asset surjection proof");
                    }
                    output.assetSurjectionProof = kp.value;
                    break;
                  case fields_1.OutputProprietaryTypes.BLINDING_PUBKEY:
                    if (output.blindingPubkey && output.blindingPubkey.length > 0) {
                      throw new OutputDuplicateFieldError("blinding pubkey");
                    }
                    if (kp.value.length !== 33) {
                      throw new Error("Invalid output blinding pubkey length");
                    }
                    output.blindingPubkey = kp.value;
                    break;
                  case fields_1.OutputProprietaryTypes.ECDH_PUBKEY:
                    if (output.ecdhPubkey && output.ecdhPubkey.length > 0) {
                      throw new OutputDuplicateFieldError("ecdh pubkey");
                    }
                    if (kp.value.length !== 33) {
                      throw new Error("Invalid output ecdh pubkey length");
                    }
                    output.ecdhPubkey = kp.value;
                    break;
                  case fields_1.OutputProprietaryTypes.BLINDER_INDEX:
                    if (output.blinderIndex !== void 0) {
                      throw new OutputDuplicateFieldError("blinder index");
                    }
                    if (kp.value.length !== 4) {
                      throw new Error("Invalid output blinder index length");
                    }
                    output.blinderIndex = kp.value.readUInt32LE();
                    break;
                  case fields_1.OutputProprietaryTypes.BLIND_VALUE_PROOF:
                    if (output.blindValueProof && output.blindValueProof.length > 0) {
                      throw new OutputDuplicateFieldError("blind value proof");
                    }
                    output.blindValueProof = kp.value;
                    break;
                  case fields_1.OutputProprietaryTypes.BLIND_ASSET_PROOF:
                    if (output.blindAssetProof && output.blindAssetProof.length > 0) {
                      throw new OutputDuplicateFieldError("blind asset proof");
                    }
                    output.blindAssetProof = kp.value;
                    break;
                  default:
                    if (!output.proprietaryData) {
                      output.proprietaryData = [];
                    }
                    output.proprietaryData.push(data);
                }
              }
              break;
            default:
              if (!output.unknowns) {
                output.unknowns = [];
              }
              output.unknowns.push(kp);
              break;
          }
        }
      }
      sanityCheck() {
        const valueCommitSet = this.valueCommitment && this.valueCommitment.length > 0;
        const blindValueProofSet = this.blindValueProof && this.blindValueProof.length > 0;
        if (this.value > 0 && valueCommitSet !== blindValueProofSet) {
          throw new Error("Missing output value commitment or blind proof");
        }
        const assetCommitSet = this.assetCommitment && this.assetCommitment.length > 0;
        const blindAssetProofSet = this.blindAssetProof && this.blindAssetProof.length > 0;
        if (!assetCommitSet && (!this.asset || this.asset.length === 0)) {
          throw new Error("Missing output asset");
        }
        if (this.asset && this.asset.length > 0 && assetCommitSet !== blindAssetProofSet) {
          throw new Error("Missing output asset commitment or blind proof");
        }
        if (this.isPartiallyBlinded() && !this.isFullyBlinded()) {
          throw new Error(
            "Output is partially blinded while it must be either unblinded or fully blinded"
          );
        }
        if (this.isFullyBlinded() && this.blinderIndex > 0) {
          throw new Error("Blinder index must be unset for fully blinded output");
        }
        return this;
      }
      needsBlinding() {
        return this.blindingPubkey && this.blindingPubkey.length > 0;
      }
      isPartiallyBlinded() {
        return this.valueCommitment && this.valueCommitment.length > 0 || this.assetCommitment && this.assetCommitment.length > 0 || this.valueRangeproof && this.valueRangeproof.length > 0 || this.assetSurjectionProof && this.assetSurjectionProof.length > 0 || this.ecdhPubkey && this.ecdhPubkey.length > 0;
      }
      isFullyBlinded() {
        return this.valueCommitment && this.valueCommitment.length > 0 && this.assetCommitment && this.assetCommitment.length > 0 && this.valueRangeproof && this.valueRangeproof.length > 0 && (this.assetSurjectionProof && this.assetSurjectionProof.length) > 0 && this.ecdhPubkey && this.ecdhPubkey.length > 0;
      }
      isTaproot() {
        return !!(this.tapInternalKey || this.tapTree || this.tapBip32Derivation && this.tapBip32Derivation.length || this.script && (0, utils_1.isP2TR)(this.script));
      }
      toBuffer() {
        const keyPairs = this.getKeyPairs();
        const kpBuf = keyPairs.map((kp) => kp.toBuffer());
        let size = 0;
        kpBuf.forEach((buf2) => {
          size += buf2.length;
        });
        const w = bufferutils_1.BufferWriter.withCapacity(size);
        kpBuf.forEach((buf2) => w.writeSlice(buf2));
        return w.buffer;
      }
      getKeyPairs() {
        const keyPairs = [];
        if (this.redeemScript && this.redeemScript.length > 0) {
          const key = new key_pair_1.Key(fields_1.OutputTypes.REDEEM_SCRIPT);
          keyPairs.push(new key_pair_1.KeyPair(key, this.redeemScript));
        }
        if (this.witnessScript && this.witnessScript.length > 0) {
          const key = new key_pair_1.Key(fields_1.OutputTypes.WITNESS_SCRIPT);
          keyPairs.push(new key_pair_1.KeyPair(key, this.witnessScript));
        }
        if (this.bip32Derivation && this.bip32Derivation.length > 0) {
          this.bip32Derivation.forEach(({ pubkey, masterFingerprint, path }) => {
            const key = new key_pair_1.Key(
              fields_1.OutputTypes.BIP32_DERIVATION,
              pubkey
            );
            const value2 = (0, bip32_1.encodeBIP32Derivation)(
              masterFingerprint,
              path
            );
            keyPairs.push(new key_pair_1.KeyPair(key, value2));
          });
        }
        if (this.tapBip32Derivation && this.tapBip32Derivation.length > 0) {
          this.tapBip32Derivation.forEach(
            ({ pubkey, masterFingerprint, path, leafHashes }) => {
              const key = new key_pair_1.Key(
                fields_1.OutputTypes.TAP_BIP32_DERIVATION,
                pubkey
              );
              const nHashesLen = bufferutils_1.varuint.encodingLength(
                leafHashes.length
              );
              const nHashesBuf = import_buffer.Buffer.allocUnsafe(nHashesLen);
              bufferutils_1.varuint.encode(leafHashes.length, nHashesBuf);
              const value2 = import_buffer.Buffer.concat([
                nHashesBuf,
                ...leafHashes,
                (0, bip32_1.encodeBIP32Derivation)(masterFingerprint, path)
              ]);
              keyPairs.push(new key_pair_1.KeyPair(key, value2));
            }
          );
        }
        if (this.tapTree) {
          const key = new key_pair_1.Key(fields_1.OutputTypes.TAP_TREE);
          const bufs = [].concat(
            ...this.tapTree.leaves.map((tapLeaf) => [
              import_buffer.Buffer.of(tapLeaf.depth, tapLeaf.leafVersion),
              bufferutils_1.varuint.encode(tapLeaf.script.length),
              tapLeaf.script
            ])
          );
          const value2 = import_buffer.Buffer.concat(bufs);
          keyPairs.push(new key_pair_1.KeyPair(key, value2));
        }
        if (this.tapInternalKey && this.tapInternalKey.length > 0) {
          const key = new key_pair_1.Key(fields_1.OutputTypes.TAP_INTERNAL_KEY);
          keyPairs.push(new key_pair_1.KeyPair(key, this.tapInternalKey));
        }
        const amountKey = new key_pair_1.Key(fields_1.OutputTypes.AMOUNT);
        const amount = import_buffer.Buffer.allocUnsafe(8);
        (0, bufferutils_1.writeUInt64LE)(amount, this.value, 0);
        keyPairs.push(new key_pair_1.KeyPair(amountKey, amount));
        const scriptKey = new key_pair_1.Key(fields_1.OutputTypes.SCRIPT);
        keyPairs.push(
          new key_pair_1.KeyPair(scriptKey, this.script || import_buffer.Buffer.alloc(0))
        );
        if (this.valueCommitment && this.valueCommitment.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.OutputProprietaryTypes.VALUE_COMMITMENT
          );
          const key = new key_pair_1.Key(fields_1.OutputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.valueCommitment));
        }
        if (this.assetCommitment && this.assetCommitment.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.OutputProprietaryTypes.ASSET_COMMITMENT
          );
          const key = new key_pair_1.Key(fields_1.OutputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.assetCommitment));
        }
        if (this.asset && this.asset.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.OutputProprietaryTypes.ASSET
          );
          const key = new key_pair_1.Key(fields_1.OutputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.asset));
        }
        if (this.valueRangeproof && this.valueRangeproof.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.OutputProprietaryTypes.VALUE_RANGEPROOF
          );
          const key = new key_pair_1.Key(fields_1.OutputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.valueRangeproof));
        }
        if (this.assetSurjectionProof && this.assetSurjectionProof.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.OutputProprietaryTypes.ASSET_SURJECTION_PROOF
          );
          const key = new key_pair_1.Key(fields_1.OutputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.assetSurjectionProof));
        }
        if (this.blindingPubkey && this.blindingPubkey.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.OutputProprietaryTypes.BLINDING_PUBKEY
          );
          const key = new key_pair_1.Key(fields_1.OutputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.blindingPubkey));
        }
        if (this.ecdhPubkey && this.ecdhPubkey.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.OutputProprietaryTypes.ECDH_PUBKEY
          );
          const key = new key_pair_1.Key(fields_1.OutputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.ecdhPubkey));
        }
        const proprietaryKeyData = proprietary_data_1.ProprietaryData.proprietaryKey(
          fields_1.OutputProprietaryTypes.BLINDER_INDEX
        );
        const blinderIndexKey = new key_pair_1.Key(
          fields_1.OutputTypes.PROPRIETARY,
          proprietaryKeyData
        );
        const blinderIndex = import_buffer.Buffer.allocUnsafe(4);
        let bi = 0;
        if (this.blinderIndex > 0) {
          bi = this.blinderIndex;
        }
        blinderIndex.writeUInt32LE(bi);
        keyPairs.push(new key_pair_1.KeyPair(blinderIndexKey, blinderIndex));
        if (this.blindValueProof && this.blindValueProof.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.OutputProprietaryTypes.BLIND_VALUE_PROOF
          );
          const key = new key_pair_1.Key(fields_1.OutputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.blindValueProof));
        }
        if (this.blindAssetProof && this.blindAssetProof.length > 0) {
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.OutputProprietaryTypes.BLIND_ASSET_PROOF
          );
          const key = new key_pair_1.Key(fields_1.OutputTypes.PROPRIETARY, keyData);
          keyPairs.push(new key_pair_1.KeyPair(key, this.blindAssetProof));
        }
        if (this.proprietaryData && this.proprietaryData.length > 0) {
          this.proprietaryData.forEach((data) => {
            const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
              data.subType,
              data.keyData
            );
            const key = new key_pair_1.Key(
              fields_1.OutputTypes.PROPRIETARY,
              keyData
            );
            keyPairs.push(new key_pair_1.KeyPair(key, data.value));
          });
        }
        keyPairs.concat(this.unknowns || []);
        return keyPairs;
      }
    };
    exports2.PsetOutput = PsetOutput;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/pset.js
var require_pset = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/pset.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Pset = exports2.magicPrefixWithSeparator = exports2.magicPrefix = void 0;
    var bufferutils_1 = require_bufferutils();
    var crypto_1 = require_crypto();
    var transaction_1 = require_transaction();
    var fields_1 = require_fields();
    var globals_1 = require_globals();
    var input_1 = require_input();
    var output_1 = require_output();
    var bscript = __importStar(require_script());
    var address_1 = require_address();
    var payments_1 = require_payments();
    var value_1 = require_value();
    var asset_1 = require_asset();
    var utils_1 = require_utils7();
    exports2.magicPrefix = import_buffer.Buffer.from([112, 115, 101, 116]);
    exports2.magicPrefixWithSeparator = import_buffer.Buffer.concat([
      exports2.magicPrefix,
      import_buffer.Buffer.of(255)
    ]);
    var Pset2 = class _Pset {
      constructor(globals3, inputs2, outputs2) {
        this.inputs = inputs2 || [];
        this.outputs = outputs2 || [];
        this.globals = globals3 || new globals_1.PsetGlobal();
      }
      static fromBase64(data) {
        const buf2 = import_buffer.Buffer.from(data, "base64");
        return this.fromBuffer(buf2);
      }
      static fromBuffer(buf2) {
        const r = new bufferutils_1.BufferReader(buf2);
        const magic = r.readSlice(exports2.magicPrefixWithSeparator.length);
        if (!magic.equals(exports2.magicPrefixWithSeparator)) {
          throw new Error("invalid magic prefix");
        }
        const globals3 = globals_1.PsetGlobal.fromBuffer(r);
        const inputs2 = [];
        for (let i = 0; i < globals3.inputCount; i++) {
          const input = input_1.PsetInput.fromBuffer(r);
          inputs2.push(input);
        }
        const outputs2 = [];
        for (let i = 0; i < globals3.outputCount; i++) {
          const output = output_1.PsetOutput.fromBuffer(r);
          outputs2.push(output);
        }
        const pset = new _Pset(globals3, inputs2, outputs2);
        pset.sanityCheck();
        return pset;
      }
      static ECCKeysGenerator(ecc2) {
        return (opts) => {
          const privateKey = (0, utils_1.randomBytes)(opts);
          const publicKey = ecc2.pointFromScalar(privateKey);
          if (!publicKey) throw new Error("Failed to generate public key");
          return {
            privateKey,
            publicKey: import_buffer.Buffer.from(publicKey)
          };
        };
      }
      static ECDSASigValidator(ecc2) {
        return (pubkey, msghash, signature2) => {
          return ecc2.verify(msghash, pubkey, signature2);
        };
      }
      static SchnorrSigValidator(ecc2) {
        return (pubkey, msghash, signature2) => ecc2.verifySchnorr(msghash, pubkey, signature2.slice(0, 64));
      }
      sanityCheck() {
        this.globals.sanityCheck();
        this.inputs.forEach((input) => input.sanityCheck());
        this.outputs.forEach((output) => output.sanityCheck());
        if (this.isFullyBlinded() && this.globals.scalars && this.globals.scalars.length > 0) {
          throw new Error("global scalars must be empty for fully blinded pset");
        }
        return this;
      }
      copy() {
        return new _Pset(this.globals, this.inputs, this.outputs);
      }
      inputsModifiable() {
        if (!this.globals.txModifiable) {
          return true;
        }
        return this.globals.txModifiable.get(0) === 1;
      }
      outputsModifiable() {
        if (!this.globals.txModifiable) {
          return true;
        }
        return this.globals.txModifiable.get(1) === 1;
      }
      hasSighashSingle() {
        if (!this.globals.txModifiable) {
          return false;
        }
        return this.globals.txModifiable.get(2) === 1;
      }
      needsBlinding() {
        return this.outputs.some(
          (out) => out.needsBlinding() && !out.isFullyBlinded()
        );
      }
      isFullyBlinded() {
        if (!this.needsBlinding()) {
          return false;
        }
        return !this.outputs.some(
          (out) => out.needsBlinding() && !out.isFullyBlinded()
        );
      }
      isComplete() {
        return this.inputs.every((input) => input.isFinalized());
      }
      locktime() {
        let heightLocktime = 0;
        let timeLocktime = 0;
        this.inputs.forEach((input) => {
          if (input.requiredTimeLocktime > 0) {
            if (input.requiredTimeLocktime > timeLocktime) {
              timeLocktime = input.requiredTimeLocktime;
            }
          }
          if (input.requiredHeightLocktime > 0) {
            if (input.requiredHeightLocktime > heightLocktime) {
              heightLocktime = input.requiredHeightLocktime;
            }
          }
        });
        if (heightLocktime > 0) {
          return heightLocktime;
        }
        if (timeLocktime > 0) {
          return timeLocktime;
        }
        return this.globals.fallbackLocktime || 0;
      }
      unsignedTx() {
        const tx = new transaction_1.Transaction();
        tx.version = this.globals.txVersion;
        tx.locktime = this.locktime();
        this.inputs.forEach((input) => {
          let issuance;
          if (input.hasIssuance() || input.hasReissuance()) {
            let assetAmount = input.issuanceValueCommitment;
            if (!assetAmount || assetAmount.length === 0) {
              assetAmount = value_1.ElementsValue.fromNumber(
                input.issuanceValue
              ).bytes;
            }
            let tokenAmount = input.issuanceInflationKeysCommitment;
            if (!tokenAmount || tokenAmount.length === 0) {
              tokenAmount = !input.issuanceInflationKeys ? import_buffer.Buffer.of(0) : value_1.ElementsValue.fromNumber(input.issuanceInflationKeys).bytes;
            }
            const assetEntropy = input.issuanceAssetEntropy;
            const assetBlindingNonce = input.issuanceBlindingNonce;
            issuance = {
              assetEntropy,
              assetAmount,
              tokenAmount,
              assetBlindingNonce
            };
          }
          tx.addInput(
            input.previousTxid,
            input.previousTxIndex,
            input.sequence,
            void 0,
            issuance
          );
        });
        this.outputs.forEach((output) => {
          const value2 = output.valueCommitment || value_1.ElementsValue.fromNumber(output.value).bytes;
          const asset = output.assetCommitment || asset_1.AssetHash.fromBytes(output.asset).bytes;
          const script = output.script || import_buffer.Buffer.from([]);
          const nonce = output.ecdhPubkey || import_buffer.Buffer.of(0);
          tx.addOutput(
            script,
            value2,
            asset,
            nonce,
            output.valueRangeproof,
            output.assetSurjectionProof
          );
        });
        return tx;
      }
      validateAllSignatures(validator) {
        return this.inputs.every(
          (_, i) => this.validateInputSignatures(i, validator)
        );
      }
      addInput(newInput) {
        newInput.sanityCheck();
        if (this.isDuplicatedInput(newInput)) {
          throw new Error("given input already exists in pset");
        }
        if (!this.inputsModifiable()) {
          throw new Error("pset is locked for updates on inputs");
        }
        if (newInput.requiredHeightLocktime > 0 || newInput.requiredTimeLocktime > 0) {
          const oldLocktime = this.locktime();
          let timeLocktime = newInput.requiredTimeLocktime;
          let heightLocktime = newInput.requiredHeightLocktime;
          let hasSigs = false;
          this.inputs.forEach((input) => {
            if (input.requiredTimeLocktime > 0 && !input.requiredHeightLocktime) {
              heightLocktime = 0;
              if (timeLocktime === 0) {
                throw new Error("invalid input locktime");
              }
            }
            if (!input.requiredTimeLocktime && input.requiredHeightLocktime > 0) {
              timeLocktime = 0;
              if (heightLocktime === 0) {
                throw new Error("invalid input locktime");
              }
            }
            if (input.requiredTimeLocktime > 0 && timeLocktime > 0) {
              timeLocktime = Math.max(timeLocktime, input.requiredTimeLocktime);
            }
            if (input.requiredHeightLocktime > 0 && heightLocktime > 0) {
              heightLocktime = Math.max(
                heightLocktime,
                input.requiredHeightLocktime
              );
            }
            if ((input.partialSigs ?? []).length > 0) {
              hasSigs = true;
            }
          });
          let newLocktime = this.globals.fallbackLocktime;
          if (timeLocktime > 0) {
            newLocktime = timeLocktime;
          }
          if (heightLocktime > 0) {
            newLocktime = heightLocktime;
          }
          if (hasSigs && oldLocktime !== newLocktime) {
            throw new Error("invalid input locktime");
          }
        }
        this.inputs.push(newInput);
        this.globals.inputCount++;
        return this;
      }
      addOutput(newOutput) {
        newOutput.sanityCheck();
        if (!this.outputsModifiable()) {
          throw new Error("pset is locked for updates on outputs");
        }
        this.outputs.push(newOutput);
        this.globals.outputCount++;
        return this;
      }
      validateInputSignatures(index, validator) {
        if (index < 0 || index >= this.globals.inputCount) {
          throw new Error("input index out of range");
        }
        const input = this.inputs[index];
        if (!input.partialSigs || input.partialSigs.length === 0) {
          return false;
        }
        return input.partialSigs.every(
          (ps) => this.validatePartialSignature(index, validator, ps)
        );
      }
      validatePartialSignature(index, validator, ps) {
        if (index < 0 || index >= this.globals.inputCount) {
          throw new Error("input index out of range");
        }
        const input = this.inputs[index];
        if (!input.partialSigs || input.partialSigs.length === 0) {
          return false;
        }
        const prevout = input.getUtxo();
        if (!prevout) {
          throw new Error("missing input (non-)witness utxo");
        }
        const sighashType = ps.signature[ps.signature.length - 1];
        const preimage = this.getInputPreimage(index, sighashType);
        const script = input.witnessScript || input.redeemScript || prevout.script;
        checkScriptForPubkey(ps.pubkey, script, "verify");
        const { signature: signature2 } = bscript.signature.decode(ps.signature);
        return validator(ps.pubkey, preimage, signature2);
      }
      getInputPreimage(index, sighashType, genesisBlockHash, leafHash) {
        if (index < 0 || index >= this.globals.inputCount) {
          throw new Error("input index out of range");
        }
        const input = this.inputs[index];
        const prevout = input.getUtxo();
        if (!prevout) {
          throw new Error("missing input (non-)witness utxo");
        }
        const unsignedTx = this.unsignedTx();
        if (input.isTaproot()) {
          if (!genesisBlockHash || genesisBlockHash.length !== 32) {
            throw new Error("Missing or invalid genesis block hash");
          }
          const prevoutScripts = [];
          const prevoutAssetsValues = [];
          this.inputs.forEach((v, i) => {
            const u = v.getUtxo();
            if (!u) throw new Error(`Missing input ${i} (non-)witness utxo`);
            prevoutScripts.push(u.script);
            prevoutAssetsValues.push({
              asset: u.asset,
              value: u.value
            });
          });
          return unsignedTx.hashForWitnessV1(
            index,
            prevoutScripts,
            prevoutAssetsValues,
            sighashType,
            genesisBlockHash,
            leafHash
          );
        }
        const script = input.redeemScript || prevout.script;
        const scriptType = (0, address_1.getScriptType)(script);
        switch (scriptType) {
          case address_1.ScriptType.P2Pkh:
          case address_1.ScriptType.P2Sh:
            return unsignedTx.hashForSignature(index, script, sighashType);
          case address_1.ScriptType.P2Wpkh:
            const legacyScript = (0, payments_1.p2pkh)({
              hash: prevout.script.slice(2)
            }).output;
            return unsignedTx.hashForWitnessV0(
              index,
              legacyScript,
              prevout.value,
              sighashType
            );
          case address_1.ScriptType.P2Wsh:
            if (!input.witnessScript || input.witnessScript.length === 0) {
              throw new Error("missing witness script for p2wsh input");
            }
            return unsignedTx.hashForWitnessV0(
              index,
              input.witnessScript,
              prevout.value,
              sighashType
            );
          default:
            throw new Error("unknown input (non-)witness utxo script type");
        }
      }
      toBase64() {
        const buffer2 = this.toBuffer();
        return buffer2.toString("base64");
      }
      toBuffer() {
        let size = exports2.magicPrefixWithSeparator.length;
        const globalsBuffer = this.globals.toBuffer();
        size += globalsBuffer.length + 1;
        const inputBuffers = this.inputs.map((input) => input.toBuffer());
        inputBuffers.forEach((buf2) => size += buf2.length + 1);
        const outputBuffers = this.outputs.map((output) => output.toBuffer());
        outputBuffers.forEach((buf2) => size += buf2.length + 1);
        const w = bufferutils_1.BufferWriter.withCapacity(size);
        w.writeSlice(exports2.magicPrefixWithSeparator);
        w.writeSlice(globalsBuffer);
        w.writeUInt8(fields_1.separator);
        inputBuffers.forEach((buf2) => {
          w.writeSlice(buf2);
          w.writeUInt8(fields_1.separator);
        });
        outputBuffers.forEach((buf2) => {
          w.writeSlice(buf2);
          w.writeUInt8(fields_1.separator);
        });
        return w.buffer;
      }
      isDuplicatedInput(input) {
        return this.inputs.some(
          (inp) => inp.previousTxid.equals(input.previousTxid) && inp.previousTxIndex === input.previousTxIndex
        );
      }
    };
    exports2.Pset = Pset2;
    function checkScriptForPubkey(pubkey, script, action) {
      if (!pubkeyInScript2(pubkey, script)) {
        throw new Error(
          `Cannot ${action} for this input with the key ${pubkey.toString("hex")}`
        );
      }
    }
    function pubkeyInScript2(pubkey, script) {
      const pubkeyHash = (0, crypto_1.hash160)(pubkey);
      const decompiled = bscript.decompile(script);
      if (decompiled === null) throw new Error("Unknown script error");
      return decompiled.some((element) => {
        if (typeof element === "number") return false;
        return element.equals(pubkey) || element.equals(pubkeyHash);
      });
    }
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/proprietary_data.js
var require_proprietary_data = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/proprietary_data.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProprietaryData = void 0;
    var bufferutils_1 = require_bufferutils();
    var pset_1 = require_pset();
    var ProprietaryData = class _ProprietaryData {
      constructor(id, subType, keyData, value2) {
        this.identifier = id;
        this.subType = subType;
        this.keyData = keyData;
        this.value = value2;
      }
      static fromKeyPair(keyPair) {
        if (keyPair.key.keyType !== 252) {
          throw new Error("invalid proprietary data key type");
        }
        const r = new bufferutils_1.BufferReader(keyPair.key.keyData);
        const kpSize = keyPair.key.keyData.length;
        let readBytes = r.offset;
        const identifier = r.readVarSlice();
        if (identifier.length === 0) {
          throw new Error("invalid proprietary data identifier");
        }
        const subType = r.readUInt8();
        readBytes = r.offset - readBytes;
        const remainingBytes = kpSize - readBytes;
        let keyData = import_buffer.Buffer.from([]);
        if (remainingBytes > 0) {
          keyData = r.readSlice(remainingBytes);
        }
        return new _ProprietaryData(identifier, subType, keyData, keyPair.value);
      }
      static proprietaryKey(subType, keyData) {
        const size = keySize(keyData);
        const buf2 = import_buffer.Buffer.allocUnsafe(size);
        const w = new bufferutils_1.BufferWriter(buf2);
        w.writeVarSlice(pset_1.magicPrefix);
        w.writeSlice(import_buffer.Buffer.from([subType]));
        if (keyData && keyData.length > 0) {
          w.writeSlice(keyData);
        }
        return buf2;
      }
    };
    exports2.ProprietaryData = ProprietaryData;
    function keySize(keyData) {
      const keyDataSize = keyData ? keyData.length : 0;
      return bufferutils_1.varuint.encodingLength(pset_1.magicPrefix.length) + pset_1.magicPrefix.length + 1 + keyDataSize;
    }
  }
});

// node_modules/.pnpm/bitset@5.2.3/node_modules/bitset/dist/bitset.js
var require_bitset = __commonJS({
  "node_modules/.pnpm/bitset@5.2.3/node_modules/bitset/dist/bitset.js"(exports2, module2) {
    "use strict";
    init_buffer_polyfill();
    var WORD_LENGTH = 32;
    var WORD_LOG = 5;
    function popCount(v) {
      v -= v >>> 1 & 1431655765;
      v = (v & 858993459) + (v >>> 2 & 858993459);
      return (v + (v >>> 4) & 252645135) * 16843009 >>> 24;
    }
    function divide(arr, B) {
      var r = 0;
      for (var i = 0; i < arr.length; i++) {
        r *= 2;
        var d = (arr[i] + r) / B | 0;
        r = (arr[i] + r) % B;
        arr[i] = d;
      }
      return r;
    }
    function parse5(P2, val) {
      if (val == null) {
        P2["data"] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        P2["_"] = 0;
        return;
      }
      if (val instanceof BitSet) {
        P2["data"] = val["data"];
        P2["_"] = val["_"];
        return;
      }
      switch (typeof val) {
        case "number":
          P2["data"] = [val | 0];
          P2["_"] = 0;
          break;
        case "string":
          var base5 = 2;
          var len = WORD_LENGTH;
          if (val.indexOf("0b") === 0) {
            val = val.substr(2);
          } else if (val.indexOf("0x") === 0) {
            val = val.substr(2);
            base5 = 16;
            len = 8;
          }
          P2["data"] = [];
          P2["_"] = 0;
          var a = val.length - len;
          var b = val.length;
          do {
            var num2 = parseInt(val.slice(a > 0 ? a : 0, b), base5);
            if (isNaN(num2)) {
              throw SyntaxError("Invalid param");
            }
            P2["data"].push(num2 | 0);
            if (a <= 0)
              break;
            a -= len;
            b -= len;
          } while (1);
          break;
        default:
          P2["data"] = [0];
          var data = P2["data"];
          if (val instanceof Array) {
            for (var i = val.length - 1; i >= 0; i--) {
              var ndx = val[i];
              if (ndx === Infinity) {
                P2["_"] = -1;
              } else {
                scale(P2, ndx);
                data[ndx >>> WORD_LOG] |= 1 << ndx;
              }
            }
            break;
          }
          if (Uint8Array && val instanceof Uint8Array) {
            var bits = 8;
            scale(P2, val.length * bits);
            for (var i = 0; i < val.length; i++) {
              var n2 = val[i];
              for (var j = 0; j < bits; j++) {
                var k = i * bits + j;
                data[k >>> WORD_LOG] |= (n2 >> j & 1) << k;
              }
            }
            break;
          }
          throw SyntaxError("Invalid param");
      }
    }
    function BitSet(param) {
      if (!(this instanceof BitSet)) {
        return new BitSet(param);
      }
      parse5(this, param);
      this["data"] = this["data"].slice();
    }
    function scale(dst, ndx) {
      var l = ndx >>> WORD_LOG;
      var d = dst["data"];
      var v = dst["_"];
      for (var i = d.length; l >= i; l--) {
        d.push(v);
      }
    }
    var P = {
      "data": [],
      // Holds the actual bits in form of a 32bit integer array.
      "_": 0
      // Holds the MSB flag information to make indefinitely large bitsets inversion-proof
    };
    BitSet.prototype = {
      "data": [],
      "_": 0,
      /**
       * Set a single bit flag
       *
       * Ex:
       * bs1 = new BitSet(10);
       *
       * bs1.set(3, 1);
       *
       * @param {number} ndx The index of the bit to be set
       * @param {number=} value Optional value that should be set on the index (0 or 1)
       * @returns {BitSet} this
       */
      "set": function(ndx, value2) {
        ndx |= 0;
        scale(this, ndx);
        if (value2 === void 0 || value2) {
          this["data"][ndx >>> WORD_LOG] |= 1 << ndx;
        } else {
          this["data"][ndx >>> WORD_LOG] &= ~(1 << ndx);
        }
        return this;
      },
      /**
       * Get a single bit flag of a certain bit position
       *
       * Ex:
       * bs1 = new BitSet();
       * var isValid = bs1.get(12);
       *
       * @param {number} ndx the index to be fetched
       * @returns {number} The binary flag
       */
      "get": function(ndx) {
        ndx |= 0;
        var d = this["data"];
        var n2 = ndx >>> WORD_LOG;
        if (n2 >= d.length) {
          return this["_"] & 1;
        }
        return d[n2] >>> ndx & 1;
      },
      /**
       * Creates the bitwise NOT of a set.
       *
       * Ex:
       * bs1 = new BitSet(10);
       *
       * res = bs1.not();
       *
       * @returns {BitSet} A new BitSet object, containing the bitwise NOT of this
       */
      "not": function() {
        var t = this["clone"]();
        var d = t["data"];
        for (var i = 0; i < d.length; i++) {
          d[i] = ~d[i];
        }
        t["_"] = ~t["_"];
        return t;
      },
      /**
       * Creates the bitwise AND of two sets.
       *
       * Ex:
       * bs1 = new BitSet(10);
       * bs2 = new BitSet(10);
       *
       * res = bs1.and(bs2);
       *
       * @param {BitSet} value A bitset object
       * @returns {BitSet} A new BitSet object, containing the bitwise AND of this and value
       */
      "and": function(value2) {
        parse5(P, value2);
        var T = this["clone"]();
        var t = T["data"];
        var p = P["data"];
        var pl = p.length;
        var p_ = P["_"];
        var t_ = T["_"];
        if (t_ !== 0) {
          scale(T, pl * WORD_LENGTH - 1);
        }
        var tl = t.length;
        var l = Math.min(pl, tl);
        var i = 0;
        for (; i < l; i++) {
          t[i] &= p[i];
        }
        for (; i < tl; i++) {
          t[i] &= p_;
        }
        T["_"] &= p_;
        return T;
      },
      /**
       * Creates the bitwise OR of two sets.
       *
       * Ex:
       * bs1 = new BitSet(10);
       * bs2 = new BitSet(10);
       *
       * res = bs1.or(bs2);
       *
       * @param {BitSet} val A bitset object
       * @returns {BitSet} A new BitSet object, containing the bitwise OR of this and val
       */
      "or": function(val) {
        parse5(P, val);
        var t = this["clone"]();
        var d = t["data"];
        var p = P["data"];
        var pl = p.length - 1;
        var tl = d.length - 1;
        var minLength = Math.min(tl, pl);
        for (var i = pl; i > minLength; i--) {
          d[i] = p[i];
        }
        for (; i >= 0; i--) {
          d[i] |= p[i];
        }
        t["_"] |= P["_"];
        return t;
      },
      /**
       * Creates the bitwise XOR of two sets.
       *
       * Ex:
       * bs1 = new BitSet(10);
       * bs2 = new BitSet(10);
       *
       * res = bs1.xor(bs2);
       *
       * @param {BitSet} val A bitset object
       * @returns {BitSet} A new BitSet object, containing the bitwise XOR of this and val
       */
      "xor": function(val) {
        parse5(P, val);
        var t = this["clone"]();
        var d = t["data"];
        var p = P["data"];
        var t_ = t["_"];
        var p_ = P["_"];
        var i = 0;
        var tl = d.length - 1;
        var pl = p.length - 1;
        for (i = tl; i > pl; i--) {
          d[i] ^= p_;
        }
        for (i = pl; i > tl; i--) {
          d[i] = t_ ^ p[i];
        }
        for (; i >= 0; i--) {
          d[i] ^= p[i];
        }
        t["_"] ^= p_;
        return t;
      },
      /**
       * Creates the bitwise AND NOT (not confuse with NAND!) of two sets.
       *
       * Ex:
       * bs1 = new BitSet(10);
       * bs2 = new BitSet(10);
       *
       * res = bs1.notAnd(bs2);
       *
       * @param {BitSet} val A bitset object
       * @returns {BitSet} A new BitSet object, containing the bitwise AND NOT of this and other
       */
      "andNot": function(val) {
        return this["and"](new BitSet(val)["flip"]());
      },
      /**
       * Flip/Invert a range of bits by setting
       *
       * Ex:
       * bs1 = new BitSet();
       * bs1.flip(); // Flip entire set
       * bs1.flip(5); // Flip single bit
       * bs1.flip(3,10); // Flip a bit range
       *
       * @param {number=} from The start index of the range to be flipped
       * @param {number=} to The end index of the range to be flipped
       * @returns {BitSet} this
       */
      "flip": function(from7, to) {
        if (from7 === void 0) {
          var d = this["data"];
          for (var i = 0; i < d.length; i++) {
            d[i] = ~d[i];
          }
          this["_"] = ~this["_"];
        } else if (to === void 0) {
          scale(this, from7);
          this["data"][from7 >>> WORD_LOG] ^= 1 << from7;
        } else if (0 <= from7 && from7 <= to) {
          scale(this, to);
          for (var i = from7; i <= to; i++) {
            this["data"][i >>> WORD_LOG] ^= 1 << i;
          }
        }
        return this;
      },
      /**
       * Clear a range of bits by setting it to 0
       *
       * Ex:
       * bs1 = new BitSet();
       * bs1.clear(); // Clear entire set
       * bs1.clear(5); // Clear single bit
       * bs1.clear(3,10); // Clear a bit range
       *
       * @param {number=} from The start index of the range to be cleared
       * @param {number=} to The end index of the range to be cleared
       * @returns {BitSet} this
       */
      "clear": function(from7, to) {
        var data = this["data"];
        if (from7 === void 0) {
          for (var i = data.length - 1; i >= 0; i--) {
            data[i] = 0;
          }
          this["_"] = 0;
        } else if (to === void 0) {
          from7 |= 0;
          scale(this, from7);
          data[from7 >>> WORD_LOG] &= ~(1 << from7);
        } else if (from7 <= to) {
          scale(this, to);
          for (var i = from7; i <= to; i++) {
            data[i >>> WORD_LOG] &= ~(1 << i);
          }
        }
        return this;
      },
      /**
       * Gets an entire range as a new bitset object
       *
       * Ex:
       * bs1 = new BitSet();
       * bs1.slice(4, 8);
       *
       * @param {number=} from The start index of the range to be get
       * @param {number=} to The end index of the range to be get
       * @returns {BitSet} A new smaller bitset object, containing the extracted range
       */
      "slice": function(from7, to) {
        if (from7 === void 0) {
          return this["clone"]();
        } else if (to === void 0) {
          to = this["data"].length * WORD_LENGTH;
          var im = Object.create(BitSet.prototype);
          im["_"] = this["_"];
          im["data"] = [0];
          for (var i = from7; i <= to; i++) {
            im["set"](i - from7, this["get"](i));
          }
          return im;
        } else if (from7 <= to && 0 <= from7) {
          var im = Object.create(BitSet.prototype);
          im["data"] = [0];
          for (var i = from7; i <= to; i++) {
            im["set"](i - from7, this["get"](i));
          }
          return im;
        }
        return null;
      },
      /**
       * Set a range of bits
       *
       * Ex:
       * bs1 = new BitSet();
       *
       * bs1.setRange(10, 15, 1);
       *
       * @param {number} from The start index of the range to be set
       * @param {number} to The end index of the range to be set
       * @param {number} value Optional value that should be set on the index (0 or 1)
       * @returns {BitSet} this
       */
      "setRange": function(from7, to, value2) {
        for (var i = from7; i <= to; i++) {
          this["set"](i, value2);
        }
        return this;
      },
      /**
       * Clones the actual object
       *
       * Ex:
       * bs1 = new BitSet(10);
       * bs2 = bs1.clone();
       *
       * @returns {BitSet|Object} A new BitSet object, containing a copy of the actual object
       */
      "clone": function() {
        var im = Object.create(BitSet.prototype);
        im["data"] = this["data"].slice();
        im["_"] = this["_"];
        return im;
      },
      /**
       * Gets a list of set bits
       *
       * @returns {Array}
       */
      "toArray": Math["clz32"] ? function() {
        var ret = [];
        var data = this["data"];
        for (var i = data.length - 1; i >= 0; i--) {
          var num2 = data[i];
          while (num2 !== 0) {
            var t = 31 - Math["clz32"](num2);
            num2 ^= 1 << t;
            ret.unshift(i * WORD_LENGTH + t);
          }
        }
        if (this["_"] !== 0)
          ret.push(Infinity);
        return ret;
      } : function() {
        var ret = [];
        var data = this["data"];
        for (var i = 0; i < data.length; i++) {
          var num2 = data[i];
          while (num2 !== 0) {
            var t = num2 & -num2;
            num2 ^= t;
            ret.push(i * WORD_LENGTH + popCount(t - 1));
          }
        }
        if (this["_"] !== 0)
          ret.push(Infinity);
        return ret;
      },
      /**
       * Overrides the toString method to get a binary representation of the BitSet
       *
       * @param {number=} base
       * @returns string A binary string
       */
      "toString": function(base5) {
        var data = this["data"];
        if (!base5)
          base5 = 2;
        if ((base5 & base5 - 1) === 0 && base5 < 36) {
          var ret = "";
          var len = 2 + Math.log(
            4294967295
            /*Math.pow(2, WORD_LENGTH)-1*/
          ) / Math.log(base5) | 0;
          for (var i = data.length - 1; i >= 0; i--) {
            var cur = data[i];
            if (cur < 0)
              cur += 4294967296;
            var tmp = cur.toString(base5);
            if (ret !== "") {
              ret += "0".repeat(len - tmp.length - 1);
            }
            ret += tmp;
          }
          if (this["_"] === 0) {
            ret = ret.replace(/^0+/, "");
            if (ret === "")
              ret = "0";
            return ret;
          } else {
            ret = "1111" + ret;
            return ret.replace(/^1+/, "...1111");
          }
        } else {
          if (2 > base5 || base5 > 36)
            throw SyntaxError("Invalid base");
          var ret = [];
          var arr = [];
          for (var i = data.length; i--; ) {
            for (var j = WORD_LENGTH; j--; ) {
              arr.push(data[i] >>> j & 1);
            }
          }
          do {
            ret.unshift(divide(arr, base5).toString(base5));
          } while (!arr.every(function(x) {
            return x === 0;
          }));
          return ret.join("");
        }
      },
      /**
       * Check if the BitSet is empty, means all bits are unset
       *
       * Ex:
       * bs1 = new BitSet(10);
       *
       * bs1.isEmpty() ? 'yes' : 'no'
       *
       * @returns {boolean} Whether the bitset is empty
       */
      "isEmpty": function() {
        if (this["_"] !== 0)
          return false;
        var d = this["data"];
        for (var i = d.length - 1; i >= 0; i--) {
          if (d[i] !== 0)
            return false;
        }
        return true;
      },
      /**
       * Calculates the number of bits set
       *
       * Ex:
       * bs1 = new BitSet(10);
       *
       * var num = bs1.cardinality();
       *
       * @returns {number} The number of bits set
       */
      "cardinality": function() {
        if (this["_"] !== 0) {
          return Infinity;
        }
        var s = 0;
        var d = this["data"];
        for (var i = 0; i < d.length; i++) {
          var n2 = d[i];
          if (n2 !== 0)
            s += popCount(n2);
        }
        return s;
      },
      /**
       * Calculates the Most Significant Bit / log base two
       *
       * Ex:
       * bs1 = new BitSet(10);
       *
       * var logbase2 = bs1.msb();
       *
       * var truncatedTwo = Math.pow(2, logbase2); // May overflow!
       *
       * @returns {number} The index of the highest bit set
       */
      "msb": Math["clz32"] ? function() {
        if (this["_"] !== 0) {
          return Infinity;
        }
        var data = this["data"];
        for (var i = data.length; i-- > 0; ) {
          var c = Math["clz32"](data[i]);
          if (c !== WORD_LENGTH) {
            return i * WORD_LENGTH + WORD_LENGTH - 1 - c;
          }
        }
        return Infinity;
      } : function() {
        if (this["_"] !== 0) {
          return Infinity;
        }
        var data = this["data"];
        for (var i = data.length; i-- > 0; ) {
          var v = data[i];
          var c = 0;
          if (v) {
            for (; (v >>>= 1) > 0; c++) {
            }
            return i * WORD_LENGTH + c;
          }
        }
        return Infinity;
      },
      /**
       * Calculates the number of trailing zeros
       *
       * Ex:
       * bs1 = new BitSet(10);
       *
       * var ntz = bs1.ntz();
       *
       * @returns {number} The index of the lowest bit set
       */
      "ntz": function() {
        var data = this["data"];
        for (var j = 0; j < data.length; j++) {
          var v = data[j];
          if (v !== 0) {
            v = (v ^ v - 1) >>> 1;
            return j * WORD_LENGTH + popCount(v);
          }
        }
        return Infinity;
      },
      /**
       * Calculates the Least Significant Bit
       *
       * Ex:
       * bs1 = new BitSet(10);
       *
       * var lsb = bs1.lsb();
       *
       * @returns {number} The index of the lowest bit set
       */
      "lsb": function() {
        var data = this["data"];
        for (var i = 0; i < data.length; i++) {
          var v = data[i];
          var c = 0;
          if (v) {
            var bit = v & -v;
            for (; bit >>>= 1; c++) {
            }
            return WORD_LENGTH * i + c;
          }
        }
        return this["_"] & 1;
      },
      /**
       * Compares two BitSet objects
       *
       * Ex:
       * bs1 = new BitSet(10);
       * bs2 = new BitSet(10);
       *
       * bs1.equals(bs2) ? 'yes' : 'no'
       *
       * @param {BitSet} val A bitset object
       * @returns {boolean} Whether the two BitSets have the same bits set (valid for indefinite sets as well)
       */
      "equals": function(val) {
        parse5(P, val);
        var t = this["data"];
        var p = P["data"];
        var t_ = this["_"];
        var p_ = P["_"];
        var tl = t.length - 1;
        var pl = p.length - 1;
        if (p_ !== t_) {
          return false;
        }
        var minLength = tl < pl ? tl : pl;
        var i = 0;
        for (; i <= minLength; i++) {
          if (t[i] !== p[i])
            return false;
        }
        for (i = tl; i > pl; i--) {
          if (t[i] !== p_)
            return false;
        }
        for (i = pl; i > tl; i--) {
          if (p[i] !== t_)
            return false;
        }
        return true;
      },
      [Symbol.iterator]: function() {
        var d = this["data"];
        var ndx = 0;
        if (this["_"] === 0) {
          var highest = 0;
          for (var i = d.length - 1; i >= 0; i--) {
            if (d[i] !== 0) {
              highest = i;
              break;
            }
          }
          return {
            "next": function() {
              var n2 = ndx >>> WORD_LOG;
              return {
                "done": n2 > highest || n2 === highest && d[n2] >>> ndx === 0,
                "value": n2 > highest ? 0 : d[n2] >>> ndx++ & 1
              };
            }
          };
        } else {
          return {
            "next": function() {
              var n2 = ndx >>> WORD_LOG;
              return {
                "done": false,
                "value": n2 < d.length ? d[n2] >>> ndx++ & 1 : 1
              };
            }
          };
        }
      }
    };
    BitSet["fromBinaryString"] = function(str) {
      return new BitSet("0b" + str);
    };
    BitSet["fromHexString"] = function(str) {
      return new BitSet("0x" + str);
    };
    BitSet["Random"] = function(n2) {
      if (n2 === void 0 || n2 < 0) {
        n2 = WORD_LENGTH;
      }
      var m = n2 % WORD_LENGTH;
      var t = [];
      var len = Math.ceil(n2 / WORD_LENGTH);
      var s = Object.create(BitSet.prototype);
      for (var i = 0; i < len; i++) {
        t.push(Math.random() * 4294967296 | 0);
      }
      if (m > 0) {
        t[len - 1] &= (1 << m) - 1;
      }
      s["data"] = t;
      s["_"] = 0;
      return s;
    };
    Object.defineProperty(BitSet, "__esModule", { "value": true });
    BitSet["default"] = BitSet;
    BitSet["BitSet"] = BitSet;
    module2["exports"] = BitSet;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/globals.js
var require_globals = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/globals.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PsetGlobal = exports2.GlobalDuplicateFieldError = void 0;
    var fields_1 = require_fields();
    var key_pair_1 = require_key_pair();
    var proprietary_data_1 = require_proprietary_data();
    var varuint_bitcoin_1 = __importDefault(require_varuint_bitcoin());
    var bitset_1 = __importDefault(require_bitset());
    var bufferutils_1 = require_bufferutils();
    var pset_1 = require_pset();
    var bip32_1 = require_bip32();
    var pubKeyLength = 78;
    var GlobalDuplicateFieldError = class extends Error {
      constructor(message) {
        if (message) {
          message = "Duplicated global " + message;
        }
        super(message);
      }
    };
    exports2.GlobalDuplicateFieldError = GlobalDuplicateFieldError;
    var PsetGlobal = class _PsetGlobal {
      constructor(txVersion, inputCount, outputCount, version, fallbackLocktime) {
        this.txVersion = txVersion || 0;
        this.inputCount = inputCount || 0;
        this.outputCount = outputCount || 0;
        this.version = version || 0;
        this.fallbackLocktime = fallbackLocktime;
      }
      static fromBuffer(r) {
        let kp;
        const global2 = new _PsetGlobal();
        while (true) {
          try {
            kp = key_pair_1.KeyPair.fromBuffer(r);
          } catch (e) {
            if (e instanceof Error && e === key_pair_1.ErrEmptyKey) {
              global2.sanityCheck();
              return global2;
            }
            throw e;
          }
          switch (kp.key.keyType) {
            case fields_1.GlobalTypes.XPUB:
              if (kp.key.keyData.length !== pubKeyLength + 1 && ![2, 3].includes(kp.key.keyData[46])) {
                throw new Error("Invalid xpub length");
              }
              const extendedKey = kp.key.keyData.slice(1);
              const { masterFingerprint, path: derivationPath } = (0, bip32_1.decodeBip32Derivation)(kp.value);
              if (!global2.xpubs) {
                global2.xpubs = [];
              }
              global2.xpubs.push({ extendedKey, masterFingerprint, derivationPath });
              break;
            case fields_1.GlobalTypes.TX_VERSION:
              if (global2.txVersion > 0) {
                throw new GlobalDuplicateFieldError("tx version");
              }
              if (kp.value.length !== 4) {
                throw new Error("Invalid global tx version length");
              }
              global2.txVersion = kp.value.readUInt32LE();
              break;
            case fields_1.GlobalTypes.FALLBACK_LOCKTIME:
              if (global2.fallbackLocktime > 0) {
                throw new GlobalDuplicateFieldError("fallback locktime");
              }
              if (kp.value.length !== 4) {
                throw new Error("Invalid global fallback locktime length");
              }
              global2.fallbackLocktime = kp.value.readUInt32LE();
              break;
            case fields_1.GlobalTypes.INPUT_COUNT:
              if (global2.inputCount > 0) {
                throw new GlobalDuplicateFieldError("input count");
              }
              global2.inputCount = varuint_bitcoin_1.default.decode(kp.value);
              break;
            case fields_1.GlobalTypes.OUTPUT_COUNT:
              if (global2.outputCount > 0) {
                throw new GlobalDuplicateFieldError("output count");
              }
              global2.outputCount = varuint_bitcoin_1.default.decode(kp.value);
              break;
            case fields_1.GlobalTypes.TX_MODIFIABLE:
              if (global2.txModifiable) {
                throw new GlobalDuplicateFieldError("tx modifiable");
              }
              if (kp.value.length !== 1) {
                throw new Error("Invalid global tx modifiable length");
              }
              global2.txModifiable = new bitset_1.default(kp.value[0]);
              break;
            case fields_1.GlobalTypes.VERSION:
              if (global2.version > 0) {
                throw new GlobalDuplicateFieldError("version");
              }
              if (kp.value.length !== 4) {
                throw new Error("Invalid global version length");
              }
              global2.version = kp.value.readUInt32LE();
              break;
            case fields_1.GlobalTypes.PROPRIETARY:
              const data = proprietary_data_1.ProprietaryData.fromKeyPair(kp);
              if (pset_1.magicPrefix.compare(data.identifier) === 0) {
                switch (data.subType) {
                  case fields_1.GlobalProprietaryTypes.SCALAR:
                    if (data.keyData.length !== 32) {
                      throw new Error("Invalid global scalar length");
                    }
                    if (!global2.scalars) {
                      global2.scalars = [];
                    }
                    global2.scalars.push(data.keyData);
                    break;
                  case fields_1.GlobalProprietaryTypes.TX_MODIFIABLE:
                    if (global2.modifiable) {
                      throw new GlobalDuplicateFieldError("pset modifiable");
                    }
                    if (kp.value.length !== 1) {
                      throw new Error("Invalid global pset modifiable length");
                    }
                    global2.modifiable = new bitset_1.default(kp.value[0]);
                    break;
                  default:
                    if (!global2.proprietaryData) {
                      global2.proprietaryData = [];
                    }
                    global2.proprietaryData.push(data);
                }
              }
              break;
            default:
              if (!global2.unknowns) {
                global2.unknowns = [];
              }
              global2.unknowns.push(kp);
              break;
          }
        }
      }
      sanityCheck() {
        if (this.txVersion < 2) {
          throw new Error("Global tx version must be at least 2");
        }
        if (this.txVersion !== 2) {
          throw new Error("Global version must be exactly 2");
        }
        if (this.txModifiable && parseInt(this.txModifiable.toString(), 2) > 7) {
          throw new Error("Invalid global tx modifiable value");
        }
        if (this.modifiable && parseInt(this.modifiable.toString(), 2) !== 0) {
          throw new Error("Invalid global pset modifiable value");
        }
        if (this.xpubs && this.xpubs.some((xpub, i) => {
          if (i === this.xpubs.length - 1) {
            return false;
          }
          const next = this.xpubs.slice(i + 1);
          return next.some(
            (nextXpub) => xpub.extendedKey.compare(nextXpub.extendedKey) === 0
          );
        })) {
          throw new GlobalDuplicateFieldError("xpub");
        }
        if (this.scalars && this.scalars.some((scalar, i) => {
          if (i === this.scalars.length - 1) {
            return false;
          }
          const next = this.scalars.slice(i + 1);
          return next.some((nextScalar) => scalar.compare(nextScalar) === 0);
        })) {
          throw new GlobalDuplicateFieldError("scalar");
        }
        return this;
      }
      toBuffer() {
        const keyPairs = this.getKeyPairs();
        const kpBuf = keyPairs.map((kp) => kp.toBuffer());
        let size = 0;
        kpBuf.forEach((buf2) => {
          size += buf2.length;
        });
        const w = bufferutils_1.BufferWriter.withCapacity(size);
        kpBuf.forEach((buf2) => w.writeSlice(buf2));
        return w.buffer;
      }
      getKeyPairs() {
        const keyPairs = [];
        if (this.xpubs && this.xpubs.length > 0) {
          this.xpubs.forEach(
            ({ extendedKey, masterFingerprint, derivationPath }) => {
              const keyData = import_buffer.Buffer.concat([
                import_buffer.Buffer.of(extendedKey.length),
                extendedKey
              ]);
              const key = new key_pair_1.Key(fields_1.GlobalTypes.XPUB, keyData);
              const value2 = (0, bip32_1.encodeBIP32Derivation)(
                masterFingerprint,
                derivationPath
              );
              keyPairs.push(new key_pair_1.KeyPair(key, value2));
            }
          );
        }
        const txVersion = import_buffer.Buffer.allocUnsafe(4);
        txVersion.writeUInt32LE(this.txVersion, 0);
        const txVersionKey = new key_pair_1.Key(fields_1.GlobalTypes.TX_VERSION);
        keyPairs.push(new key_pair_1.KeyPair(txVersionKey, txVersion));
        if (this.fallbackLocktime !== void 0) {
          const fallbackLocktime = import_buffer.Buffer.allocUnsafe(4);
          fallbackLocktime.writeUInt32LE(this.fallbackLocktime, 0);
          const fallbackLocktimeKey = new key_pair_1.Key(
            fields_1.GlobalTypes.FALLBACK_LOCKTIME
          );
          keyPairs.push(
            new key_pair_1.KeyPair(fallbackLocktimeKey, fallbackLocktime)
          );
        }
        const inputCount = import_buffer.Buffer.allocUnsafe(
          varuint_bitcoin_1.default.encodingLength(this.inputCount)
        );
        varuint_bitcoin_1.default.encode(this.inputCount, inputCount, 0);
        const inputCountKey = new key_pair_1.Key(fields_1.GlobalTypes.INPUT_COUNT);
        keyPairs.push(new key_pair_1.KeyPair(inputCountKey, inputCount));
        const outputCount = import_buffer.Buffer.allocUnsafe(
          varuint_bitcoin_1.default.encodingLength(this.outputCount)
        );
        varuint_bitcoin_1.default.encode(this.outputCount, outputCount, 0);
        const outputCountKey = new key_pair_1.Key(
          fields_1.GlobalTypes.OUTPUT_COUNT
        );
        keyPairs.push(new key_pair_1.KeyPair(outputCountKey, outputCount));
        if (this.txModifiable) {
          const txModifiable = import_buffer.Buffer.allocUnsafe(1);
          txModifiable.writeUInt8(Number(this.txModifiable.toString(10)), 0);
          const txModifiableKey = new key_pair_1.Key(
            fields_1.GlobalTypes.TX_MODIFIABLE
          );
          keyPairs.push(new key_pair_1.KeyPair(txModifiableKey, txModifiable));
        }
        if (this.scalars && this.scalars.length > 0) {
          this.scalars.forEach((scalar) => {
            const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
              fields_1.GlobalProprietaryTypes.SCALAR,
              scalar
            );
            const scalarKey = new key_pair_1.Key(
              fields_1.GlobalTypes.PROPRIETARY,
              keyData
            );
            keyPairs.push(new key_pair_1.KeyPair(scalarKey));
          });
        }
        if (this.modifiable && parseInt(this.modifiable.toString(), 2) > 0) {
          const modifiable = import_buffer.Buffer.allocUnsafe(1);
          modifiable.writeUInt8(Number(this.modifiable.toString(2)), 0);
          const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
            fields_1.GlobalProprietaryTypes.TX_MODIFIABLE
          );
          const modifiableKey = new key_pair_1.Key(
            fields_1.GlobalTypes.PROPRIETARY,
            keyData
          );
          keyPairs.push(new key_pair_1.KeyPair(modifiableKey, modifiable));
        }
        const version = import_buffer.Buffer.allocUnsafe(4);
        version.writeUInt32LE(this.version, 0);
        const versionKey = new key_pair_1.Key(fields_1.GlobalTypes.VERSION);
        keyPairs.push(new key_pair_1.KeyPair(versionKey, version));
        if (this.proprietaryData && this.proprietaryData.length > 0) {
          this.proprietaryData.forEach((data) => {
            const keyData = proprietary_data_1.ProprietaryData.proprietaryKey(
              data.subType,
              data.keyData
            );
            const key = new key_pair_1.Key(
              fields_1.GlobalTypes.PROPRIETARY,
              keyData
            );
            keyPairs.push(new key_pair_1.KeyPair(key, data.value));
          });
        }
        keyPairs.concat(this.unknowns || []);
        return keyPairs;
      }
    };
    exports2.PsetGlobal = PsetGlobal;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/creator.js
var require_creator = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/creator.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Creator = exports2.CreatorOutput = exports2.CreatorInput = void 0;
    var bitset_1 = __importDefault(require_bitset());
    var asset_1 = require_asset();
    var bufferutils_1 = require_bufferutils();
    var transaction_1 = require_transaction();
    var globals_1 = require_globals();
    var input_1 = require_input();
    var output_1 = require_output();
    var pset_1 = require_pset();
    var CreatorInput = class {
      constructor(txid, txIndex, sequence, heightLocktime, timeLocktime) {
        this.txid = txid;
        this.txIndex = txIndex;
        this.sequence = sequence ?? transaction_1.Transaction.DEFAULT_SEQUENCE;
        this.heightLocktime = heightLocktime || 0;
        this.timeLocktime = timeLocktime || 0;
      }
      validate() {
        if (this.txid.length === 0) {
          throw new Error("missing prevout txid");
        }
        if (this.txid.length !== 64) {
          throw new Error("invalid prevout txid length");
        }
        if (this.txIndex < 0) {
          throw new Error("missing prevout tx index");
        }
      }
      toPartialInput() {
        const prevTxid = (0, bufferutils_1.reverseBuffer)(
          import_buffer.Buffer.from(this.txid, "hex")
        );
        const input = new input_1.PsetInput(prevTxid, this.txIndex, this.sequence);
        input.requiredHeightLocktime = this.heightLocktime;
        input.requiredTimeLocktime = this.timeLocktime;
        return input;
      }
    };
    exports2.CreatorInput = CreatorInput;
    var CreatorOutput = class {
      constructor(asset, amount, script, blindingPublicKey, blinderIndex) {
        this.asset = asset;
        this.amount = amount;
        this.script = script;
        this.blindingPublicKey = blindingPublicKey;
        this.blinderIndex = blinderIndex;
      }
      validate() {
        if (this.asset.length === 0) {
          throw new Error("missing asset");
        }
        if (import_buffer.Buffer.from(this.asset, "hex").length !== 32) {
          throw new Error("invalid asset length");
        }
        if (this.blindingPublicKey && (this.blinderIndex === void 0 || this.blinderIndex < 0)) {
          throw new Error("missing blinder index for confidential output");
        }
      }
      toPartialOutput() {
        const asset = asset_1.AssetHash.fromHex(this.asset);
        const output = new output_1.PsetOutput(
          this.amount,
          asset.bytesWithoutPrefix,
          this.script || import_buffer.Buffer.of()
        );
        if (this.blindingPublicKey) {
          output.blinderIndex = this.blinderIndex;
          output.blindingPubkey = this.blindingPublicKey;
        }
        return output;
      }
    };
    exports2.CreatorOutput = CreatorOutput;
    var Creator = class {
      static newPset(args) {
        const locktime = args ? args.locktime : void 0;
        const txModifiable = new bitset_1.default(0);
        txModifiable.set(0);
        txModifiable.set(1);
        const globals3 = new globals_1.PsetGlobal(2, 0, 0, 2, locktime);
        globals3.txModifiable = txModifiable;
        globals3.xpubs = [];
        globals3.scalars = [];
        globals3.proprietaryData = [];
        globals3.unknowns = [];
        const pset = new pset_1.Pset(globals3);
        if (args && args.inputs)
          args.inputs.forEach((input) => {
            input.validate();
            pset.addInput(input.toPartialInput());
          });
        if (args && args.outputs)
          args.outputs.forEach((output) => {
            output.validate();
            pset.addOutput(output.toPartialOutput());
          });
        return pset;
      }
    };
    exports2.Creator = Creator;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/updater.js
var require_updater = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/updater.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Updater = void 0;
    var address_1 = require_address();
    var asset_1 = require_asset();
    var issuance_1 = require_issuance();
    var creator_1 = require_creator();
    var bscript = __importStar(require_script());
    function processOutputDestination(dest) {
      if (typeof dest === "string") {
        const script = (0, address_1.toOutputScript)(dest);
        if ((0, address_1.isConfidential)(dest))
          return {
            script,
            blindingPublicKey: (0, address_1.fromConfidential)(dest).blindingKey
          };
        return { script };
      }
      return dest;
    }
    var Updater = class {
      constructor(pset) {
        pset.sanityCheck();
        this.pset = pset;
      }
      addInputs(ins) {
        const pset = this.pset.copy();
        ins.forEach((input) => {
          const creatorInput = new creator_1.CreatorInput(
            input.txid,
            input.txIndex,
            input.sequence,
            input.heightLocktime,
            input.timeLocktime
          );
          creatorInput.validate();
          pset.addInput(creatorInput.toPartialInput());
          const inputIndex = pset.inputs.length - 1;
          if (input.witnessUtxo)
            this.addInWitnessUtxo(inputIndex, input.witnessUtxo);
          if (input.witnessUtxo && input.witnessUtxo.rangeProof) {
            this.addInUtxoRangeProof(inputIndex, input.witnessUtxo.rangeProof);
          }
          if (input.witnessScript)
            this.addInWitnessScript(inputIndex, input.witnessScript);
          if (input.nonWitnessUtxo)
            this.addInNonWitnessUtxo(inputIndex, input.nonWitnessUtxo);
          if (input.nonWitnessUtxo && input.nonWitnessUtxo.outs[input.txIndex]) {
            const previousOutput = input.nonWitnessUtxo.outs[input.txIndex];
            if (previousOutput.rangeProof)
              this.addInUtxoRangeProof(inputIndex, previousOutput.rangeProof);
          }
          if (input.sighashType !== void 0)
            this.addInSighashType(inputIndex, input.sighashType);
          if (input.tapInternalKey)
            this.addInTapInternalKey(inputIndex, input.tapInternalKey);
          if (input.tapLeafScript)
            this.addInTapLeafScript(inputIndex, input.tapLeafScript);
          if (input.tapMerkleRoot)
            this.addInTapMerkleRoot(inputIndex, input.tapMerkleRoot);
          if (input.issaunceOpts)
            this.addInIssuance(inputIndex, input.issaunceOpts);
          if (input.reissuanceOpts)
            this.addInReissuance(inputIndex, input.reissuanceOpts);
          if (input.explicitAsset) {
            this.addInExplicitAsset(
              inputIndex,
              input.explicitAsset,
              input.explicitAssetProof ?? import_buffer.Buffer.alloc(0)
            );
          }
          if (input.explicitValue) {
            this.addInExplicitValue(
              inputIndex,
              input.explicitValue,
              input.explicitValueProof ?? import_buffer.Buffer.alloc(0)
            );
          }
        });
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addOutputs(outs) {
        const pset = this.pset.copy();
        outs.forEach((output) => {
          const creatorOutput = new creator_1.CreatorOutput(
            output.asset,
            output.amount,
            output.script,
            output.blindingPublicKey,
            output.blinderIndex
          );
          creatorOutput.validate();
          pset.addOutput(creatorOutput.toPartialOutput());
        });
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInNonWitnessUtxo(inIndex, nonWitnessUtxo) {
        this.validateInputIndex(inIndex);
        const pset = this.pset.copy();
        const txid = nonWitnessUtxo.getHash(false);
        if (!txid.equals(pset.inputs[inIndex].previousTxid)) {
          throw new Error("Non-witness utxo hash does not match prevout txid");
        }
        pset.inputs[inIndex].nonWitnessUtxo = nonWitnessUtxo;
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInWitnessUtxo(inIndex, witnessUtxo) {
        this.validateInputIndex(inIndex);
        const pset = this.pset.copy();
        pset.inputs[inIndex].witnessUtxo = witnessUtxo;
        pset.inputs[inIndex].utxoRangeProof = witnessUtxo.rangeProof;
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInRedeemScript(inIndex, redeemScript) {
        this.validateInputIndex(inIndex);
        const pset = this.pset.copy();
        pset.inputs[inIndex].redeemScript = redeemScript;
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInWitnessScript(inIndex, witnessScript) {
        this.validateInputIndex(inIndex);
        const pset = this.pset.copy();
        pset.inputs[inIndex].witnessScript = witnessScript;
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInBIP32Derivation(inIndex, d) {
        this.validateInputIndex(inIndex);
        if (d.pubkey.length !== 33) {
          throw new Error("Invalid pubkey length");
        }
        const pset = this.pset.copy();
        if (!pset.inputs[inIndex].bip32Derivation) {
          pset.inputs[inIndex].bip32Derivation = [];
        }
        if (pset.inputs[inIndex].bip32Derivation.some(
          ({ pubkey }) => pubkey.equals(d.pubkey)
        )) {
          throw new Error("Duplicated bip32 derivation pubkey");
        }
        pset.inputs[inIndex].bip32Derivation.push(d);
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInSighashType(inIndex, sighashType) {
        this.validateInputIndex(inIndex);
        if (sighashType < 0) {
          throw new Error("Invalid sighash type");
        }
        const pset = this.pset.copy();
        pset.inputs[inIndex].sighashType = sighashType;
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInUtxoRangeProof(inIndex, proof) {
        this.validateInputIndex(inIndex);
        const pset = this.pset.copy();
        pset.inputs[inIndex].utxoRangeProof = proof;
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInIssuance(inIndex, args) {
        this.validateIssuanceInput(inIndex);
        validateAddInIssuanceArgs(args);
        const pset = this.pset.copy();
        const assetAmount = args.assetAmount || 0;
        const tokenAmount = args.tokenAmount || 0;
        const issuance = (0, issuance_1.newIssuance)(
          assetAmount,
          tokenAmount,
          args.contract
        );
        pset.inputs[inIndex].issuanceValue = assetAmount;
        pset.inputs[inIndex].issuanceInflationKeys = tokenAmount;
        pset.inputs[inIndex].issuanceAssetEntropy = issuance.assetEntropy;
        pset.inputs[inIndex].issuanceBlindingNonce = issuance.assetBlindingNonce;
        pset.inputs[inIndex].blindedIssuance = args.blindedIssuance !== void 0 ? args.blindedIssuance : true;
        const entropy = (0, issuance_1.generateEntropy)(
          {
            txHash: pset.inputs[inIndex].previousTxid,
            vout: pset.inputs[inIndex].previousTxIndex
          },
          issuance.assetEntropy
        );
        if (assetAmount > 0) {
          const issuedAsset = asset_1.AssetHash.fromBytes(
            (0, issuance_1.calculateAsset)(entropy)
          ).hex;
          const { blindingPublicKey, script } = processOutputDestination(
            args.assetAddress
          );
          const output = new creator_1.CreatorOutput(
            issuedAsset,
            assetAmount,
            script,
            blindingPublicKey,
            blindingPublicKey ? inIndex : void 0
          );
          pset.addOutput(output.toPartialOutput());
        }
        if (tokenAmount > 0) {
          const reissuanceToken = asset_1.AssetHash.fromBytes(
            (0, issuance_1.calculateReissuanceToken)(
              entropy,
              args.blindedIssuance ?? true
            )
          ).hex;
          const { blindingPublicKey, script } = processOutputDestination(
            args.tokenAddress
          );
          const output = new creator_1.CreatorOutput(
            reissuanceToken,
            tokenAmount,
            script,
            blindingPublicKey,
            blindingPublicKey ? inIndex : void 0
          );
          pset.addOutput(output.toPartialOutput());
        }
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInReissuance(inIndex, args) {
        this.validateReissuanceInput(inIndex);
        validateAddInReissuanceArgs(args);
        const pset = this.pset.copy();
        const entropy = typeof args.entropy === "string" ? import_buffer.Buffer.from(args.entropy, "hex").reverse() : args.entropy;
        const blindingNonce = typeof args.tokenAssetBlinder === "string" ? import_buffer.Buffer.from(args.tokenAssetBlinder, "hex").reverse() : args.tokenAssetBlinder;
        const asset = asset_1.AssetHash.fromBytes(
          (0, issuance_1.calculateAsset)(entropy)
        ).hex;
        const reissuanceToken = asset_1.AssetHash.fromBytes(
          (0, issuance_1.calculateReissuanceToken)(
            entropy,
            args.initialIssuanceBlinded ?? true
          )
        ).hex;
        pset.inputs[inIndex].issuanceAssetEntropy = entropy;
        pset.inputs[inIndex].issuanceBlindingNonce = blindingNonce;
        pset.inputs[inIndex].issuanceValue = args.assetAmount;
        pset.inputs[inIndex].issuanceInflationKeys = 0;
        if (args.blindedIssuance !== void 0) {
          pset.inputs[inIndex].blindedIssuance = args.blindedIssuance;
        }
        if (args.assetAddress) {
          const { blindingPublicKey, script } = processOutputDestination(
            args.assetAddress
          );
          const assetOutput = new creator_1.CreatorOutput(
            asset,
            args.assetAmount,
            script,
            blindingPublicKey,
            blindingPublicKey ? inIndex : void 0
          );
          pset.addOutput(assetOutput.toPartialOutput());
        }
        if (args.tokenAddress) {
          const { blindingPublicKey, script } = processOutputDestination(
            args.tokenAddress
          );
          const tokenOutput = new creator_1.CreatorOutput(
            reissuanceToken,
            args.tokenAmount,
            script,
            blindingPublicKey,
            blindingPublicKey ? inIndex : void 0
          );
          pset.addOutput(tokenOutput.toPartialOutput());
        }
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInPartialSignature(inIndex, ps, validator) {
        this.validateInputIndex(inIndex);
        validatePartialSignature(ps);
        if ((this.pset.inputs[inIndex].partialSigs || []).some(
          ({ pubkey }) => pubkey.equals(ps.pubkey)
        )) {
          throw new Error("Duplicated signature pubkey");
        }
        const pset = this.pset.copy();
        const sighashType = ps.signature.slice(-1)[0];
        const preimage = pset.getInputPreimage(inIndex, sighashType);
        const { signature: signature2 } = bscript.signature.decode(ps.signature);
        if (!validator(ps.pubkey, preimage, signature2)) {
          throw new Error("Invalid signature");
        }
        if (!pset.inputs[inIndex].partialSigs) {
          pset.inputs[inIndex].partialSigs = [];
        }
        pset.inputs[inIndex].partialSigs.push(ps);
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInTimeLocktime(inIndex, locktime) {
        this.validateInputIndex(inIndex);
        if (locktime < 0) {
          throw new Error("Invalid required time locktime");
        }
        const pset = this.pset.copy();
        pset.inputs[inIndex].requiredTimeLocktime = locktime;
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInHeightLocktime(inIndex, locktime) {
        this.validateInputIndex(inIndex);
        if (locktime < 0) {
          throw new Error("Invalid required height locktime");
        }
        const pset = this.pset.copy();
        pset.inputs[inIndex].requiredHeightLocktime = locktime;
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInTapKeySig(inIndex, sig, genesisBlockHash, validator) {
        this.validateInputIndex(inIndex);
        if (sig.length !== 64 && sig.length !== 65) {
          throw new Error("Invalid taproot key signature length");
        }
        if (genesisBlockHash.length !== 32) {
          throw new Error("Invalid genesis block hash length");
        }
        const pset = this.pset.copy();
        const input = pset.inputs[inIndex];
        if (!input.getUtxo()) {
          throw new Error("Missing input witness utxo");
        }
        if (input.sighashType === void 0) {
          throw new Error("Missing input sighash type");
        }
        const tweakedKey = input.getUtxo().script.slice(2);
        const sighash = pset.getInputPreimage(
          inIndex,
          input.sighashType,
          genesisBlockHash
        );
        if (!validator(tweakedKey, sighash, sig)) {
          throw new Error(`Invalid taproot key signature for input ${inIndex}`);
        }
        pset.inputs[inIndex].tapKeySig = sig;
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInTapScriptSig(inIndex, sig, genesisBlockHash, validator) {
        this.validateInputIndex(inIndex);
        if (sig.pubkey.length !== 32) {
          throw new Error("Invalid xonly pubkey length");
        }
        if (sig.leafHash.length !== 32) {
          throw new Error("Invalid leaf hash length");
        }
        if (sig.signature.length !== 64 && sig.signature.length !== 65) {
          throw new Error("Invalid signature length");
        }
        if (genesisBlockHash.length !== 32) {
          throw new Error("Invalid genesis block hash length");
        }
        const pset = this.pset.copy();
        const input = pset.inputs[inIndex];
        if (input.sighashType === void 0) {
          throw new Error("Missing input sighash type");
        }
        const sighash = pset.getInputPreimage(
          inIndex,
          input.sighashType,
          genesisBlockHash,
          sig.leafHash
        );
        if (!validator(sig.pubkey, sighash, sig.signature)) {
          throw new Error(`Invalid taproot script signature for input ${inIndex}`);
        }
        if (!pset.inputs[inIndex].tapScriptSig) {
          pset.inputs[inIndex].tapScriptSig = [];
        }
        pset.inputs[inIndex].tapScriptSig.push(sig);
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInTapLeafScript(inIndex, tapLeafScript) {
        this.validateInputIndex(inIndex);
        const pset = this.pset.copy();
        if (!pset.inputs[inIndex].tapLeafScript) {
          pset.inputs[inIndex].tapLeafScript = [];
        }
        pset.inputs[inIndex].tapLeafScript.push(tapLeafScript);
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInTapBIP32Derivation(inIndex, d) {
        this.validateInputIndex(inIndex);
        if (d.pubkey.length !== 33) {
          throw new Error("Invalid input taproot pubkey length");
        }
        const pset = this.pset.copy();
        if (!pset.inputs[inIndex].tapBip32Derivation) {
          pset.inputs[inIndex].tapBip32Derivation = [];
        }
        if (pset.inputs[inIndex].bip32Derivation.some(
          ({ pubkey }) => pubkey.equals(d.pubkey)
        )) {
          throw new Error("Duplicated taproot bip32 derivation pubkey");
        }
        pset.inputs[inIndex].tapBip32Derivation.push(d);
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInTapInternalKey(inIndex, tapInternalKey) {
        this.validateInputIndex(inIndex);
        if (tapInternalKey.length !== 32) {
          throw new Error("Invalid taproot internal key length");
        }
        if (this.pset.inputs[inIndex].tapInternalKey && this.pset.inputs[inIndex].tapInternalKey.length > 0) {
          throw new Error("Duplicated taproot internal key");
        }
        const pset = this.pset.copy();
        pset.inputs[inIndex].tapInternalKey = tapInternalKey;
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInTapMerkleRoot(inIndex, tapMerkleRoot) {
        this.validateInputIndex(inIndex);
        if (tapMerkleRoot.length !== 32) {
          throw new Error("Invalid taproot merkle root length");
        }
        if (this.pset.inputs[inIndex].tapMerkleRoot && this.pset.inputs[inIndex].tapMerkleRoot.length > 0) {
          throw new Error("Duplicated taproot merkle root");
        }
        const pset = this.pset.copy();
        pset.inputs[inIndex].tapMerkleRoot = tapMerkleRoot;
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInExplicitValue(inIndex, explicitValue, explicitValueProof) {
        this.validateInputIndex(inIndex);
        const pset = this.pset.copy();
        pset.inputs[inIndex].explicitValue = explicitValue;
        pset.inputs[inIndex].explicitValueProof = explicitValueProof;
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addInExplicitAsset(inIndex, explicitAsset, explicitAssetProof) {
        this.validateInputIndex(inIndex);
        const pset = this.pset.copy();
        pset.inputs[inIndex].explicitAsset = explicitAsset;
        pset.inputs[inIndex].explicitAssetProof = explicitAssetProof;
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addOutBIP32Derivation(outIndex, d) {
        this.validateOutputIndex(outIndex);
        if (d.pubkey.length !== 33) {
          throw new Error("Invalid pubkey length");
        }
        const pset = this.pset.copy();
        if (!pset.outputs[outIndex].bip32Derivation) {
          pset.outputs[outIndex].bip32Derivation = [];
        }
        if (pset.outputs[outIndex].bip32Derivation.some(
          ({ pubkey }) => pubkey.equals(d.pubkey)
        )) {
          throw new Error("Duplicated bip32 derivation pubkey");
        }
        pset.outputs[outIndex].bip32Derivation.push(d);
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addOutRedeemScript(outIndex, redeemScript) {
        this.validateOutputIndex(outIndex);
        const pset = this.pset.copy();
        pset.outputs[outIndex].redeemScript = redeemScript;
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addOutWitnessScript(outIndex, witnessScript) {
        this.validateOutputIndex(outIndex);
        const pset = this.pset.copy();
        pset.outputs[outIndex].witnessScript = witnessScript;
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addOutTapInternalKey(outIndex, tapInternalKey) {
        this.validateOutputIndex(outIndex);
        if (tapInternalKey.length !== 32) {
          throw new Error("Invalid taproot internal key length");
        }
        if (this.pset.outputs[outIndex].tapInternalKey && this.pset.outputs[outIndex].tapInternalKey.length > 0) {
          throw new Error("Duplicated taproot internal key");
        }
        const pset = this.pset.copy();
        pset.outputs[outIndex].tapInternalKey = tapInternalKey;
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addOutTapTree(outIndex, tapTree) {
        this.validateOutputIndex(outIndex);
        if (this.pset.outputs[outIndex].tapTree) {
          throw new Error("Duplicated taproot tree");
        }
        const pset = this.pset.copy();
        pset.outputs[outIndex].tapTree = tapTree;
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      addOutTapBIP32Derivation(outIndex, d) {
        this.validateOutputIndex(outIndex);
        if (d.pubkey.length !== 33) {
          throw new Error("Invalid output taproot pubkey length");
        }
        const pset = this.pset.copy();
        if (!pset.outputs[outIndex].tapBip32Derivation) {
          pset.outputs[outIndex].tapBip32Derivation = [];
        }
        if (pset.outputs[outIndex].bip32Derivation.some(
          ({ pubkey }) => pubkey.equals(d.pubkey)
        )) {
          throw new Error("Duplicated taproot bip32 derivation pubkey");
        }
        pset.outputs[outIndex].tapBip32Derivation.push(d);
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      validateIssuanceInput(inIndex) {
        this.validateInputIndex(inIndex);
        const input = this.pset.inputs[inIndex];
        if (input.issuanceAssetEntropy && input.issuanceAssetEntropy.length > 0) {
          throw new Error("Input " + inIndex + " already has an issuance");
        }
      }
      validateReissuanceInput(inIndex) {
        this.validateInputIndex(inIndex);
        const input = this.pset.inputs[inIndex];
        if (input.issuanceAssetEntropy && input.issuanceAssetEntropy.length > 0) {
          throw new Error(`Input ${inIndex} already has an issuance`);
        }
        const prevout = input.getUtxo();
        if (!prevout) {
          throw new Error("Input is missing prevout (non-)witness utxo");
        }
        if (prevout.nonce.length <= 1) {
          throw new Error("Input prevout (non-)witness utxo must be confidential");
        }
      }
      validateOutputIndex(outIndex) {
        if (outIndex < 0 || outIndex >= this.pset.globals.outputCount) {
          throw new Error("Output index out of range");
        }
      }
      validateInputIndex(inIndex) {
        if (inIndex < 0 || inIndex >= this.pset.globals.inputCount) {
          throw new Error("Input index out of range");
        }
      }
    };
    exports2.Updater = Updater;
    function validateAddInIssuanceArgs(args) {
      const assetAmount = args.assetAmount || 0;
      const tokenAmount = args.tokenAmount || 0;
      if (assetAmount <= 0 && tokenAmount <= 0) {
        throw new Error("Either asset or token amounts must be a positive number");
      }
      if (assetAmount > 0) {
        if (!args.assetAddress) {
          throw new Error(
            "Asset address must be defined if asset amount is non-zero"
          );
        }
      }
      if (tokenAmount > 0) {
        if (!args.tokenAddress) {
          throw new Error(
            "Token address must be defined if token amount is non-zero"
          );
        }
      }
      if (!matchAddressesNetworkType(args.assetAddress, args.tokenAddress)) {
        throw new Error("Asset and token addresses must be of same network");
      }
    }
    function validateAddInReissuanceArgs(args) {
      const entropy = typeof args.entropy === "string" ? import_buffer.Buffer.from(args.entropy, "hex").reverse() : args.entropy;
      if (entropy.length !== 32) {
        throw new Error("Invalid entropy length");
      }
      const blinder = typeof args.tokenAssetBlinder === "string" ? import_buffer.Buffer.from(args.tokenAssetBlinder, "hex").reverse() : args.tokenAssetBlinder;
      if (blinder.length !== 32) {
        throw new Error("Invalid token asset blinder length");
      }
      if (args.assetAmount <= 0) {
        throw new Error("Asset amount must be a positive number");
      }
      if (args.tokenAmount <= 0) {
        throw new Error("Token amount must be a positive number");
      }
      if (!args.assetAddress) {
        throw new Error("Missing asset address");
      }
      if (!args.assetAddress) {
        throw new Error("Missing token address");
      }
      if (!matchAddressesNetworkType(args.assetAddress, args.tokenAddress)) {
        throw new Error(
          "Asset and token addresses must be both of same network and both confidential"
        );
      }
    }
    function matchAddressesNetworkType(addrA, addrB) {
      if (!addrA || !addrB) {
        return true;
      }
      if (typeof addrA === "string" && typeof addrB === "string") {
        const netA = (0, address_1.getNetwork)(addrA);
        const netB = (0, address_1.getNetwork)(addrB);
        return netA.name === netB.name;
      }
      return true;
    }
    function validatePartialSignature(psig) {
      if (psig.pubkey.length !== 33) {
        throw new Error("Invalid pubkey length");
      }
      bscript.signature.decode(psig.signature);
    }
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/blinder.js
var require_blinder = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/blinder.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Blinder = void 0;
    var asset_1 = require_asset();
    var issuance_1 = require_issuance();
    var transaction_1 = require_transaction();
    var Blinder = class {
      constructor(pset, ownedInputs, validator, generator) {
        if (ownedInputs.length === 0) {
          throw new Error("Missing owned inputs");
        }
        pset.sanityCheck();
        this.pset = pset;
        this.ownedInputs = ownedInputs;
        this.blindingValidator = validator;
        this.blindingGenerator = generator;
      }
      blindNonLast(args) {
        this.blind(args, false);
      }
      blindLast(args) {
        this.blind(args, true);
      }
      blind(args, lastBlinder) {
        if (this.pset.isFullyBlinded()) {
          return;
        }
        const { issuanceBlindingArgs, outputBlindingArgs } = args;
        if (outputBlindingArgs.length === 0) {
          throw new Error("missing outputs blinding args");
        }
        if (issuanceBlindingArgs && issuanceBlindingArgs.length > 0) {
          issuanceBlindingArgs.forEach(
            (arg) => this.validateIssuanceBlindingArgs(arg)
          );
        }
        const sortedOutputBlindingArgs = outputBlindingArgs.sort(
          (a, b) => a.index - b.index
        );
        sortedOutputBlindingArgs.forEach((arg, i) => {
          const isLastBlinder = lastBlinder && i === sortedOutputBlindingArgs.length - 1;
          this.validateOutputBlindingArgs(arg, isLastBlinder);
        });
        this.validateBlindingData(lastBlinder, outputBlindingArgs);
        const inputScalar = this.calculateInputScalar(issuanceBlindingArgs);
        const outputScalar = this.calculateOutputScalar(sortedOutputBlindingArgs);
        const pset = this.pset.copy();
        if (issuanceBlindingArgs) {
          issuanceBlindingArgs.forEach(
            ({
              index,
              issuanceValueCommitment,
              issuanceValueRangeProof,
              issuanceValueBlindProof,
              issuanceTokenCommitment,
              issuanceTokenRangeProof,
              issuanceTokenBlindProof
            }) => {
              pset.inputs[index].issuanceValueCommitment = issuanceValueCommitment;
              pset.inputs[index].issuanceValueRangeproof = issuanceValueRangeProof;
              pset.inputs[index].issuanceBlindValueProof = issuanceValueBlindProof;
              pset.inputs[index].issuanceInflationKeysCommitment = issuanceTokenCommitment;
              pset.inputs[index].issuanceInflationKeysRangeproof = issuanceTokenRangeProof;
              pset.inputs[index].issuanceBlindInflationKeysProof = issuanceTokenBlindProof;
            }
          );
        }
        for (let i = 0; i < sortedOutputBlindingArgs.length; i++) {
          const {
            index,
            assetBlinder,
            assetCommitment,
            assetSurjectionProof,
            assetBlindProof,
            valueBlinder,
            nonceCommitment,
            nonce
          } = sortedOutputBlindingArgs[i];
          let { valueCommitment, valueRangeProof, valueBlindProof } = sortedOutputBlindingArgs[i];
          const targetOutput = pset.outputs[index];
          const value2 = targetOutput.value.toString(10);
          if (lastBlinder && i === sortedOutputBlindingArgs.length - 1) {
            const lastValueBlinder = this.calculateLastValueBlinder(
              valueBlinder,
              outputScalar,
              inputScalar
            );
            valueCommitment = this.blindingGenerator.lastValueCommitment(
              value2,
              assetCommitment,
              lastValueBlinder
            );
            valueRangeProof = this.blindingGenerator.lastValueRangeProof(
              value2,
              targetOutput.asset,
              valueCommitment,
              assetCommitment,
              lastValueBlinder,
              assetBlinder,
              nonce,
              targetOutput.script || import_buffer.Buffer.alloc(0)
            );
            valueBlindProof = this.blindingGenerator.lastBlindValueProof(
              value2,
              valueCommitment,
              assetCommitment,
              lastValueBlinder
            );
          }
          pset.outputs[index].valueCommitment = valueCommitment;
          pset.outputs[index].valueRangeproof = valueRangeProof;
          pset.outputs[index].blindValueProof = valueBlindProof;
          pset.outputs[index].assetCommitment = assetCommitment;
          pset.outputs[index].assetSurjectionProof = assetSurjectionProof;
          pset.outputs[index].blindAssetProof = assetBlindProof;
          pset.outputs[index].ecdhPubkey = nonceCommitment;
          pset.outputs[index].blinderIndex = void 0;
        }
        if (!lastBlinder) {
          if (!pset.globals.scalars) {
            pset.globals.scalars = [];
          }
          pset.globals.scalars.push(outputScalar);
        } else {
          pset.globals.scalars = void 0;
        }
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
      }
      calculateInputScalar(issuanceBlindingArgs) {
        let scalar = import_buffer.Buffer.from(transaction_1.ZERO);
        for (const input of this.ownedInputs) {
          scalar = this.blindingGenerator.computeAndAddToScalarOffset(
            scalar,
            input.value,
            input.assetBlindingFactor,
            input.valueBlindingFactor
          );
          const pInput = this.pset.inputs[input.index];
          if (pInput.hasIssuance() || pInput.hasReissuance()) {
            const issuance = issuanceBlindingArgs && issuanceBlindingArgs.find(({ index }) => index === input.index);
            if (issuance) {
              const valueBlinder = issuance.issuanceValueBlinder && issuance.issuanceValueBlinder.length > 0 ? issuance.issuanceValueBlinder : transaction_1.ZERO;
              scalar = this.blindingGenerator.computeAndAddToScalarOffset(
                scalar,
                pInput.issuanceValue ? pInput.issuanceValue.toString(10) : "0",
                transaction_1.ZERO,
                valueBlinder
              );
              if (pInput.issuanceInflationKeys > 0) {
                const tokenBlinder = issuance.issuanceTokenBlinder && issuance.issuanceTokenBlinder.length > 0 ? issuance.issuanceTokenBlinder : transaction_1.ZERO;
                scalar = this.blindingGenerator.computeAndAddToScalarOffset(
                  scalar,
                  pInput.issuanceInflationKeys.toString(10),
                  transaction_1.ZERO,
                  tokenBlinder
                );
              }
            }
          }
        }
        return scalar;
      }
      calculateOutputScalar(outputBlindingArgs) {
        let scalar = import_buffer.Buffer.from(transaction_1.ZERO);
        for (const args of outputBlindingArgs) {
          const output = this.pset.outputs[args.index];
          scalar = this.blindingGenerator.computeAndAddToScalarOffset(
            scalar,
            output.value.toString(10),
            args.assetBlinder,
            args.valueBlinder
          );
        }
        return scalar;
      }
      calculateLastValueBlinder(valueBlinder, outputScalar, inputScalar) {
        const offset = this.blindingGenerator.subtractScalars(
          outputScalar,
          inputScalar
        );
        let lastValueBlinder = this.blindingGenerator.subtractScalars(
          valueBlinder,
          offset
        );
        if (this.pset.globals.scalars) {
          for (const scalar of this.pset.globals.scalars) {
            lastValueBlinder = this.blindingGenerator.subtractScalars(
              lastValueBlinder,
              scalar
            );
          }
        }
        return lastValueBlinder;
      }
      validateIssuanceBlindingArgs(args) {
        const {
          index,
          issuanceAsset,
          issuanceToken,
          issuanceValueCommitment,
          issuanceTokenCommitment,
          issuanceValueRangeProof,
          issuanceTokenRangeProof,
          issuanceValueBlindProof,
          issuanceTokenBlindProof,
          issuanceValueBlinder,
          issuanceTokenBlinder
        } = args;
        if (index < 0 || index >= this.pset.globals.inputCount) {
          throw new Error("Input index out of range");
        }
        const targetInput = this.pset.inputs[index];
        if (!targetInput.hasIssuance() && !targetInput.hasReissuance()) {
          throw new Error("Missing issuance on target input");
        }
        if (issuanceAsset.length === 0) {
          throw new Error("Missing issuance asset");
        }
        if (issuanceAsset.length !== 32) {
          throw new Error("Invalid issuance asset length");
        }
        if (issuanceValueCommitment.length === 0) {
          throw new Error("Missing issuance value commitment");
        }
        if (issuanceValueCommitment.length !== 33) {
          throw new Error("Invalid issuance value commitment length");
        }
        if (issuanceValueBlinder.length === 0) {
          throw new Error("Missing issuance value blinder");
        }
        if (issuanceValueBlinder.length !== 32) {
          throw new Error("Invalid issuance value blinder length");
        }
        if (issuanceValueRangeProof.length === 0) {
          throw new Error("Missing issuance value range proof");
        }
        if (issuanceValueBlindProof.length === 0) {
          throw new Error("Missing issuance blind value proof");
        }
        if (targetInput.issuanceInflationKeys > 0) {
          if (issuanceToken.length === 0) {
            throw new Error("Missing issuance token");
          }
          if (issuanceToken.length !== 32) {
            throw new Error("Invalid issuance token length");
          }
          if (issuanceTokenCommitment.length === 0) {
            throw new Error("Missing issuance token commitment");
          }
          if (issuanceTokenCommitment.length !== 33) {
            throw new Error("Invalid issuance token commitment length");
          }
          if (issuanceTokenBlinder.length === 0) {
            throw new Error("Missing issuance token blinder");
          }
          if (issuanceTokenBlinder.length !== 32) {
            throw new Error("Invalid issuance token blinder length");
          }
          if (issuanceTokenRangeProof.length === 0) {
            throw new Error("Missing issuance token range proof");
          }
          if (issuanceTokenBlindProof.length === 0) {
            throw new Error("Missing issuance blind token value proof");
          }
        }
      }
      async validateOutputBlindingArgs(args, lastBlinder) {
        const {
          index,
          nonce,
          nonceCommitment,
          valueCommitment,
          assetCommitment,
          valueRangeProof,
          assetSurjectionProof,
          valueBlindProof,
          assetBlindProof,
          valueBlinder,
          assetBlinder
        } = args;
        if (index < 0 || index >= this.pset.globals.outputCount) {
          throw new Error("Output index out of range");
        }
        const targetOutput = this.pset.outputs[index];
        if (!targetOutput.needsBlinding()) {
          throw new Error(
            "Target output does not need blinding (does not have a blinding pubkey set)"
          );
        }
        if (!this.ownOutput(targetOutput.blinderIndex)) {
          throw new Error("Output is not owned by this blinder");
        }
        if (nonce.length === 0) {
          throw new Error("Missing nonce");
        }
        if (nonce.length !== 32) {
          throw new Error("Invalid nonce length");
        }
        if (nonceCommitment.length === 0) {
          throw new Error("Missing nonce commitment");
        }
        if (nonceCommitment.length !== 33) {
          throw new Error("Invalid nonce commitment length");
        }
        if (valueBlinder.length === 0) {
          throw new Error("Missing value blinder");
        }
        if (valueBlinder.length !== 32) {
          throw new Error("Invalid value blinder length");
        }
        if (assetBlinder.length === 0) {
          throw new Error("Missing asset blinder");
        }
        if (assetBlinder.length !== 32) {
          throw new Error("Invalid asset blinder length");
        }
        if (assetCommitment.length === 0) {
          throw new Error("Missing asset commitment");
        }
        if (assetCommitment.length !== 33) {
          throw new Error("Invalid asset commitment length");
        }
        if (assetSurjectionProof.length === 0) {
          throw new Error("Missing asset surjection proof");
        }
        if (assetBlindProof.length === 0) {
          throw new Error("Missing blind asset proof");
        }
        if (!lastBlinder) {
          if (valueCommitment.length === 0) {
            throw new Error("Missing value commitment");
          }
          if (valueCommitment.length !== 33) {
            throw new Error("Invalid value commitment length");
          }
          if (valueRangeProof.length === 0) {
            throw new Error("Missing value range proof");
          }
          if (valueBlindProof.length === 0) {
            throw new Error("Missing blind value proof");
          }
        }
      }
      ownOutput(blinderIndex) {
        return this.ownedInputs.find(({ index }) => index === blinderIndex) !== void 0;
      }
      validateBlindingData(isLastBlinder, outputBlindingArgs) {
        const inAssetsAndBlinders = this.pset.inputs.map((input, i) => {
          const ownedInput = this.ownedInputs.find(({ index }) => index === i);
          return ownedInput ? {
            asset: ownedInput.asset,
            assetBlinder: ownedInput.assetBlindingFactor
          } : {
            asset: asset_1.AssetHash.fromBytes(input.getUtxo().asset).bytesWithoutPrefix,
            assetBlinder: transaction_1.ZERO
          };
        });
        for (const input of this.pset.inputs) {
          if (input.hasIssuance() || input.hasReissuance()) {
            inAssetsAndBlinders.push({
              asset: input.getIssuanceAssetHash(),
              assetBlinder: transaction_1.ZERO
            });
            if (input.issuanceInflationKeys > 0) {
              const entropy = input.getIssuanceEntropy();
              const token = (0, issuance_1.calculateReissuanceToken)(
                entropy,
                input.blindedIssuance ?? true
              );
              inAssetsAndBlinders.push({
                asset: token,
                assetBlinder: transaction_1.ZERO
              });
            }
          }
        }
        const inputAssets = inAssetsAndBlinders.map((v) => v.asset);
        const inputAssetBlinders = inAssetsAndBlinders.map((v) => v.assetBlinder);
        for (let i = 0; i < outputBlindingArgs.length; i++) {
          const {
            index,
            assetBlinder,
            assetCommitment,
            assetSurjectionProof,
            assetBlindProof,
            valueCommitment,
            valueRangeProof,
            valueBlindProof
          } = outputBlindingArgs[i];
          const targetOutput = this.pset.outputs[index];
          const lastBlinder = isLastBlinder && i === outputBlindingArgs.length - 1;
          if (!this.blindingValidator.verifyAssetSurjectionProof(
            inputAssets,
            inputAssetBlinders,
            targetOutput.asset,
            assetBlinder,
            assetSurjectionProof
          )) {
            throw new Error("Invalid output asset surjection proof");
          }
          if (!this.blindingValidator.verifyBlindAssetProof(
            targetOutput.asset,
            assetCommitment,
            assetBlindProof
          )) {
            throw new Error("Invalid output asset blind proof");
          }
          if (!lastBlinder) {
            if (!this.blindingValidator.verifyValueRangeProof(
              valueRangeProof,
              valueCommitment,
              assetCommitment,
              targetOutput.script
            )) {
              throw new Error("Invalid output value range proof");
            }
            if (!this.blindingValidator.verifyBlindValueProof(
              valueBlindProof,
              valueCommitment,
              assetCommitment
            )) {
              throw new Error("Invalid output value blind proof");
            }
          }
        }
      }
    };
    exports2.Blinder = Blinder;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/signer.js
var require_signer = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/signer.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Signer = void 0;
    var transaction_1 = require_transaction();
    var updater_1 = require_updater();
    var utils_1 = require_utils7();
    var Signer = class {
      constructor(pset) {
        pset.sanityCheck();
        this.pset = pset;
      }
      addSignature(inIndex, sigData, validator) {
        if (inIndex < 0 || inIndex >= this.pset.globals.inputCount) {
          throw new Error("Input index out of range");
        }
        const input = this.pset.inputs[inIndex];
        if (input.isFinalized()) {
          throw new Error("Input is already finalized");
        }
        if (input.sighashType === void 0) {
          throw new Error("Missing input sighash type");
        }
        if ((input.sighashType & 31) === transaction_1.Transaction.SIGHASH_ALL) {
          if (this.pset.outputs.some(
            (out) => out.needsBlinding() && !out.isFullyBlinded()
          )) {
            throw new Error("Pset must be fully blinded");
          }
        }
        if (input.isTaproot()) {
          return this._addTaprootSignature(inIndex, sigData, validator);
        }
        return this._addSignature(inIndex, sigData, validator);
      }
      _addSignature(inIndex, data, validator) {
        const input = this.pset.inputs[inIndex];
        const pset = this.pset.copy();
        const sighashType = input.sighashType;
        const { partialSig, witnessScript, redeemScript } = data;
        if (!partialSig) {
          throw new Error("Missing partial signature for input");
        }
        if (partialSig.signature.slice(-1)[0] !== sighashType) {
          throw new Error("Input and signature sighash types must match");
        }
        const u = new updater_1.Updater(pset);
        if (witnessScript && witnessScript.length > 0) {
          u.addInWitnessScript(inIndex, witnessScript);
          if (!input.witnessUtxo) {
            u.addInWitnessUtxo(
              inIndex,
              input.nonWitnessUtxo.outs[input.previousTxIndex]
            );
            pset.inputs[inIndex].nonWitnessUtxo = void 0;
          }
        }
        if (redeemScript && redeemScript.length > 0) {
          u.addInRedeemScript(inIndex, redeemScript);
          const isSegwit = (0, utils_1.isP2WPKH)(redeemScript) || (0, utils_1.isP2WSH)(redeemScript);
          if (isSegwit && !input.witnessUtxo) {
            u.addInWitnessUtxo(
              inIndex,
              input.nonWitnessUtxo.outs[input.previousTxIndex]
            );
            pset.inputs[inIndex].nonWitnessUtxo = void 0;
          }
        }
        if (pset.inputs[inIndex].nonWitnessUtxo) {
          const script = input.nonWitnessUtxo.outs[input.previousTxIndex].script;
          const isSegwit = (0, utils_1.isP2WPKH)(script) || (0, utils_1.isP2WSH)(script);
          if (isSegwit) {
            u.addInWitnessUtxo(
              inIndex,
              input.nonWitnessUtxo.outs[input.previousTxIndex]
            );
            pset.inputs[inIndex].nonWitnessUtxo = void 0;
          }
        }
        u.addInPartialSignature(inIndex, partialSig, validator);
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
      _addTaprootSignature(inIndex, data, validator) {
        const pset = this.pset.copy();
        const { tapKeySig, tapScriptSigs, genesisBlockHash } = data;
        if (!tapKeySig && (!tapScriptSigs || !tapScriptSigs.length)) {
          throw new Error("Missing taproot signature");
        }
        const u = new updater_1.Updater(pset);
        if (!!tapKeySig) {
          u.addInTapKeySig(inIndex, tapKeySig, genesisBlockHash, validator);
        }
        if (!!tapScriptSigs) {
          tapScriptSigs.forEach((tapScriptSig) => {
            u.addInTapScriptSig(inIndex, tapScriptSig, genesisBlockHash, validator);
          });
        }
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
    };
    exports2.Signer = Signer;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/bip371.js
var require_bip3712 = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/bip371.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findTapLeafToFinalize = exports2.sortSignatures = exports2.serializeTaprootSignature = exports2.toXOnly = void 0;
    var bip341_1 = require_bip341();
    var utils_1 = require_utils7();
    var toXOnly2 = (pubkey) => {
      switch (pubkey.length) {
        case 32:
          return pubkey;
        case 33:
          return import_buffer.Buffer.from(pubkey.slice(1));
        default:
          throw new Error("Invalid pubkey length");
      }
    };
    exports2.toXOnly = toXOnly2;
    function serializeTaprootSignature2(sig, sighashType) {
      const sighashTypeByte = sighashType ? import_buffer.Buffer.from([sighashType]) : import_buffer.Buffer.from([]);
      return import_buffer.Buffer.concat([sig, sighashTypeByte]);
    }
    exports2.serializeTaprootSignature = serializeTaprootSignature2;
    function sortSignatures(input, tapLeaf) {
      const leafHash = (0, bip341_1.tapLeafHash)({
        scriptHex: tapLeaf.script.toString("hex"),
        version: tapLeaf.leafVersion
      });
      return (input.tapScriptSig || []).filter((tss) => tss.leafHash.equals(leafHash)).map((tss) => addPubkeyPositionInScript(tapLeaf.script, tss)).sort((t1, t2) => t2.positionInScript - t1.positionInScript).map((t) => t.signature);
    }
    exports2.sortSignatures = sortSignatures;
    function addPubkeyPositionInScript(script, tss) {
      return Object.assign(
        {
          positionInScript: (0, utils_1.pubkeyPositionInScript)(tss.pubkey, script)
        },
        tss
      );
    }
    function findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {
      if (!input.tapScriptSig || !input.tapScriptSig.length)
        throw new Error(
          `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`
        );
      const tapLeaf = (input.tapLeafScript || []).sort((a, b) => a.controlBlock.length - b.controlBlock.length).find(
        (leaf) => canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize)
      );
      if (!tapLeaf)
        throw new Error(
          `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`
        );
      return tapLeaf;
    }
    exports2.findTapLeafToFinalize = findTapLeafToFinalize;
    function canFinalizeLeaf(leaf, tapScriptSig, hash) {
      const leafHash = (0, bip341_1.tapLeafHash)({
        scriptHex: leaf.script.toString("hex"),
        version: leaf.leafVersion
      });
      const whiteListedHash = !hash || hash.equals(leafHash);
      return whiteListedHash && tapScriptSig.find((tss) => tss.leafHash.equals(leafHash)) !== void 0;
    }
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/finalizer.js
var require_finalizer = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/finalizer.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Finalizer = void 0;
    var __1 = require_src6();
    var bip371_1 = require_bip3712();
    var utils_1 = require_utils7();
    var Finalizer = class {
      constructor(pset) {
        pset.sanityCheck();
        this.pset = pset;
      }
      finalize() {
        const pset = this.pset.copy();
        pset.inputs.forEach((_, i) => {
          this.finalizeInput(i);
        });
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
      }
      finalizeInput(inIndex, finalizeFunc = defaultFinalizer) {
        if (inIndex < 0 || inIndex >= this.pset.globals.inputCount) {
          throw new Error("Input index out of range");
        }
        const input = this.pset.inputs[inIndex];
        if (input.isFinalized()) {
          return this;
        }
        if (input.sighashType === void 0) {
          throw new Error("Missing input sighash type");
        }
        if (!input.getUtxo()) {
          throw new Error("Missing input (non-)witness utxo");
        }
        const pset = this.pset.copy();
        const { finalScriptSig, finalScriptWitness } = finalizeFunc(inIndex, pset);
        if (finalScriptSig) {
          pset.inputs[inIndex].finalScriptSig = finalScriptSig;
        }
        if (finalScriptWitness) {
          pset.inputs[inIndex].finalScriptWitness = finalScriptWitness;
        }
        if (!finalScriptSig && !finalScriptWitness && !input.finalScriptWitness) {
          throw new Error(`Unknown error finalizing input #${inIndex}`);
        }
        pset.sanityCheck();
        this.pset.globals = pset.globals;
        this.pset.inputs = pset.inputs;
        this.pset.outputs = pset.outputs;
        return this;
      }
    };
    exports2.Finalizer = Finalizer;
    function getScriptFromInput(input) {
      const res = {
        script: null,
        isSegwit: false,
        isP2SH: false,
        isP2WSH: false
      };
      res.isP2SH = !!input.redeemScript;
      res.isP2WSH = !!input.witnessScript;
      if (input.witnessScript) {
        res.script = input.witnessScript;
      } else if (input.redeemScript) {
        res.script = input.redeemScript;
      } else {
        if (input.nonWitnessUtxo) {
          res.script = input.nonWitnessUtxo.outs[input.previousTxIndex].script;
        } else if (input.witnessUtxo) {
          res.script = input.witnessUtxo.script;
        }
      }
      if (input.witnessScript || (0, utils_1.isP2WPKH)(res.script)) {
        res.isSegwit = true;
      }
      return res;
    }
    var defaultFinalizer = (inIndex, pset) => {
      const input = pset.inputs[inIndex];
      if ((!input.partialSigs || input.partialSigs.length === 0) && (!input.tapKeySig || input.tapKeySig.length === 0) && (!input.tapScriptSig || input.tapScriptSig.length === 0)) {
        throw new Error(
          `Missing partial signatures for input at index ${inIndex}. If the script does not have a CHECKSIG operation you must pass a custom finalizer function`
        );
      }
      if (input.isTaproot()) return finalizeTaprootInput(inIndex, pset);
      return finalizeInput(inIndex, pset);
    };
    var finalizeInput = (inIndex, pset) => {
      const input = pset.inputs[inIndex];
      const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(input);
      if (!script) throw new Error(`No script found for input #${inIndex}`);
      return getFinalScripts(inIndex, input, script, isSegwit, isP2SH, isP2WSH);
    };
    var finalizeTaprootInput = (inIndex, pset) => {
      const input = pset.inputs[inIndex];
      if (!input.witnessUtxo)
        throw new Error(
          `Cannot finalize input #${inIndex}. Missing withness utxo.`
        );
      if (input.tapKeySig) {
        return {
          finalScriptWitness: (0, utils_1.witnessStackToScriptWitness)([
            input.tapKeySig
          ])
        };
      } else {
        return getTaprootFinalScripts(inIndex, input);
      }
    };
    function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {
      const scriptType = (0, utils_1.classifyScript)(script);
      if (!canFinalize(input, script, scriptType))
        throw new Error(`Can not finalize input #${inputIndex}`);
      return prepareFinalScripts(
        script,
        scriptType,
        input.partialSigs,
        isSegwit,
        isP2SH,
        isP2WSH
      );
    }
    function prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH) {
      if (scriptType === "nonstandard")
        return {
          finalScriptSig: void 0,
          finalScriptWitness: void 0
        };
      let finalScriptSig;
      let finalScriptWitness;
      const payment = (0, utils_1.getPayment)(script, scriptType, partialSig);
      const p2wsh2 = !isP2WSH ? null : __1.payments.p2wsh({ redeem: payment });
      const p2sh2 = !isP2SH ? null : __1.payments.p2sh({ redeem: p2wsh2 || payment });
      if (isSegwit) {
        if (p2wsh2) {
          finalScriptWitness = (0, utils_1.witnessStackToScriptWitness)(
            p2wsh2.witness
          );
        } else {
          finalScriptWitness = (0, utils_1.witnessStackToScriptWitness)(
            payment.witness
          );
        }
        if (p2sh2) {
          finalScriptSig = p2sh2.input;
        }
      } else {
        if (p2sh2) {
          finalScriptSig = p2sh2.input;
        } else {
          finalScriptSig = payment.input;
        }
      }
      return {
        finalScriptSig,
        finalScriptWitness
      };
    }
    function canFinalize(input, script, scriptType) {
      switch (scriptType) {
        case "pubkey":
        case "pubkeyhash":
        case "witnesspubkeyhash":
          return (0, utils_1.hasSigs)(1, input.partialSigs);
        case "multisig":
          const p2ms2 = __1.payments.p2ms({ output: script });
          return (0, utils_1.hasSigs)(p2ms2.m, input.partialSigs, p2ms2.pubkeys);
        default:
          return false;
      }
    }
    function getTaprootFinalScripts(inputIndex, input, tapLeafHashToFinalize) {
      const tapLeaf = (0, bip371_1.findTapLeafToFinalize)(
        input,
        inputIndex,
        tapLeafHashToFinalize
      );
      try {
        const sigs = (0, bip371_1.sortSignatures)(input, tapLeaf);
        const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);
        return {
          finalScriptWitness: (0, utils_1.witnessStackToScriptWitness)(witness)
        };
      } catch (err) {
        throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);
      }
    }
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/extractor.js
var require_extractor = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/extractor.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Extractor = void 0;
    var asset_1 = require_asset();
    var transaction_1 = require_transaction();
    var value_1 = require_value();
    var utils_1 = require_utils7();
    var Extractor = class {
      static extract(pset) {
        pset.sanityCheck();
        if (!pset.isComplete()) {
          throw new Error(
            "Pset must be completed to extract final raw transaction"
          );
        }
        const tx = new transaction_1.Transaction();
        tx.version = pset.globals.txVersion;
        tx.locktime = pset.locktime();
        pset.inputs.forEach((input) => {
          tx.addInput(input.previousTxid, input.previousTxIndex, input.sequence);
          const inIndex = tx.ins.length - 1;
          if (input.hasIssuance() || input.hasReissuance()) {
            const assetAmount = input.issuanceValueCommitment && input.issuanceValueCommitment.length > 0 ? input.issuanceValueCommitment : input.issuanceValue > 0 ? value_1.ElementsValue.fromNumber(input.issuanceValue).bytes : import_buffer.Buffer.of(0);
            const tokenAmount = input.issuanceInflationKeysCommitment && input.issuanceInflationKeysCommitment.length > 0 ? input.issuanceInflationKeysCommitment : input.issuanceInflationKeys > 0 ? value_1.ElementsValue.fromNumber(input.issuanceInflationKeys).bytes : import_buffer.Buffer.of(0);
            tx.ins[inIndex].issuance = {
              assetAmount,
              tokenAmount,
              assetEntropy: input.issuanceAssetEntropy,
              assetBlindingNonce: input.issuanceBlindingNonce
            };
            if (input.issuanceValueRangeproof && input.issuanceValueRangeproof.length > 0) {
              tx.ins[inIndex].issuanceRangeProof = input.issuanceValueRangeproof;
            }
            if (input.issuanceInflationKeysRangeproof && input.issuanceInflationKeysRangeproof.length > 0) {
              tx.ins[inIndex].inflationRangeProof = input.issuanceInflationKeysRangeproof;
            }
          }
          tx.ins[inIndex].isPegin = input.peginWitness && input.peginWitness.length > 0;
          if (tx.ins[inIndex].isPegin) {
            tx.ins[inIndex].peginWitness = input.peginWitness;
          }
          if (input.finalScriptSig && input.finalScriptSig.length > 0) {
            tx.ins[inIndex].script = input.finalScriptSig;
          }
          if (input.finalScriptWitness && input.finalScriptWitness.length > 0) {
            tx.ins[inIndex].witness = (0, utils_1.scriptWitnessToWitnessStack)(
              input.finalScriptWitness
            );
          }
        });
        pset.outputs.forEach((output) => {
          const script = output.script || import_buffer.Buffer.from([]);
          const value2 = output.valueCommitment && output.valueCommitment.length > 0 ? output.valueCommitment : value_1.ElementsValue.fromNumber(output.value).bytes;
          const asset = output.assetCommitment && output.assetCommitment.length > 0 ? output.assetCommitment : asset_1.AssetHash.fromBytes(output.asset).bytes;
          const nonce = output.ecdhPubkey && output.ecdhPubkey.length > 0 ? output.ecdhPubkey : import_buffer.Buffer.of(0);
          tx.addOutput(
            script,
            value2,
            asset,
            nonce,
            output.valueRangeproof,
            output.assetSurjectionProof
          );
        });
        return tx;
      }
    };
    exports2.Extractor = Extractor;
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/zkp.js
var require_zkp = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/zkp.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ZKPGenerator = exports2.ZKPValidator = void 0;
    var confidential_1 = require_confidential();
    var transaction_1 = require_transaction();
    var value_1 = require_value();
    var utils_1 = require_utils7();
    var issuance_1 = require_issuance();
    var asset_1 = require_asset();
    var ZKPValidator = class {
      constructor(zkpLib) {
        this.confidential = new confidential_1.Confidential(zkpLib);
      }
      verifyValueRangeProof(proof, valueCommitment, assetCommitment, script) {
        try {
          return this.confidential.rangeProofVerify(
            proof,
            valueCommitment,
            assetCommitment,
            script
          );
        } catch (ignore) {
          return false;
        }
      }
      verifyAssetSurjectionProof(inAssets, inAssetBlinders, outAsset, outAssetBlinder, proof) {
        try {
          return this.confidential.surjectionProofVerify(
            inAssets,
            inAssetBlinders,
            outAsset,
            outAssetBlinder,
            proof
          );
        } catch (ignore) {
          return false;
        }
      }
      verifyBlindValueProof(proof, valueCommitment, assetCommitment) {
        try {
          return this.confidential.rangeProofVerify(
            proof,
            valueCommitment,
            assetCommitment
          );
        } catch (ignore) {
          return false;
        }
      }
      verifyBlindAssetProof(asset, assetCommit, proof) {
        try {
          return this.confidential.assetBlindProofVerify(asset, assetCommit, proof);
        } catch (ignore) {
          return false;
        }
      }
    };
    exports2.ZKPValidator = ZKPValidator;
    var ZKPGenerator = class {
      constructor(zkp, ...options) {
        this.zkp = zkp;
        this.confidential = new confidential_1.Confidential(zkp);
        for (const option of options) {
          option(this);
        }
      }
      static WithBlindingKeysOfInputs(inBlindingKeys) {
        return (g) => {
          g.inBlindingKeys = inBlindingKeys;
        };
      }
      static WithMasterBlindingKey(masterKey) {
        return (g) => {
          g.masterBlindingKey = masterKey;
        };
      }
      static WithOwnedInputs(ownedInputs) {
        return (g) => {
          g.ownedInputs = ownedInputs;
        };
      }
      computeAndAddToScalarOffset(scalar, value2, assetBlinder, valueBlinder) {
        if (assetBlinder.equals(transaction_1.ZERO) && valueBlinder.equals(transaction_1.ZERO)) {
          return scalar.slice();
        }
        const scalarOffset = this.calculateScalarOffset(
          value2,
          assetBlinder,
          valueBlinder
        );
        if (scalar.equals(transaction_1.ZERO)) {
          return scalarOffset;
        }
        const { ecc: ecc2 } = this.zkp;
        const negScalarOffset = scalarOffset.equals(transaction_1.ZERO) ? scalarOffset : import_buffer.Buffer.from(ecc2.privateNegate(scalarOffset));
        if (scalar.equals(negScalarOffset)) {
          return transaction_1.ZERO;
        }
        return import_buffer.Buffer.from(ecc2.privateAdd(scalar, scalarOffset));
      }
      subtractScalars(inputScalar, outputScalar) {
        if (outputScalar.equals(transaction_1.ZERO)) {
          return inputScalar.slice();
        }
        const { ecc: ecc2 } = this.zkp;
        const negOutputScalar = import_buffer.Buffer.from(ecc2.privateNegate(outputScalar));
        if (inputScalar.equals(transaction_1.ZERO)) {
          return negOutputScalar;
        }
        return import_buffer.Buffer.from(ecc2.privateAdd(inputScalar, negOutputScalar));
      }
      lastValueCommitment(value2, asset, blinder) {
        return this.confidential.valueCommitment(value2, asset, blinder);
      }
      lastBlindValueProof(value2, valueCommit, assetCommit, blinder) {
        const nonce = (0, utils_1.randomBytes)(this.opts);
        return this.confidential.blindValueProof(
          value2,
          valueCommit,
          assetCommit,
          blinder,
          nonce
        );
      }
      lastValueRangeProof(value2, asset, valueCommitment, assetCommitment, valueBlinder, assetBlinder, nonce, script) {
        return this.confidential.rangeProof(
          value2,
          asset,
          valueCommitment,
          assetCommitment,
          valueBlinder,
          assetBlinder,
          nonce,
          script
        );
      }
      unblindInputs(pset, inIndexes) {
        validatePset(pset);
        if (inIndexes) {
          validateInIndexes(pset, inIndexes);
        }
        const inputIndexes = inIndexes || Array.from({ length: pset.globals.inputCount }, (_, i) => i);
        if (this.ownedInputs && this.ownedInputs.length > 0) {
          return this.ownedInputs;
        }
        const revealedInputs = inputIndexes.map((i) => {
          const prevout = pset.inputs[i].getUtxo();
          const revealedInput = this.unblindUtxo(prevout);
          revealedInput.index = i;
          return revealedInput;
        });
        this.ownedInputs = revealedInputs;
        return revealedInputs;
      }
      blindIssuances(pset, blindingKeysByIndex) {
        validatePset(pset);
        validateBlindingKeysByIndex(pset, blindingKeysByIndex);
        return Object.entries(blindingKeysByIndex).map(([i, key]) => {
          const input = pset.inputs[parseInt(i, 10)];
          let blindingArgs = {};
          if (input.issuanceValue > 0) {
            const value2 = input.issuanceValue.toString(10);
            const asset = input.getIssuanceAssetHash();
            const blinder = (0, utils_1.randomBytes)(this.opts);
            const assetCommitment = this.confidential.assetCommitment(
              asset,
              transaction_1.ZERO
            );
            const valueCommitment = this.confidential.valueCommitment(
              value2,
              assetCommitment,
              blinder
            );
            const nonce = (0, utils_1.randomBytes)(this.opts);
            const blindproof = this.confidential.blindValueProof(
              value2,
              valueCommitment,
              assetCommitment,
              blinder,
              nonce
            );
            const rangeproof = this.confidential.rangeProof(
              value2,
              asset,
              valueCommitment,
              assetCommitment,
              blinder,
              transaction_1.ZERO,
              key,
              import_buffer.Buffer.from([])
            );
            blindingArgs = {
              ...blindingArgs,
              index: parseInt(i, 10),
              issuanceAsset: asset,
              issuanceValueCommitment: valueCommitment,
              issuanceValueRangeProof: rangeproof,
              issuanceValueBlindProof: blindproof,
              issuanceValueBlinder: blinder
            };
          }
          if (input.issuanceInflationKeys > 0) {
            const token = input.issuanceInflationKeys.toString(10);
            const entropy = input.getIssuanceEntropy();
            const asset = (0, issuance_1.calculateReissuanceToken)(entropy, true);
            if (!asset)
              throw new Error(
                "something went wrong during the inflation token hash computation"
              );
            const blinder = (0, utils_1.randomBytes)(this.opts);
            const assetCommitment = this.confidential.assetCommitment(
              asset,
              transaction_1.ZERO
            );
            const tokenCommitment = this.confidential.valueCommitment(
              token,
              assetCommitment,
              blinder
            );
            const nonce = (0, utils_1.randomBytes)(this.opts);
            const blindproof = this.confidential.blindValueProof(
              token,
              tokenCommitment,
              assetCommitment,
              blinder,
              nonce
            );
            const rangeproof = this.confidential.rangeProof(
              token,
              asset,
              tokenCommitment,
              assetCommitment,
              blinder,
              transaction_1.ZERO,
              key,
              import_buffer.Buffer.from([])
            );
            blindingArgs = {
              ...blindingArgs,
              issuanceToken: asset,
              issuanceTokenCommitment: tokenCommitment,
              issuanceTokenRangeProof: rangeproof,
              issuanceTokenBlindProof: blindproof,
              issuanceTokenBlinder: blinder
            };
          }
          return blindingArgs;
        });
      }
      blindOutputs(pset, keysGenerator, outIndexes) {
        validatePset(pset);
        if (outIndexes) {
          validateOutIndexes(pset, outIndexes);
        }
        const outputIndexes = outIndexes && outIndexes.length > 0 ? outIndexes : pset.outputs.reduce(
          (arr, out, i) => (out.needsBlinding() && arr.push(i), arr),
          []
        );
        const { assets, assetBlinders } = this.getInputAssetsAndBlinders(pset);
        return outputIndexes.map((i) => {
          const output = pset.outputs[i];
          const assetBlinder = (0, utils_1.randomBytes)(this.opts);
          const valueBlinder = (0, utils_1.randomBytes)(this.opts);
          const seed = (0, utils_1.randomBytes)(this.opts);
          const value2 = output.value.toString(10);
          const assetCommitment = this.confidential.assetCommitment(
            output.asset,
            assetBlinder
          );
          const valueCommitment = this.confidential.valueCommitment(
            value2,
            assetCommitment,
            valueBlinder
          );
          const ephemeralKeyPair = keysGenerator();
          const nonceCommitment = ephemeralKeyPair.publicKey;
          const ecdhNonce = this.confidential.nonceHash(
            output.blindingPubkey,
            ephemeralKeyPair.privateKey
          );
          const script = output.script || import_buffer.Buffer.from([]);
          const rangeproof = this.confidential.rangeProof(
            value2,
            output.asset,
            valueCommitment,
            assetCommitment,
            valueBlinder,
            assetBlinder,
            ecdhNonce,
            script
          );
          const surjectionproof = this.confidential.surjectionProof(
            output.asset,
            assetBlinder,
            assets,
            assetBlinders,
            seed
          );
          const nonce = (0, utils_1.randomBytes)(this.opts);
          const valueBlindProof = this.confidential.blindValueProof(
            value2,
            valueCommitment,
            assetCommitment,
            valueBlinder,
            nonce
          );
          const assetBlindProof = this.confidential.blindAssetProof(
            output.asset,
            assetCommitment,
            assetBlinder
          );
          return {
            index: i,
            nonce: ecdhNonce,
            nonceCommitment,
            valueCommitment,
            assetCommitment,
            valueRangeProof: rangeproof,
            assetSurjectionProof: surjectionproof,
            valueBlindProof,
            assetBlindProof,
            valueBlinder,
            assetBlinder
          };
        });
      }
      calculateScalarOffset(value2, assetBlinder, valueBlinder) {
        if (valueBlinder.length === 0) {
          throw new Error("missing value blinder");
        }
        if (assetBlinder.equals(transaction_1.ZERO)) {
          return valueBlinder.slice();
        }
        if (value2 === "0") {
          return valueBlinder.slice();
        }
        const { ecc: ecc2 } = this.zkp;
        const val = import_buffer.Buffer.alloc(32, 0);
        val.writeBigUInt64BE(BigInt(value2), 24);
        const result = import_buffer.Buffer.from(ecc2.privateMul(assetBlinder, val));
        const negVb = import_buffer.Buffer.from(ecc2.privateNegate(valueBlinder));
        if (negVb.equals(result)) {
          return transaction_1.ZERO;
        }
        return import_buffer.Buffer.from(ecc2.privateAdd(result, valueBlinder));
      }
      unblindUtxo(out) {
        if (out.nonce.length === 1 || out.rangeProof === void 0 || out.rangeProof.length === 0) {
          return {
            index: 0,
            value: value_1.ElementsValue.fromBytes(out.value).number.toString(10),
            asset: out.asset.slice(1),
            valueBlindingFactor: transaction_1.ZERO,
            assetBlindingFactor: transaction_1.ZERO
          };
        }
        if (!this.inBlindingKeys && !this.masterBlindingKey) {
          throw new Error(
            "Missing either input private blinding keys or SLIP-77 master blinding key"
          );
        }
        const keys = this.inBlindingKeys ? this.inBlindingKeys : [this.masterBlindingKey.derive(out.script).privateKey];
        for (const key of keys) {
          try {
            const revealed = this.confidential.unblindOutputWithKey(out, key);
            return {
              index: 0,
              value: revealed.value,
              asset: revealed.asset,
              valueBlindingFactor: revealed.valueBlindingFactor,
              assetBlindingFactor: revealed.assetBlindingFactor
            };
          } catch (ignore) {
          }
        }
        throw new Error("Could not unblind output with any blinding key");
      }
      getInputAssetsAndBlinders(pset) {
        const assets = [];
        const assetBlinders = [];
        const unblindedIns = this.maybeUnblindInUtxos(pset);
        for (const unblindedIn of unblindedIns) {
          assets.push(unblindedIn.asset);
          assetBlinders.push(unblindedIn.assetBlindingFactor);
        }
        pset.inputs.forEach((input, i) => {
          if (input.hasIssuance() || input.hasReissuance()) {
            const issAssetHash = input.getIssuanceAssetHash();
            if (!issAssetHash)
              throw new Error(
                `something went wrong while getting the issuance asset hash on input #${i}`
              );
            assets.push(issAssetHash);
            assetBlinders.push(transaction_1.ZERO);
            if (!input.hasReissuance() && input.issuanceInflationKeys > 0) {
              const entropy = input.getIssuanceEntropy();
              const inflationTokenAssetHash = (0, issuance_1.calculateReissuanceToken)(
                entropy,
                input.blindedIssuance ?? true
              );
              if (!inflationTokenAssetHash)
                throw new Error(
                  `something went wrong computing the issuance inflation keys hash on input #${i}`
                );
              assets.push(inflationTokenAssetHash);
              assetBlinders.push(transaction_1.ZERO);
            }
          }
        });
        return { assets, assetBlinders };
      }
      maybeUnblindInUtxos(pset) {
        if (this.ownedInputs && this.ownedInputs.length > 0) {
          return pset.inputs.map((input, i) => {
            const ownedInput = this.ownedInputs?.find(({ index }) => index === i);
            if (ownedInput) {
              return {
                value: "",
                valueBlindingFactor: import_buffer.Buffer.from([]),
                asset: ownedInput.asset,
                assetBlindingFactor: ownedInput.assetBlindingFactor
              };
            }
            const utxo = input.getUtxo();
            if (!utxo) {
              throw new Error(`Missing utxo for input #${i}`);
            }
            return {
              value: "",
              valueBlindingFactor: import_buffer.Buffer.from([]),
              asset: asset_1.AssetHash.fromBytes(utxo.asset).bytesWithoutPrefix,
              assetBlindingFactor: transaction_1.ZERO
            };
          });
        }
        if (!this.inBlindingKeys && !this.masterBlindingKey) {
          throw new Error(
            "Missing either input private blinding keys or SLIP-77 master blinding key"
          );
        }
        return pset.inputs.map((input) => {
          const prevout = input.getUtxo();
          try {
            const revealed = this.unblindUtxo(prevout);
            return {
              value: revealed.value,
              asset: revealed.asset,
              valueBlindingFactor: revealed.valueBlindingFactor,
              assetBlindingFactor: revealed.assetBlindingFactor
            };
          } catch (ignore) {
            return {
              value: "",
              asset: prevout.asset,
              valueBlindingFactor: import_buffer.Buffer.from([]),
              assetBlindingFactor: transaction_1.ZERO
            };
          }
        });
      }
    };
    exports2.ZKPGenerator = ZKPGenerator;
    function validatePset(pset) {
      pset.sanityCheck();
      pset.inputs.forEach((input, i) => {
        if (!input.getUtxo()) {
          throw new Error("Missing (non-)witness utxo for input " + i);
        }
      });
    }
    function validateInIndexes(pset, inIndexes) {
      if (inIndexes.length > 0) {
        inIndexes.forEach((i) => {
          if (i < 0 || i >= pset.globals.inputCount) {
            throw new Error("Input index out of range");
          }
        });
      }
    }
    function validateOutIndexes(pset, outIndexes) {
      if (outIndexes.length > 0) {
        outIndexes.forEach((i) => {
          if (i < 0 || i >= pset.globals.outputCount) {
            throw new Error("Output index out of range");
          }
        });
      }
    }
    function validateBlindingKeysByIndex(pset, keys) {
      Object.entries(keys).forEach(([k, v]) => {
        const i = parseInt(k, 10);
        if (i < 0 || i >= pset.globals.inputCount) {
          throw new Error("Input index out of range");
        }
        if (!pset.inputs[i].hasIssuance() && !pset.inputs[i].hasReissuance()) {
          throw new Error(
            "Input does not have any issuance or reissuance to blind"
          );
        }
        if (v.length !== 32) {
          throw new Error("Invalid private blinding key length for input " + i);
        }
      });
    }
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/index.js
var require_psetv2 = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/psetv2/index.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.classifyScript = exports2.scriptWitnessToWitnessStack = exports2.witnessStackToScriptWitness = exports2.ZKPValidator = exports2.ZKPGenerator = exports2.Updater = exports2.Signer = exports2.PsetOutput = exports2.PsetInput = exports2.PsetGlobal = exports2.Pset = exports2.CreatorOutput = exports2.CreatorInput = exports2.Finalizer = exports2.Extractor = exports2.Creator = exports2.Blinder = void 0;
    var globals_1 = require_globals();
    Object.defineProperty(exports2, "PsetGlobal", {
      enumerable: true,
      get: function() {
        return globals_1.PsetGlobal;
      }
    });
    var input_1 = require_input();
    Object.defineProperty(exports2, "PsetInput", {
      enumerable: true,
      get: function() {
        return input_1.PsetInput;
      }
    });
    var output_1 = require_output();
    Object.defineProperty(exports2, "PsetOutput", {
      enumerable: true,
      get: function() {
        return output_1.PsetOutput;
      }
    });
    var pset_1 = require_pset();
    Object.defineProperty(exports2, "Pset", {
      enumerable: true,
      get: function() {
        return pset_1.Pset;
      }
    });
    var creator_1 = require_creator();
    Object.defineProperty(exports2, "Creator", {
      enumerable: true,
      get: function() {
        return creator_1.Creator;
      }
    });
    Object.defineProperty(exports2, "CreatorInput", {
      enumerable: true,
      get: function() {
        return creator_1.CreatorInput;
      }
    });
    Object.defineProperty(exports2, "CreatorOutput", {
      enumerable: true,
      get: function() {
        return creator_1.CreatorOutput;
      }
    });
    var updater_1 = require_updater();
    Object.defineProperty(exports2, "Updater", {
      enumerable: true,
      get: function() {
        return updater_1.Updater;
      }
    });
    var blinder_1 = require_blinder();
    Object.defineProperty(exports2, "Blinder", {
      enumerable: true,
      get: function() {
        return blinder_1.Blinder;
      }
    });
    var signer_1 = require_signer();
    Object.defineProperty(exports2, "Signer", {
      enumerable: true,
      get: function() {
        return signer_1.Signer;
      }
    });
    var finalizer_1 = require_finalizer();
    Object.defineProperty(exports2, "Finalizer", {
      enumerable: true,
      get: function() {
        return finalizer_1.Finalizer;
      }
    });
    var extractor_1 = require_extractor();
    Object.defineProperty(exports2, "Extractor", {
      enumerable: true,
      get: function() {
        return extractor_1.Extractor;
      }
    });
    var utils_1 = require_utils7();
    Object.defineProperty(exports2, "witnessStackToScriptWitness", {
      enumerable: true,
      get: function() {
        return utils_1.witnessStackToScriptWitness;
      }
    });
    Object.defineProperty(exports2, "scriptWitnessToWitnessStack", {
      enumerable: true,
      get: function() {
        return utils_1.scriptWitnessToWitnessStack;
      }
    });
    Object.defineProperty(exports2, "classifyScript", {
      enumerable: true,
      get: function() {
        return utils_1.classifyScript;
      }
    });
    var zkp_1 = require_zkp();
    Object.defineProperty(exports2, "ZKPGenerator", {
      enumerable: true,
      get: function() {
        return zkp_1.ZKPGenerator;
      }
    });
    Object.defineProperty(exports2, "ZKPValidator", {
      enumerable: true,
      get: function() {
        return zkp_1.ZKPValidator;
      }
    });
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/secp256k1-zkp.js
var require_secp256k1_zkp = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/secp256k1-zkp.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/index.js
var require_src6 = __commonJS({
  "node_modules/.pnpm/liquidjs-lib@6.0.2-liquid.37/node_modules/liquidjs-lib/src/index.js"(exports2) {
    "use strict";
    init_buffer_polyfill();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Transaction = exports2.opcodes = exports2.bip341 = exports2.issuance = exports2.script = exports2.payments = exports2.networks = exports2.crypto = exports2.confidential = exports2.address = void 0;
    var address = __importStar(require_address());
    exports2.address = address;
    var crypto2 = __importStar(require_crypto());
    exports2.crypto = crypto2;
    var networks2 = __importStar(require_networks());
    exports2.networks = networks2;
    var payments = __importStar(require_payments());
    exports2.payments = payments;
    var script = __importStar(require_script());
    exports2.script = script;
    var issuance = __importStar(require_issuance());
    exports2.issuance = issuance;
    var bip341 = __importStar(require_bip341());
    exports2.bip341 = bip341;
    var confidential = __importStar(require_confidential());
    exports2.confidential = confidential;
    var ops_1 = require_ops();
    Object.defineProperty(exports2, "opcodes", {
      enumerable: true,
      get: function() {
        return ops_1.OPS;
      }
    });
    var transaction_1 = require_transaction();
    Object.defineProperty(exports2, "Transaction", {
      enumerable: true,
      get: function() {
        return transaction_1.Transaction;
      }
    });
    __exportStar(require_asset(), exports2);
    __exportStar(require_value(), exports2);
    __exportStar(require_psetv2(), exports2);
    __exportStar(require_secp256k1_zkp(), exports2);
  }
});

// src/ui/app.ts
init_buffer_polyfill();

// src/ui/palette-init.ts
init_buffer_polyfill();
var import_buffer2 = __toESM(require_buffer());
var import_process2 = __toESM(require_browser());
if (typeof window !== "undefined") {
  window.Buffer = import_buffer2.Buffer;
  window.process = import_process2.default;
}
if (typeof globalThis !== "undefined") {
  globalThis.Buffer = import_buffer2.Buffer;
  globalThis.process = import_process2.default;
}
function setupPasswordToggle(inputId, buttonId) {
  const input = document.getElementById(inputId);
  const button = document.getElementById(buttonId);
  if (input && button) {
    button.addEventListener("click", () => {
      const isPassword = input.type === "password";
      input.type = isPassword ? "text" : "password";
      button.innerText = isPassword ? "\u{1F648}" : "\u{1F441}\uFE0F";
      button.setAttribute(
        "aria-label",
        isPassword ? "Hide PIN" : "Show PIN"
      );
    });
  }
}
function initPalette() {
  setupPasswordToggle("pinInput", "togglePin");
}
if (typeof document !== "undefined") {
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initPalette);
  } else {
    initPalette();
  }
}

// src/core/wallet.ts
init_buffer_polyfill();

// src/core/secure-bitcoin-lib.ts
init_buffer_polyfill();
var import_buffer3 = __toESM(require_buffer());

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/index.js
init_buffer_polyfill();

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/address.js
init_buffer_polyfill();

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/networks.js
var networks_exports = {};
__export(networks_exports, {
  bitcoin: () => bitcoin,
  regtest: () => regtest,
  testnet: () => testnet
});
init_buffer_polyfill();
var bitcoin = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: "Bitcoin Signed Message:\n",
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
var regtest = {
  messagePrefix: "Bitcoin Signed Message:\n",
  bech32: "bcrt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var testnet = {
  messagePrefix: "Bitcoin Signed Message:\n",
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/payments/index.js
var payments_exports = {};
__export(payments_exports, {
  embed: () => p2data,
  p2ms: () => p2ms,
  p2pk: () => p2pk,
  p2pkh: () => p2pkh,
  p2sh: () => p2sh,
  p2tr: () => p2tr,
  p2wpkh: () => p2wpkh,
  p2wsh: () => p2wsh
});
init_buffer_polyfill();

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/payments/embed.js
init_buffer_polyfill();

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/script.js
init_buffer_polyfill();

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/bip66.js
init_buffer_polyfill();
function check(buffer2) {
  if (buffer2.length < 8) return false;
  if (buffer2.length > 72) return false;
  if (buffer2[0] !== 48) return false;
  if (buffer2[1] !== buffer2.length - 2) return false;
  if (buffer2[2] !== 2) return false;
  const lenR = buffer2[3];
  if (lenR === 0) return false;
  if (5 + lenR >= buffer2.length) return false;
  if (buffer2[4 + lenR] !== 2) return false;
  const lenS = buffer2[5 + lenR];
  if (lenS === 0) return false;
  if (6 + lenR + lenS !== buffer2.length) return false;
  if (buffer2[4] & 128) return false;
  if (lenR > 1 && buffer2[4] === 0 && !(buffer2[5] & 128)) return false;
  if (buffer2[lenR + 6] & 128) return false;
  if (lenS > 1 && buffer2[lenR + 6] === 0 && !(buffer2[lenR + 7] & 128))
    return false;
  return true;
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/ops.js
init_buffer_polyfill();
var OPS;
(function(OPS10) {
  OPS10[OPS10["OP_FALSE"] = 0] = "OP_FALSE";
  OPS10[OPS10["OP_0"] = 0] = "OP_0";
  OPS10[OPS10["OP_PUSHDATA1"] = 76] = "OP_PUSHDATA1";
  OPS10[OPS10["OP_PUSHDATA2"] = 77] = "OP_PUSHDATA2";
  OPS10[OPS10["OP_PUSHDATA4"] = 78] = "OP_PUSHDATA4";
  OPS10[OPS10["OP_1NEGATE"] = 79] = "OP_1NEGATE";
  OPS10[OPS10["OP_RESERVED"] = 80] = "OP_RESERVED";
  OPS10[OPS10["OP_TRUE"] = 81] = "OP_TRUE";
  OPS10[OPS10["OP_1"] = 81] = "OP_1";
  OPS10[OPS10["OP_2"] = 82] = "OP_2";
  OPS10[OPS10["OP_3"] = 83] = "OP_3";
  OPS10[OPS10["OP_4"] = 84] = "OP_4";
  OPS10[OPS10["OP_5"] = 85] = "OP_5";
  OPS10[OPS10["OP_6"] = 86] = "OP_6";
  OPS10[OPS10["OP_7"] = 87] = "OP_7";
  OPS10[OPS10["OP_8"] = 88] = "OP_8";
  OPS10[OPS10["OP_9"] = 89] = "OP_9";
  OPS10[OPS10["OP_10"] = 90] = "OP_10";
  OPS10[OPS10["OP_11"] = 91] = "OP_11";
  OPS10[OPS10["OP_12"] = 92] = "OP_12";
  OPS10[OPS10["OP_13"] = 93] = "OP_13";
  OPS10[OPS10["OP_14"] = 94] = "OP_14";
  OPS10[OPS10["OP_15"] = 95] = "OP_15";
  OPS10[OPS10["OP_16"] = 96] = "OP_16";
  OPS10[OPS10["OP_NOP"] = 97] = "OP_NOP";
  OPS10[OPS10["OP_VER"] = 98] = "OP_VER";
  OPS10[OPS10["OP_IF"] = 99] = "OP_IF";
  OPS10[OPS10["OP_NOTIF"] = 100] = "OP_NOTIF";
  OPS10[OPS10["OP_VERIF"] = 101] = "OP_VERIF";
  OPS10[OPS10["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
  OPS10[OPS10["OP_ELSE"] = 103] = "OP_ELSE";
  OPS10[OPS10["OP_ENDIF"] = 104] = "OP_ENDIF";
  OPS10[OPS10["OP_VERIFY"] = 105] = "OP_VERIFY";
  OPS10[OPS10["OP_RETURN"] = 106] = "OP_RETURN";
  OPS10[OPS10["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
  OPS10[OPS10["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
  OPS10[OPS10["OP_2DROP"] = 109] = "OP_2DROP";
  OPS10[OPS10["OP_2DUP"] = 110] = "OP_2DUP";
  OPS10[OPS10["OP_3DUP"] = 111] = "OP_3DUP";
  OPS10[OPS10["OP_2OVER"] = 112] = "OP_2OVER";
  OPS10[OPS10["OP_2ROT"] = 113] = "OP_2ROT";
  OPS10[OPS10["OP_2SWAP"] = 114] = "OP_2SWAP";
  OPS10[OPS10["OP_IFDUP"] = 115] = "OP_IFDUP";
  OPS10[OPS10["OP_DEPTH"] = 116] = "OP_DEPTH";
  OPS10[OPS10["OP_DROP"] = 117] = "OP_DROP";
  OPS10[OPS10["OP_DUP"] = 118] = "OP_DUP";
  OPS10[OPS10["OP_NIP"] = 119] = "OP_NIP";
  OPS10[OPS10["OP_OVER"] = 120] = "OP_OVER";
  OPS10[OPS10["OP_PICK"] = 121] = "OP_PICK";
  OPS10[OPS10["OP_ROLL"] = 122] = "OP_ROLL";
  OPS10[OPS10["OP_ROT"] = 123] = "OP_ROT";
  OPS10[OPS10["OP_SWAP"] = 124] = "OP_SWAP";
  OPS10[OPS10["OP_TUCK"] = 125] = "OP_TUCK";
  OPS10[OPS10["OP_CAT"] = 126] = "OP_CAT";
  OPS10[OPS10["OP_SUBSTR"] = 127] = "OP_SUBSTR";
  OPS10[OPS10["OP_LEFT"] = 128] = "OP_LEFT";
  OPS10[OPS10["OP_RIGHT"] = 129] = "OP_RIGHT";
  OPS10[OPS10["OP_SIZE"] = 130] = "OP_SIZE";
  OPS10[OPS10["OP_INVERT"] = 131] = "OP_INVERT";
  OPS10[OPS10["OP_AND"] = 132] = "OP_AND";
  OPS10[OPS10["OP_OR"] = 133] = "OP_OR";
  OPS10[OPS10["OP_XOR"] = 134] = "OP_XOR";
  OPS10[OPS10["OP_EQUAL"] = 135] = "OP_EQUAL";
  OPS10[OPS10["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
  OPS10[OPS10["OP_RESERVED1"] = 137] = "OP_RESERVED1";
  OPS10[OPS10["OP_RESERVED2"] = 138] = "OP_RESERVED2";
  OPS10[OPS10["OP_1ADD"] = 139] = "OP_1ADD";
  OPS10[OPS10["OP_1SUB"] = 140] = "OP_1SUB";
  OPS10[OPS10["OP_2MUL"] = 141] = "OP_2MUL";
  OPS10[OPS10["OP_2DIV"] = 142] = "OP_2DIV";
  OPS10[OPS10["OP_NEGATE"] = 143] = "OP_NEGATE";
  OPS10[OPS10["OP_ABS"] = 144] = "OP_ABS";
  OPS10[OPS10["OP_NOT"] = 145] = "OP_NOT";
  OPS10[OPS10["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
  OPS10[OPS10["OP_ADD"] = 147] = "OP_ADD";
  OPS10[OPS10["OP_SUB"] = 148] = "OP_SUB";
  OPS10[OPS10["OP_MUL"] = 149] = "OP_MUL";
  OPS10[OPS10["OP_DIV"] = 150] = "OP_DIV";
  OPS10[OPS10["OP_MOD"] = 151] = "OP_MOD";
  OPS10[OPS10["OP_LSHIFT"] = 152] = "OP_LSHIFT";
  OPS10[OPS10["OP_RSHIFT"] = 153] = "OP_RSHIFT";
  OPS10[OPS10["OP_BOOLAND"] = 154] = "OP_BOOLAND";
  OPS10[OPS10["OP_BOOLOR"] = 155] = "OP_BOOLOR";
  OPS10[OPS10["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
  OPS10[OPS10["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
  OPS10[OPS10["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
  OPS10[OPS10["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
  OPS10[OPS10["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
  OPS10[OPS10["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
  OPS10[OPS10["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
  OPS10[OPS10["OP_MIN"] = 163] = "OP_MIN";
  OPS10[OPS10["OP_MAX"] = 164] = "OP_MAX";
  OPS10[OPS10["OP_WITHIN"] = 165] = "OP_WITHIN";
  OPS10[OPS10["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
  OPS10[OPS10["OP_SHA1"] = 167] = "OP_SHA1";
  OPS10[OPS10["OP_SHA256"] = 168] = "OP_SHA256";
  OPS10[OPS10["OP_HASH160"] = 169] = "OP_HASH160";
  OPS10[OPS10["OP_HASH256"] = 170] = "OP_HASH256";
  OPS10[OPS10["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
  OPS10[OPS10["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
  OPS10[OPS10["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
  OPS10[OPS10["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
  OPS10[OPS10["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
  OPS10[OPS10["OP_NOP1"] = 176] = "OP_NOP1";
  OPS10[OPS10["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
  OPS10[OPS10["OP_NOP2"] = 177] = "OP_NOP2";
  OPS10[OPS10["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
  OPS10[OPS10["OP_NOP3"] = 178] = "OP_NOP3";
  OPS10[OPS10["OP_NOP4"] = 179] = "OP_NOP4";
  OPS10[OPS10["OP_NOP5"] = 180] = "OP_NOP5";
  OPS10[OPS10["OP_NOP6"] = 181] = "OP_NOP6";
  OPS10[OPS10["OP_NOP7"] = 182] = "OP_NOP7";
  OPS10[OPS10["OP_NOP8"] = 183] = "OP_NOP8";
  OPS10[OPS10["OP_NOP9"] = 184] = "OP_NOP9";
  OPS10[OPS10["OP_NOP10"] = 185] = "OP_NOP10";
  OPS10[OPS10["OP_CHECKSIGADD"] = 186] = "OP_CHECKSIGADD";
  OPS10[OPS10["OP_PUBKEYHASH"] = 253] = "OP_PUBKEYHASH";
  OPS10[OPS10["OP_PUBKEY"] = 254] = "OP_PUBKEY";
  OPS10[OPS10["OP_INVALIDOPCODE"] = 255] = "OP_INVALIDOPCODE";
})(OPS || (OPS = {}));

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/push_data.js
init_buffer_polyfill();

// node_modules/.pnpm/uint8array-tools@0.0.9/node_modules/uint8array-tools/src/mjs/browser.js
init_buffer_polyfill();
var HEX_STRINGS = "0123456789abcdefABCDEF";
var HEX_CODES = HEX_STRINGS.split("").map((c) => c.codePointAt(0));
var HEX_CODEPOINTS = Array(256).fill(true).map((_, i) => {
  const s = String.fromCodePoint(i);
  const index = HEX_STRINGS.indexOf(s);
  return index < 0 ? void 0 : index < 16 ? index : index - 6;
});
var ENCODER = new TextEncoder();
var DECODER = new TextDecoder();
function toUtf8(bytes) {
  return DECODER.decode(bytes);
}
function fromUtf8(s) {
  return ENCODER.encode(s);
}
function concat(arrays) {
  const totalLength = arrays.reduce((a, b) => a + b.length, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const array2 of arrays) {
    result.set(array2, offset);
    offset += array2.length;
  }
  return result;
}
function toHex(bytes) {
  const b = bytes || new Uint8Array();
  return b.length > 512 ? _toHexLengthPerf(b) : _toHexIterPerf(b);
}
function _toHexIterPerf(bytes) {
  let s = "";
  for (let i = 0; i < bytes.length; ++i) {
    s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] >> 4]]];
    s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] & 15]]];
  }
  return s;
}
function _toHexLengthPerf(bytes) {
  const hexBytes = new Uint8Array(bytes.length * 2);
  for (let i = 0; i < bytes.length; ++i) {
    hexBytes[i * 2] = HEX_CODES[bytes[i] >> 4];
    hexBytes[i * 2 + 1] = HEX_CODES[bytes[i] & 15];
  }
  return DECODER.decode(hexBytes);
}
function fromHex(hexString) {
  const hexBytes = ENCODER.encode(hexString || "");
  const resultBytes = new Uint8Array(Math.floor(hexBytes.length / 2));
  let i;
  for (i = 0; i < resultBytes.length; i++) {
    const a = HEX_CODEPOINTS[hexBytes[i * 2]];
    const b = HEX_CODEPOINTS[hexBytes[i * 2 + 1]];
    if (a === void 0 || b === void 0) {
      break;
    }
    resultBytes[i] = a << 4 | b;
  }
  return i === resultBytes.length ? resultBytes : resultBytes.slice(0, i);
}
function compare(v1, v2) {
  const minLength = Math.min(v1.length, v2.length);
  for (let i = 0; i < minLength; ++i) {
    if (v1[i] !== v2[i]) {
      return v1[i] < v2[i] ? -1 : 1;
    }
  }
  return v1.length === v2.length ? 0 : v1.length > v2.length ? 1 : -1;
}
function writeUInt8(buffer2, offset, value2) {
  if (offset + 1 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  if (value2 > 255) {
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${255}. Received ${value2}`);
  }
  buffer2[offset] = value2;
  return offset + 1;
}
function writeUInt16(buffer2, offset, value2, littleEndian) {
  if (offset + 2 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (value2 > 65535) {
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${65535}. Received ${value2}`);
  }
  if (littleEndian === "LE") {
    buffer2[offset] = value2 & 255;
    buffer2[offset + 1] = value2 >> 8 & 255;
  } else {
    buffer2[offset] = value2 >> 8 & 255;
    buffer2[offset + 1] = value2 & 255;
  }
  return offset + 2;
}
function writeUInt32(buffer2, offset, value2, littleEndian) {
  if (offset + 4 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (value2 > 4294967295) {
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${value2}`);
  }
  if (littleEndian === "LE") {
    buffer2[offset] = value2 & 255;
    buffer2[offset + 1] = value2 >> 8 & 255;
    buffer2[offset + 2] = value2 >> 16 & 255;
    buffer2[offset + 3] = value2 >> 24 & 255;
  } else {
    buffer2[offset] = value2 >> 24 & 255;
    buffer2[offset + 1] = value2 >> 16 & 255;
    buffer2[offset + 2] = value2 >> 8 & 255;
    buffer2[offset + 3] = value2 & 255;
  }
  return offset + 4;
}
function readUInt8(buffer2, offset) {
  if (offset + 1 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  return buffer2[offset];
}
function readUInt16(buffer2, offset, littleEndian) {
  if (offset + 2 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    let num2 = 0;
    num2 = (num2 << 8) + buffer2[offset + 1];
    num2 = (num2 << 8) + buffer2[offset];
    return num2;
  } else {
    let num2 = 0;
    num2 = (num2 << 8) + buffer2[offset];
    num2 = (num2 << 8) + buffer2[offset + 1];
    return num2;
  }
}
function readUInt32(buffer2, offset, littleEndian) {
  if (offset + 4 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    let num2 = 0;
    num2 = (num2 << 8) + buffer2[offset + 3] >>> 0;
    num2 = (num2 << 8) + buffer2[offset + 2] >>> 0;
    num2 = (num2 << 8) + buffer2[offset + 1] >>> 0;
    num2 = (num2 << 8) + buffer2[offset] >>> 0;
    return num2;
  } else {
    let num2 = 0;
    num2 = (num2 << 8) + buffer2[offset] >>> 0;
    num2 = (num2 << 8) + buffer2[offset + 1] >>> 0;
    num2 = (num2 << 8) + buffer2[offset + 2] >>> 0;
    num2 = (num2 << 8) + buffer2[offset + 3] >>> 0;
    return num2;
  }
}
function writeInt64(buffer2, offset, value2, littleEndian) {
  if (offset + 8 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  if (value2 > 0x7fffffffffffffffn || value2 < -0x8000000000000000n) {
    throw new Error(`The value of "value" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${value2}`);
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    buffer2[offset] = Number(value2 & 0xffn);
    buffer2[offset + 1] = Number(value2 >> 8n & 0xffn);
    buffer2[offset + 2] = Number(value2 >> 16n & 0xffn);
    buffer2[offset + 3] = Number(value2 >> 24n & 0xffn);
    buffer2[offset + 4] = Number(value2 >> 32n & 0xffn);
    buffer2[offset + 5] = Number(value2 >> 40n & 0xffn);
    buffer2[offset + 6] = Number(value2 >> 48n & 0xffn);
    buffer2[offset + 7] = Number(value2 >> 56n & 0xffn);
  } else {
    buffer2[offset] = Number(value2 >> 56n & 0xffn);
    buffer2[offset + 1] = Number(value2 >> 48n & 0xffn);
    buffer2[offset + 2] = Number(value2 >> 40n & 0xffn);
    buffer2[offset + 3] = Number(value2 >> 32n & 0xffn);
    buffer2[offset + 4] = Number(value2 >> 24n & 0xffn);
    buffer2[offset + 5] = Number(value2 >> 16n & 0xffn);
    buffer2[offset + 6] = Number(value2 >> 8n & 0xffn);
    buffer2[offset + 7] = Number(value2 & 0xffn);
  }
  return offset + 8;
}
function readInt64(buffer2, offset, littleEndian) {
  if (offset + 8 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  let num2 = 0n;
  if (littleEndian === "LE") {
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 7]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 6]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 5]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 4]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 3]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 2]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 1]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset]);
    return buffer2[offset + 7] <= 127 ? num2 : num2 - 0x10000000000000000n;
  } else {
    let num3 = 0n;
    num3 = (num3 << 8n) + BigInt(buffer2[offset]);
    num3 = (num3 << 8n) + BigInt(buffer2[offset + 1]);
    num3 = (num3 << 8n) + BigInt(buffer2[offset + 2]);
    num3 = (num3 << 8n) + BigInt(buffer2[offset + 3]);
    num3 = (num3 << 8n) + BigInt(buffer2[offset + 4]);
    num3 = (num3 << 8n) + BigInt(buffer2[offset + 5]);
    num3 = (num3 << 8n) + BigInt(buffer2[offset + 6]);
    num3 = (num3 << 8n) + BigInt(buffer2[offset + 7]);
    return buffer2[offset] <= 127 ? num3 : num3 - 0x10000000000000000n;
  }
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/push_data.js
function encodingLength(i) {
  return i < OPS.OP_PUSHDATA1 ? 1 : i <= 255 ? 2 : i <= 65535 ? 3 : 5;
}
function encode(buffer2, num2, offset) {
  const size = encodingLength(num2);
  if (size === 1) {
    writeUInt8(buffer2, offset, num2);
  } else if (size === 2) {
    writeUInt8(buffer2, offset, OPS.OP_PUSHDATA1);
    writeUInt8(buffer2, offset + 1, num2);
  } else if (size === 3) {
    writeUInt8(buffer2, offset, OPS.OP_PUSHDATA2);
    writeUInt16(buffer2, offset + 1, num2, "LE");
  } else {
    writeUInt8(buffer2, offset, OPS.OP_PUSHDATA4);
    writeUInt32(buffer2, offset + 1, num2, "LE");
  }
  return size;
}
function decode(buffer2, offset) {
  const opcode = readUInt8(buffer2, offset);
  let num2;
  let size;
  if (opcode < OPS.OP_PUSHDATA1) {
    num2 = opcode;
    size = 1;
  } else if (opcode === OPS.OP_PUSHDATA1) {
    if (offset + 2 > buffer2.length) return null;
    num2 = readUInt8(buffer2, offset + 1);
    size = 2;
  } else if (opcode === OPS.OP_PUSHDATA2) {
    if (offset + 3 > buffer2.length) return null;
    num2 = readUInt16(buffer2, offset + 1, "LE");
    size = 3;
  } else {
    if (offset + 5 > buffer2.length) return null;
    if (opcode !== OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    num2 = readUInt32(buffer2, offset + 1, "LE");
    size = 5;
  }
  return {
    opcode,
    number: num2,
    size
  };
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/script_number.js
init_buffer_polyfill();
function decode2(buffer2, maxLength, minimal) {
  maxLength = maxLength || 4;
  minimal = minimal === void 0 ? true : minimal;
  const length6 = buffer2.length;
  if (length6 === 0) return 0;
  if (length6 > maxLength) throw new TypeError("Script number overflow");
  if (minimal) {
    if ((buffer2[length6 - 1] & 127) === 0) {
      if (length6 <= 1 || (buffer2[length6 - 2] & 128) === 0)
        throw new Error("Non-minimally encoded script number");
    }
  }
  if (length6 === 5) {
    const a = readUInt32(buffer2, 0, "LE");
    const b = readUInt8(buffer2, 4);
    if (b & 128) return -((b & ~128) * 4294967296 + a);
    return b * 4294967296 + a;
  }
  let result = 0;
  for (let i = 0; i < length6; ++i) {
    result |= buffer2[i] << 8 * i;
  }
  if (buffer2[length6 - 1] & 128)
    return -(result & ~(128 << 8 * (length6 - 1)));
  return result;
}
function scriptNumSize(i) {
  return i > 2147483647 ? 5 : i > 8388607 ? 4 : i > 32767 ? 3 : i > 127 ? 2 : i > 0 ? 1 : 0;
}
function encode2(_number) {
  let value2 = Math.abs(_number);
  const size = scriptNumSize(value2);
  const buffer2 = new Uint8Array(size);
  const negative = _number < 0;
  for (let i = 0; i < size; ++i) {
    writeUInt8(buffer2, i, value2 & 255);
    value2 >>= 8;
  }
  if (buffer2[size - 1] & 128) {
    writeUInt8(buffer2, size - 1, negative ? 128 : 0);
  } else if (negative) {
    buffer2[size - 1] |= 128;
  }
  return buffer2;
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/script_signature.js
init_buffer_polyfill();

// node_modules/.pnpm/valibot@1.2.0_typescript@5.9.3/node_modules/valibot/dist/index.mjs
init_buffer_polyfill();
var store$4;
// @__NO_SIDE_EFFECTS__
function getGlobalConfig(config$1) {
  return {
    lang: config$1?.lang ?? store$4?.lang,
    message: config$1?.message,
    abortEarly: config$1?.abortEarly ?? store$4?.abortEarly,
    abortPipeEarly: config$1?.abortPipeEarly ?? store$4?.abortPipeEarly
  };
}
var store$3;
// @__NO_SIDE_EFFECTS__
function getGlobalMessage(lang) {
  return store$3?.get(lang);
}
var store$2;
// @__NO_SIDE_EFFECTS__
function getSchemaMessage(lang) {
  return store$2?.get(lang);
}
var store$1;
// @__NO_SIDE_EFFECTS__
function getSpecificMessage(reference, lang) {
  return store$1?.get(reference)?.get(lang);
}
// @__NO_SIDE_EFFECTS__
function _stringify(input) {
  const type = typeof input;
  if (type === "string") return `"${input}"`;
  if (type === "number" || type === "bigint" || type === "boolean") return `${input}`;
  if (type === "object" || type === "function") return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
  return type;
}
function _addIssue(context, label, dataset, config$1, other) {
  const input = other && "input" in other ? other.input : dataset.value;
  const expected14 = other?.expected ?? context.expects ?? null;
  const received = other?.received ?? /* @__PURE__ */ _stringify(input);
  const issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected: expected14,
    received,
    message: `Invalid ${label}: ${expected14 ? `Expected ${expected14} but r` : "R"}eceived ${received}`,
    requirement: context.requirement,
    path: other?.path,
    issues: other?.issues,
    lang: config$1.lang,
    abortEarly: config$1.abortEarly,
    abortPipeEarly: config$1.abortPipeEarly
  };
  const isSchema = context.kind === "schema";
  const message$1 = other?.message ?? context.message ?? /* @__PURE__ */ getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? /* @__PURE__ */ getSchemaMessage(issue.lang) : null) ?? config$1.message ?? /* @__PURE__ */ getGlobalMessage(issue.lang);
  if (message$1 !== void 0) issue.message = typeof message$1 === "function" ? message$1(issue) : message$1;
  if (isSchema) dataset.typed = false;
  if (dataset.issues) dataset.issues.push(issue);
  else dataset.issues = [issue];
}
// @__NO_SIDE_EFFECTS__
function _getStandardProps(context) {
  return {
    version: 1,
    vendor: "valibot",
    validate(value$1) {
      return context["~run"]({ value: value$1 }, /* @__PURE__ */ getGlobalConfig());
    }
  };
}
// @__NO_SIDE_EFFECTS__
function _joinExpects(values$1, separator) {
  const list = [...new Set(values$1)];
  if (list.length > 1) return `(${list.join(` ${separator} `)})`;
  return list[0] ?? "never";
}
var ValiError = class extends Error {
  /**
  * Creates a Valibot error with useful information.
  *
  * @param issues The error issues.
  */
  constructor(issues) {
    super(issues[0].message);
    this.name = "ValiError";
    this.issues = issues;
  }
};
// @__NO_SIDE_EFFECTS__
function everyItem(requirement, message$1) {
  return {
    kind: "validation",
    type: "every_item",
    reference: everyItem,
    async: false,
    expects: null,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !dataset.value.every(this.requirement)) _addIssue(this, "item", dataset, config$1);
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function integer(message$1) {
  return {
    kind: "validation",
    type: "integer",
    reference: integer,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "integer", dataset, config$1);
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function length(requirement, message$1) {
  return {
    kind: "validation",
    type: "length",
    reference: length,
    async: false,
    expects: `${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.length !== this.requirement) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function maxValue(requirement, message$1) {
  return {
    kind: "validation",
    type: "max_value",
    reference: maxValue,
    async: false,
    expects: `<=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !(dataset.value <= this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function minValue(requirement, message$1) {
  return {
    kind: "validation",
    type: "min_value",
    reference: minValue,
    async: false,
    expects: `>=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !(dataset.value >= this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function regex(requirement, message$1) {
  return {
    kind: "validation",
    type: "regex",
    reference: regex,
    async: false,
    expects: `${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "format", dataset, config$1);
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function getFallback(schema, dataset, config$1) {
  return typeof schema.fallback === "function" ? schema.fallback(dataset, config$1) : schema.fallback;
}
// @__NO_SIDE_EFFECTS__
function getDefault(schema, dataset, config$1) {
  return typeof schema.default === "function" ? schema.default(dataset, config$1) : schema.default;
}
// @__NO_SIDE_EFFECTS__
function is(schema, input) {
  return !schema["~run"]({ value: input }, { abortEarly: true }).issues;
}
// @__NO_SIDE_EFFECTS__
function any() {
  return {
    kind: "schema",
    type: "any",
    reference: any,
    expects: "any",
    async: false,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset) {
      dataset.typed = true;
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function array(item, message$1) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: false,
    item,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key = 0; key < input.length; key++) {
          const value$1 = input[key];
          const itemDataset = this.item["~run"]({ value: value$1 }, config$1);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function bigint(message$1) {
  return {
    kind: "schema",
    type: "bigint",
    reference: bigint,
    expects: "bigint",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (typeof dataset.value === "bigint") dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function custom(check$1, message$1) {
  return {
    kind: "schema",
    type: "custom",
    reference: custom,
    expects: "unknown",
    async: false,
    check: check$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (this.check(dataset.value)) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function instance(class_, message$1) {
  return {
    kind: "schema",
    type: "instance",
    reference: instance,
    expects: class_.name,
    async: false,
    class: class_,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value instanceof this.class) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function nullish(wrapped, default_) {
  return {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `(${wrapped.expects} | null | undefined)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === null || dataset.value === void 0) {
        if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === null || dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function number(message$1) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (typeof dataset.value === "number" && !isNaN(dataset.value)) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function object(entries$1, message$1) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: false,
    entries: entries$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key in this.entries) {
          const valueSchema = this.entries[key];
          if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
            const value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);
            const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key,
                value: value$1
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) issue.path.unshift(pathItem);
                else issue.path = [pathItem];
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) dataset.issues = valueDataset.issues;
              if (config$1.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) dataset.typed = false;
            dataset.value[key] = valueDataset.value;
          } else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);
          else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
            _addIssue(this, "key", dataset, config$1, {
              input: void 0,
              expected: `"${key}"`,
              path: [{
                type: "object",
                origin: "key",
                input,
                key,
                value: input[key]
              }]
            });
            if (config$1.abortEarly) break;
          }
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function optional(wrapped, default_) {
  return {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${wrapped.expects} | undefined)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === void 0) {
        if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function string(message$1) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (typeof dataset.value === "string") dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function _subIssues(datasets) {
  let issues;
  if (datasets) for (const dataset of datasets) if (issues) issues.push(...dataset.issues);
  else issues = dataset.issues;
  return issues;
}
// @__NO_SIDE_EFFECTS__
function union(options, message$1) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), "|"),
    async: false,
    options,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      let validDataset;
      let typedDatasets;
      let untypedDatasets;
      for (const schema of this.options) {
        const optionDataset = schema["~run"]({ value: dataset.value }, config$1);
        if (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);
        else typedDatasets = [optionDataset];
        else {
          validDataset = optionDataset;
          break;
        }
        else if (untypedDatasets) untypedDatasets.push(optionDataset);
        else untypedDatasets = [optionDataset];
      }
      if (validDataset) return validDataset;
      if (typedDatasets) {
        if (typedDatasets.length === 1) return typedDatasets[0];
        _addIssue(this, "type", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });
        dataset.typed = true;
      } else if (untypedDatasets?.length === 1) return untypedDatasets[0];
      else _addIssue(this, "type", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });
      return dataset;
    }
  };
}
function parse(schema, input, config$1) {
  const dataset = schema["~run"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));
  if (dataset.issues) throw new ValiError(dataset.issues);
  return dataset.value;
}
// @__NO_SIDE_EFFECTS__
function partial(schema, keys) {
  const entries$1 = {};
  for (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ optional(schema.entries[key]) : schema.entries[key];
  return {
    ...schema,
    entries: entries$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function pipe(...pipe$1) {
  return {
    ...pipe$1[0],
    pipe: pipe$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      for (const item of pipe$1) if (item.kind !== "metadata") {
        if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
          dataset.typed = false;
          break;
        }
        if (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = item["~run"](dataset, config$1);
      }
      return dataset;
    }
  };
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/types.js
init_buffer_polyfill();
var ZERO32 = new Uint8Array(32);
var EC_P = fromHex(
  "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
);
var NBufferSchemaFactory = (size) => pipe(instance(Uint8Array), length(size));
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((x, i) => {
    return compare(x, b[i]) === 0;
  });
}
function isPoint(p) {
  if (!(p instanceof Uint8Array)) return false;
  if (p.length < 33) return false;
  const t = p[0];
  const x = p.slice(1, 33);
  if (compare(ZERO32, x) === 0) return false;
  if (compare(x, EC_P) >= 0) return false;
  if ((t === 2 || t === 3) && p.length === 33) {
    return true;
  }
  const y = p.slice(33);
  if (compare(ZERO32, y) === 0) return false;
  if (compare(y, EC_P) >= 0) return false;
  if (t === 4 && p.length === 65) return true;
  return false;
}
var TAPLEAF_VERSION_MASK = 254;
function isTapleaf(o) {
  if (!o || !("output" in o)) return false;
  if (!(o.output instanceof Uint8Array)) return false;
  if (o.version !== void 0)
    return (o.version & TAPLEAF_VERSION_MASK) === o.version;
  return true;
}
function isTaptree(scriptTree) {
  if (!Array.isArray(scriptTree)) return isTapleaf(scriptTree);
  if (scriptTree.length !== 2) return false;
  return scriptTree.every((t) => isTaptree(t));
}
var Buffer256bitSchema = NBufferSchemaFactory(32);
var Hash160bitSchema = NBufferSchemaFactory(20);
var Hash256bitSchema = NBufferSchemaFactory(32);
var BufferSchema = instance(Uint8Array);
var HexSchema = pipe(string(), regex(/^([0-9a-f]{2})+$/i));
var UInt8Schema = pipe(
  number(),
  integer(),
  minValue(0),
  maxValue(255)
);
var UInt32Schema = pipe(
  number(),
  integer(),
  minValue(0),
  maxValue(4294967295)
);
var SatoshiSchema = pipe(
  bigint(),
  minValue(0n),
  maxValue(0x7fffffffffffffffn)
);
var NullablePartial = (a) => object(
  Object.entries(a).reduce(
    (acc, next) => ({ ...acc, [next[0]]: nullish(next[1]) }),
    {}
  )
);

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/script_signature.js
var ZERO = new Uint8Array(1);

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/script.js
var OP_INT_BASE = OPS.OP_RESERVED;
var StackSchema = array(union([instance(Uint8Array), number()]));
function isOPInt(value2) {
  return is(number(), value2) && (value2 === OPS.OP_0 || value2 >= OPS.OP_1 && value2 <= OPS.OP_16 || value2 === OPS.OP_1NEGATE);
}
function isPushOnlyChunk(value2) {
  return is(BufferSchema, value2) || isOPInt(value2);
}
function isPushOnly(value2) {
  return is(pipe(any(), everyItem(isPushOnlyChunk)), value2);
}
function countNonPushOnlyOPs(value2) {
  return value2.length - value2.filter(isPushOnlyChunk).length;
}
function asMinimalOP(buffer2) {
  if (buffer2.length === 0) return OPS.OP_0;
  if (buffer2.length !== 1) return;
  if (buffer2[0] >= 1 && buffer2[0] <= 16) return OP_INT_BASE + buffer2[0];
  if (buffer2[0] === 129) return OPS.OP_1NEGATE;
}
function chunksIsBuffer(buf2) {
  return buf2 instanceof Uint8Array;
}
function chunksIsArray(buf2) {
  return is(StackSchema, buf2);
}
function singleChunkIsBuffer(buf2) {
  return buf2 instanceof Uint8Array;
}
function compile(chunks) {
  if (chunksIsBuffer(chunks)) return chunks;
  parse(StackSchema, chunks);
  const bufferSize = chunks.reduce((accum, chunk) => {
    if (singleChunkIsBuffer(chunk)) {
      if (chunk.length === 1 && asMinimalOP(chunk) !== void 0) {
        return accum + 1;
      }
      return accum + encodingLength(chunk.length) + chunk.length;
    }
    return accum + 1;
  }, 0);
  const buffer2 = new Uint8Array(bufferSize);
  let offset = 0;
  chunks.forEach((chunk) => {
    if (singleChunkIsBuffer(chunk)) {
      const opcode = asMinimalOP(chunk);
      if (opcode !== void 0) {
        writeUInt8(buffer2, offset, opcode);
        offset += 1;
        return;
      }
      offset += encode(buffer2, chunk.length, offset);
      buffer2.set(chunk, offset);
      offset += chunk.length;
    } else {
      writeUInt8(buffer2, offset, chunk);
      offset += 1;
    }
  });
  if (offset !== buffer2.length) throw new Error("Could not decode chunks");
  return buffer2;
}
function decompile(buffer2) {
  if (chunksIsArray(buffer2)) return buffer2;
  parse(BufferSchema, buffer2);
  const chunks = [];
  let i = 0;
  while (i < buffer2.length) {
    const opcode = buffer2[i];
    if (opcode > OPS.OP_0 && opcode <= OPS.OP_PUSHDATA4) {
      const d = decode(buffer2, i);
      if (d === null) return null;
      i += d.size;
      if (i + d.number > buffer2.length) return null;
      const data = buffer2.slice(i, i + d.number);
      i += d.number;
      const op = asMinimalOP(data);
      if (op !== void 0) {
        chunks.push(op);
      } else {
        chunks.push(data);
      }
    } else {
      chunks.push(opcode);
      i += 1;
    }
  }
  return chunks;
}
function toStack(chunks) {
  chunks = decompile(chunks);
  parse(custom(isPushOnly), chunks);
  return chunks.map((op) => {
    if (singleChunkIsBuffer(op)) return op;
    if (op === OPS.OP_0) return new Uint8Array(0);
    return encode2(op - OP_INT_BASE);
  });
}
function isDefinedHashType(hashType) {
  const hashTypeMod = hashType & ~128;
  return hashTypeMod > 0 && hashTypeMod < 4;
}
function isCanonicalScriptSignature(buffer2) {
  if (!(buffer2 instanceof Uint8Array)) return false;
  if (!isDefinedHashType(buffer2[buffer2.length - 1])) return false;
  return check(buffer2.slice(0, -1));
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/payments/lazy.js
init_buffer_polyfill();
function prop(object3, name10, f) {
  Object.defineProperty(object3, name10, {
    configurable: true,
    enumerable: true,
    get() {
      const _value = f.call(this);
      this[name10] = _value;
      return _value;
    },
    set(_value) {
      Object.defineProperty(this, name10, {
        configurable: true,
        enumerable: true,
        value: _value,
        writable: true
      });
    }
  });
}
function value(f) {
  let _value;
  return () => {
    if (_value !== void 0) return _value;
    _value = f();
    return _value;
  };
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/payments/embed.js
var OPS2 = OPS;
function p2data(a, opts) {
  if (!a.data && !a.output) throw new TypeError("Not enough data");
  opts = Object.assign({ validate: true }, opts || {});
  parse(
    partial(
      object({
        network: object({}),
        output: BufferSchema,
        data: array(BufferSchema)
      })
    ),
    a
  );
  const network = a.network || bitcoin;
  const o = { name: "embed", network };
  prop(o, "output", () => {
    if (!a.data) return;
    return compile([OPS2.OP_RETURN].concat(a.data));
  });
  prop(o, "data", () => {
    if (!a.output) return;
    return decompile(a.output).slice(1);
  });
  if (opts.validate) {
    if (a.output) {
      const chunks = decompile(a.output);
      if (chunks[0] !== OPS2.OP_RETURN) throw new TypeError("Output is invalid");
      if (!chunks.slice(1).every((chunk) => is(BufferSchema, chunk)))
        throw new TypeError("Output is invalid");
      if (a.data && !stacksEqual(a.data, o.data))
        throw new TypeError("Data mismatch");
    }
  }
  return Object.assign(o, a);
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/payments/p2ms.js
init_buffer_polyfill();
var OPS3 = OPS;
var OP_INT_BASE2 = OPS3.OP_RESERVED;
function encodeSmallOrScriptNum(n2) {
  return n2 <= 16 ? OP_INT_BASE2 + n2 : encode2(n2);
}
function decodeSmallOrScriptNum(chunk) {
  if (typeof chunk === "number") {
    const val = chunk - OP_INT_BASE2;
    if (val < 1 || val > 16)
      throw new TypeError(`Invalid opcode: expected OP_1\u2013OP_16, got ${chunk}`);
    return val;
  } else return decode2(chunk);
}
function isSmallOrScriptNum(chunk) {
  if (typeof chunk === "number")
    return chunk - OP_INT_BASE2 >= 1 && chunk - OP_INT_BASE2 <= 16;
  else return Number.isInteger(decode2(chunk));
}
function p2ms(a, opts) {
  if (!a.input && !a.output && !(a.pubkeys && a.m !== void 0) && !a.signatures)
    throw new TypeError("Not enough data");
  opts = Object.assign({ validate: true }, opts || {});
  function isAcceptableSignature(x) {
    return isCanonicalScriptSignature(x) || (opts.allowIncomplete && x === OPS3.OP_0) !== void 0;
  }
  parse(
    partial(
      object({
        network: object({}),
        m: number(),
        n: number(),
        output: BufferSchema,
        pubkeys: array(custom(isPoint), "Received invalid pubkey"),
        signatures: array(
          custom(isAcceptableSignature),
          "Expected signature to be of type isAcceptableSignature"
        ),
        input: BufferSchema
      })
    ),
    a
  );
  const network = a.network || bitcoin;
  const o = { network };
  let chunks = [];
  let decoded = false;
  function decode44(output) {
    if (decoded) return;
    decoded = true;
    chunks = decompile(output);
    if (chunks.length < 3) throw new TypeError("Output is invalid");
    o.m = decodeSmallOrScriptNum(chunks[0]);
    o.n = decodeSmallOrScriptNum(chunks[chunks.length - 2]);
    o.pubkeys = chunks.slice(1, -2);
  }
  prop(o, "output", () => {
    if (!a.m) return;
    if (!o.n) return;
    if (!a.pubkeys) return;
    return compile(
      [].concat(
        encodeSmallOrScriptNum(a.m),
        a.pubkeys,
        encodeSmallOrScriptNum(o.n),
        OPS3.OP_CHECKMULTISIG
      )
    );
  });
  prop(o, "m", () => {
    if (!o.output) return;
    decode44(o.output);
    return o.m;
  });
  prop(o, "n", () => {
    if (!o.pubkeys) return;
    return o.pubkeys.length;
  });
  prop(o, "pubkeys", () => {
    if (!a.output) return;
    decode44(a.output);
    return o.pubkeys;
  });
  prop(o, "signatures", () => {
    if (!a.input) return;
    return decompile(a.input).slice(1);
  });
  prop(o, "input", () => {
    if (!a.signatures) return;
    return compile([OPS3.OP_0].concat(a.signatures));
  });
  prop(o, "witness", () => {
    if (!o.input) return;
    return [];
  });
  prop(o, "name", () => {
    if (!o.m || !o.n) return;
    return `p2ms(${o.m} of ${o.n})`;
  });
  if (opts.validate) {
    if (a.output) {
      decode44(a.output);
      if (!isSmallOrScriptNum(chunks[0]))
        throw new TypeError("Output is invalid");
      if (!isSmallOrScriptNum(chunks[chunks.length - 2]))
        throw new TypeError("Output is invalid");
      if (chunks[chunks.length - 1] !== OPS3.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (o.m <= 0 || o.n > 20 || o.m > o.n || o.n !== chunks.length - 3)
        throw new TypeError("Output is invalid");
      if (!o.pubkeys.every((x) => isPoint(x)))
        throw new TypeError("Output is invalid");
      if (a.m !== void 0 && a.m !== o.m) throw new TypeError("m mismatch");
      if (a.n !== void 0 && a.n !== o.n) throw new TypeError("n mismatch");
      if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (a.pubkeys) {
      if (a.n !== void 0 && a.n !== a.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      o.n = a.pubkeys.length;
      if (o.n < o.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (a.signatures) {
      if (a.signatures.length < o.m)
        throw new TypeError("Not enough signatures provided");
      if (a.signatures.length > o.m)
        throw new TypeError("Too many signatures provided");
    }
    if (a.input) {
      if (a.input[0] !== OPS3.OP_0) throw new TypeError("Input is invalid");
      if (o.signatures.length === 0 || !o.signatures.every(isAcceptableSignature))
        throw new TypeError("Input has invalid signature(s)");
      if (a.signatures && !stacksEqual(a.signatures, o.signatures))
        throw new TypeError("Signature mismatch");
      if (a.m !== void 0 && a.m !== a.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(o, a);
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/payments/p2pk.js
init_buffer_polyfill();
var OPS4 = OPS;
function p2pk(a, opts) {
  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)
    throw new TypeError("Not enough data");
  opts = Object.assign({ validate: true }, opts || {});
  parse(
    partial(
      object({
        network: object({}),
        output: BufferSchema,
        pubkey: custom(isPoint, "invalid pubkey"),
        signature: custom(
          isCanonicalScriptSignature,
          "Expected signature to be of type isCanonicalScriptSignature"
        ),
        input: BufferSchema
      })
    ),
    a
  );
  const _chunks = value(() => {
    return decompile(a.input);
  });
  const network = a.network || bitcoin;
  const o = { name: "p2pk", network };
  prop(o, "output", () => {
    if (!a.pubkey) return;
    return compile([a.pubkey, OPS4.OP_CHECKSIG]);
  });
  prop(o, "pubkey", () => {
    if (!a.output) return;
    return a.output.slice(1, -1);
  });
  prop(o, "signature", () => {
    if (!a.input) return;
    return _chunks()[0];
  });
  prop(o, "input", () => {
    if (!a.signature) return;
    return compile([a.signature]);
  });
  prop(o, "witness", () => {
    if (!o.input) return;
    return [];
  });
  if (opts.validate) {
    if (a.output) {
      if (a.output[a.output.length - 1] !== OPS4.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!isPoint(o.pubkey)) throw new TypeError("Output pubkey is invalid");
      if (a.pubkey && compare(a.pubkey, o.pubkey) !== 0)
        throw new TypeError("Pubkey mismatch");
    }
    if (a.signature) {
      if (a.input && compare(a.input, o.input) !== 0)
        throw new TypeError("Signature mismatch");
    }
    if (a.input) {
      if (_chunks().length !== 1) throw new TypeError("Input is invalid");
      if (!isCanonicalScriptSignature(o.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(o, a);
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/payments/p2pkh.js
init_buffer_polyfill();

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/crypto.js
init_buffer_polyfill();

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/ripemd160.js
init_buffer_polyfill();

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/legacy.js
init_buffer_polyfill();

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_md.js
init_buffer_polyfill();

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js
init_buffer_polyfill();
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error("positive integer expected, got " + n2);
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash(h3) {
  if (typeof h3 !== "function" || typeof h3.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber(h3.outputLen);
  anumber(h3.blockLen);
}
function aexists(instance3, checkFinished = true) {
  if (instance3.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance3.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance3) {
  abytes(out);
  const min = instance3.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function clean(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function rotl(word, shift) {
  return word << shift | word >>> 32 - shift >>> 0;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
var Hash = class {
};
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value2, isLE) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value2, isLE);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value2 >> _32n2 & _u32_max);
  const wl = Number(value2 & _u32_max);
  const h3 = isLE ? 4 : 0;
  const l = isLE ? 0 : 4;
  view.setUint32(byteOffset + h3, wh, isLE);
  view.setUint32(byteOffset + l, wl, isLE);
}
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes(data);
    const { view, buffer: buffer2, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView2 = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView2, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length: length6, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length6;
    to.pos = pos;
    if (length6 % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA512_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/legacy.js
var Rho160 = /* @__PURE__ */ Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
var Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();
var idxLR = /* @__PURE__ */ (() => {
  const L = [Id160];
  const R = [Pi160];
  const res = [L, R];
  for (let i = 0; i < 4; i++)
    for (let j of res)
      j.push(j[i].map((k) => Rho160[k]));
  return res;
})();
var idxL = /* @__PURE__ */ (() => idxLR[0])();
var idxR = /* @__PURE__ */ (() => idxLR[1])();
var shifts160 = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => Uint8Array.from(i));
var shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
var shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
var Kl160 = /* @__PURE__ */ Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr160 = /* @__PURE__ */ Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function ripemd_f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  if (group === 1)
    return x & y | ~x & z;
  if (group === 2)
    return (x | ~y) ^ z;
  if (group === 3)
    return x & z | y & ~z;
  return x ^ (y | ~z);
}
var BUF_160 = /* @__PURE__ */ new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3, h4 } = this;
    return [h0, h1, h22, h3, h4];
  }
  set(h0, h1, h22, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      BUF_160[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl160[group], hbr = Kr160[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL160[group], sr = shiftsR160[group];
      for (let i = 0; i < 16; i++) {
        const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    clean(BUF_160);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = /* @__PURE__ */ createHasher(() => new RIPEMD160());

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/ripemd160.js
var ripemd1602 = ripemd160;

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha256.js
init_buffer_polyfill();

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha2.js
init_buffer_polyfill();

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_u64.js
init_buffer_polyfill();
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i = 0; i < len; i++) {
    const { h: h3, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h3, l];
  }
  return [Ah, Al];
}
var shrSH = (h3, _l, s) => h3 >>> s;
var shrSL = (h3, l, s) => h3 << 32 - s | l >>> s;
var rotrSH = (h3, l, s) => h3 >>> s | l << 32 - s;
var rotrSL = (h3, l, s) => h3 << 32 - s | l >>> s;
var rotrBH = (h3, l, s) => h3 << 64 - s | l >>> s - 32;
var rotrBL = (h3, l, s) => h3 >>> s - 32 | l << 64 - s;
function add(Ah, Al, Bh, Bl2) {
  const l = (Al >>> 0) + (Bl2 >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl2, Cl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl2, Cl, Dl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl2, Cl, Dl, El) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha2.js
var SHA256_K = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G: G2, H } = this;
    return [A, B, C, D, E, F, G2, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G2, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G2 | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G: G2, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G2) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G2;
      G2 = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G2 = G2 + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G2, H);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var K512 = /* @__PURE__ */ (() => split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = SHA512_IV[0] | 0;
    this.Al = SHA512_IV[1] | 0;
    this.Bh = SHA512_IV[2] | 0;
    this.Bl = SHA512_IV[3] | 0;
    this.Ch = SHA512_IV[4] | 0;
    this.Cl = SHA512_IV[5] | 0;
    this.Dh = SHA512_IV[6] | 0;
    this.Dl = SHA512_IV[7] | 0;
    this.Eh = SHA512_IV[8] | 0;
    this.El = SHA512_IV[9] | 0;
    this.Fh = SHA512_IV[10] | 0;
    this.Fl = SHA512_IV[11] | 0;
    this.Gh = SHA512_IV[12] | 0;
    this.Gl = SHA512_IV[13] | 0;
    this.Hh = SHA512_IV[14] | 0;
    this.Hl = SHA512_IV[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl: Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl2 | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl: Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl2 ^ Al & Cl ^ Bl2 & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl2 | 0;
      Bh = Ah | 0;
      Bl2 = Al | 0;
      const All = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl2 } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl2 | 0));
    ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var sha256 = /* @__PURE__ */ createHasher(() => new SHA256());
var sha512 = /* @__PURE__ */ createHasher(() => new SHA512());

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha256.js
var sha2562 = sha256;

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/crypto.js
function hash160(buffer2) {
  return ripemd1602(sha2562(buffer2));
}
var TAGGED_HASH_PREFIXES = {
  "BIP0340/challenge": Uint8Array.from([
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124,
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124
  ]),
  "BIP0340/aux": Uint8Array.from([
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144,
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144
  ]),
  "BIP0340/nonce": Uint8Array.from([
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47,
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47
  ]),
  TapLeaf: Uint8Array.from([
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238,
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238
  ]),
  TapBranch: Uint8Array.from([
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21,
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21
  ]),
  TapSighash: Uint8Array.from([
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49,
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49
  ]),
  TapTweak: Uint8Array.from([
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233,
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233
  ]),
  "KeyAgg list": Uint8Array.from([
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240,
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240
  ]),
  "KeyAgg coefficient": Uint8Array.from([
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129,
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129
  ])
};
function taggedHash(prefix, data) {
  return sha2562(concat([TAGGED_HASH_PREFIXES[prefix], data]));
}

// node_modules/.pnpm/bs58check@4.0.0/node_modules/bs58check/src/esm/index.js
init_buffer_polyfill();

// node_modules/.pnpm/bs58check@4.0.0/node_modules/bs58check/src/esm/base.js
init_buffer_polyfill();

// node_modules/.pnpm/bs58@6.0.0/node_modules/bs58/src/esm/index.js
init_buffer_polyfill();

// node_modules/.pnpm/base-x@5.0.1/node_modules/base-x/src/esm/index.js
init_buffer_polyfill();
function base(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (let i = 0; i < ALPHABET2.length; i++) {
    const x = ALPHABET2.charAt(i);
    const xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  const BASE = ALPHABET2.length;
  const LEADER = ALPHABET2.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode42(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length6 = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i = 0;
      for (let it1 = size - 1; (carry !== 0 || i < length6) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length6 = i;
      pbegin++;
    }
    let it2 = size - length6;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length6 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i = 0;
      for (let it3 = size - 1; (carry !== 0 || i < length6) && it3 !== -1; it3--, i++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length6 = i;
      psz++;
    }
    let it4 = size - length6;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size - it4));
    let j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  function decode44(string5) {
    const buffer2 = decodeUnsafe(string5);
    if (buffer2) {
      return buffer2;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode42,
    decodeUnsafe,
    decode: decode44
  };
}
var esm_default = base;

// node_modules/.pnpm/bs58@6.0.0/node_modules/bs58/src/esm/index.js
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default2 = esm_default(ALPHABET);

// node_modules/.pnpm/bs58check@4.0.0/node_modules/bs58check/src/esm/base.js
function base_default(checksumFn) {
  function encode42(payload) {
    var payloadU8 = Uint8Array.from(payload);
    var checksum2 = checksumFn(payloadU8);
    var length6 = payloadU8.length + 4;
    var both = new Uint8Array(length6);
    both.set(payloadU8, 0);
    both.set(checksum2.subarray(0, 4), payloadU8.length);
    return esm_default2.encode(both);
  }
  function decodeRaw(buffer2) {
    var payload = buffer2.slice(0, -4);
    var checksum2 = buffer2.slice(-4);
    var newChecksum = checksumFn(payload);
    if (checksum2[0] ^ newChecksum[0] | checksum2[1] ^ newChecksum[1] | checksum2[2] ^ newChecksum[2] | checksum2[3] ^ newChecksum[3])
      return;
    return payload;
  }
  function decodeUnsafe(str) {
    var buffer2 = esm_default2.decodeUnsafe(str);
    if (buffer2 == null)
      return;
    return decodeRaw(buffer2);
  }
  function decode44(str) {
    var buffer2 = esm_default2.decode(str);
    var payload = decodeRaw(buffer2);
    if (payload == null)
      throw new Error("Invalid checksum");
    return payload;
  }
  return {
    encode: encode42,
    decode: decode44,
    decodeUnsafe
  };
}

// node_modules/.pnpm/bs58check@4.0.0/node_modules/bs58check/src/esm/index.js
function sha256x2(buffer2) {
  return sha2562(sha2562(buffer2));
}
var esm_default3 = base_default(sha256x2);

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/payments/p2pkh.js
var OPS5 = OPS;
function p2pkh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)
    throw new TypeError("Not enough data");
  opts = Object.assign({ validate: true }, opts || {});
  parse(
    partial(
      object({
        network: object({}),
        address: string(),
        hash: Hash160bitSchema,
        output: NBufferSchemaFactory(25),
        pubkey: custom(isPoint),
        signature: custom(isCanonicalScriptSignature),
        input: BufferSchema
      })
    ),
    a
  );
  const _address = value(() => {
    const payload = esm_default3.decode(a.address);
    const version = readUInt8(payload, 0);
    const hash = payload.slice(1);
    return { version, hash };
  });
  const _chunks = value(() => {
    return decompile(a.input);
  });
  const network = a.network || bitcoin;
  const o = { name: "p2pkh", network };
  prop(o, "address", () => {
    if (!o.hash) return;
    const payload = new Uint8Array(21);
    writeUInt8(payload, 0, network.pubKeyHash);
    payload.set(o.hash, 1);
    return esm_default3.encode(payload);
  });
  prop(o, "hash", () => {
    if (a.output) return a.output.slice(3, 23);
    if (a.address) return _address().hash;
    if (a.pubkey || o.pubkey) return hash160(a.pubkey || o.pubkey);
  });
  prop(o, "output", () => {
    if (!o.hash) return;
    return compile([
      OPS5.OP_DUP,
      OPS5.OP_HASH160,
      o.hash,
      OPS5.OP_EQUALVERIFY,
      OPS5.OP_CHECKSIG
    ]);
  });
  prop(o, "pubkey", () => {
    if (!a.input) return;
    return _chunks()[1];
  });
  prop(o, "signature", () => {
    if (!a.input) return;
    return _chunks()[0];
  });
  prop(o, "input", () => {
    if (!a.pubkey) return;
    if (!a.signature) return;
    return compile([a.signature, a.pubkey]);
  });
  prop(o, "witness", () => {
    if (!o.input) return;
    return [];
  });
  if (opts.validate) {
    let hash = Uint8Array.from([]);
    if (a.address) {
      if (_address().version !== network.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (_address().hash.length !== 20) throw new TypeError("Invalid address");
      hash = _address().hash;
    }
    if (a.hash) {
      if (hash.length > 0 && compare(hash, a.hash) !== 0)
        throw new TypeError("Hash mismatch");
      else hash = a.hash;
    }
    if (a.output) {
      if (a.output.length !== 25 || a.output[0] !== OPS5.OP_DUP || a.output[1] !== OPS5.OP_HASH160 || a.output[2] !== 20 || a.output[23] !== OPS5.OP_EQUALVERIFY || a.output[24] !== OPS5.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const hash2 = a.output.slice(3, 23);
      if (hash.length > 0 && compare(hash, hash2) !== 0)
        throw new TypeError("Hash mismatch");
      else hash = hash2;
    }
    if (a.pubkey) {
      const pkh = hash160(a.pubkey);
      if (hash.length > 0 && compare(hash, pkh) !== 0)
        throw new TypeError("Hash mismatch");
      else hash = pkh;
    }
    if (a.input) {
      const chunks = _chunks();
      if (chunks.length !== 2) throw new TypeError("Input is invalid");
      if (!isCanonicalScriptSignature(chunks[0]))
        throw new TypeError("Input has invalid signature");
      if (!isPoint(chunks[1])) throw new TypeError("Input has invalid pubkey");
      if (a.signature && compare(a.signature, chunks[0]) !== 0)
        throw new TypeError("Signature mismatch");
      if (a.pubkey && compare(a.pubkey, chunks[1]) !== 0)
        throw new TypeError("Pubkey mismatch");
      const pkh = hash160(chunks[1]);
      if (hash.length > 0 && compare(hash, pkh) !== 0)
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(o, a);
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/payments/p2sh.js
init_buffer_polyfill();
var OPS6 = OPS;
function p2sh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)
    throw new TypeError("Not enough data");
  opts = Object.assign({ validate: true }, opts || {});
  parse(
    partial(
      object({
        network: object({}),
        address: string(),
        hash: NBufferSchemaFactory(20),
        output: NBufferSchemaFactory(23),
        redeem: partial(
          object({
            network: object({}),
            output: BufferSchema,
            input: BufferSchema,
            witness: array(BufferSchema)
          })
        ),
        input: BufferSchema,
        witness: array(BufferSchema)
      })
    ),
    a
  );
  let network = a.network;
  if (!network) {
    network = a.redeem && a.redeem.network || bitcoin;
  }
  const o = { network };
  const _address = value(() => {
    const payload = esm_default3.decode(a.address);
    const version = readUInt8(payload, 0);
    const hash = payload.slice(1);
    return { version, hash };
  });
  const _chunks = value(() => {
    return decompile(a.input);
  });
  const _redeem = value(() => {
    const chunks = _chunks();
    const lastChunk = chunks[chunks.length - 1];
    return {
      network,
      output: lastChunk === OPS6.OP_FALSE ? Uint8Array.from([]) : lastChunk,
      input: compile(chunks.slice(0, -1)),
      witness: a.witness || []
    };
  });
  prop(o, "address", () => {
    if (!o.hash) return;
    const payload = new Uint8Array(21);
    writeUInt8(payload, 0, o.network.scriptHash);
    payload.set(o.hash, 1);
    return esm_default3.encode(payload);
  });
  prop(o, "hash", () => {
    if (a.output) return a.output.slice(2, 22);
    if (a.address) return _address().hash;
    if (o.redeem && o.redeem.output) return hash160(o.redeem.output);
  });
  prop(o, "output", () => {
    if (!o.hash) return;
    return compile([OPS6.OP_HASH160, o.hash, OPS6.OP_EQUAL]);
  });
  prop(o, "redeem", () => {
    if (!a.input) return;
    return _redeem();
  });
  prop(o, "input", () => {
    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;
    return compile(
      [].concat(decompile(a.redeem.input), a.redeem.output)
    );
  });
  prop(o, "witness", () => {
    if (o.redeem && o.redeem.witness) return o.redeem.witness;
    if (o.input) return [];
  });
  prop(o, "name", () => {
    const nameParts = ["p2sh"];
    if (o.redeem !== void 0 && o.redeem.name !== void 0)
      nameParts.push(o.redeem.name);
    return nameParts.join("-");
  });
  if (opts.validate) {
    let hash = Uint8Array.from([]);
    if (a.address) {
      if (_address().version !== network.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (_address().hash.length !== 20) throw new TypeError("Invalid address");
      hash = _address().hash;
    }
    if (a.hash) {
      if (hash.length > 0 && compare(hash, a.hash) !== 0)
        throw new TypeError("Hash mismatch");
      else hash = a.hash;
    }
    if (a.output) {
      if (a.output.length !== 23 || a.output[0] !== OPS6.OP_HASH160 || a.output[1] !== 20 || a.output[22] !== OPS6.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const hash2 = a.output.slice(2, 22);
      if (hash.length > 0 && compare(hash, hash2) !== 0)
        throw new TypeError("Hash mismatch");
      else hash = hash2;
    }
    const checkRedeem = (redeem) => {
      if (redeem.output) {
        const decompile2 = decompile(redeem.output);
        if (!decompile2 || decompile2.length < 1)
          throw new TypeError("Redeem.output too short");
        if (redeem.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (countNonPushOnlyOPs(decompile2) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const hash2 = hash160(redeem.output);
        if (hash.length > 0 && compare(hash, hash2) !== 0)
          throw new TypeError("Hash mismatch");
        else hash = hash2;
      }
      if (redeem.input) {
        const hasInput = redeem.input.length > 0;
        const hasWitness = redeem.witness && redeem.witness.length > 0;
        if (!hasInput && !hasWitness) throw new TypeError("Empty input");
        if (hasInput && hasWitness)
          throw new TypeError("Input and witness provided");
        if (hasInput) {
          const richunks = decompile(redeem.input);
          if (!isPushOnly(richunks))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (a.input) {
      const chunks = _chunks();
      if (!chunks || chunks.length < 1) throw new TypeError("Input too short");
      if (!(_redeem().output instanceof Uint8Array))
        throw new TypeError("Input is invalid");
      checkRedeem(_redeem());
    }
    if (a.redeem) {
      if (a.redeem.network && a.redeem.network !== network)
        throw new TypeError("Network mismatch");
      if (a.input) {
        const redeem = _redeem();
        if (a.redeem.output && compare(a.redeem.output, redeem.output) !== 0)
          throw new TypeError("Redeem.output mismatch");
        if (a.redeem.input && compare(a.redeem.input, redeem.input) !== 0)
          throw new TypeError("Redeem.input mismatch");
      }
      checkRedeem(a.redeem);
    }
    if (a.witness) {
      if (a.redeem && a.redeem.witness && !stacksEqual(a.redeem.witness, a.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
    }
  }
  return Object.assign(o, a);
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/payments/p2wpkh.js
init_buffer_polyfill();
var import_bech32 = __toESM(require_dist(), 1);
var OPS7 = OPS;
var EMPTY_BUFFER = new Uint8Array(0);
function p2wpkh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)
    throw new TypeError("Not enough data");
  opts = Object.assign({ validate: true }, opts || {});
  parse(
    partial(
      object({
        address: string(),
        hash: NBufferSchemaFactory(20),
        input: NBufferSchemaFactory(0),
        network: object({}),
        output: NBufferSchemaFactory(22),
        pubkey: custom(isPoint, "Not a valid pubkey"),
        signature: custom(isCanonicalScriptSignature),
        witness: array(BufferSchema)
      })
    ),
    a
  );
  const _address = value(() => {
    const result = import_bech32.bech32.decode(a.address);
    const version = result.words.shift();
    const data = import_bech32.bech32.fromWords(result.words);
    return {
      version,
      prefix: result.prefix,
      data: Uint8Array.from(data)
    };
  });
  const network = a.network || bitcoin;
  const o = { name: "p2wpkh", network };
  prop(o, "address", () => {
    if (!o.hash) return;
    const words = import_bech32.bech32.toWords(o.hash);
    words.unshift(0);
    return import_bech32.bech32.encode(network.bech32, words);
  });
  prop(o, "hash", () => {
    if (a.output) return a.output.slice(2, 22);
    if (a.address) return _address().data;
    if (a.pubkey || o.pubkey) return hash160(a.pubkey || o.pubkey);
  });
  prop(o, "output", () => {
    if (!o.hash) return;
    return compile([OPS7.OP_0, o.hash]);
  });
  prop(o, "pubkey", () => {
    if (a.pubkey) return a.pubkey;
    if (!a.witness) return;
    return a.witness[1];
  });
  prop(o, "signature", () => {
    if (!a.witness) return;
    return a.witness[0];
  });
  prop(o, "input", () => {
    if (!o.witness) return;
    return EMPTY_BUFFER;
  });
  prop(o, "witness", () => {
    if (!a.pubkey) return;
    if (!a.signature) return;
    return [a.signature, a.pubkey];
  });
  if (opts.validate) {
    let hash = Uint8Array.from([]);
    if (a.address) {
      if (network && network.bech32 !== _address().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (_address().version !== 0)
        throw new TypeError("Invalid address version");
      if (_address().data.length !== 20)
        throw new TypeError("Invalid address data");
      hash = _address().data;
    }
    if (a.hash) {
      if (hash.length > 0 && compare(hash, a.hash) !== 0)
        throw new TypeError("Hash mismatch");
      else hash = a.hash;
    }
    if (a.output) {
      if (a.output.length !== 22 || a.output[0] !== OPS7.OP_0 || a.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (hash.length > 0 && compare(hash, a.output.slice(2)) !== 0)
        throw new TypeError("Hash mismatch");
      else hash = a.output.slice(2);
    }
    if (a.pubkey) {
      const pkh = hash160(a.pubkey);
      if (hash.length > 0 && compare(hash, pkh) !== 0)
        throw new TypeError("Hash mismatch");
      else hash = pkh;
      if (!isPoint(a.pubkey) || a.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (a.witness) {
      if (a.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!isCanonicalScriptSignature(a.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!isPoint(a.witness[1]) || a.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (a.signature && compare(a.signature, a.witness[0]) !== 0)
        throw new TypeError("Signature mismatch");
      if (a.pubkey && compare(a.pubkey, a.witness[1]) !== 0)
        throw new TypeError("Pubkey mismatch");
      const pkh = hash160(a.witness[1]);
      if (hash.length > 0 && compare(hash, pkh) !== 0)
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(o, a);
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/payments/p2wsh.js
init_buffer_polyfill();
var import_bech322 = __toESM(require_dist(), 1);
var OPS8 = OPS;
var EMPTY_BUFFER2 = new Uint8Array(0);
function chunkHasUncompressedPubkey(chunk) {
  if (chunk instanceof Uint8Array && chunk.length === 65 && chunk[0] === 4 && isPoint(chunk)) {
    return true;
  } else {
    return false;
  }
}
function p2wsh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)
    throw new TypeError("Not enough data");
  opts = Object.assign({ validate: true }, opts || {});
  parse(
    NullablePartial({
      network: object({}),
      address: string(),
      hash: Buffer256bitSchema,
      output: NBufferSchemaFactory(34),
      redeem: NullablePartial({
        input: BufferSchema,
        network: object({}),
        output: BufferSchema,
        witness: array(BufferSchema)
      }),
      input: NBufferSchemaFactory(0),
      witness: array(BufferSchema)
    }),
    a
  );
  const _address = value(() => {
    const result = import_bech322.bech32.decode(a.address);
    const version = result.words.shift();
    const data = import_bech322.bech32.fromWords(result.words);
    return {
      version,
      prefix: result.prefix,
      data: Uint8Array.from(data)
    };
  });
  const _rchunks = value(() => {
    return decompile(a.redeem.input);
  });
  let network = a.network;
  if (!network) {
    network = a.redeem && a.redeem.network || bitcoin;
  }
  const o = { network };
  prop(o, "address", () => {
    if (!o.hash) return;
    const words = import_bech322.bech32.toWords(o.hash);
    words.unshift(0);
    return import_bech322.bech32.encode(network.bech32, words);
  });
  prop(o, "hash", () => {
    if (a.output) return a.output.slice(2);
    if (a.address) return _address().data;
    if (o.redeem && o.redeem.output) return sha2562(o.redeem.output);
  });
  prop(o, "output", () => {
    if (!o.hash) return;
    return compile([OPS8.OP_0, o.hash]);
  });
  prop(o, "redeem", () => {
    if (!a.witness) return;
    return {
      output: a.witness[a.witness.length - 1],
      input: EMPTY_BUFFER2,
      witness: a.witness.slice(0, -1)
    };
  });
  prop(o, "input", () => {
    if (!o.witness) return;
    return EMPTY_BUFFER2;
  });
  prop(o, "witness", () => {
    if (a.redeem && a.redeem.input && a.redeem.input.length > 0 && a.redeem.output && a.redeem.output.length > 0) {
      const stack = toStack(_rchunks());
      o.redeem = Object.assign({ witness: stack }, a.redeem);
      o.redeem.input = EMPTY_BUFFER2;
      return [].concat(stack, a.redeem.output);
    }
    if (!a.redeem) return;
    if (!a.redeem.output) return;
    if (!a.redeem.witness) return;
    return [].concat(a.redeem.witness, a.redeem.output);
  });
  prop(o, "name", () => {
    const nameParts = ["p2wsh"];
    if (o.redeem !== void 0 && o.redeem.name !== void 0)
      nameParts.push(o.redeem.name);
    return nameParts.join("-");
  });
  if (opts.validate) {
    let hash = Uint8Array.from([]);
    if (a.address) {
      if (_address().prefix !== network.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (_address().version !== 0)
        throw new TypeError("Invalid address version");
      if (_address().data.length !== 32)
        throw new TypeError("Invalid address data");
      hash = _address().data;
    }
    if (a.hash) {
      if (hash.length > 0 && compare(hash, a.hash) !== 0)
        throw new TypeError("Hash mismatch");
      else hash = a.hash;
    }
    if (a.output) {
      if (a.output.length !== 34 || a.output[0] !== OPS8.OP_0 || a.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const hash2 = a.output.slice(2);
      if (hash.length > 0 && compare(hash, hash2) !== 0)
        throw new TypeError("Hash mismatch");
      else hash = hash2;
    }
    if (a.redeem) {
      if (a.redeem.network && a.redeem.network !== network)
        throw new TypeError("Network mismatch");
      if (a.redeem.input && a.redeem.input.length > 0 && a.redeem.witness && a.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (a.redeem.output) {
        const decompile2 = decompile(a.redeem.output);
        if (!decompile2 || decompile2.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (a.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (countNonPushOnlyOPs(decompile2) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const hash2 = sha2562(a.redeem.output);
        if (hash.length > 0 && compare(hash, hash2) !== 0)
          throw new TypeError("Hash mismatch");
        else hash = hash2;
      }
      if (a.redeem.input && !isPushOnly(_rchunks()))
        throw new TypeError("Non push-only scriptSig");
      if (a.witness && a.redeem.witness && !stacksEqual(a.witness, a.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey) || a.redeem.output && (decompile(a.redeem.output) || []).some(
        chunkHasUncompressedPubkey
      )) {
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
      }
    }
    if (a.witness && a.witness.length > 0) {
      const wScript = a.witness[a.witness.length - 1];
      if (a.redeem && a.redeem.output && compare(a.redeem.output, wScript) !== 0)
        throw new TypeError("Witness and redeem.output mismatch");
      if (a.witness.some(chunkHasUncompressedPubkey) || (decompile(wScript) || []).some(chunkHasUncompressedPubkey))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(o, a);
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/payments/p2tr.js
init_buffer_polyfill();

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/ecc_lib.js
init_buffer_polyfill();
var _ECCLIB_CACHE = {};
function initEccLib(eccLib, opts) {
  if (!eccLib) {
    _ECCLIB_CACHE.eccLib = eccLib;
  } else if (eccLib !== _ECCLIB_CACHE.eccLib) {
    if (!opts?.DANGER_DO_NOT_VERIFY_ECCLIB)
      verifyEcc(eccLib);
    _ECCLIB_CACHE.eccLib = eccLib;
  }
}
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return _ECCLIB_CACHE.eccLib;
}
var h = (hex) => fromHex(hex);
function verifyEcc(ecc2) {
  assert(typeof ecc2.isXOnlyPoint === "function");
  assert(
    ecc2.isXOnlyPoint(
      h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  );
  assert(
    ecc2.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  );
  assert(
    ecc2.isXOnlyPoint(
      h("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  );
  assert(
    ecc2.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000001")
    )
  );
  assert(
    !ecc2.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000000")
    )
  );
  assert(
    !ecc2.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  );
  assert(typeof ecc2.xOnlyPointAddTweak === "function");
  tweakAddVectors.forEach((t) => {
    const r = ecc2.xOnlyPointAddTweak(h(t.pubkey), h(t.tweak));
    if (t.result === null) {
      assert(r === null);
    } else {
      assert(r !== null);
      assert(r.parity === t.parity);
      assert(compare(r.xOnlyPubkey, h(t.result)) === 0);
    }
  });
}
function assert(bool) {
  if (!bool) throw new Error("ecc library invalid");
}
var tweakAddVectors = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
];

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/payments/bip341.js
init_buffer_polyfill();

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/bufferutils.js
init_buffer_polyfill();

// node_modules/.pnpm/varuint-bitcoin@2.0.0/node_modules/varuint-bitcoin/src/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  decode: () => decode4,
  encode: () => encode4,
  encodingLength: () => encodingLength2
});
init_buffer_polyfill();

// node_modules/.pnpm/uint8array-tools@0.0.8/node_modules/uint8array-tools/src/mjs/browser.js
init_buffer_polyfill();
var HEX_STRINGS2 = "0123456789abcdefABCDEF";
var HEX_CODES2 = HEX_STRINGS2.split("").map((c) => c.codePointAt(0));
var HEX_CODEPOINTS2 = Array(256).fill(true).map((_, i) => {
  const s = String.fromCodePoint(i);
  const index = HEX_STRINGS2.indexOf(s);
  return index < 0 ? void 0 : index < 16 ? index : index - 6;
});
var ENCODER2 = new TextEncoder();
var DECODER2 = new TextDecoder();
function fromUtf82(s) {
  return ENCODER2.encode(s);
}
function concat2(arrays) {
  const totalLength = arrays.reduce((a, b) => a + b.length, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const array2 of arrays) {
    result.set(array2, offset);
    offset += array2.length;
  }
  return result;
}
function fromHex2(hexString) {
  const hexBytes = ENCODER2.encode(hexString || "");
  const resultBytes = new Uint8Array(Math.floor(hexBytes.length / 2));
  let i;
  for (i = 0; i < resultBytes.length; i++) {
    const a = HEX_CODEPOINTS2[hexBytes[i * 2]];
    const b = HEX_CODEPOINTS2[hexBytes[i * 2 + 1]];
    if (a === void 0 || b === void 0) {
      break;
    }
    resultBytes[i] = a << 4 | b;
  }
  return i === resultBytes.length ? resultBytes : resultBytes.slice(0, i);
}
function compare2(v1, v2) {
  const minLength = Math.min(v1.length, v2.length);
  for (let i = 0; i < minLength; ++i) {
    if (v1[i] !== v2[i]) {
      return v1[i] < v2[i] ? -1 : 1;
    }
  }
  return v1.length === v2.length ? 0 : v1.length > v2.length ? 1 : -1;
}
function writeUInt82(buffer2, offset, value2) {
  if (offset + 1 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  if (value2 > 255) {
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${255}. Received ${value2}`);
  }
  buffer2[offset] = value2;
}
function writeUInt162(buffer2, offset, value2, littleEndian) {
  if (offset + 2 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (value2 > 65535) {
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${65535}. Received ${value2}`);
  }
  if (littleEndian === "LE") {
    buffer2[offset] = value2 & 255;
    buffer2[offset + 1] = value2 >> 8 & 255;
  } else {
    buffer2[offset] = value2 >> 8 & 255;
    buffer2[offset + 1] = value2 & 255;
  }
}
function writeUInt322(buffer2, offset, value2, littleEndian) {
  if (offset + 4 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (value2 > 4294967295) {
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${value2}`);
  }
  if (littleEndian === "LE") {
    buffer2[offset] = value2 & 255;
    buffer2[offset + 1] = value2 >> 8 & 255;
    buffer2[offset + 2] = value2 >> 16 & 255;
    buffer2[offset + 3] = value2 >> 24 & 255;
  } else {
    buffer2[offset] = value2 >> 24 & 255;
    buffer2[offset + 1] = value2 >> 16 & 255;
    buffer2[offset + 2] = value2 >> 8 & 255;
    buffer2[offset + 3] = value2 & 255;
  }
}
function writeUInt64(buffer2, offset, value2, littleEndian) {
  if (offset + 8 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (value2 > 0xffffffffffffffffn) {
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${value2}`);
  }
  if (littleEndian === "LE") {
    buffer2[offset] = Number(value2 & 0xffn);
    buffer2[offset + 1] = Number(value2 >> 8n & 0xffn);
    buffer2[offset + 2] = Number(value2 >> 16n & 0xffn);
    buffer2[offset + 3] = Number(value2 >> 24n & 0xffn);
    buffer2[offset + 4] = Number(value2 >> 32n & 0xffn);
    buffer2[offset + 5] = Number(value2 >> 40n & 0xffn);
    buffer2[offset + 6] = Number(value2 >> 48n & 0xffn);
    buffer2[offset + 7] = Number(value2 >> 56n & 0xffn);
  } else {
    buffer2[offset] = Number(value2 >> 56n & 0xffn);
    buffer2[offset + 1] = Number(value2 >> 48n & 0xffn);
    buffer2[offset + 2] = Number(value2 >> 40n & 0xffn);
    buffer2[offset + 3] = Number(value2 >> 32n & 0xffn);
    buffer2[offset + 4] = Number(value2 >> 24n & 0xffn);
    buffer2[offset + 5] = Number(value2 >> 16n & 0xffn);
    buffer2[offset + 6] = Number(value2 >> 8n & 0xffn);
    buffer2[offset + 7] = Number(value2 & 0xffn);
  }
}
function readUInt162(buffer2, offset, littleEndian) {
  if (offset + 2 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    let num2 = 0;
    num2 = (num2 << 8) + buffer2[offset + 1];
    num2 = (num2 << 8) + buffer2[offset];
    return num2;
  } else {
    let num2 = 0;
    num2 = (num2 << 8) + buffer2[offset];
    num2 = (num2 << 8) + buffer2[offset + 1];
    return num2;
  }
}
function readUInt322(buffer2, offset, littleEndian) {
  if (offset + 4 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    let num2 = 0;
    num2 = (num2 << 8) + buffer2[offset + 3] >>> 0;
    num2 = (num2 << 8) + buffer2[offset + 2] >>> 0;
    num2 = (num2 << 8) + buffer2[offset + 1] >>> 0;
    num2 = (num2 << 8) + buffer2[offset] >>> 0;
    return num2;
  } else {
    let num2 = 0;
    num2 = (num2 << 8) + buffer2[offset] >>> 0;
    num2 = (num2 << 8) + buffer2[offset + 1] >>> 0;
    num2 = (num2 << 8) + buffer2[offset + 2] >>> 0;
    num2 = (num2 << 8) + buffer2[offset + 3] >>> 0;
    return num2;
  }
}
function readUInt64(buffer2, offset, littleEndian) {
  if (offset + 8 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    let num2 = 0n;
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 7]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 6]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 5]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 4]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 3]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 2]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 1]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset]);
    return num2;
  } else {
    let num2 = 0n;
    num2 = (num2 << 8n) + BigInt(buffer2[offset]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 1]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 2]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 3]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 4]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 5]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 6]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 7]);
    return num2;
  }
}

// node_modules/.pnpm/varuint-bitcoin@2.0.0/node_modules/varuint-bitcoin/src/esm/index.js
var checkUInt64 = (n2) => {
  if (n2 < 0 || n2 > 0xffffffffffffffffn) {
    throw new RangeError("value out of range");
  }
};
function checkUInt53(n2) {
  if (n2 < 0 || n2 > Number.MAX_SAFE_INTEGER || n2 % 1 !== 0)
    throw new RangeError("value out of range");
}
function checkUint53OrUint64(n2) {
  if (typeof n2 === "number")
    checkUInt53(n2);
  else
    checkUInt64(n2);
}
function encode4(n2, buffer2, offset) {
  checkUint53OrUint64(n2);
  if (offset === void 0)
    offset = 0;
  if (buffer2 === void 0) {
    buffer2 = new Uint8Array(encodingLength2(n2));
  }
  let bytes = 0;
  if (n2 < 253) {
    buffer2.set([Number(n2)], offset);
    bytes = 1;
  } else if (n2 <= 65535) {
    buffer2.set([253], offset);
    writeUInt162(buffer2, offset + 1, Number(n2), "LE");
    bytes = 3;
  } else if (n2 <= 4294967295) {
    buffer2.set([254], offset);
    writeUInt322(buffer2, offset + 1, Number(n2), "LE");
    bytes = 5;
  } else {
    buffer2.set([255], offset);
    writeUInt64(buffer2, offset + 1, BigInt(n2), "LE");
    bytes = 9;
  }
  return { buffer: buffer2, bytes };
}
function decode4(buffer2, offset) {
  if (offset === void 0)
    offset = 0;
  const first2 = buffer2.at(offset);
  if (first2 === void 0)
    throw new Error("buffer too small");
  if (first2 < 253) {
    return { numberValue: first2, bigintValue: BigInt(first2), bytes: 1 };
  } else if (first2 === 253) {
    const val = readUInt162(buffer2, offset + 1, "LE");
    return {
      numberValue: val,
      bigintValue: BigInt(val),
      bytes: 3
    };
  } else if (first2 === 254) {
    const val = readUInt322(buffer2, offset + 1, "LE");
    return {
      numberValue: val,
      bigintValue: BigInt(val),
      bytes: 5
    };
  } else {
    const number3 = readUInt64(buffer2, offset + 1, "LE");
    return { numberValue: number3 <= Number.MAX_SAFE_INTEGER ? Number(number3) : null, bigintValue: number3, bytes: 9 };
  }
}
function encodingLength2(n2) {
  checkUint53OrUint64(n2);
  return n2 < 253 ? 1 : n2 <= 65535 ? 3 : n2 <= 4294967295 ? 5 : 9;
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/payments/bip341.js
var LEAF_VERSION_TAPSCRIPT = 192;
var isHashBranch = (ht) => "left" in ht && "right" in ht;
function rootHashFromPath(controlBlock, leafHash) {
  if (controlBlock.length < 33)
    throw new TypeError(
      `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`
    );
  const m = (controlBlock.length - 33) / 32;
  let kj = leafHash;
  for (let j = 0; j < m; j++) {
    const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);
    if (compare(kj, ej) < 0) {
      kj = tapBranchHash(kj, ej);
    } else {
      kj = tapBranchHash(ej, kj);
    }
  }
  return kj;
}
function toHashTree(scriptTree) {
  if (isTapleaf(scriptTree)) return { hash: tapleafHash(scriptTree) };
  const hashes4 = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];
  hashes4.sort((a, b) => compare(a.hash, b.hash));
  const [left, right] = hashes4;
  return {
    hash: tapBranchHash(left.hash, right.hash),
    left,
    right
  };
}
function findScriptPath(node, hash) {
  if (isHashBranch(node)) {
    const leftPath = findScriptPath(node.left, hash);
    if (leftPath !== void 0) return [...leftPath, node.right.hash];
    const rightPath = findScriptPath(node.right, hash);
    if (rightPath !== void 0) return [...rightPath, node.left.hash];
  } else if (compare(node.hash, hash) === 0) {
    return [];
  }
  return void 0;
}
function tapleafHash(leaf) {
  const version = leaf.version || LEAF_VERSION_TAPSCRIPT;
  return taggedHash(
    "TapLeaf",
    concat([Uint8Array.from([version]), serializeScript(leaf.output)])
  );
}
function tapTweakHash(pubKey, h3) {
  return taggedHash(
    "TapTweak",
    concat(h3 ? [pubKey, h3] : [pubKey])
  );
}
function tweakKey(pubKey, h3) {
  if (!(pubKey instanceof Uint8Array)) return null;
  if (pubKey.length !== 32) return null;
  if (h3 && h3.length !== 32) return null;
  const tweakHash = tapTweakHash(pubKey, h3);
  const res = getEccLib().xOnlyPointAddTweak(pubKey, tweakHash);
  if (!res || res.xOnlyPubkey === null) return null;
  return {
    parity: res.parity,
    x: Uint8Array.from(res.xOnlyPubkey)
  };
}
function tapBranchHash(a, b) {
  return taggedHash("TapBranch", concat([a, b]));
}
function serializeScript(s) {
  const varintLen = esm_exports.encodingLength(s.length);
  const buffer2 = new Uint8Array(varintLen);
  esm_exports.encode(s.length, buffer2);
  return concat([buffer2, s]);
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/payments/p2tr.js
var import_bech323 = __toESM(require_dist(), 1);
var OPS9 = OPS;
var TAPROOT_WITNESS_VERSION = 1;
var ANNEX_PREFIX = 80;
function p2tr(a, opts) {
  if (!a.address && !a.output && !a.pubkey && !a.internalPubkey && !(a.witness && a.witness.length > 1))
    throw new TypeError("Not enough data");
  opts = Object.assign({ validate: true }, opts || {});
  parse(
    partial(
      object({
        address: string(),
        input: NBufferSchemaFactory(0),
        network: object({}),
        output: NBufferSchemaFactory(34),
        internalPubkey: NBufferSchemaFactory(32),
        hash: NBufferSchemaFactory(32),
        // merkle root hash, the tweak
        pubkey: NBufferSchemaFactory(32),
        // tweaked with `hash` from `internalPubkey`
        signature: union([
          NBufferSchemaFactory(64),
          NBufferSchemaFactory(65)
        ]),
        witness: array(BufferSchema),
        scriptTree: custom(isTaptree, "Taptree is not of type isTaptree"),
        redeem: partial(
          object({
            output: BufferSchema,
            // tapleaf script
            redeemVersion: number(),
            // tapleaf version
            witness: array(BufferSchema)
          })
        ),
        redeemVersion: number()
      })
    ),
    a
  );
  const _address = value(() => {
    return fromBech32(a.address);
  });
  const _witness = value(() => {
    if (!a.witness || !a.witness.length) return;
    if (a.witness.length >= 2 && a.witness[a.witness.length - 1][0] === ANNEX_PREFIX) {
      return a.witness.slice(0, -1);
    }
    return a.witness.slice();
  });
  const _hashTree = value(() => {
    if (a.scriptTree) return toHashTree(a.scriptTree);
    if (a.hash) return { hash: a.hash };
    return;
  });
  const network = a.network || bitcoin;
  const o = { name: "p2tr", network };
  prop(o, "address", () => {
    if (!o.pubkey) return;
    const words = import_bech323.bech32m.toWords(o.pubkey);
    words.unshift(TAPROOT_WITNESS_VERSION);
    return import_bech323.bech32m.encode(network.bech32, words);
  });
  prop(o, "hash", () => {
    const hashTree = _hashTree();
    if (hashTree) return hashTree.hash;
    const w = _witness();
    if (w && w.length > 1) {
      const controlBlock = w[w.length - 1];
      const leafVersion = controlBlock[0] & TAPLEAF_VERSION_MASK;
      const script = w[w.length - 2];
      const leafHash = tapleafHash({ output: script, version: leafVersion });
      return rootHashFromPath(controlBlock, leafHash);
    }
    return null;
  });
  prop(o, "output", () => {
    if (!o.pubkey) return;
    return compile([OPS9.OP_1, o.pubkey]);
  });
  prop(o, "redeemVersion", () => {
    if (a.redeemVersion) return a.redeemVersion;
    if (a.redeem && a.redeem.redeemVersion !== void 0 && a.redeem.redeemVersion !== null) {
      return a.redeem.redeemVersion;
    }
    return LEAF_VERSION_TAPSCRIPT;
  });
  prop(o, "redeem", () => {
    const witness = _witness();
    if (!witness || witness.length < 2) return;
    return {
      output: witness[witness.length - 2],
      witness: witness.slice(0, -2),
      redeemVersion: witness[witness.length - 1][0] & TAPLEAF_VERSION_MASK
    };
  });
  prop(o, "pubkey", () => {
    if (a.pubkey) return a.pubkey;
    if (a.output) return a.output.slice(2);
    if (a.address) return _address().data;
    if (o.internalPubkey) {
      const tweakedKey = tweakKey(o.internalPubkey, o.hash);
      if (tweakedKey) return tweakedKey.x;
    }
  });
  prop(o, "internalPubkey", () => {
    if (a.internalPubkey) return a.internalPubkey;
    const witness = _witness();
    if (witness && witness.length > 1)
      return witness[witness.length - 1].slice(1, 33);
  });
  prop(o, "signature", () => {
    if (a.signature) return a.signature;
    const witness = _witness();
    if (!witness || witness.length !== 1) return;
    return witness[0];
  });
  prop(o, "witness", () => {
    if (a.witness) return a.witness;
    const hashTree = _hashTree();
    if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {
      const leafHash = tapleafHash({
        output: a.redeem.output,
        version: o.redeemVersion
      });
      const path = findScriptPath(hashTree, leafHash);
      if (!path) return;
      const outputKey = tweakKey(a.internalPubkey, hashTree.hash);
      if (!outputKey) return;
      const controlBock = concat(
        [
          Uint8Array.from([o.redeemVersion | outputKey.parity]),
          a.internalPubkey
        ].concat(path)
      );
      return [a.redeem.output, controlBock];
    }
    if (a.signature) return [a.signature];
  });
  if (opts.validate) {
    let pubkey = Uint8Array.from([]);
    if (a.address) {
      if (network && network.bech32 !== _address().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (_address().version !== TAPROOT_WITNESS_VERSION)
        throw new TypeError("Invalid address version");
      if (_address().data.length !== 32)
        throw new TypeError("Invalid address data");
      pubkey = _address().data;
    }
    if (a.pubkey) {
      if (pubkey.length > 0 && compare(pubkey, a.pubkey) !== 0)
        throw new TypeError("Pubkey mismatch");
      else pubkey = a.pubkey;
    }
    if (a.output) {
      if (a.output.length !== 34 || a.output[0] !== OPS9.OP_1 || a.output[1] !== 32)
        throw new TypeError("Output is invalid");
      if (pubkey.length > 0 && compare(pubkey, a.output.slice(2)) !== 0)
        throw new TypeError("Pubkey mismatch");
      else pubkey = a.output.slice(2);
    }
    if (a.internalPubkey) {
      const tweakedKey = tweakKey(a.internalPubkey, o.hash);
      if (pubkey.length > 0 && compare(pubkey, tweakedKey.x) !== 0)
        throw new TypeError("Pubkey mismatch");
      else pubkey = tweakedKey.x;
    }
    if (pubkey && pubkey.length) {
      if (!getEccLib().isXOnlyPoint(pubkey))
        throw new TypeError("Invalid pubkey for p2tr");
    }
    const hashTree = _hashTree();
    if (a.hash && hashTree) {
      if (compare(a.hash, hashTree.hash) !== 0)
        throw new TypeError("Hash mismatch");
    }
    if (a.redeem && a.redeem.output && hashTree) {
      const leafHash = tapleafHash({
        output: a.redeem.output,
        version: o.redeemVersion
      });
      if (!findScriptPath(hashTree, leafHash))
        throw new TypeError("Redeem script not in tree");
    }
    const witness = _witness();
    if (a.redeem && o.redeem) {
      if (a.redeem.redeemVersion) {
        if (a.redeem.redeemVersion !== o.redeem.redeemVersion)
          throw new TypeError("Redeem.redeemVersion and witness mismatch");
      }
      if (a.redeem.output) {
        if (decompile(a.redeem.output).length === 0)
          throw new TypeError("Redeem.output is invalid");
        if (o.redeem.output && compare(a.redeem.output, o.redeem.output) !== 0)
          throw new TypeError("Redeem.output and witness mismatch");
      }
      if (a.redeem.witness) {
        if (o.redeem.witness && !stacksEqual(a.redeem.witness, o.redeem.witness))
          throw new TypeError("Redeem.witness and witness mismatch");
      }
    }
    if (witness && witness.length) {
      if (witness.length === 1) {
        if (a.signature && compare(a.signature, witness[0]) !== 0)
          throw new TypeError("Signature mismatch");
      } else {
        const controlBlock = witness[witness.length - 1];
        if (controlBlock.length < 33)
          throw new TypeError(
            `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`
          );
        if ((controlBlock.length - 33) % 32 !== 0)
          throw new TypeError(
            `The control-block length of ${controlBlock.length} is incorrect!`
          );
        const m = (controlBlock.length - 33) / 32;
        if (m > 128)
          throw new TypeError(
            `The script path is too long. Got ${m}, expected max 128.`
          );
        const internalPubkey = controlBlock.slice(1, 33);
        if (a.internalPubkey && compare(a.internalPubkey, internalPubkey) !== 0)
          throw new TypeError("Internal pubkey mismatch");
        if (!getEccLib().isXOnlyPoint(internalPubkey))
          throw new TypeError("Invalid internalPubkey for p2tr witness");
        const leafVersion = controlBlock[0] & TAPLEAF_VERSION_MASK;
        const script = witness[witness.length - 2];
        const leafHash = tapleafHash({ output: script, version: leafVersion });
        const hash = rootHashFromPath(controlBlock, leafHash);
        const outputKey = tweakKey(internalPubkey, hash);
        if (!outputKey)
          throw new TypeError("Invalid outputKey for p2tr witness");
        if (pubkey.length && compare(pubkey, outputKey.x) !== 0)
          throw new TypeError("Pubkey mismatch for p2tr witness");
        if (outputKey.parity !== (controlBlock[0] & 1))
          throw new Error("Incorrect parity");
      }
    }
  }
  return Object.assign(o, a);
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/address.js
var import_bech324 = __toESM(require_dist(), 1);
function fromBech32(address) {
  let result;
  let version;
  try {
    result = import_bech324.bech32.decode(address);
  } catch (e) {
  }
  if (result) {
    version = result.words[0];
    if (version !== 0) throw new TypeError(address + " uses wrong encoding");
  } else {
    result = import_bech324.bech32m.decode(address);
    version = result.words[0];
    if (version === 0) throw new TypeError(address + " uses wrong encoding");
  }
  const data = import_bech324.bech32.fromWords(result.words.slice(1));
  return {
    version,
    prefix: result.prefix,
    data: Uint8Array.from(data)
  };
}

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/block.js
init_buffer_polyfill();

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/merkle.js
init_buffer_polyfill();

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/transaction.js
init_buffer_polyfill();
var EMPTY_BUFFER3 = new Uint8Array(0);
var ZERO2 = fromHex(
  "0000000000000000000000000000000000000000000000000000000000000000"
);
var ONE = fromHex(
  "0000000000000000000000000000000000000000000000000000000000000001"
);
var VALUE_UINT64_MAX = fromHex("ffffffffffffffff");

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/block.js
var errorMerkleNoTxes = new TypeError(
  "Cannot compute merkle root for zero transactions"
);
var errorWitnessNotSegwit = new TypeError(
  "Cannot compute witness commit for non-segwit block"
);

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/psbt.js
init_buffer_polyfill();

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/psbt.js
init_buffer_polyfill();

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/combiner/index.js
init_buffer_polyfill();

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/parser/index.js
init_buffer_polyfill();

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/parser/fromBuffer.js
init_buffer_polyfill();

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/index.js
var converter_exports = {};
__export(converter_exports, {
  globals: () => globals2,
  inputs: () => inputs,
  outputs: () => outputs
});
init_buffer_polyfill();

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/typeFields.js
init_buffer_polyfill();
var GlobalTypes;
(function(GlobalTypes2) {
  GlobalTypes2[GlobalTypes2["UNSIGNED_TX"] = 0] = "UNSIGNED_TX";
  GlobalTypes2[GlobalTypes2["GLOBAL_XPUB"] = 1] = "GLOBAL_XPUB";
})(GlobalTypes || (GlobalTypes = {}));
var InputTypes;
(function(InputTypes2) {
  InputTypes2[InputTypes2["NON_WITNESS_UTXO"] = 0] = "NON_WITNESS_UTXO";
  InputTypes2[InputTypes2["WITNESS_UTXO"] = 1] = "WITNESS_UTXO";
  InputTypes2[InputTypes2["PARTIAL_SIG"] = 2] = "PARTIAL_SIG";
  InputTypes2[InputTypes2["SIGHASH_TYPE"] = 3] = "SIGHASH_TYPE";
  InputTypes2[InputTypes2["REDEEM_SCRIPT"] = 4] = "REDEEM_SCRIPT";
  InputTypes2[InputTypes2["WITNESS_SCRIPT"] = 5] = "WITNESS_SCRIPT";
  InputTypes2[InputTypes2["BIP32_DERIVATION"] = 6] = "BIP32_DERIVATION";
  InputTypes2[InputTypes2["FINAL_SCRIPTSIG"] = 7] = "FINAL_SCRIPTSIG";
  InputTypes2[InputTypes2["FINAL_SCRIPTWITNESS"] = 8] = "FINAL_SCRIPTWITNESS";
  InputTypes2[InputTypes2["POR_COMMITMENT"] = 9] = "POR_COMMITMENT";
  InputTypes2[InputTypes2["TAP_KEY_SIG"] = 19] = "TAP_KEY_SIG";
  InputTypes2[InputTypes2["TAP_SCRIPT_SIG"] = 20] = "TAP_SCRIPT_SIG";
  InputTypes2[InputTypes2["TAP_LEAF_SCRIPT"] = 21] = "TAP_LEAF_SCRIPT";
  InputTypes2[InputTypes2["TAP_BIP32_DERIVATION"] = 22] = "TAP_BIP32_DERIVATION";
  InputTypes2[InputTypes2["TAP_INTERNAL_KEY"] = 23] = "TAP_INTERNAL_KEY";
  InputTypes2[InputTypes2["TAP_MERKLE_ROOT"] = 24] = "TAP_MERKLE_ROOT";
})(InputTypes || (InputTypes = {}));
var OutputTypes;
(function(OutputTypes2) {
  OutputTypes2[OutputTypes2["REDEEM_SCRIPT"] = 0] = "REDEEM_SCRIPT";
  OutputTypes2[OutputTypes2["WITNESS_SCRIPT"] = 1] = "WITNESS_SCRIPT";
  OutputTypes2[OutputTypes2["BIP32_DERIVATION"] = 2] = "BIP32_DERIVATION";
  OutputTypes2[OutputTypes2["TAP_INTERNAL_KEY"] = 5] = "TAP_INTERNAL_KEY";
  OutputTypes2[OutputTypes2["TAP_TREE"] = 6] = "TAP_TREE";
  OutputTypes2[OutputTypes2["TAP_BIP32_DERIVATION"] = 7] = "TAP_BIP32_DERIVATION";
})(OutputTypes || (OutputTypes = {}));

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/global/globalXpub.js
var globalXpub_exports = {};
__export(globalXpub_exports, {
  canAddToArray: () => canAddToArray,
  check: () => check2,
  decode: () => decode5,
  encode: () => encode5,
  expected: () => expected
});
init_buffer_polyfill();
var range = (n2) => [...Array(n2).keys()];
function decode5(keyVal) {
  if (keyVal.key[0] !== GlobalTypes.GLOBAL_XPUB) {
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + toHex(keyVal.key)
    );
  }
  if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + toHex(keyVal.key)
    );
  }
  if (keyVal.value.length / 4 % 1 !== 0) {
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  }
  const extendedPubkey = keyVal.key.slice(1);
  const data = {
    masterFingerprint: keyVal.value.slice(0, 4),
    extendedPubkey,
    path: "m"
  };
  for (const i of range(keyVal.value.length / 4 - 1)) {
    const val = readUInt32(keyVal.value, i * 4 + 4, "LE");
    const isHard = !!(val & 2147483648);
    const idx = val & 2147483647;
    data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
  }
  return data;
}
function encode5(data) {
  const head = new Uint8Array([GlobalTypes.GLOBAL_XPUB]);
  const key = concat([head, data.extendedPubkey]);
  const splitPath = data.path.split("/");
  const value2 = new Uint8Array(splitPath.length * 4);
  value2.set(data.masterFingerprint, 0);
  let offset = 4;
  splitPath.slice(1).forEach((level) => {
    const isHard = level.slice(-1) === "'";
    let num2 = 2147483647 & parseInt(isHard ? level.slice(0, -1) : level, 10);
    if (isHard) num2 += 2147483648;
    writeUInt32(value2, offset, num2, "LE");
    offset += 4;
  });
  return {
    key,
    value: value2
  };
}
var expected = "{ masterFingerprint: Uint8Array; extendedPubkey: Uint8Array; path: string; }";
function check2(data) {
  const epk = data.extendedPubkey;
  const mfp = data.masterFingerprint;
  const p = data.path;
  return epk instanceof Uint8Array && epk.length === 78 && [2, 3].indexOf(epk[45]) > -1 && mfp instanceof Uint8Array && mfp.length === 4 && typeof p === "string" && !!p.match(/^m(\/\d+'?)*$/);
}
function canAddToArray(array2, item, dupeSet) {
  const dupeString = toHex(item.extendedPubkey);
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return array2.filter((v) => compare(v.extendedPubkey, item.extendedPubkey)).length === 0;
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/global/unsignedTx.js
var unsignedTx_exports = {};
__export(unsignedTx_exports, {
  encode: () => encode6
});
init_buffer_polyfill();
function encode6(data) {
  return {
    key: new Uint8Array([GlobalTypes.UNSIGNED_TX]),
    value: data.toBuffer()
  };
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/input/finalScriptSig.js
var finalScriptSig_exports = {};
__export(finalScriptSig_exports, {
  canAdd: () => canAdd,
  check: () => check3,
  decode: () => decode6,
  encode: () => encode7,
  expected: () => expected2
});
init_buffer_polyfill();
function decode6(keyVal) {
  if (keyVal.key[0] !== InputTypes.FINAL_SCRIPTSIG) {
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + toHex(keyVal.key)
    );
  }
  return keyVal.value;
}
function encode7(data) {
  const key = new Uint8Array([InputTypes.FINAL_SCRIPTSIG]);
  return {
    key,
    value: data
  };
}
var expected2 = "Uint8Array";
function check3(data) {
  return data instanceof Uint8Array;
}
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.finalScriptSig === void 0;
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/input/finalScriptWitness.js
var finalScriptWitness_exports = {};
__export(finalScriptWitness_exports, {
  canAdd: () => canAdd2,
  check: () => check4,
  decode: () => decode7,
  encode: () => encode8,
  expected: () => expected3
});
init_buffer_polyfill();
function decode7(keyVal) {
  if (keyVal.key[0] !== InputTypes.FINAL_SCRIPTWITNESS) {
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + toHex(keyVal.key)
    );
  }
  return keyVal.value;
}
function encode8(data) {
  const key = new Uint8Array([InputTypes.FINAL_SCRIPTWITNESS]);
  return {
    key,
    value: data
  };
}
var expected3 = "Uint8Array";
function check4(data) {
  return data instanceof Uint8Array;
}
function canAdd2(currentData, newData) {
  return !!currentData && !!newData && currentData.finalScriptWitness === void 0;
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/input/nonWitnessUtxo.js
var nonWitnessUtxo_exports = {};
__export(nonWitnessUtxo_exports, {
  canAdd: () => canAdd3,
  check: () => check5,
  decode: () => decode8,
  encode: () => encode9,
  expected: () => expected4
});
init_buffer_polyfill();
function decode8(keyVal) {
  if (keyVal.key[0] !== InputTypes.NON_WITNESS_UTXO) {
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + toHex(keyVal.key)
    );
  }
  return keyVal.value;
}
function encode9(data) {
  return {
    key: new Uint8Array([InputTypes.NON_WITNESS_UTXO]),
    value: data
  };
}
var expected4 = "Uint8Array";
function check5(data) {
  return data instanceof Uint8Array;
}
function canAdd3(currentData, newData) {
  return !!currentData && !!newData && currentData.nonWitnessUtxo === void 0;
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/input/partialSig.js
var partialSig_exports = {};
__export(partialSig_exports, {
  canAddToArray: () => canAddToArray2,
  check: () => check6,
  decode: () => decode9,
  encode: () => encode10,
  expected: () => expected5
});
init_buffer_polyfill();
function decode9(keyVal) {
  if (keyVal.key[0] !== InputTypes.PARTIAL_SIG) {
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + toHex(keyVal.key)
    );
  }
  if (!(keyVal.key.length === 34 || keyVal.key.length === 66) || ![2, 3, 4].includes(keyVal.key[1])) {
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + toHex(keyVal.key)
    );
  }
  const pubkey = keyVal.key.slice(1);
  return {
    pubkey,
    signature: keyVal.value
  };
}
function encode10(pSig) {
  const head = new Uint8Array([InputTypes.PARTIAL_SIG]);
  return {
    key: concat([head, pSig.pubkey]),
    value: pSig.signature
  };
}
var expected5 = "{ pubkey: Uint8Array; signature: Uint8Array; }";
function check6(data) {
  return data.pubkey instanceof Uint8Array && data.signature instanceof Uint8Array && [33, 65].includes(data.pubkey.length) && [2, 3, 4].includes(data.pubkey[0]) && isDerSigWithSighash(data.signature);
}
function isDerSigWithSighash(buf2) {
  if (!(buf2 instanceof Uint8Array) || buf2.length < 9) return false;
  if (buf2[0] !== 48) return false;
  if (buf2.length !== buf2[1] + 3) return false;
  if (buf2[2] !== 2) return false;
  const rLen = buf2[3];
  if (rLen > 33 || rLen < 1) return false;
  if (buf2[3 + rLen + 1] !== 2) return false;
  const sLen = buf2[3 + rLen + 2];
  if (sLen > 33 || sLen < 1) return false;
  if (buf2.length !== 3 + rLen + 2 + sLen + 2) return false;
  return true;
}
function canAddToArray2(array2, item, dupeSet) {
  const dupeString = toHex(item.pubkey);
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return array2.filter((v) => compare(v.pubkey, item.pubkey) === 0).length === 0;
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/input/porCommitment.js
var porCommitment_exports = {};
__export(porCommitment_exports, {
  canAdd: () => canAdd4,
  check: () => check7,
  decode: () => decode10,
  encode: () => encode11,
  expected: () => expected6
});
init_buffer_polyfill();
function decode10(keyVal) {
  if (keyVal.key[0] !== InputTypes.POR_COMMITMENT) {
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + toHex(keyVal.key)
    );
  }
  return toUtf8(keyVal.value);
}
function encode11(data) {
  const key = new Uint8Array([InputTypes.POR_COMMITMENT]);
  return {
    key,
    value: fromUtf8(data)
  };
}
var expected6 = "string";
function check7(data) {
  return typeof data === "string";
}
function canAdd4(currentData, newData) {
  return !!currentData && !!newData && currentData.porCommitment === void 0;
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/input/sighashType.js
var sighashType_exports = {};
__export(sighashType_exports, {
  canAdd: () => canAdd5,
  check: () => check8,
  decode: () => decode11,
  encode: () => encode12,
  expected: () => expected7
});
init_buffer_polyfill();
function decode11(keyVal) {
  if (keyVal.key[0] !== InputTypes.SIGHASH_TYPE) {
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + toHex(keyVal.key)
    );
  }
  return Number(readUInt32(keyVal.value, 0, "LE"));
}
function encode12(data) {
  const key = Uint8Array.from([InputTypes.SIGHASH_TYPE]);
  const value2 = new Uint8Array(4);
  writeUInt32(value2, 0, data, "LE");
  return {
    key,
    value: value2
  };
}
var expected7 = "number";
function check8(data) {
  return typeof data === "number";
}
function canAdd5(currentData, newData) {
  return !!currentData && !!newData && currentData.sighashType === void 0;
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/input/tapKeySig.js
var tapKeySig_exports = {};
__export(tapKeySig_exports, {
  canAdd: () => canAdd6,
  check: () => check9,
  decode: () => decode12,
  encode: () => encode13,
  expected: () => expected8
});
init_buffer_polyfill();
function decode12(keyVal) {
  if (keyVal.key[0] !== InputTypes.TAP_KEY_SIG || keyVal.key.length !== 1) {
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + toHex(keyVal.key)
    );
  }
  if (!check9(keyVal.value)) {
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  }
  return keyVal.value;
}
function encode13(value2) {
  const key = Uint8Array.from([InputTypes.TAP_KEY_SIG]);
  return { key, value: value2 };
}
var expected8 = "Uint8Array";
function check9(data) {
  return data instanceof Uint8Array && (data.length === 64 || data.length === 65);
}
function canAdd6(currentData, newData) {
  return !!currentData && !!newData && currentData.tapKeySig === void 0;
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/input/tapLeafScript.js
var tapLeafScript_exports = {};
__export(tapLeafScript_exports, {
  canAddToArray: () => canAddToArray3,
  check: () => check10,
  decode: () => decode13,
  encode: () => encode14,
  expected: () => expected9
});
init_buffer_polyfill();
function decode13(keyVal) {
  if (keyVal.key[0] !== InputTypes.TAP_LEAF_SCRIPT) {
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + toHex(keyVal.key)
    );
  }
  if ((keyVal.key.length - 2) % 32 !== 0) {
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + toHex(keyVal.key)
    );
  }
  const leafVersion = keyVal.value[keyVal.value.length - 1];
  if ((keyVal.key[1] & 254) !== leafVersion) {
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + toHex(keyVal.key)
    );
  }
  const script = keyVal.value.slice(0, -1);
  const controlBlock = keyVal.key.slice(1);
  return { controlBlock, script, leafVersion };
}
function encode14(tScript) {
  const head = Uint8Array.from([InputTypes.TAP_LEAF_SCRIPT]);
  const verBuf = Uint8Array.from([tScript.leafVersion]);
  return {
    key: concat([head, tScript.controlBlock]),
    value: concat([tScript.script, verBuf])
  };
}
var expected9 = "{ controlBlock: Uint8Array; leafVersion: number, script: Uint8Array; }";
function check10(data) {
  return data.controlBlock instanceof Uint8Array && (data.controlBlock.length - 1) % 32 === 0 && (data.controlBlock[0] & 254) === data.leafVersion && data.script instanceof Uint8Array;
}
function canAddToArray3(array2, item, dupeSet) {
  const dupeString = toHex(item.controlBlock);
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return array2.filter((v) => compare(v.controlBlock, item.controlBlock) === 0).length === 0;
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/input/tapMerkleRoot.js
var tapMerkleRoot_exports = {};
__export(tapMerkleRoot_exports, {
  canAdd: () => canAdd7,
  check: () => check11,
  decode: () => decode14,
  encode: () => encode15,
  expected: () => expected10
});
init_buffer_polyfill();
function decode14(keyVal) {
  if (keyVal.key[0] !== InputTypes.TAP_MERKLE_ROOT || keyVal.key.length !== 1) {
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + toHex(keyVal.key)
    );
  }
  if (!check11(keyVal.value)) {
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  }
  return keyVal.value;
}
function encode15(value2) {
  const key = Uint8Array.from([InputTypes.TAP_MERKLE_ROOT]);
  return { key, value: value2 };
}
var expected10 = "Uint8Array";
function check11(data) {
  return data instanceof Uint8Array && data.length === 32;
}
function canAdd7(currentData, newData) {
  return !!currentData && !!newData && currentData.tapMerkleRoot === void 0;
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/input/tapScriptSig.js
var tapScriptSig_exports = {};
__export(tapScriptSig_exports, {
  canAddToArray: () => canAddToArray4,
  check: () => check12,
  decode: () => decode15,
  encode: () => encode16,
  expected: () => expected11
});
init_buffer_polyfill();
function decode15(keyVal) {
  if (keyVal.key[0] !== InputTypes.TAP_SCRIPT_SIG) {
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + toHex(keyVal.key)
    );
  }
  if (keyVal.key.length !== 65) {
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + toHex(keyVal.key)
    );
  }
  if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + toHex(keyVal.key)
    );
  }
  const pubkey = keyVal.key.slice(1, 33);
  const leafHash = keyVal.key.slice(33);
  return {
    pubkey,
    leafHash,
    signature: keyVal.value
  };
}
function encode16(tSig) {
  const head = Uint8Array.from([InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: concat([head, tSig.pubkey, tSig.leafHash]),
    value: tSig.signature
  };
}
var expected11 = "{ pubkey: Uint8Array; leafHash: Uint8Array; signature: Uint8Array; }";
function check12(data) {
  return data.pubkey instanceof Uint8Array && data.leafHash instanceof Uint8Array && data.signature instanceof Uint8Array && data.pubkey.length === 32 && data.leafHash.length === 32 && (data.signature.length === 64 || data.signature.length === 65);
}
function canAddToArray4(array2, item, dupeSet) {
  const dupeString = toHex(item.pubkey) + toHex(item.leafHash);
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return array2.filter(
    (v) => compare(v.pubkey, item.pubkey) === 0 && compare(v.leafHash, item.leafHash) === 0
  ).length === 0;
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/input/witnessUtxo.js
var witnessUtxo_exports = {};
__export(witnessUtxo_exports, {
  canAdd: () => canAdd8,
  check: () => check13,
  decode: () => decode16,
  encode: () => encode17,
  expected: () => expected12
});
init_buffer_polyfill();
function decode16(keyVal) {
  if (keyVal.key[0] !== InputTypes.WITNESS_UTXO) {
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + toHex(keyVal.key)
    );
  }
  const value2 = readInt64(keyVal.value, 0, "LE");
  let _offset = 8;
  const { numberValue: scriptLen, bytes } = decode4(
    keyVal.value,
    _offset
  );
  _offset += bytes;
  const script = keyVal.value.slice(_offset);
  if (script.length !== scriptLen) {
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  }
  return {
    script,
    value: value2
  };
}
function encode17(data) {
  const { script, value: value2 } = data;
  const varuintlen = encodingLength2(script.length);
  const result = new Uint8Array(8 + varuintlen + script.length);
  writeInt64(result, 0, BigInt(value2), "LE");
  encode4(script.length, result, 8);
  result.set(script, 8 + varuintlen);
  return {
    key: Uint8Array.from([InputTypes.WITNESS_UTXO]),
    value: result
  };
}
var expected12 = "{ script: Uint8Array; value: bigint; }";
function check13(data) {
  return data.script instanceof Uint8Array && typeof data.value === "bigint";
}
function canAdd8(currentData, newData) {
  return !!currentData && !!newData && currentData.witnessUtxo === void 0;
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/output/tapTree.js
var tapTree_exports = {};
__export(tapTree_exports, {
  canAdd: () => canAdd9,
  check: () => check14,
  decode: () => decode17,
  encode: () => encode18,
  expected: () => expected13
});
init_buffer_polyfill();
function decode17(keyVal) {
  if (keyVal.key[0] !== OutputTypes.TAP_TREE || keyVal.key.length !== 1) {
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + toHex(keyVal.key)
    );
  }
  let _offset = 0;
  const data = [];
  while (_offset < keyVal.value.length) {
    const depth = keyVal.value[_offset++];
    const leafVersion = keyVal.value[_offset++];
    const { numberValue: scriptLen, bytes } = decode4(
      keyVal.value,
      _offset
    );
    _offset += bytes;
    data.push({
      depth,
      leafVersion,
      script: keyVal.value.slice(_offset, _offset + scriptLen)
    });
    _offset += scriptLen;
  }
  return { leaves: data };
}
function encode18(tree) {
  const key = Uint8Array.from([OutputTypes.TAP_TREE]);
  const bufs = [].concat(
    ...tree.leaves.map((tapLeaf) => [
      Uint8Array.of(tapLeaf.depth, tapLeaf.leafVersion),
      encode4(BigInt(tapLeaf.script.length)).buffer,
      tapLeaf.script
    ])
  );
  return {
    key,
    value: concat(bufs)
  };
}
var expected13 = "{ leaves: [{ depth: number; leafVersion: number, script: Uint8Array; }] }";
function check14(data) {
  return Array.isArray(data.leaves) && data.leaves.every(
    (tapLeaf) => tapLeaf.depth >= 0 && tapLeaf.depth <= 128 && (tapLeaf.leafVersion & 254) === tapLeaf.leafVersion && tapLeaf.script instanceof Uint8Array
  );
}
function canAdd9(currentData, newData) {
  return !!currentData && !!newData && currentData.tapTree === void 0;
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/shared/bip32Derivation.js
init_buffer_polyfill();
var range2 = (n2) => [...Array(n2).keys()];
var isValidDERKey = (pubkey) => pubkey.length === 33 && [2, 3].includes(pubkey[0]) || pubkey.length === 65 && 4 === pubkey[0];
function makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {
  function decode44(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + toHex(keyVal.key)
      );
    }
    const pubkey = keyVal.key.slice(1);
    if (!isValidPubkey(pubkey)) {
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + toHex(keyVal.key)
      );
    }
    if (keyVal.value.length / 4 % 1 !== 0) {
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    }
    const data = {
      masterFingerprint: keyVal.value.slice(0, 4),
      pubkey,
      path: "m"
    };
    for (const i of range2(keyVal.value.length / 4 - 1)) {
      const val = readUInt32(keyVal.value, i * 4 + 4, "LE");
      const isHard = !!(val & 2147483648);
      const idx = val & 2147483647;
      data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
    }
    return data;
  }
  function encode42(data) {
    const head = Uint8Array.from([TYPE_BYTE]);
    const key = concat([head, data.pubkey]);
    const splitPath = data.path.split("/");
    const value2 = new Uint8Array(splitPath.length * 4);
    value2.set(data.masterFingerprint, 0);
    let offset = 4;
    splitPath.slice(1).forEach((level) => {
      const isHard = level.slice(-1) === "'";
      let num2 = 2147483647 & parseInt(isHard ? level.slice(0, -1) : level, 10);
      if (isHard) num2 += 2147483648;
      writeUInt32(value2, offset, num2, "LE");
      offset += 4;
    });
    return {
      key,
      value: value2
    };
  }
  const expected14 = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; }";
  function check15(data) {
    return data.pubkey instanceof Uint8Array && data.masterFingerprint instanceof Uint8Array && typeof data.path === "string" && isValidPubkey(data.pubkey) && data.masterFingerprint.length === 4;
  }
  function canAddToArray5(array2, item, dupeSet) {
    const dupeString = toHex(item.pubkey);
    if (dupeSet.has(dupeString)) return false;
    dupeSet.add(dupeString);
    return array2.filter((v) => compare(v.pubkey, item.pubkey) === 0).length === 0;
  }
  return {
    decode: decode44,
    encode: encode42,
    check: check15,
    expected: expected14,
    canAddToArray: canAddToArray5
  };
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/shared/checkPubkey.js
init_buffer_polyfill();
function makeChecker(pubkeyTypes) {
  return checkPubkey;
  function checkPubkey(keyVal) {
    let pubkey;
    if (pubkeyTypes.includes(keyVal.key[0])) {
      pubkey = keyVal.key.slice(1);
      if (!(pubkey.length === 33 || pubkey.length === 65) || ![2, 3, 4].includes(pubkey[0])) {
        throw new Error(
          "Format Error: invalid pubkey in key 0x" + toHex(keyVal.key)
        );
      }
    }
    return pubkey;
  }
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/shared/redeemScript.js
init_buffer_polyfill();
function makeConverter2(TYPE_BYTE) {
  function decode44(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + toHex(keyVal.key)
      );
    }
    return keyVal.value;
  }
  function encode42(data) {
    const key = Uint8Array.from([TYPE_BYTE]);
    return {
      key,
      value: data
    };
  }
  const expected14 = "Uint8Array";
  function check15(data) {
    return data instanceof Uint8Array;
  }
  function canAdd10(currentData, newData) {
    return !!currentData && !!newData && currentData.redeemScript === void 0;
  }
  return {
    decode: decode44,
    encode: encode42,
    check: check15,
    expected: expected14,
    canAdd: canAdd10
  };
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/shared/tapBip32Derivation.js
init_buffer_polyfill();
var isValidBIP340Key = (pubkey) => pubkey.length === 32;
function makeConverter3(TYPE_BYTE) {
  const parent = makeConverter(TYPE_BYTE, isValidBIP340Key);
  function decode44(keyVal) {
    const { numberValue: nHashes, bytes: nHashesLen } = decode4(
      keyVal.value
    );
    const base5 = parent.decode({
      key: keyVal.key,
      value: keyVal.value.slice(nHashesLen + Number(nHashes) * 32)
    });
    const leafHashes = new Array(Number(nHashes));
    for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {
      leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);
    }
    return { ...base5, leafHashes };
  }
  function encode42(data) {
    const base5 = parent.encode(data);
    const nHashesLen = encodingLength2(data.leafHashes.length);
    const nHashesBuf = new Uint8Array(nHashesLen);
    encode4(data.leafHashes.length, nHashesBuf);
    const value2 = concat([nHashesBuf, ...data.leafHashes, base5.value]);
    return { ...base5, value: value2 };
  }
  const expected14 = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; leafHashes: Uint8Array[]; }";
  function check15(data) {
    return Array.isArray(data.leafHashes) && data.leafHashes.every(
      (leafHash) => leafHash instanceof Uint8Array && leafHash.length === 32
    ) && parent.check(data);
  }
  return {
    decode: decode44,
    encode: encode42,
    check: check15,
    expected: expected14,
    canAddToArray: parent.canAddToArray
  };
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/shared/tapInternalKey.js
init_buffer_polyfill();
function makeConverter4(TYPE_BYTE) {
  function decode44(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + toHex(keyVal.key)
      );
    }
    if (keyVal.value.length !== 32) {
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    }
    return keyVal.value;
  }
  function encode42(value2) {
    const key = Uint8Array.from([TYPE_BYTE]);
    return { key, value: value2 };
  }
  const expected14 = "Uint8Array";
  function check15(data) {
    return data instanceof Uint8Array && data.length === 32;
  }
  function canAdd10(currentData, newData) {
    return !!currentData && !!newData && currentData.tapInternalKey === void 0;
  }
  return {
    decode: decode44,
    encode: encode42,
    check: check15,
    expected: expected14,
    canAdd: canAdd10
  };
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/shared/witnessScript.js
init_buffer_polyfill();
function makeConverter5(TYPE_BYTE) {
  function decode44(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + toHex(keyVal.key)
      );
    }
    return keyVal.value;
  }
  function encode42(data) {
    const key = Uint8Array.from([TYPE_BYTE]);
    return {
      key,
      value: data
    };
  }
  const expected14 = "Uint8Array";
  function check15(data) {
    return data instanceof Uint8Array;
  }
  function canAdd10(currentData, newData) {
    return !!currentData && !!newData && currentData.witnessScript === void 0;
  }
  return {
    decode: decode44,
    encode: encode42,
    check: check15,
    expected: expected14,
    canAdd: canAdd10
  };
}

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/index.js
var globals2 = {
  unsignedTx: unsignedTx_exports,
  globalXpub: globalXpub_exports,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: makeChecker([])
};
var inputs = {
  nonWitnessUtxo: nonWitnessUtxo_exports,
  partialSig: partialSig_exports,
  sighashType: sighashType_exports,
  finalScriptSig: finalScriptSig_exports,
  finalScriptWitness: finalScriptWitness_exports,
  porCommitment: porCommitment_exports,
  witnessUtxo: witnessUtxo_exports,
  bip32Derivation: makeConverter(InputTypes.BIP32_DERIVATION),
  redeemScript: makeConverter2(InputTypes.REDEEM_SCRIPT),
  witnessScript: makeConverter5(InputTypes.WITNESS_SCRIPT),
  checkPubkey: makeChecker([
    InputTypes.PARTIAL_SIG,
    InputTypes.BIP32_DERIVATION
  ]),
  tapKeySig: tapKeySig_exports,
  tapScriptSig: tapScriptSig_exports,
  tapLeafScript: tapLeafScript_exports,
  tapBip32Derivation: makeConverter3(
    InputTypes.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: makeConverter4(InputTypes.TAP_INTERNAL_KEY),
  tapMerkleRoot: tapMerkleRoot_exports
};
var outputs = {
  bip32Derivation: makeConverter(OutputTypes.BIP32_DERIVATION),
  redeemScript: makeConverter2(OutputTypes.REDEEM_SCRIPT),
  witnessScript: makeConverter5(OutputTypes.WITNESS_SCRIPT),
  checkPubkey: makeChecker([OutputTypes.BIP32_DERIVATION]),
  tapBip32Derivation: makeConverter3(
    OutputTypes.TAP_BIP32_DERIVATION
  ),
  tapTree: tapTree_exports,
  tapInternalKey: makeConverter4(OutputTypes.TAP_INTERNAL_KEY)
};

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/converter/tools.js
init_buffer_polyfill();

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/parser/toBuffer.js
init_buffer_polyfill();

// node_modules/.pnpm/bip174@3.0.0/node_modules/bip174/src/esm/lib/utils.js
init_buffer_polyfill();
function throwForUpdateMaker(typeName, name10, expected14, data) {
  throw new Error(
    `Data for ${typeName} key ${name10} is incorrect: Expected ${expected14} and got ${JSON.stringify(data)}`
  );
}
function updateMaker(typeName) {
  return (updateData, mainData) => {
    for (const name10 of Object.keys(updateData)) {
      const data = updateData[name10];
      const { canAdd: canAdd10, canAddToArray: canAddToArray5, check: check15, expected: expected14 } = (
        // @ts-ignore
        converter_exports[typeName + "s"][name10] || {}
      );
      const isArray = !!canAddToArray5;
      if (check15) {
        if (isArray) {
          if (!Array.isArray(data) || // @ts-ignore
          mainData[name10] && !Array.isArray(mainData[name10])) {
            throw new Error(`Key type ${name10} must be an array`);
          }
          if (!data.every(check15)) {
            throwForUpdateMaker(typeName, name10, expected14, data);
          }
          const arr = mainData[name10] || [];
          const dupeCheckSet = /* @__PURE__ */ new Set();
          if (!data.every((v) => canAddToArray5(arr, v, dupeCheckSet))) {
            throw new Error("Can not add duplicate data to array");
          }
          mainData[name10] = arr.concat(data);
        } else {
          if (!check15(data)) {
            throwForUpdateMaker(typeName, name10, expected14, data);
          }
          if (!canAdd10(mainData, data)) {
            throw new Error(`Can not add duplicate data to ${typeName}`);
          }
          mainData[name10] = data;
        }
      }
    }
  };
}
var updateGlobal = updateMaker("global");
var updateInput = updateMaker("input");
var updateOutput = updateMaker("output");

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/psbt/bip371.js
init_buffer_polyfill();

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/psbt/psbtutils.js
init_buffer_polyfill();
function isPaymentFactory(payment) {
  return (script) => {
    try {
      payment({ output: script });
      return true;
    } catch (err) {
      return false;
    }
  };
}
var isP2MS = isPaymentFactory(p2ms);
var isP2PK = isPaymentFactory(p2pk);
var isP2PKH = isPaymentFactory(p2pkh);
var isP2WPKH = isPaymentFactory(p2wpkh);
var isP2WSHScript = isPaymentFactory(p2wsh);
var isP2SHScript = isPaymentFactory(p2sh);
var isP2TR = isPaymentFactory(p2tr);

// node_modules/.pnpm/bitcoinjs-lib@7.0.1_typescript@5.9.3/node_modules/bitcoinjs-lib/src/esm/psbt.js
function scriptCheckerFactory(payment, paymentScriptName) {
  return (inputIndex, scriptPubKey, redeemScript, ioType) => {
    const redeemScriptOutput = payment({
      redeem: { output: redeemScript }
    }).output;
    if (compare(scriptPubKey, redeemScriptOutput)) {
      throw new Error(
        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`
      );
    }
  };
}
var checkRedeemScript = scriptCheckerFactory(p2sh, "Redeem script");
var checkWitnessScript = scriptCheckerFactory(
  p2wsh,
  "Witness script"
);

// node_modules/.pnpm/bip32@5.0.0_typescript@5.9.3/node_modules/bip32/src/esm/index.js
init_buffer_polyfill();

// node_modules/.pnpm/bip32@5.0.0_typescript@5.9.3/node_modules/bip32/src/esm/bip32.js
init_buffer_polyfill();

// node_modules/.pnpm/bip32@5.0.0_typescript@5.9.3/node_modules/bip32/src/esm/crypto.js
init_buffer_polyfill();

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/hmac.js
init_buffer_polyfill();
var HMAC = class extends Hash {
  constructor(hash, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash);
    const key = toBytes(_key);
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean(pad);
  }
  update(buf2) {
    aexists(this);
    this.iHash.update(buf2);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key) => new HMAC(hash, key);

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha512.js
init_buffer_polyfill();
var sha5122 = sha512;

// node_modules/.pnpm/bip32@5.0.0_typescript@5.9.3/node_modules/bip32/src/esm/crypto.js
function hash1602(buffer2) {
  return ripemd1602(sha2562(buffer2));
}
function hmacSHA512(key, data) {
  return hmac(sha5122, key, data);
}

// node_modules/.pnpm/bip32@5.0.0_typescript@5.9.3/node_modules/bip32/src/esm/testecc.js
init_buffer_polyfill();
var h2 = (hex) => fromHex2(hex);
function testEcc(ecc2) {
  assert2(ecc2.isPoint(h2("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")));
  assert2(!ecc2.isPoint(h2("030000000000000000000000000000000000000000000000000000000000000005")));
  assert2(ecc2.isPrivate(h2("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")));
  assert2(ecc2.isPrivate(h2("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")));
  assert2(!ecc2.isPrivate(h2("0000000000000000000000000000000000000000000000000000000000000000")));
  assert2(!ecc2.isPrivate(h2("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")));
  assert2(!ecc2.isPrivate(h2("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")));
  assert2(compare2(ecc2.pointFromScalar(h2("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), h2("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")) === 0);
  if (ecc2.xOnlyPointAddTweak) {
    assert2(ecc2.xOnlyPointAddTweak(h2("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h2("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
    let xOnlyRes = ecc2.xOnlyPointAddTweak(h2("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), h2("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
    assert2(compare2(xOnlyRes.xOnlyPubkey, h2("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) === 0 && xOnlyRes.parity === 1);
    xOnlyRes = ecc2.xOnlyPointAddTweak(h2("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), h2("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
  }
  assert2(compare2(ecc2.pointAddScalar(h2("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h2("0000000000000000000000000000000000000000000000000000000000000003")), h2("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5")) === 0);
  assert2(compare2(ecc2.privateAdd(h2("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), h2("0000000000000000000000000000000000000000000000000000000000000002")), h2("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0);
  if (ecc2.privateNegate) {
    assert2(compare2(ecc2.privateNegate(h2("0000000000000000000000000000000000000000000000000000000000000001")), h2("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0);
    assert2(compare2(ecc2.privateNegate(h2("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")), h2("0000000000000000000000000000000000000000000000000000000000000003")) === 0);
    assert2(compare2(ecc2.privateNegate(h2("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), h2("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")) === 0);
  }
  assert2(compare2(ecc2.sign(h2("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), h2("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")), h2("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")) === 0);
  assert2(ecc2.verify(h2("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), h2("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h2("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")));
  if (ecc2.signSchnorr) {
    assert2(compare2(ecc2.signSchnorr(h2("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), h2("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), h2("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")), h2("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")) === 0);
  }
  if (ecc2.verifySchnorr) {
    assert2(ecc2.verifySchnorr(h2("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), h2("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), h2("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
  }
}
function assert2(bool) {
  if (!bool)
    throw new Error("ecc library invalid");
}

// node_modules/.pnpm/@scure+base@1.2.6/node_modules/@scure/base/lib/esm/index.js
init_buffer_polyfill();
function isBytes2(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function isArrayOf(isString, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber2(n2) {
  if (!Number.isSafeInteger(n2))
    throw new Error(`invalid integer: ${n2}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function chain(...args) {
  const id = (a) => a;
  const wrap = (a, b) => (c) => a(b(c));
  const encode42 = args.map((x) => x.encode).reduceRight(wrap, id);
  const decode44 = args.map((x) => x.decode).reduce(wrap, id);
  return { encode: encode42, decode: decode44 };
}
// @__NO_SIDE_EFFECTS__
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l, i) => [l, i]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i) => {
        if (!Number.isSafeInteger(i) || i < 0 || i >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
        return lettersA[i];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i = indexes.get(letter);
        if (i === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from7) => {
      astrArr("join.decode", from7);
      return from7.join(separator);
    },
    decode: (to) => {
      astr("join.decode", to);
      return to.split(separator);
    }
  };
}
function convertRadix(data, from7, to) {
  if (from7 < 2)
    throw new Error(`convertRadix: invalid from=${from7}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d) => {
    anumber2(d);
    if (d < 0 || d >= from7)
      throw new Error(`invalid integer: ${d}`);
    return d;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i = pos; i < dlen; i++) {
      const digit = digits[i];
      const fromCarry = from7 * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from7 !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to;
      carry = digitBase % to;
      const rounded = Math.floor(div);
      digits[i] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
    res.push(0);
  return res.reverse();
}
// @__NO_SIDE_EFFECTS__
function radix(num2) {
  anumber2(num2);
  const _256 = 2 ** 8;
  return {
    encode: (bytes) => {
      if (!isBytes2(bytes))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes), _256, num2);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num2, _256));
    }
  };
}
function checksum(len, fn) {
  anumber2(len);
  afn(fn);
  return {
    encode(data) {
      if (!isBytes2(data))
        throw new Error("checksum.encode: input should be Uint8Array");
      const sum = fn(data).slice(0, len);
      const res = new Uint8Array(data.length + len);
      res.set(data);
      res.set(sum, data.length);
      return res;
    },
    decode(data) {
      if (!isBytes2(data))
        throw new Error("checksum.decode: input should be Uint8Array");
      const payload = data.slice(0, -len);
      const oldChecksum = data.slice(-len);
      const newChecksum = fn(payload).slice(0, len);
      for (let i = 0; i < len; i++)
        if (newChecksum[i] !== oldChecksum[i])
          throw new Error("Invalid checksum");
      return payload;
    }
  };
}
var genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => /* @__PURE__ */ chain(/* @__PURE__ */ radix(58), /* @__PURE__ */ alphabet(abc), /* @__PURE__ */ join(""));
var base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var createBase58check = (sha2567) => /* @__PURE__ */ chain(checksum(4, (data) => sha2567(sha2567(data))), base58);
var base58check = createBase58check;

// node_modules/.pnpm/valibot@0.37.0_typescript@5.9.3/node_modules/valibot/dist/index.js
init_buffer_polyfill();
var store;
function getGlobalConfig2(config2) {
  return {
    lang: config2?.lang ?? store?.lang,
    message: config2?.message,
    abortEarly: config2?.abortEarly ?? store?.abortEarly,
    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly
  };
}
var store2;
function getGlobalMessage2(lang) {
  return store2?.get(lang);
}
var store3;
function getSchemaMessage2(lang) {
  return store3?.get(lang);
}
var store4;
function getSpecificMessage2(reference, lang) {
  return store4?.get(reference)?.get(lang);
}
function _stringify2(input) {
  const type = typeof input;
  if (type === "string") {
    return `"${input}"`;
  }
  if (type === "number" || type === "bigint" || type === "boolean") {
    return `${input}`;
  }
  if (type === "object" || type === "function") {
    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
  }
  return type;
}
function _addIssue2(context, label, dataset, config2, other) {
  const input = other && "input" in other ? other.input : dataset.value;
  const expected14 = other?.expected ?? context.expects ?? null;
  const received = other?.received ?? _stringify2(input);
  const issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected: expected14,
    received,
    message: `Invalid ${label}: ${expected14 ? `Expected ${expected14} but r` : "R"}eceived ${received}`,
    // @ts-expect-error
    requirement: context.requirement,
    path: other?.path,
    issues: other?.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly
  };
  const isSchema = context.kind === "schema";
  const message = other?.message ?? // @ts-expect-error
  context.message ?? getSpecificMessage2(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage2(issue.lang) : null) ?? config2.message ?? getGlobalMessage2(issue.lang);
  if (message) {
    issue.message = typeof message === "function" ? message(issue) : message;
  }
  if (isSchema) {
    dataset.typed = false;
  }
  if (dataset.issues) {
    dataset.issues.push(issue);
  } else {
    dataset.issues = [issue];
  }
}
var ValiError2 = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    /**
     * The error issues.
     */
    __publicField(this, "issues");
    this.name = "ValiError";
    this.issues = issues;
  }
};
function integer2(message) {
  return {
    kind: "validation",
    type: "integer",
    reference: integer2,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message,
    _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue2(this, "integer", dataset, config2);
      }
      return dataset;
    }
  };
}
function length2(requirement, message) {
  return {
    kind: "validation",
    type: "length",
    reference: length2,
    async: false,
    expects: `${requirement}`,
    requirement,
    message,
    _run(dataset, config2) {
      if (dataset.typed && dataset.value.length !== this.requirement) {
        _addIssue2(this, "length", dataset, config2, {
          received: `${dataset.value.length}`
        });
      }
      return dataset;
    }
  };
}
function maxValue2(requirement, message) {
  return {
    kind: "validation",
    type: "max_value",
    reference: maxValue2,
    async: false,
    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify2(requirement)}`,
    requirement,
    message,
    _run(dataset, config2) {
      if (dataset.typed && dataset.value > this.requirement) {
        _addIssue2(this, "value", dataset, config2, {
          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify2(dataset.value)
        });
      }
      return dataset;
    }
  };
}
function minValue2(requirement, message) {
  return {
    kind: "validation",
    type: "min_value",
    reference: minValue2,
    async: false,
    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify2(requirement)}`,
    requirement,
    message,
    _run(dataset, config2) {
      if (dataset.typed && dataset.value < this.requirement) {
        _addIssue2(this, "value", dataset, config2, {
          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify2(dataset.value)
        });
      }
      return dataset;
    }
  };
}
function regex2(requirement, message) {
  return {
    kind: "validation",
    type: "regex",
    reference: regex2,
    async: false,
    expects: `${requirement}`,
    requirement,
    message,
    _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue2(this, "format", dataset, config2);
      }
      return dataset;
    }
  };
}
function instance2(class_, message) {
  return {
    kind: "schema",
    type: "instance",
    reference: instance2,
    expects: class_.name,
    async: false,
    class: class_,
    message,
    _run(dataset, config2) {
      if (dataset.value instanceof this.class) {
        dataset.typed = true;
      } else {
        _addIssue2(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function number2(message) {
  return {
    kind: "schema",
    type: "number",
    reference: number2,
    expects: "number",
    async: false,
    message,
    _run(dataset, config2) {
      if (typeof dataset.value === "number" && !isNaN(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue2(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function object2(entries, message) {
  return {
    kind: "schema",
    type: "object",
    reference: object2,
    expects: "Object",
    async: false,
    entries,
    message,
    _run(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key in this.entries) {
          const value2 = input[key];
          const valueDataset = this.entries[key]._run(
            { typed: false, value: value2 },
            config2
          );
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = valueDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) {
            dataset.typed = false;
          }
          if (valueDataset.value !== void 0 || key in input) {
            dataset.value[key] = valueDataset.value;
          }
        }
      } else {
        _addIssue2(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function string2(message) {
  return {
    kind: "schema",
    type: "string",
    reference: string2,
    expects: "string",
    async: false,
    message,
    _run(dataset, config2) {
      if (typeof dataset.value === "string") {
        dataset.typed = true;
      } else {
        _addIssue2(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function parse2(schema, input, config2) {
  const dataset = schema._run(
    { typed: false, value: input },
    getGlobalConfig2(config2)
  );
  if (dataset.issues) {
    throw new ValiError2(dataset.issues);
  }
  return dataset.value;
}
function pipe2(...pipe22) {
  return {
    ...pipe22[0],
    pipe: pipe22,
    _run(dataset, config2) {
      for (const item of pipe22) {
        if (item.kind !== "metadata") {
          if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
            dataset.typed = false;
            break;
          }
          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {
            dataset = item._run(dataset, config2);
          }
        }
      }
      return dataset;
    }
  };
}

// node_modules/.pnpm/bip32@5.0.0_typescript@5.9.3/node_modules/bip32/src/esm/types.js
init_buffer_polyfill();
var Uint32Schema = pipe2(number2(), integer2(), minValue2(0), maxValue2(4294967295));
var Uint31Schema = pipe2(number2(), integer2(), minValue2(0), maxValue2(2147483647));
var Uint8Schema = pipe2(number2(), integer2(), minValue2(0), maxValue2(255));
var Buffer256Bit = pipe2(instance2(Uint8Array), length2(32));
var Buffer33Bytes = pipe2(instance2(Uint8Array), length2(33));
var NetworkSchema = object2({
  wif: Uint8Schema,
  bip32: object2({
    public: Uint32Schema,
    private: Uint32Schema
  })
});
var Bip32PathSchema = pipe2(string2(), regex2(/^(m\/)?(\d+'?\/)*\d+'?$/));

// node_modules/.pnpm/wif@5.0.0/node_modules/wif/src/esm/index.js
init_buffer_polyfill();
function encodeRaw(version, privateKey, compressed) {
  if (privateKey.length !== 32)
    throw new TypeError("Invalid privateKey length");
  var result = new Uint8Array(compressed ? 34 : 33);
  var view = new DataView(result.buffer);
  view.setUint8(0, version);
  result.set(privateKey, 1);
  if (compressed) {
    result[33] = 1;
  }
  return result;
}
function encode19(wif) {
  return esm_default3.encode(encodeRaw(wif.version, wif.privateKey, wif.compressed));
}

// node_modules/.pnpm/bip32@5.0.0_typescript@5.9.3/node_modules/bip32/src/esm/bip32.js
var _bs58check = base58check(sha2562);
var bs58check = {
  encode: (data) => _bs58check.encode(data),
  decode: (str) => _bs58check.decode(str)
};
function BIP32Factory(ecc2) {
  testEcc(ecc2);
  const BITCOIN = {
    messagePrefix: "Bitcoin Signed Message:\n",
    bech32: "bc",
    bip32: {
      public: 76067358,
      private: 76066276
    },
    pubKeyHash: 0,
    scriptHash: 5,
    wif: 128
  };
  const HIGHEST_BIT = 2147483648;
  function toXOnly2(pubKey) {
    return pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
  }
  class Bip32Signer {
    constructor(__D, __Q) {
      __publicField(this, "__D");
      __publicField(this, "__Q");
      __publicField(this, "lowR", false);
      this.__D = __D;
      this.__Q = __Q;
    }
    get publicKey() {
      if (this.__Q === void 0)
        this.__Q = ecc2.pointFromScalar(this.__D, true);
      return this.__Q;
    }
    get privateKey() {
      return this.__D;
    }
    sign(hash, lowR) {
      if (!this.privateKey)
        throw new Error("Missing private key");
      if (lowR === void 0)
        lowR = this.lowR;
      if (lowR === false) {
        return ecc2.sign(hash, this.privateKey);
      } else {
        let sig = ecc2.sign(hash, this.privateKey);
        const extraData = new Uint8Array(32);
        let counter = 0;
        while (sig[0] > 127) {
          counter++;
          writeUInt322(extraData, 0, counter, "LE");
          sig = ecc2.sign(hash, this.privateKey, extraData);
        }
        return sig;
      }
    }
    signSchnorr(hash) {
      if (!this.privateKey)
        throw new Error("Missing private key");
      if (!ecc2.signSchnorr)
        throw new Error("signSchnorr not supported by ecc library");
      return ecc2.signSchnorr(hash, this.privateKey);
    }
    verify(hash, signature2) {
      return ecc2.verify(hash, this.publicKey, signature2);
    }
    verifySchnorr(hash, signature2) {
      if (!ecc2.verifySchnorr)
        throw new Error("verifySchnorr not supported by ecc library");
      return ecc2.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature2);
    }
  }
  class BIP32 extends Bip32Signer {
    constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0) {
      super(__D, __Q);
      __publicField(this, "chainCode");
      __publicField(this, "network");
      __publicField(this, "__DEPTH");
      __publicField(this, "__INDEX");
      __publicField(this, "__PARENT_FINGERPRINT");
      this.chainCode = chainCode;
      this.network = network;
      this.__DEPTH = __DEPTH;
      this.__INDEX = __INDEX;
      this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
      parse2(NetworkSchema, network);
    }
    get depth() {
      return this.__DEPTH;
    }
    get index() {
      return this.__INDEX;
    }
    get parentFingerprint() {
      return this.__PARENT_FINGERPRINT;
    }
    get identifier() {
      return hash1602(this.publicKey);
    }
    get fingerprint() {
      return this.identifier.slice(0, 4);
    }
    get compressed() {
      return true;
    }
    // Private === not neutered
    // Public === neutered
    isNeutered() {
      return this.__D === void 0;
    }
    neutered() {
      return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
    }
    toBase58() {
      const network = this.network;
      const version = !this.isNeutered() ? network.bip32.private : network.bip32.public;
      const buffer2 = new Uint8Array(78);
      writeUInt322(buffer2, 0, version, "BE");
      writeUInt82(buffer2, 4, this.depth);
      writeUInt322(buffer2, 5, this.parentFingerprint, "BE");
      writeUInt322(buffer2, 9, this.index, "BE");
      buffer2.set(this.chainCode, 13);
      if (!this.isNeutered()) {
        writeUInt82(buffer2, 45, 0);
        buffer2.set(this.privateKey, 46);
      } else {
        buffer2.set(this.publicKey, 45);
      }
      return bs58check.encode(buffer2);
    }
    toWIF() {
      if (!this.privateKey)
        throw new TypeError("Missing private key");
      return encode19({
        version: this.network.wif,
        privateKey: this.privateKey,
        compressed: true
      });
    }
    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
    derive(index) {
      parse2(Uint32Schema, index);
      const isHardened = index >= HIGHEST_BIT;
      const data = new Uint8Array(37);
      if (isHardened) {
        if (this.isNeutered())
          throw new TypeError("Missing private key for hardened child key");
        data[0] = 0;
        data.set(this.privateKey, 1);
        writeUInt322(data, 33, index, "BE");
      } else {
        data.set(this.publicKey, 0);
        writeUInt322(data, 33, index, "BE");
      }
      const I = hmacSHA512(this.chainCode, data);
      const IL = I.slice(0, 32);
      const IR = I.slice(32);
      if (!ecc2.isPrivate(IL))
        return this.derive(index + 1);
      let hd;
      if (!this.isNeutered()) {
        const ki = ecc2.privateAdd(this.privateKey, IL);
        if (ki == null)
          return this.derive(index + 1);
        hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, readUInt322(this.fingerprint, 0, "BE"));
      } else {
        const Ki = ecc2.pointAddScalar(this.publicKey, IL, true);
        if (Ki === null)
          return this.derive(index + 1);
        hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, readUInt322(this.fingerprint, 0, "BE"));
      }
      return hd;
    }
    deriveHardened(index) {
      if (typeof parse2(Uint31Schema, index) === "number")
        return this.derive(index + HIGHEST_BIT);
      throw new TypeError("Expected UInt31, got " + index);
    }
    derivePath(path) {
      parse2(Bip32PathSchema, path);
      let splitPath = path.split("/");
      if (splitPath[0] === "m") {
        if (this.parentFingerprint)
          throw new TypeError("Expected master, got child");
        splitPath = splitPath.slice(1);
      }
      return splitPath.reduce((prevHd, indexStr) => {
        let index;
        if (indexStr.slice(-1) === `'`) {
          index = parseInt(indexStr.slice(0, -1), 10);
          return prevHd.deriveHardened(index);
        } else {
          index = parseInt(indexStr, 10);
          return prevHd.derive(index);
        }
      }, this);
    }
    tweak(t) {
      if (this.privateKey)
        return this.tweakFromPrivateKey(t);
      return this.tweakFromPublicKey(t);
    }
    tweakFromPublicKey(t) {
      const xOnlyPubKey = toXOnly2(this.publicKey);
      if (!ecc2.xOnlyPointAddTweak)
        throw new Error("xOnlyPointAddTweak not supported by ecc library");
      const tweakedPublicKey = ecc2.xOnlyPointAddTweak(xOnlyPubKey, t);
      if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null)
        throw new Error("Cannot tweak public key!");
      const parityByte = Uint8Array.from([
        tweakedPublicKey.parity === 0 ? 2 : 3
      ]);
      const tweakedPublicKeyCompresed = concat2([
        parityByte,
        tweakedPublicKey.xOnlyPubkey
      ]);
      return new Bip32Signer(void 0, tweakedPublicKeyCompresed);
    }
    tweakFromPrivateKey(t) {
      const hasOddY = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1;
      const privateKey = (() => {
        if (!hasOddY)
          return this.privateKey;
        else if (!ecc2.privateNegate)
          throw new Error("privateNegate not supported by ecc library");
        else
          return ecc2.privateNegate(this.privateKey);
      })();
      const tweakedPrivateKey = ecc2.privateAdd(privateKey, t);
      if (!tweakedPrivateKey)
        throw new Error("Invalid tweaked private key!");
      return new Bip32Signer(tweakedPrivateKey, void 0);
    }
  }
  function fromBase58(inString, network) {
    const buffer2 = bs58check.decode(inString);
    if (buffer2.length !== 78)
      throw new TypeError("Invalid buffer length");
    network = network || BITCOIN;
    const version = readUInt322(buffer2, 0, "BE");
    if (version !== network.bip32.private && version !== network.bip32.public)
      throw new TypeError("Invalid network version");
    const depth = buffer2[4];
    const parentFingerprint = readUInt322(buffer2, 5, "BE");
    if (depth === 0) {
      if (parentFingerprint !== 0)
        throw new TypeError("Invalid parent fingerprint");
    }
    const index = readUInt322(buffer2, 9, "BE");
    if (depth === 0 && index !== 0)
      throw new TypeError("Invalid index");
    const chainCode = buffer2.slice(13, 45);
    let hd;
    if (version === network.bip32.private) {
      if (buffer2[45] !== 0)
        throw new TypeError("Invalid private key");
      const k = buffer2.slice(46, 78);
      hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);
    } else {
      const X = buffer2.slice(45, 78);
      hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);
    }
    return hd;
  }
  function fromPrivateKey(privateKey, chainCode, network) {
    return fromPrivateKeyLocal(privateKey, chainCode, network);
  }
  function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
    parse2(Buffer256Bit, privateKey);
    parse2(Buffer256Bit, chainCode);
    network = network || BITCOIN;
    if (!ecc2.isPrivate(privateKey))
      throw new TypeError("Private key not in range [1, n)");
    return new BIP32(privateKey, void 0, chainCode, network, depth, index, parentFingerprint);
  }
  function fromPublicKey(publicKey, chainCode, network) {
    return fromPublicKeyLocal(publicKey, chainCode, network);
  }
  function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
    parse2(Buffer33Bytes, publicKey);
    parse2(Buffer256Bit, chainCode);
    network = network || BITCOIN;
    if (!ecc2.isPoint(publicKey))
      throw new TypeError("Point is not on the curve");
    return new BIP32(void 0, publicKey, chainCode, network, depth, index, parentFingerprint);
  }
  function fromSeed(seed, network) {
    parse2(instance2(Uint8Array), seed);
    if (seed.length < 16)
      throw new TypeError("Seed should be at least 128 bits");
    if (seed.length > 64)
      throw new TypeError("Seed should be at most 512 bits");
    network = network || BITCOIN;
    const I = hmacSHA512(fromUtf82("Bitcoin seed"), seed);
    const IL = I.slice(0, 32);
    const IR = I.slice(32);
    return fromPrivateKey(IL, IR, network);
  }
  return {
    fromSeed,
    fromBase58,
    fromPublicKey,
    fromPrivateKey
  };
}

// src/core/ecc.ts
var ecc_exports = {};
__export(ecc_exports, {
  default: () => ecc_default,
  isPoint: () => isPoint2,
  isPrivate: () => isPrivate,
  isXOnlyPoint: () => isXOnlyPoint,
  pointAdd: () => pointAdd,
  pointAddScalar: () => pointAddScalar,
  pointCompress: () => pointCompress,
  pointFromScalar: () => pointFromScalar,
  pointMultiply: () => pointMultiply,
  privateAdd: () => privateAdd,
  privateNegate: () => privateNegate,
  privateTweakAdd: () => privateTweakAdd,
  sign: () => sign,
  signSchnorr: () => signSchnorr,
  verify: () => verify,
  verifySchnorr: () => verifySchnorr,
  xOnlyPointAddTweak: () => xOnlyPointAddTweak
});
init_buffer_polyfill();
var import_elliptic = __toESM(require_elliptic());
var import_bn = __toESM(require_bn2());

// node_modules/.pnpm/@noble+curves@2.0.1/node_modules/@noble/curves/secp256k1.js
init_buffer_polyfill();

// node_modules/.pnpm/@noble+hashes@2.0.1/node_modules/@noble/hashes/sha2.js
init_buffer_polyfill();

// node_modules/.pnpm/@noble+hashes@2.0.1/node_modules/@noble/hashes/_md.js
init_buffer_polyfill();

// node_modules/.pnpm/@noble+hashes@2.0.1/node_modules/@noble/hashes/utils.js
init_buffer_polyfill();
function isBytes3(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber3(n2, title = "") {
  if (!Number.isSafeInteger(n2) || n2 < 0) {
    const prefix = title && `"${title}" `;
    throw new Error(`${prefix}expected integer >= 0, got ${n2}`);
  }
}
function abytes2(value2, length6, title = "") {
  const bytes = isBytes3(value2);
  const len = value2?.length;
  const needsLen = length6 !== void 0;
  if (!bytes || needsLen && len !== length6) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length6}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value2}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value2;
}
function ahash2(h3) {
  if (typeof h3 !== "function" || typeof h3.create !== "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  anumber3(h3.outputLen);
  anumber3(h3.blockLen);
}
function aexists2(instance3, checkFinished = true) {
  if (instance3.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance3.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput2(out, instance3) {
  abytes2(out, void 0, "digestInto() output");
  const min = instance3.outputLen;
  if (out.length < min) {
    throw new Error('"digestInto() output" expected to be of length >=' + min);
  }
}
function clean2(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView2(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr2(word, shift) {
  return word << 32 - shift | word >>> shift;
}
var hasHexBuiltin = /* @__PURE__ */ (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
  abytes2(bytes);
  if (hasHexBuiltin)
    return bytes.toHex();
  let hex = "";
  for (let i = 0; i < bytes.length; i++) {
    hex += hexes[bytes[i]];
  }
  return hex;
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array2 = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array2[ai] = n1 * 16 + n2;
  }
  return array2;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes2(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
function createHasher2(hashCons, info = {}) {
  const hashC = (msg, opts) => hashCons(opts).update(msg).digest();
  const tmp = hashCons(void 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  Object.assign(hashC, info);
  return Object.freeze(hashC);
}
function randomBytes(bytesLength = 32) {
  const cr = typeof globalThis === "object" ? globalThis.crypto : null;
  if (typeof cr?.getRandomValues !== "function")
    throw new Error("crypto.getRandomValues must be defined");
  return cr.getRandomValues(new Uint8Array(bytesLength));
}
var oidNist = (suffix) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
});

// node_modules/.pnpm/@noble+hashes@2.0.1/node_modules/@noble/hashes/_md.js
function Chi2(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj2(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD2 = class {
  constructor(blockLen, outputLen, padOffset, isLE) {
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "padOffset");
    __publicField(this, "isLE");
    // For partial updates less than block size
    __publicField(this, "buffer");
    __publicField(this, "view");
    __publicField(this, "finished", false);
    __publicField(this, "length", 0);
    __publicField(this, "pos", 0);
    __publicField(this, "destroyed", false);
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data) {
    aexists2(this);
    abytes2(data);
    const { view, buffer: buffer2, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView2 = createView2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView2, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists2(this);
    aoutput2(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    clean2(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);
    this.process(view, 0);
    const oview = createView2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length: length6, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length6;
    to.pos = pos;
    if (length6 % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV2 = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);

// node_modules/.pnpm/@noble+hashes@2.0.1/node_modules/@noble/hashes/sha2.js
var SHA256_K2 = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);
var SHA2_32B = class extends HashMD2 {
  constructor(outputLen) {
    super(64, outputLen, 8, false);
  }
  get() {
    const { A, B, C, D, E, F, G: G2, H } = this;
    return [A, B, C, D, E, F, G2, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G2, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G2 | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W2[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W2[i - 15];
      const W2 = SHA256_W2[i - 2];
      const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
      SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G: G2, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
      const T1 = H + sigma1 + Chi2(E, F, G2) + SHA256_K2[i] + SHA256_W2[i] | 0;
      const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
      const T2 = sigma0 + Maj2(A, B, C) | 0;
      H = G2;
      G2 = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G2 = G2 + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G2, H);
  }
  roundClean() {
    clean2(SHA256_W2);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean2(this.buffer);
  }
};
var _SHA256 = class extends SHA2_32B {
  constructor() {
    super(32);
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    __publicField(this, "A", SHA256_IV2[0] | 0);
    __publicField(this, "B", SHA256_IV2[1] | 0);
    __publicField(this, "C", SHA256_IV2[2] | 0);
    __publicField(this, "D", SHA256_IV2[3] | 0);
    __publicField(this, "E", SHA256_IV2[4] | 0);
    __publicField(this, "F", SHA256_IV2[5] | 0);
    __publicField(this, "G", SHA256_IV2[6] | 0);
    __publicField(this, "H", SHA256_IV2[7] | 0);
  }
};
var sha2563 = /* @__PURE__ */ createHasher2(
  () => new _SHA256(),
  /* @__PURE__ */ oidNist(1)
);

// node_modules/.pnpm/@noble+curves@2.0.1/node_modules/@noble/curves/abstract/curve.js
init_buffer_polyfill();

// node_modules/.pnpm/@noble+curves@2.0.1/node_modules/@noble/curves/utils.js
init_buffer_polyfill();
var _0n = /* @__PURE__ */ BigInt(0);
var _1n = /* @__PURE__ */ BigInt(1);
function abool(value2, title = "") {
  if (typeof value2 !== "boolean") {
    const prefix = title && `"${title}" `;
    throw new Error(prefix + "expected boolean, got type=" + typeof value2);
  }
  return value2;
}
function abignumber(n2) {
  if (typeof n2 === "bigint") {
    if (!isPosBig(n2))
      throw new Error("positive bigint expected, got " + n2);
  } else
    anumber3(n2);
  return n2;
}
function numberToHexUnpadded(num2) {
  const hex = abignumber(num2).toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n : BigInt("0x" + hex);
}
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
  return hexToNumber(bytesToHex(copyBytes(abytes2(bytes)).reverse()));
}
function numberToBytesBE(n2, len) {
  anumber3(len);
  n2 = abignumber(n2);
  const res = hexToBytes(n2.toString(16).padStart(len * 2, "0"));
  if (res.length !== len)
    throw new Error("number too large");
  return res;
}
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
function copyBytes(bytes) {
  return Uint8Array.from(bytes);
}
function asciiToBytes(ascii3) {
  return Uint8Array.from(ascii3, (c, i) => {
    const charCode = c.charCodeAt(0);
    if (c.length !== 1 || charCode > 127) {
      throw new Error(`string contains non-ASCII character "${ascii3[i]}" with code ${charCode} at position ${i}`);
    }
    return charCode;
  });
}
var isPosBig = (n2) => typeof n2 === "bigint" && _0n <= n2;
function inRange(n2, min, max) {
  return isPosBig(n2) && isPosBig(min) && isPosBig(max) && min <= n2 && n2 < max;
}
function aInRange(title, n2, min, max) {
  if (!inRange(n2, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n2);
}
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n; n2 >>= _1n, len += 1)
    ;
  return len;
}
var bitMask = (n2) => (_1n << BigInt(n2)) - _1n;
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  anumber3(hashLen, "hashLen");
  anumber3(qByteLen, "qByteLen");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n = (len) => new Uint8Array(len);
  const NULL = Uint8Array.of();
  const byte0 = Uint8Array.of(0);
  const byte1 = Uint8Array.of(1);
  const _maxDrbgIters = 1e3;
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h3 = (...msgs) => hmacFn(k, concatBytes(v, ...msgs));
  const reseed = (seed = NULL) => {
    k = h3(byte0, seed);
    v = h3();
    if (seed.length === 0)
      return;
    k = h3(byte1, seed);
    v = h3();
  };
  const gen = () => {
    if (i++ >= _maxDrbgIters)
      throw new Error("drbg: tried max amount of iterations");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h3();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function validateObject(object3, fields = {}, optFields = {}) {
  if (!object3 || typeof object3 !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object3[fieldName];
    if (isOpt && val === void 0)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  const iter = (f, isOpt) => Object.entries(f).forEach(([k, v]) => checkField(k, v, isOpt));
  iter(fields, false);
  iter(optFields, true);
}
function memoized(fn) {
  const map2 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map2.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map2.set(arg, computed);
    return computed;
  };
}

// node_modules/.pnpm/@noble+curves@2.0.1/node_modules/@noble/curves/abstract/modular.js
init_buffer_polyfill();
var _0n2 = /* @__PURE__ */ BigInt(0);
var _1n2 = /* @__PURE__ */ BigInt(1);
var _2n = /* @__PURE__ */ BigInt(2);
var _3n = /* @__PURE__ */ BigInt(3);
var _4n = /* @__PURE__ */ BigInt(4);
var _5n = /* @__PURE__ */ BigInt(5);
var _7n = /* @__PURE__ */ BigInt(7);
var _8n = /* @__PURE__ */ BigInt(8);
var _9n = /* @__PURE__ */ BigInt(9);
var _16n = /* @__PURE__ */ BigInt(16);
function mod2(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number3, modulo) {
  if (number3 === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod2(number3, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n2 = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n2;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function assertIsSquare(Fp, root, n2) {
  if (!Fp.eql(Fp.sqr(root), n2))
    throw new Error("Cannot find square root");
}
function sqrt3mod4(Fp, n2) {
  const p1div4 = (Fp.ORDER + _1n2) / _4n;
  const root = Fp.pow(n2, p1div4);
  assertIsSquare(Fp, root, n2);
  return root;
}
function sqrt5mod8(Fp, n2) {
  const p5div8 = (Fp.ORDER - _5n) / _8n;
  const n22 = Fp.mul(n2, _2n);
  const v = Fp.pow(n22, p5div8);
  const nv = Fp.mul(n2, v);
  const i = Fp.mul(Fp.mul(nv, _2n), v);
  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
  assertIsSquare(Fp, root, n2);
  return root;
}
function sqrt9mod16(P) {
  const Fp_ = Field(P);
  const tn = tonelliShanks(P);
  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
  const c2 = tn(Fp_, c1);
  const c3 = tn(Fp_, Fp_.neg(c1));
  const c4 = (P + _7n) / _16n;
  return (Fp, n2) => {
    let tv1 = Fp.pow(n2, c4);
    let tv2 = Fp.mul(tv1, c1);
    const tv3 = Fp.mul(tv1, c2);
    const tv4 = Fp.mul(tv1, c3);
    const e1 = Fp.eql(Fp.sqr(tv2), n2);
    const e2 = Fp.eql(Fp.sqr(tv3), n2);
    tv1 = Fp.cmov(tv1, tv2, e1);
    tv2 = Fp.cmov(tv4, tv3, e2);
    const e3 = Fp.eql(Fp.sqr(tv2), n2);
    const root = Fp.cmov(tv1, tv2, e3);
    assertIsSquare(Fp, root, n2);
    return root;
  };
}
function tonelliShanks(P) {
  if (P < _3n)
    throw new Error("sqrt is not defined for small field");
  let Q = P - _1n2;
  let S = 0;
  while (Q % _2n === _0n2) {
    Q /= _2n;
    S++;
  }
  let Z = _2n;
  const _Fp = Field(P);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n2) / _2n;
  return function tonelliSlow(Fp, n2) {
    if (Fp.is0(n2))
      return n2;
    if (FpLegendre(Fp, n2) !== 1)
      throw new Error("Cannot find square root");
    let M = S;
    let c = Fp.mul(Fp.ONE, cc);
    let t = Fp.pow(n2, Q);
    let R = Fp.pow(n2, Q1div2);
    while (!Fp.eql(t, Fp.ONE)) {
      if (Fp.is0(t))
        return Fp.ZERO;
      let i = 1;
      let t_tmp = Fp.sqr(t);
      while (!Fp.eql(t_tmp, Fp.ONE)) {
        i++;
        t_tmp = Fp.sqr(t_tmp);
        if (i === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n2 << BigInt(M - i - 1);
      const b = Fp.pow(c, exponent);
      M = i;
      c = Fp.sqr(b);
      t = Fp.mul(t, c);
      R = Fp.mul(R, b);
    }
    return R;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n)
    return sqrt3mod4;
  if (P % _8n === _5n)
    return sqrt5mod8;
  if (P % _16n === _9n)
    return sqrt9mod16(P);
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS.reduce((map2, val) => {
    map2[val] = "function";
    return map2;
  }, initial);
  validateObject(field, opts);
  return field;
}
function FpPow(Fp, num2, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return Fp.ONE;
  if (power === _1n2)
    return num2;
  let p = Fp.ONE;
  let d = num2;
  while (power > _0n2) {
    if (power & _1n2)
      p = Fp.mul(p, d);
    d = Fp.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(Fp, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num2, i) => {
    if (Fp.is0(num2))
      return acc;
    inverted[i] = acc;
    return Fp.mul(acc, num2);
  }, Fp.ONE);
  const invertedAcc = Fp.inv(multipliedAcc);
  nums.reduceRight((acc, num2, i) => {
    if (Fp.is0(num2))
      return acc;
    inverted[i] = Fp.mul(acc, inverted[i]);
    return Fp.mul(acc, num2);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp, n2) {
  const p1mod2 = (Fp.ORDER - _1n2) / _2n;
  const powered = Fp.pow(n2, p1mod2);
  const yes = Fp.eql(powered, Fp.ONE);
  const zero = Fp.eql(powered, Fp.ZERO);
  const no = Fp.eql(powered, Fp.neg(Fp.ONE));
  if (!yes && !zero && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero ? 0 : -1;
}
function nLength(n2, nBitLength) {
  if (nBitLength !== void 0)
    anumber3(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
var _Field = class {
  constructor(ORDER, opts = {}) {
    __publicField(this, "ORDER");
    __publicField(this, "BITS");
    __publicField(this, "BYTES");
    __publicField(this, "isLE");
    __publicField(this, "ZERO", _0n2);
    __publicField(this, "ONE", _1n2);
    __publicField(this, "_lengths");
    __publicField(this, "_sqrt");
    // cached sqrt
    __publicField(this, "_mod");
    if (ORDER <= _0n2)
      throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
    let _nbitLength = void 0;
    this.isLE = false;
    if (opts != null && typeof opts === "object") {
      if (typeof opts.BITS === "number")
        _nbitLength = opts.BITS;
      if (typeof opts.sqrt === "function")
        this.sqrt = opts.sqrt;
      if (typeof opts.isLE === "boolean")
        this.isLE = opts.isLE;
      if (opts.allowedLengths)
        this._lengths = opts.allowedLengths?.slice();
      if (typeof opts.modFromBytes === "boolean")
        this._mod = opts.modFromBytes;
    }
    const { nBitLength, nByteLength } = nLength(ORDER, _nbitLength);
    if (nByteLength > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    this.ORDER = ORDER;
    this.BITS = nBitLength;
    this.BYTES = nByteLength;
    this._sqrt = void 0;
    Object.preventExtensions(this);
  }
  create(num2) {
    return mod2(num2, this.ORDER);
  }
  isValid(num2) {
    if (typeof num2 !== "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof num2);
    return _0n2 <= num2 && num2 < this.ORDER;
  }
  is0(num2) {
    return num2 === _0n2;
  }
  // is valid and invertible
  isValidNot0(num2) {
    return !this.is0(num2) && this.isValid(num2);
  }
  isOdd(num2) {
    return (num2 & _1n2) === _1n2;
  }
  neg(num2) {
    return mod2(-num2, this.ORDER);
  }
  eql(lhs, rhs) {
    return lhs === rhs;
  }
  sqr(num2) {
    return mod2(num2 * num2, this.ORDER);
  }
  add(lhs, rhs) {
    return mod2(lhs + rhs, this.ORDER);
  }
  sub(lhs, rhs) {
    return mod2(lhs - rhs, this.ORDER);
  }
  mul(lhs, rhs) {
    return mod2(lhs * rhs, this.ORDER);
  }
  pow(num2, power) {
    return FpPow(this, num2, power);
  }
  div(lhs, rhs) {
    return mod2(lhs * invert(rhs, this.ORDER), this.ORDER);
  }
  // Same as above, but doesn't normalize
  sqrN(num2) {
    return num2 * num2;
  }
  addN(lhs, rhs) {
    return lhs + rhs;
  }
  subN(lhs, rhs) {
    return lhs - rhs;
  }
  mulN(lhs, rhs) {
    return lhs * rhs;
  }
  inv(num2) {
    return invert(num2, this.ORDER);
  }
  sqrt(num2) {
    if (!this._sqrt)
      this._sqrt = FpSqrt(this.ORDER);
    return this._sqrt(this, num2);
  }
  toBytes(num2) {
    return this.isLE ? numberToBytesLE(num2, this.BYTES) : numberToBytesBE(num2, this.BYTES);
  }
  fromBytes(bytes, skipValidation = false) {
    abytes2(bytes);
    const { _lengths: allowedLengths, BYTES, isLE, ORDER, _mod: modFromBytes } = this;
    if (allowedLengths) {
      if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
        throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
      }
      const padded = new Uint8Array(BYTES);
      padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
      bytes = padded;
    }
    if (bytes.length !== BYTES)
      throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
    let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
    if (modFromBytes)
      scalar = mod2(scalar, ORDER);
    if (!skipValidation) {
      if (!this.isValid(scalar))
        throw new Error("invalid field element: outside of range 0..ORDER");
    }
    return scalar;
  }
  // TODO: we don't need it here, move out to separate fn
  invertBatch(lst) {
    return FpInvertBatch(this, lst);
  }
  // We can't move this out because Fp6, Fp12 implement it
  // and it's unclear what to return in there.
  cmov(a, b, condition) {
    return condition ? b : a;
  }
};
function Field(ORDER, opts = {}) {
  return new _Field(ORDER, opts);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length6 = getFieldBytesLength(fieldOrder);
  return length6 + Math.ceil(length6 / 2);
}
function mapHashToField(key, fieldOrder, isLE = false) {
  abytes2(key);
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num2 = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod2(num2, fieldOrder - _1n2) + _1n2;
  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/.pnpm/@noble+curves@2.0.1/node_modules/@noble/curves/abstract/curve.js
var _0n3 = /* @__PURE__ */ BigInt(0);
var _1n3 = /* @__PURE__ */ BigInt(1);
function negateCt(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ(c, points) {
  const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));
  return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n2, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n2 & mask);
  let nextN = n2 >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n3;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function assert0(n2) {
  if (n2 !== _0n3)
    throw new Error("invalid wNAF");
}
var wNAF = class {
  // Parametrized with a given Point class (not individual point)
  constructor(Point, bits) {
    __publicField(this, "BASE");
    __publicField(this, "ZERO");
    __publicField(this, "Fn");
    __publicField(this, "bits");
    this.BASE = Point.BASE;
    this.ZERO = Point.ZERO;
    this.Fn = Point.Fn;
    this.bits = bits;
  }
  // non-const time multiplication ladder
  _unsafeLadder(elm, n2, p = this.ZERO) {
    let d = elm;
    while (n2 > _0n3) {
      if (n2 & _1n3)
        p = p.add(d);
      d = d.double();
      n2 >>= _1n3;
    }
    return p;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(1) * (Math.ceil( / ) + 1), where:
   * -  is the window size
   * -  is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(point, W) {
    const { windows, windowSize } = calcWOpts(W, this.bits);
    const points = [];
    let p = point;
    let base5 = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base5 = p;
      points.push(base5);
      for (let i = 1; i < windowSize; i++) {
        base5 = base5.add(p);
        points.push(base5);
      }
      p = base5.double();
    }
    return points;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(W, precomputes, n2) {
    if (!this.Fn.isValid(n2))
      throw new Error("invalid scalar");
    let p = this.ZERO;
    let f = this.BASE;
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n2, window2, wo);
      n2 = nextN;
      if (isZero) {
        f = f.add(negateCt(isNegF, precomputes[offsetF]));
      } else {
        p = p.add(negateCt(isNeg, precomputes[offset]));
      }
    }
    assert0(n2);
    return { p, f };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(W, precomputes, n2, acc = this.ZERO) {
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      if (n2 === _0n3)
        break;
      const { nextN, offset, isZero, isNeg } = calcOffsets(n2, window2, wo);
      n2 = nextN;
      if (isZero) {
        continue;
      } else {
        const item = precomputes[offset];
        acc = acc.add(isNeg ? item.negate() : item);
      }
    }
    assert0(n2);
    return acc;
  }
  getPrecomputes(W, point, transform) {
    let comp = pointPrecomputes.get(point);
    if (!comp) {
      comp = this.precomputeWindow(point, W);
      if (W !== 1) {
        if (typeof transform === "function")
          comp = transform(comp);
        pointPrecomputes.set(point, comp);
      }
    }
    return comp;
  }
  cached(point, scalar, transform) {
    const W = getW(point);
    return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
  }
  unsafe(point, scalar, transform, prev) {
    const W = getW(point);
    if (W === 1)
      return this._unsafeLadder(point, scalar, prev);
    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(P, W) {
    validateW(W, this.bits);
    pointWindowSizes.set(P, W);
    pointPrecomputes.delete(P);
  }
  hasCache(elm) {
    return getW(elm) !== 1;
  }
};
function mulEndoUnsafe(Point, point, k1, k2) {
  let acc = point;
  let p1 = Point.ZERO;
  let p2 = Point.ZERO;
  while (k1 > _0n3 || k2 > _0n3) {
    if (k1 & _1n3)
      p1 = p1.add(acc);
    if (k2 & _1n3)
      p2 = p2.add(acc);
    acc = acc.double();
    k1 >>= _1n3;
    k2 >>= _1n3;
  }
  return { p1, p2 };
}
function createField(order, field, isLE) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField(field);
    return field;
  } else {
    return Field(order, { isLE });
  }
}
function createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
  if (FpFnLE === void 0)
    FpFnLE = type === "edwards";
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type} CURVE object`);
  for (const p of ["p", "n", "h"]) {
    const val = CURVE[p];
    if (!(typeof val === "bigint" && val > _0n3))
      throw new Error(`CURVE.${p} must be positive bigint`);
  }
  const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
  const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
  const _b = type === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b];
  for (const p of params) {
    if (!Fp.isValid(CURVE[p]))
      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
  }
  CURVE = Object.freeze(Object.assign({}, CURVE));
  return { CURVE, Fp, Fn };
}
function createKeygen(randomSecretKey, getPublicKey) {
  return function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey(secretKey) };
  };
}

// node_modules/.pnpm/@noble+curves@2.0.1/node_modules/@noble/curves/abstract/weierstrass.js
init_buffer_polyfill();

// node_modules/.pnpm/@noble+hashes@2.0.1/node_modules/@noble/hashes/hmac.js
init_buffer_polyfill();
var _HMAC = class {
  constructor(hash, key) {
    __publicField(this, "oHash");
    __publicField(this, "iHash");
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "finished", false);
    __publicField(this, "destroyed", false);
    ahash2(hash);
    abytes2(key, void 0, "key");
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean2(pad);
  }
  update(buf2) {
    aexists2(this);
    this.iHash.update(buf2);
    return this;
  }
  digestInto(out) {
    aexists2(this);
    abytes2(out, this.outputLen, "output");
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac2 = (hash, key, message) => new _HMAC(hash, key).update(message).digest();
hmac2.create = (hash, key) => new _HMAC(hash, key);

// node_modules/.pnpm/@noble+curves@2.0.1/node_modules/@noble/curves/abstract/weierstrass.js
var divNearest = (num2, den) => (num2 + (num2 >= 0 ? den : -den) / _2n2) / den;
function _splitEndoScalar(k, basis, n2) {
  const [[a1, b1], [a2, b2]] = basis;
  const c1 = divNearest(b2 * k, n2);
  const c2 = divNearest(-b1 * k, n2);
  let k1 = k - c1 * a1 - c2 * a2;
  let k2 = -c1 * b1 - c2 * b2;
  const k1neg = k1 < _0n4;
  const k2neg = k2 < _0n4;
  if (k1neg)
    k1 = -k1;
  if (k2neg)
    k2 = -k2;
  const MAX_NUM = bitMask(Math.ceil(bitLen(n2) / 2)) + _1n4;
  if (k1 < _0n4 || k1 >= MAX_NUM || k2 < _0n4 || k2 >= MAX_NUM) {
    throw new Error("splitScalar (endomorphism): failed, k=" + k);
  }
  return { k1neg, k1, k2neg, k2 };
}
function validateSigFormat(format5) {
  if (!["compact", "recovered", "der"].includes(format5))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return format5;
}
function validateSigOpts(opts, def) {
  const optsn = {};
  for (let optName of Object.keys(def)) {
    optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
  }
  abool(optsn.lowS, "lowS");
  abool(optsn.prehash, "prehash");
  if (optsn.format !== void 0)
    validateSigFormat(optsn.format);
  return optsn;
}
var DERErr = class extends Error {
  constructor(m = "") {
    super(m);
  }
};
var DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E } = DER;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128)
        throw new E("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
      const t = numberToHexUnpadded(tag);
      return t + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E } = DER;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E("tlv.decode: wrong tlv");
      const first2 = data[pos++];
      const isLong = !!(first2 & 128);
      let length6 = 0;
      if (!isLong)
        length6 = first2;
      else {
        const lenLen = first2 & 127;
        if (!lenLen)
          throw new E("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E("tlv.decode(long): zero leftmost byte");
        for (const b of lengthBytes)
          length6 = length6 << 8 | b;
        pos += lenLen;
        if (length6 < 128)
          throw new E("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length6);
      if (v.length !== length6)
        throw new E("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length6) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num2) {
      const { Err: E } = DER;
      if (num2 < _0n4)
        throw new E("integer: negative integers are not allowed");
      let hex = numberToHexUnpadded(num2);
      if (Number.parseInt(hex[0], 16) & 8)
        hex = "00" + hex;
      if (hex.length & 1)
        throw new E("unexpected DER parsing assertion: unpadded hex");
      return hex;
    },
    decode(data) {
      const { Err: E } = DER;
      if (data[0] & 128)
        throw new E("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE(data);
    }
  },
  toSig(bytes) {
    const { Err: E, _int: int, _tlv: tlv } = DER;
    const data = abytes2(bytes, void 0, "signature");
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER;
    const rs = tlv.encode(2, int.encode(sig.r));
    const ss = tlv.encode(2, int.encode(sig.s));
    const seq = rs + ss;
    return tlv.encode(48, seq);
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n2 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrass(params, extraOpts = {}) {
  const validated = createCurveFields("weierstrass", params, extraOpts);
  const { Fp, Fn } = validated;
  let CURVE = validated.CURVE;
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  validateObject(extraOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object"
  });
  const { endo } = extraOpts;
  if (endo) {
    if (!Fp.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
      throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    }
  }
  const lengths = getWLengths(Fp, Fn);
  function assertCompressionIsSupported() {
    if (!Fp.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes2(_c, point, isCompressed) {
    const { x, y } = point.toAffine();
    const bx = Fp.toBytes(x);
    abool(isCompressed, "isCompressed");
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp.isOdd(y);
      return concatBytes(pprefix(hasEvenY), bx);
    } else {
      return concatBytes(Uint8Array.of(4), bx, Fp.toBytes(y));
    }
  }
  function pointFromBytes(bytes) {
    abytes2(bytes, void 0, "Point");
    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
    const length6 = bytes.length;
    const head = bytes[0];
    const tail = bytes.subarray(1);
    if (length6 === comp && (head === 2 || head === 3)) {
      const x = Fp.fromBytes(tail);
      if (!Fp.isValid(x))
        throw new Error("bad point: is not on curve, wrong x");
      const y2 = weierstrassEquation(x);
      let y;
      try {
        y = Fp.sqrt(y2);
      } catch (sqrtError) {
        const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err);
      }
      assertCompressionIsSupported();
      const evenY = Fp.isOdd(y);
      const evenH = (head & 1) === 1;
      if (evenH !== evenY)
        y = Fp.neg(y);
      return { x, y };
    } else if (length6 === uncomp && head === 4) {
      const L = Fp.BYTES;
      const x = Fp.fromBytes(tail.subarray(0, L));
      const y = Fp.fromBytes(tail.subarray(L, L * 2));
      if (!isValidXY(x, y))
        throw new Error("bad point: is not on curve");
      return { x, y };
    } else {
      throw new Error(`bad point: got length ${length6}, expected compressed=${comp} or uncompressed=${uncomp}`);
    }
  }
  const encodePoint = extraOpts.toBytes || pointToBytes2;
  const decodePoint = extraOpts.fromBytes || pointFromBytes;
  function weierstrassEquation(x) {
    const x2 = Fp.sqr(x);
    const x3 = Fp.mul(x2, x);
    return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b);
  }
  function isValidXY(x, y) {
    const left = Fp.sqr(y);
    const right = weierstrassEquation(x);
    return Fp.eql(left, right);
  }
  if (!isValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n2), _4n2);
  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
  if (Fp.is0(Fp.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n2, banZero = false) {
    if (!Fp.isValid(n2) || banZero && Fp.is0(n2))
      throw new Error(`bad point coordinate ${title}`);
    return n2;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point))
      throw new Error("Weierstrass Point expected");
  }
  function splitEndoScalarN(k) {
    if (!endo || !endo.basises)
      throw new Error("no endo");
    return _splitEndoScalar(k, endo.basises, Fn.ORDER);
  }
  const toAffineMemo = memoized((p, iz) => {
    const { X, Y, Z } = p;
    if (Fp.eql(Z, Fp.ONE))
      return { x: X, y: Y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp.ONE : Fp.inv(Z);
    const x = Fp.mul(X, iz);
    const y = Fp.mul(Y, iz);
    const zz = Fp.mul(Z, iz);
    if (is0)
      return { x: Fp.ZERO, y: Fp.ZERO };
    if (!Fp.eql(zz, Fp.ONE))
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p.toAffine();
    if (!Fp.isValid(x) || !Fp.isValid(y))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x, y))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
    k1p = negateCt(k1neg, k1p);
    k2p = negateCt(k2neg, k2p);
    return k1p.add(k2p);
  }
  const _Point = class _Point {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(X, Y, Z) {
      __publicField(this, "X");
      __publicField(this, "Y");
      __publicField(this, "Z");
      this.X = acoord("x", X);
      this.Y = acoord("y", Y, true);
      this.Z = acoord("z", Z);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof _Point)
        throw new Error("projective point not allowed");
      if (Fp.is0(x) && Fp.is0(y))
        return _Point.ZERO;
      return new _Point(x, y, Fp.ONE);
    }
    static fromBytes(bytes) {
      const P = _Point.fromAffine(decodePoint(abytes2(bytes, void 0, "point")));
      P.assertValidity();
      return P;
    }
    static fromHex(hex) {
      return _Point.fromBytes(hexToBytes(hex));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_3n2);
      return this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (!Fp.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp.isOdd(y);
    }
    /** Compare one point to another. */
    equals(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new _Point(this.X, Fp.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp.mul(b, _3n2);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t2 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a, Z3);
      Y3 = Fp.mul(b3, t2);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3);
      t2 = Fp.mul(a, t2);
      t3 = Fp.sub(t0, t2);
      t3 = Fp.mul(a, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t2);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t2 = Fp.mul(Y1, Z1);
      t2 = Fp.add(t2, t2);
      t0 = Fp.mul(t2, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t2, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new _Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      const a = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n2);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t2 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t2);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t2);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a, t4);
      X3 = Fp.mul(b3, t2);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t2 = Fp.mul(a, t2);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t2);
      t2 = Fp.sub(t0, t2);
      t2 = Fp.mul(a, t2);
      t4 = Fp.add(t4, t2);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4);
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0);
      return new _Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(_Point.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo2 } = extraOpts;
      if (!Fn.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul = (n2) => wnaf.cached(this, n2, (p) => normalizeZ(_Point, p));
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
        const { p: k1p, f: k1f } = mul(k1);
        const { p: k2p, f: k2f } = mul(k2);
        fake = k1f.add(k2f);
        point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p, f } = mul(scalar);
        point = p;
        fake = f;
      }
      return normalizeZ(_Point, [point, fake])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo: endo2 } = extraOpts;
      const p = this;
      if (!Fn.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n4 || p.is0())
        return _Point.ZERO;
      if (sc === _1n4)
        return p;
      if (wnaf.hasCache(this))
        return this.multiply(sc);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
        const { p1, p2 } = mulEndoUnsafe(_Point, p, k1, k2);
        return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
      } else {
        return wnaf.unsafe(p, sc);
      }
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree } = extraOpts;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(_Point, this);
      return wnaf.unsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = extraOpts;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(_Point, this);
      return this.multiplyUnsafe(cofactor);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    toBytes(isCompressed = true) {
      abool(isCompressed, "isCompressed");
      this.assertValidity();
      return encodePoint(_Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  };
  // base / generator point
  __publicField(_Point, "BASE", new _Point(CURVE.Gx, CURVE.Gy, Fp.ONE));
  // zero / infinity / identity point
  __publicField(_Point, "ZERO", new _Point(Fp.ZERO, Fp.ONE, Fp.ZERO));
  // 0, 1, 0
  // math field
  __publicField(_Point, "Fp", Fp);
  // scalar field
  __publicField(_Point, "Fn", Fn);
  let Point = _Point;
  const bits = Fn.BITS;
  const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
  Point.BASE.precompute(8);
  return Point;
}
function pprefix(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function getWLengths(Fp, Fn) {
  return {
    secretKey: Fn.BYTES,
    publicKey: 1 + Fp.BYTES,
    publicKeyUncompressed: 1 + 2 * Fp.BYTES,
    publicKeyHasPrefix: true,
    signature: 2 * Fn.BYTES
  };
}
function ecdh(Point, ecdhOpts = {}) {
  const { Fn } = Point;
  const randomBytes_ = ecdhOpts.randomBytes || randomBytes;
  const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });
  function isValidSecretKey(secretKey) {
    try {
      const num2 = Fn.fromBytes(secretKey);
      return Fn.isValidNot0(num2);
    } catch (error) {
      return false;
    }
  }
  function isValidPublicKey(publicKey, isCompressed) {
    const { publicKey: comp, publicKeyUncompressed } = lengths;
    try {
      const l = publicKey.length;
      if (isCompressed === true && l !== comp)
        return false;
      if (isCompressed === false && l !== publicKeyUncompressed)
        return false;
      return !!Point.fromBytes(publicKey);
    } catch (error) {
      return false;
    }
  }
  function randomSecretKey(seed = randomBytes_(lengths.seed)) {
    return mapHashToField(abytes2(seed, lengths.seed, "seed"), Fn.ORDER);
  }
  function getPublicKey(secretKey, isCompressed = true) {
    return Point.BASE.multiply(Fn.fromBytes(secretKey)).toBytes(isCompressed);
  }
  function isProbPub(item) {
    const { secretKey, publicKey, publicKeyUncompressed } = lengths;
    if (!isBytes3(item))
      return void 0;
    if ("_lengths" in Fn && Fn._lengths || secretKey === publicKey)
      return void 0;
    const l = abytes2(item, void 0, "key").length;
    return l === publicKey || l === publicKeyUncompressed;
  }
  function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
    if (isProbPub(secretKeyA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicKeyB) === false)
      throw new Error("second arg must be public key");
    const s = Fn.fromBytes(secretKeyA);
    const b = Point.fromBytes(publicKeyB);
    return b.multiply(s).toBytes(isCompressed);
  }
  const utils = {
    isValidSecretKey,
    isValidPublicKey,
    randomSecretKey
  };
  const keygen = createKeygen(randomSecretKey, getPublicKey);
  return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });
}
function ecdsa(Point, hash, ecdsaOpts = {}) {
  ahash2(hash);
  validateObject(ecdsaOpts, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  ecdsaOpts = Object.assign({}, ecdsaOpts);
  const randomBytes2 = ecdsaOpts.randomBytes || randomBytes;
  const hmac3 = ecdsaOpts.hmac || ((key, msg) => hmac2(hash, key, msg));
  const { Fp, Fn } = Point;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
  const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
  const defaultSigOpts = {
    prehash: true,
    lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : true,
    format: "compact",
    extraEntropy: false
  };
  const hasLargeCofactor = CURVE_ORDER * _2n2 < Fp.ORDER;
  function isBiggerThanHalfOrder(number3) {
    const HALF = CURVE_ORDER >> _1n4;
    return number3 > HALF;
  }
  function validateRS(title, num2) {
    if (!Fn.isValidNot0(num2))
      throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
    return num2;
  }
  function assertSmallCofactor() {
    if (hasLargeCofactor)
      throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
  }
  function validateSigLength(bytes, format5) {
    validateSigFormat(format5);
    const size = lengths.signature;
    const sizer = format5 === "compact" ? size : format5 === "recovered" ? size + 1 : void 0;
    return abytes2(bytes, sizer);
  }
  class Signature {
    constructor(r, s, recovery) {
      __publicField(this, "r");
      __publicField(this, "s");
      __publicField(this, "recovery");
      this.r = validateRS("r", r);
      this.s = validateRS("s", s);
      if (recovery != null) {
        assertSmallCofactor();
        if (![0, 1, 2, 3].includes(recovery))
          throw new Error("invalid recovery id");
        this.recovery = recovery;
      }
      Object.freeze(this);
    }
    static fromBytes(bytes, format5 = defaultSigOpts.format) {
      validateSigLength(bytes, format5);
      let recid;
      if (format5 === "der") {
        const { r: r2, s: s2 } = DER.toSig(abytes2(bytes));
        return new Signature(r2, s2);
      }
      if (format5 === "recovered") {
        recid = bytes[0];
        format5 = "compact";
        bytes = bytes.subarray(1);
      }
      const L = lengths.signature / 2;
      const r = bytes.subarray(0, L);
      const s = bytes.subarray(L, L * 2);
      return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);
    }
    static fromHex(hex, format5) {
      return this.fromBytes(hexToBytes(hex), format5);
    }
    assertRecovery() {
      const { recovery } = this;
      if (recovery == null)
        throw new Error("invalid recovery id: must be present");
      return recovery;
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(messageHash) {
      const { r, s } = this;
      const recovery = this.assertRecovery();
      const radj = recovery === 2 || recovery === 3 ? r + CURVE_ORDER : r;
      if (!Fp.isValid(radj))
        throw new Error("invalid recovery id: sig.r+curve.n != R.x");
      const x = Fp.toBytes(radj);
      const R = Point.fromBytes(concatBytes(pprefix((recovery & 1) === 0), x));
      const ir = Fn.inv(radj);
      const h3 = bits2int_modN(abytes2(messageHash, void 0, "msgHash"));
      const u1 = Fn.create(-h3 * ir);
      const u2 = Fn.create(s * ir);
      const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
      if (Q.is0())
        throw new Error("invalid recovery: point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    toBytes(format5 = defaultSigOpts.format) {
      validateSigFormat(format5);
      if (format5 === "der")
        return hexToBytes(DER.hexFromSig(this));
      const { r, s } = this;
      const rb = Fn.toBytes(r);
      const sb = Fn.toBytes(s);
      if (format5 === "recovered") {
        assertSmallCofactor();
        return concatBytes(Uint8Array.of(this.assertRecovery()), rb, sb);
      }
      return concatBytes(rb, sb);
    }
    toHex(format5) {
      return bytesToHex(this.toBytes(format5));
    }
  }
  const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const num2 = bytesToNumberBE(bytes);
    const delta = bytes.length * 8 - fnBits;
    return delta > 0 ? num2 >> BigInt(delta) : num2;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
    return Fn.create(bits2int(bytes));
  };
  const ORDER_MASK = bitMask(fnBits);
  function int2octets(num2) {
    aInRange("num < 2^" + fnBits, num2, _0n4, ORDER_MASK);
    return Fn.toBytes(num2);
  }
  function validateMsgAndHash(message, prehash) {
    abytes2(message, void 0, "message");
    return prehash ? abytes2(hash(message), void 0, "prehashed message") : message;
  }
  function prepSig(message, secretKey, opts) {
    const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
    message = validateMsgAndHash(message, prehash);
    const h1int = bits2int_modN(message);
    const d = Fn.fromBytes(secretKey);
    if (!Fn.isValidNot0(d))
      throw new Error("invalid private key");
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (extraEntropy != null && extraEntropy !== false) {
      const e = extraEntropy === true ? randomBytes2(lengths.secretKey) : extraEntropy;
      seedArgs.push(abytes2(e, void 0, "extraEntropy"));
    }
    const seed = concatBytes(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!Fn.isValidNot0(k))
        return;
      const ik = Fn.inv(k);
      const q = Point.BASE.multiply(k).toAffine();
      const r = Fn.create(q.x);
      if (r === _0n4)
        return;
      const s = Fn.create(ik * Fn.create(m + r * d));
      if (s === _0n4)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = Fn.neg(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, hasLargeCofactor ? void 0 : recovery);
    }
    return { seed, k2sig };
  }
  function sign2(message, secretKey, opts = {}) {
    const { seed, k2sig } = prepSig(message, secretKey, opts);
    const drbg = createHmacDrbg(hash.outputLen, Fn.BYTES, hmac3);
    const sig = drbg(seed, k2sig);
    return sig.toBytes(opts.format);
  }
  function verify2(signature2, message, publicKey, opts = {}) {
    const { lowS, prehash, format: format5 } = validateSigOpts(opts, defaultSigOpts);
    publicKey = abytes2(publicKey, void 0, "publicKey");
    message = validateMsgAndHash(message, prehash);
    if (!isBytes3(signature2)) {
      const end = signature2 instanceof Signature ? ", use sig.toBytes()" : "";
      throw new Error("verify expects Uint8Array signature" + end);
    }
    validateSigLength(signature2, format5);
    try {
      const sig = Signature.fromBytes(signature2, format5);
      const P = Point.fromBytes(publicKey);
      if (lowS && sig.hasHighS())
        return false;
      const { r, s } = sig;
      const h3 = bits2int_modN(message);
      const is3 = Fn.inv(s);
      const u1 = Fn.create(h3 * is3);
      const u2 = Fn.create(r * is3);
      const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
      if (R.is0())
        return false;
      const v = Fn.create(R.x);
      return v === r;
    } catch (e) {
      return false;
    }
  }
  function recoverPublicKey(signature2, message, opts = {}) {
    const { prehash } = validateSigOpts(opts, defaultSigOpts);
    message = validateMsgAndHash(message, prehash);
    return Signature.fromBytes(signature2, "recovered").recoverPublicKey(message).toBytes();
  }
  return Object.freeze({
    keygen,
    getPublicKey,
    getSharedSecret,
    utils,
    lengths,
    Point,
    sign: sign2,
    verify: verify2,
    recoverPublicKey,
    Signature,
    hash
  });
}

// node_modules/.pnpm/@noble+curves@2.0.1/node_modules/@noble/curves/secp256k1.js
var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var secp256k1_ENDO = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var _0n5 = /* @__PURE__ */ BigInt(0);
var _2n3 = /* @__PURE__ */ BigInt(2);
function sqrtMod(y) {
  const P = secp256k1_CURVE.p;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n3, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n3, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
var Pointk1 = /* @__PURE__ */ weierstrass(secp256k1_CURVE, {
  Fp: Fpk1,
  endo: secp256k1_ENDO
});
var secp256k1 = /* @__PURE__ */ ecdsa(Pointk1, sha2563);
var TAGGED_HASH_PREFIXES2 = {};
function taggedHash2(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES2[tag];
  if (tagP === void 0) {
    const tagH = sha2563(asciiToBytes(tag));
    tagP = concatBytes(tagH, tagH);
    TAGGED_HASH_PREFIXES2[tag] = tagP;
  }
  return sha2563(concatBytes(tagP, ...messages));
}
var pointToBytes = (point) => point.toBytes(true).slice(1);
var hasEven = (y) => y % _2n3 === _0n5;
function schnorrGetExtPubKey(priv) {
  const { Fn, BASE } = Pointk1;
  const d_ = Fn.fromBytes(priv);
  const p = BASE.multiply(d_);
  const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  const Fp = Fpk1;
  if (!Fp.isValidNot0(x))
    throw new Error("invalid x: Fail if x \u2265 p");
  const xx = Fp.create(x * x);
  const c = Fp.create(xx * x + BigInt(7));
  let y = Fp.sqrt(c);
  if (!hasEven(y))
    y = Fp.neg(y);
  const p = Pointk1.fromAffine({ x, y });
  p.assertValidity();
  return p;
}
var num = bytesToNumberBE;
function challenge(...args) {
  return Pointk1.Fn.create(num(taggedHash2("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(secretKey) {
  return schnorrGetExtPubKey(secretKey).bytes;
}
function schnorrSign(message, secretKey, auxRand = randomBytes(32)) {
  const { Fn } = Pointk1;
  const m = abytes2(message, void 0, "message");
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey);
  const a = abytes2(auxRand, 32, "auxRand");
  const t = Fn.toBytes(d ^ num(taggedHash2("BIP0340/aux", a)));
  const rand = taggedHash2("BIP0340/nonce", t, px, m);
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature2, message, publicKey) {
  const { Fp, Fn, BASE } = Pointk1;
  const sig = abytes2(signature2, 64, "signature");
  const m = abytes2(message, void 0, "message");
  const pub = abytes2(publicKey, 32, "publicKey");
  try {
    const P = lift_x(num(pub));
    const r = num(sig.subarray(0, 32));
    if (!Fp.isValidNot0(r))
      return false;
    const s = num(sig.subarray(32, 64));
    if (!Fn.isValidNot0(s))
      return false;
    const e = challenge(Fn.toBytes(r), pointToBytes(P), m);
    const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));
    const { x, y } = R.toAffine();
    if (R.is0() || !hasEven(y) || x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = /* @__PURE__ */ (() => {
  const size = 32;
  const seedLength = 48;
  const randomSecretKey = (seed = randomBytes(seedLength)) => {
    return mapHashToField(seed, secp256k1_CURVE.n);
  };
  return {
    keygen: createKeygen(randomSecretKey, schnorrGetPublicKey),
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    Point: Pointk1,
    utils: {
      randomSecretKey,
      taggedHash: taggedHash2,
      lift_x,
      pointToBytes
    },
    lengths: {
      secretKey: size,
      publicKey: size,
      publicKeyHasPrefix: false,
      signature: size * 2,
      seed: seedLength
    }
  };
})();

// src/core/ecc.ts
var ec = new import_elliptic.default.ec("secp256k1");
var G = ec.curve.g;
var n = ec.curve.n;
var NOBLE_ORDER = secp256k1.Point.Fn.ORDER;
var toHex2 = (b) => import_buffer.Buffer.from(b).toString("hex");
var fromHex3 = (s) => Uint8Array.from(import_buffer.Buffer.from(s, "hex"));
var isPoint2 = (p) => {
  try {
    ec.curve.decodePoint(p);
    return true;
  } catch {
    return false;
  }
};
var isPrivate = (d) => {
  if (d.length !== 32) return false;
  const bn = new import_bn.default(d);
  return bn.gt(new import_bn.default(0)) && bn.lt(n);
};
var pointAdd = (pA, pB, compressed) => {
  try {
    const a = ec.curve.decodePoint(pA);
    const b = ec.curve.decodePoint(pB);
    const res = a.add(b);
    if (res.isInfinity()) return null;
    return Uint8Array.from(res.encode(void 0, compressed !== false));
  } catch {
    return null;
  }
};
var pointAddScalar = (p, tweak, compressed) => {
  try {
    const pp = ec.curve.decodePoint(p);
    const tt = new import_bn.default(tweak);
    const qq = G.mul(tt);
    const res = pp.add(qq);
    if (res.isInfinity()) return null;
    return Uint8Array.from(res.encode(void 0, compressed !== false));
  } catch {
    return null;
  }
};
var pointCompress = (p, compressed) => {
  const pp = ec.curve.decodePoint(p);
  return Uint8Array.from(pp.encode(void 0, compressed !== false));
};
var pointMultiply = (p, tweak, compressed) => {
  try {
    const pp = ec.curve.decodePoint(p);
    const tt = new import_bn.default(tweak);
    const res = pp.mul(tt);
    if (res.isInfinity()) return null;
    return Uint8Array.from(res.encode(void 0, compressed !== false));
  } catch {
    return null;
  }
};
var pointFromScalar = (d, compressed) => {
  try {
    const dd = new import_bn.default(d);
    if (dd.isZero() || dd.gte(n)) return null;
    const res = G.mul(dd);
    if (res.isInfinity()) return null;
    return Uint8Array.from(res.encode(void 0, compressed !== false));
  } catch {
    return null;
  }
};
var privateAdd = (d, tweak) => {
  const dd = new import_bn.default(d);
  const tt = new import_bn.default(tweak);
  const res = dd.add(tt).umod(n);
  if (res.isZero()) return null;
  return Uint8Array.from(res.toArrayLike(import_buffer.Buffer, "be", 32));
};
var privateNegate = (d) => {
  const dd = new import_bn.default(d);
  const res = n.sub(dd).umod(n);
  return Uint8Array.from(res.toArrayLike(import_buffer.Buffer, "be", 32));
};
var sign = (hash, x) => {
  const sig = ec.sign(hash, x, { canonical: true });
  const res = import_buffer.Buffer.allocUnsafe(64);
  sig.r.toArrayLike(import_buffer.Buffer, "be", 32).copy(res, 0);
  sig.s.toArrayLike(import_buffer.Buffer, "be", 32).copy(res, 32);
  return Uint8Array.from(res);
};
var verify = (hash, p, signature2) => {
  try {
    const r = signature2.slice(0, 32);
    const s = signature2.slice(32, 64);
    return ec.verify(hash, { r, s }, p);
  } catch {
    return false;
  }
};
var isXOnlyPoint = (p) => {
  if (p.length !== 32) return false;
  try {
    secp256k1.Point.fromHex("02" + toHex2(p));
    return true;
  } catch {
    return false;
  }
};
var xOnlyPointAddTweak = (p, t) => {
  try {
    const pt = secp256k1.Point.fromHex("02" + toHex2(p));
    const scalar = BigInt("0x" + toHex2(t));
    if (scalar >= NOBLE_ORDER) return null;
    const res = pt.add(secp256k1.Point.BASE.multiply(scalar));
    if (res.is0()) return null;
    return {
      parity: res.hasEvenY() ? 0 : 1,
      xOnlyPubkey: res.toBytes(false).slice(1, 33)
    };
  } catch {
    return null;
  }
};
var privateTweakAdd = (d, t) => {
  try {
    const d_bi = BigInt("0x" + toHex2(d));
    const P = secp256k1.Point.BASE.multiply(d_bi);
    let d_norm = d_bi;
    if (!P.hasEvenY()) {
      d_norm = (NOBLE_ORDER - d_bi) % NOBLE_ORDER;
    }
    const t_bi = BigInt("0x" + toHex2(t));
    if (t_bi >= NOBLE_ORDER) return null;
    const res = (d_norm + t_bi) % NOBLE_ORDER;
    if (res === 0n) return null;
    return fromHex3(res.toString(16).padStart(64, "0"));
  } catch {
    return null;
  }
};
var signSchnorr = (h3, d, e = new Uint8Array(32)) => {
  return schnorr.sign(h3, d, e);
};
var verifySchnorr = (h3, p, s) => {
  return schnorr.verify(s, h3, p);
};
var ecc = {
  isPoint: isPoint2,
  isPrivate,
  pointAdd,
  pointAddScalar,
  pointCompress,
  pointMultiply,
  pointFromScalar,
  privateAdd,
  privateNegate,
  sign,
  verify,
  isXOnlyPoint,
  xOnlyPointAddTweak,
  privateTweakAdd,
  signSchnorr,
  verifySchnorr
};
var ecc_default = ecc;

// src/core/secure-bitcoin-lib.ts
if (typeof window !== "undefined") window.Buffer = import_buffer3.Buffer;
if (typeof self !== "undefined") self.Buffer = import_buffer3.Buffer;
var bip32 = BIP32Factory(ecc_exports);
var CryptoWorkerClient = class {
  static getInstance() {
    if (!this.instance) {
      this.instance = new Worker("crypto-worker.js", { type: "module" });
      this.instance.onmessage = (event) => {
        const { requestId, status, payload, error } = event.data;
        const handlers = this.pendingRequests.get(requestId);
        if (handlers) {
          if (status === "success") {
            handlers.resolve(payload);
          } else {
            handlers.reject(new Error(error || "Worker operation failed"));
          }
          this.pendingRequests.delete(requestId);
        }
      };
      this.instance.onerror = (error) => {
        console.error("Crypto worker error:", error);
        for (const handlers of this.pendingRequests.values()) {
          handlers.reject(new Error("Crypto worker crashed"));
        }
        this.pendingRequests.clear();
        this.instance = null;
      };
    }
    return this.instance;
  }
  static call(type, payload) {
    const requestId = this.nextRequestId++;
    const worker = this.getInstance();
    return new Promise((resolve2, reject) => {
      this.pendingRequests.set(requestId, { resolve: resolve2, reject });
      worker.postMessage({ type, payload, requestId });
    });
  }
};
CryptoWorkerClient.instance = null;
CryptoWorkerClient.pendingRequests = /* @__PURE__ */ new Map();
CryptoWorkerClient.nextRequestId = 0;
var SecureWallet = class {
  constructor(encryptedMnemonic, secureStorage2) {
    this.encryptedMnemonic = encryptedMnemonic;
    this.secureStorage = secureStorage2;
  }
  async getAddress(index, pin) {
    const response = await CryptoWorkerClient.call(
      "getAddress",
      {
        encryptedMnemonic: this.encryptedMnemonic,
        pin,
        index
      }
    );
    return response.address;
  }
  async getNode(index, pin) {
    const response = await CryptoWorkerClient.call("getNode", {
      encryptedMnemonic: this.encryptedMnemonic,
      pin,
      index
    });
    const { privateKey, chainCode } = response.node;
    return bip32.fromPrivateKey(
      Uint8Array.from(import_buffer3.Buffer.from(privateKey)),
      Uint8Array.from(import_buffer3.Buffer.from(chainCode)),
      networks_exports.bitcoin
    );
  }
};

// src/core/wallet.ts
var BitcoinWallet = class {
  constructor(secureWallet, encryptedMnemonic) {
    this.secureWallet = secureWallet;
    this.encryptedMnemonic = encryptedMnemonic;
  }
  getAddress(index, pin) {
    return this.secureWallet.getAddress(index, pin);
  }
  getEncryptedMnemonic() {
    return this.encryptedMnemonic;
  }
};
async function generateMnemonicAsync() {
  const response = await CryptoWorkerClient.call(
    "generateMnemonic",
    {}
  );
  return response.mnemonic;
}
async function createWallet(secureStorage2, pin) {
  const mnemonic = await generateMnemonicAsync();
  const encryptedMnemonic = await secureStorage2.encrypt(mnemonic, pin);
  const secureWallet = new SecureWallet(encryptedMnemonic, secureStorage2);
  const wallet = new BitcoinWallet(secureWallet, encryptedMnemonic);
  return { wallet, mnemonic };
}

// src/services/secure-storage.ts
init_buffer_polyfill();
var SecureStorageService = class {
  constructor() {
    this.SALT_LENGTH = 16;
    this.IV_LENGTH = 12;
    this.KEY_LENGTH = 256;
    this.PBKDF2_ITERATIONS = 1e5;
  }
  async encrypt(data, pin) {
    const salt = crypto.getRandomValues(new Uint8Array(this.SALT_LENGTH));
    const iv = crypto.getRandomValues(new Uint8Array(this.IV_LENGTH));
    const key = await this.deriveKey(pin, salt);
    const encryptedData = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      new TextEncoder().encode(data)
    );
    const encryptedBytes = new Uint8Array(encryptedData);
    const result = new Uint8Array(salt.length + iv.length + encryptedBytes.length);
    result.set(salt, 0);
    result.set(iv, salt.length);
    result.set(encryptedBytes, salt.length + iv.length);
    return import_buffer.Buffer.from(result).toString("hex");
  }
  async decrypt(encryptedHexString, pin) {
    const encryptedDataBytes = import_buffer.Buffer.from(encryptedHexString, "hex");
    const salt = Uint8Array.from(encryptedDataBytes.slice(0, this.SALT_LENGTH));
    const iv = Uint8Array.from(encryptedDataBytes.slice(this.SALT_LENGTH, this.SALT_LENGTH + this.IV_LENGTH));
    const data = Uint8Array.from(encryptedDataBytes.slice(this.SALT_LENGTH + this.IV_LENGTH));
    const key = await this.deriveKey(pin, salt);
    const decryptedData = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      data
    );
    return new TextDecoder().decode(decryptedData);
  }
  async deriveKey(pin, salt) {
    const keyMaterial = await crypto.subtle.importKey(
      "raw",
      new TextEncoder().encode(pin),
      { name: "PBKDF2" },
      false,
      ["deriveKey"]
    );
    return crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt,
        iterations: this.PBKDF2_ITERATIONS,
        hash: "SHA-256"
      },
      keyMaterial,
      { name: "AES-GCM", length: this.KEY_LENGTH },
      true,
      ["encrypt", "decrypt"]
    );
  }
};

// src/services/ipfs.ts
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/multibases.js
init_buffer_polyfill();
var LOAD_BASE = (name10) => Promise.reject(new Error(`No base found for "${name10}"`));
var Multibases = class {
  /**
   * @param {object} options
   * @param {LoadBaseFn} [options.loadBase]
   * @param {MultibaseCodec[]} options.bases
   */
  constructor(options) {
    this._basesByName = {};
    this._basesByPrefix = {};
    this._loadBase = options.loadBase || LOAD_BASE;
    for (const base5 of options.bases) {
      this.addBase(base5);
    }
  }
  /**
   * Add support for a multibase codec
   *
   * @param {MultibaseCodec} base
   */
  addBase(base5) {
    if (this._basesByName[base5.name] || this._basesByPrefix[base5.prefix]) {
      throw new Error(`Codec already exists for codec "${base5.name}"`);
    }
    this._basesByName[base5.name] = base5;
    this._basesByPrefix[base5.prefix] = base5;
  }
  /**
   * Remove support for a multibase codec
   *
   * @param {MultibaseCodec} base
   */
  removeBase(base5) {
    delete this._basesByName[base5.name];
    delete this._basesByPrefix[base5.prefix];
  }
  /**
   * @param {string} nameOrPrefix
   */
  async getBase(nameOrPrefix) {
    if (this._basesByName[nameOrPrefix]) {
      return this._basesByName[nameOrPrefix];
    }
    if (this._basesByPrefix[nameOrPrefix]) {
      return this._basesByPrefix[nameOrPrefix];
    }
    const base5 = await this._loadBase(nameOrPrefix);
    if (this._basesByName[base5.name] == null && this._basesByPrefix[base5.prefix] == null) {
      this.addBase(base5);
    }
    return base5;
  }
  listBases() {
    return Object.values(this._basesByName);
  }
};

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/multicodecs.js
init_buffer_polyfill();
var LOAD_CODEC = (codeOrName) => Promise.reject(new Error(`No codec found for "${codeOrName}"`));
var Multicodecs = class {
  /**
   * @param {object} options
   * @param {LoadCodecFn} [options.loadCodec]
   * @param {BlockCodec[]} options.codecs
   */
  constructor(options) {
    this._codecsByName = {};
    this._codecsByCode = {};
    this._loadCodec = options.loadCodec || LOAD_CODEC;
    for (const codec of options.codecs) {
      this.addCodec(codec);
    }
  }
  /**
   * Add support for a block codec
   *
   * @param {BlockCodec} codec
   */
  addCodec(codec) {
    if (this._codecsByName[codec.name] || this._codecsByCode[codec.code]) {
      throw new Error(`Resolver already exists for codec "${codec.name}"`);
    }
    this._codecsByName[codec.name] = codec;
    this._codecsByCode[codec.code] = codec;
  }
  /**
   * Remove support for a block codec
   *
   * @param {BlockCodec} codec
   */
  removeCodec(codec) {
    delete this._codecsByName[codec.name];
    delete this._codecsByCode[codec.code];
  }
  /**
   * @param {number | string} code
   */
  async getCodec(code10) {
    const table2 = typeof code10 === "string" ? this._codecsByName : this._codecsByCode;
    if (table2[code10]) {
      return table2[code10];
    }
    const codec = await this._loadCodec(code10);
    if (table2[code10] == null) {
      this.addCodec(codec);
    }
    return codec;
  }
  listCodecs() {
    return Object.values(this._codecsByName);
  }
};

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/multihashes.js
init_buffer_polyfill();
var LOAD_HASHER = (codeOrName) => Promise.reject(new Error(`No hasher found for "${codeOrName}"`));
var Multihashes = class {
  /**
   * @param {object} options
   * @param {LoadHasherFn} [options.loadHasher]
   * @param {MultihashHasher[]} options.hashers
   */
  constructor(options) {
    this._hashersByName = {};
    this._hashersByCode = {};
    this._loadHasher = options.loadHasher || LOAD_HASHER;
    for (const hasher of options.hashers) {
      this.addHasher(hasher);
    }
  }
  /**
   * Add support for a multibase hasher
   *
   * @param {MultihashHasher} hasher
   */
  addHasher(hasher) {
    if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {
      throw new Error(`Resolver already exists for codec "${hasher.name}"`);
    }
    this._hashersByName[hasher.name] = hasher;
    this._hashersByCode[hasher.code] = hasher;
  }
  /**
   * Remove support for a multibase hasher
   *
   * @param {MultihashHasher} hasher
   */
  removeHasher(hasher) {
    delete this._hashersByName[hasher.name];
    delete this._hashersByCode[hasher.code];
  }
  /**
   * @param {number | string} code
   */
  async getHasher(code10) {
    const table2 = typeof code10 === "string" ? this._hashersByName : this._hashersByCode;
    if (table2[code10]) {
      return table2[code10];
    }
    const hasher = await this._loadHasher(code10);
    if (table2[code10] == null) {
      this.addHasher(hasher);
    }
    return hasher;
  }
  listHashers() {
    return Object.values(this._hashersByName);
  }
};

// node_modules/.pnpm/@ipld+dag-pb@4.1.5/node_modules/@ipld/dag-pb/src/index.js
var src_exports = {};
__export(src_exports, {
  code: () => code,
  createLink: () => createLink,
  createNode: () => createNode,
  decode: () => decode22,
  encode: () => encode22,
  name: () => name,
  prepare: () => prepare,
  validate: () => validate
});
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/cid.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bytes.js
init_buffer_polyfill();
var empty = new Uint8Array(0);
function equals(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString(str) {
  return new TextEncoder().encode(str);
}
function toString(b) {
  return new TextDecoder().decode(b);
}

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/vendor/base-x.js
init_buffer_polyfill();
function base2(ALPHABET2, name10) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET2.length; i++) {
    var x = ALPHABET2.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode42(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length6 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length6) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length6 = i2;
      pbegin++;
    }
    var it2 = size - length6;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length6 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length6) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length6 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length6;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode44(string5) {
    var buffer2 = decodeUnsafe(string5);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name10} character`);
  }
  return {
    encode: encode42,
    decodeUnsafe,
    decode: decode44
  };
}
var src = base2;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base.js
var Encoder = class {
  constructor(name10, prefix, baseEncode) {
    __publicField(this, "name");
    __publicField(this, "prefix");
    __publicField(this, "baseEncode");
    this.name = name10;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  constructor(name10, prefix, baseDecode) {
    __publicField(this, "name");
    __publicField(this, "prefix");
    __publicField(this, "baseDecode");
    __publicField(this, "prefixCodePoint");
    this.name = name10;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  constructor(decoders3) {
    __publicField(this, "decoders");
    this.decoders = decoders3;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or(left, right) {
  return new ComposedDecoder({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec = class {
  constructor(name10, prefix, baseEncode, baseDecode) {
    __publicField(this, "name");
    __publicField(this, "prefix");
    __publicField(this, "baseEncode");
    __publicField(this, "baseDecode");
    __publicField(this, "encoder");
    __publicField(this, "decoder");
    this.name = name10;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name10, prefix, baseEncode);
    this.decoder = new Decoder(name10, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from({ name: name10, prefix, encode: encode42, decode: decode44 }) {
  return new Codec(name10, prefix, encode42, decode44);
}
function baseX({ name: name10, prefix, alphabet: alphabet5 }) {
  const { encode: encode42, decode: decode44 } = base_x_default(alphabet5, name10);
  return from({
    prefix,
    name: name10,
    encode: encode42,
    decode: (text) => coerce(decode44(text))
  });
}
function decode18(string5, alphabetIdx, bitsPerChar, name10) {
  let end = string5.length;
  while (string5[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value2 = alphabetIdx[string5[i]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name10} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer2 << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode20(data, alphabet5, bitsPerChar) {
  const pad = alphabet5[alphabet5.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet5[mask & buffer2 >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet5[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx(alphabet5) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet5.length; ++i) {
    alphabetIdx[alphabet5[i]] = i;
  }
  return alphabetIdx;
}
function rfc4648({ name: name10, prefix, bitsPerChar, alphabet: alphabet5 }) {
  const alphabetIdx = createAlphabetIdx(alphabet5);
  return from({
    prefix,
    name: name10,
    encode(input) {
      return encode20(input, alphabet5, bitsPerChar);
    },
    decode(input) {
      return decode18(input, alphabetIdx, bitsPerChar, name10);
    }
  });
}

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base32.js
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
init_buffer_polyfill();
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
init_buffer_polyfill();
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/hashes/digest.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/varint.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/vendor/varint.js
init_buffer_polyfill();
var encode_1 = encode21;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode21(num2, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num2 >= INT) {
    out[offset++] = num2 & 255 | MSB;
    num2 /= 128;
  }
  while (num2 & MSBALL) {
    out[offset++] = num2 & 255 | MSB;
    num2 >>>= 7;
  }
  out[offset] = num2 | 0;
  encode21.bytes = offset - oldOffset + 1;
  return out;
}
var decode19 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length3 = function(value2) {
  return value2 < N1 ? 1 : value2 < N2 ? 2 : value2 < N3 ? 3 : value2 < N4 ? 4 : value2 < N5 ? 5 : value2 < N6 ? 6 : value2 < N7 ? 7 : value2 < N8 ? 8 : value2 < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode19,
  encodingLength: length3
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/varint.js
function decode20(data, offset = 0) {
  const code10 = varint_default.decode(data, offset);
  return [code10, varint_default.decode.bytes];
}
function encodeTo(int, target, offset = 0) {
  varint_default.encode(int, target, offset);
  return target;
}
function encodingLength3(int) {
  return varint_default.encodingLength(int);
}

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/hashes/digest.js
function create(code10, digest4) {
  const size = digest4.byteLength;
  const sizeOffset = encodingLength3(code10);
  const digestOffset = sizeOffset + encodingLength3(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code10, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest4, digestOffset);
  return new Digest(code10, size, digest4, bytes);
}
function decode21(multihash) {
  const bytes = coerce(multihash);
  const [code10, sizeOffset] = decode20(bytes);
  const [size, digestOffset] = decode20(bytes.subarray(sizeOffset));
  const digest4 = bytes.subarray(sizeOffset + digestOffset);
  if (digest4.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code10, size, digest4, bytes);
}
function equals2(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals(a.bytes, data.bytes);
  }
}
var Digest = class {
  /**
   * Creates a multihash digest.
   */
  constructor(code10, size, digest4, bytes) {
    __publicField(this, "code");
    __publicField(this, "size");
    __publicField(this, "digest");
    __publicField(this, "bytes");
    this.code = code10;
    this.size = size;
    this.digest = digest4;
    this.bytes = bytes;
  }
};

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/link/interface.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/cid.js
function format(link, base5) {
  const { bytes, version } = link;
  switch (version) {
    case 0:
      return toStringV0(bytes, baseCache(link), base5 ?? base58btc.encoder);
    default:
      return toStringV1(bytes, baseCache(link), base5 ?? base32.encoder);
  }
}
var cache = /* @__PURE__ */ new WeakMap();
function baseCache(cid) {
  const baseCache4 = cache.get(cid);
  if (baseCache4 == null) {
    const baseCache5 = /* @__PURE__ */ new Map();
    cache.set(cid, baseCache5);
    return baseCache5;
  }
  return baseCache4;
}
var _a;
var CID = class _CID {
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version, code10, multihash, bytes) {
    __publicField(this, "code");
    __publicField(this, "version");
    __publicField(this, "multihash");
    __publicField(this, "bytes");
    __publicField(this, "/");
    __publicField(this, _a, "CID");
    this.code = code10;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code10, multihash } = this;
        if (code10 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code10, digest: digest4 } = this.multihash;
        const multihash = create(code10, digest4);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals2(self2.multihash, unknown.multihash);
  }
  toString(base5) {
    return format(this, base5);
  }
  toJSON() {
    return { "/": format(this) };
  }
  link() {
    return this;
  }
  // Legacy
  [(_a = Symbol.toStringTag, /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom"))]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof _CID) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version, code: code10, multihash, bytes } = value2;
      return new _CID(version, code10, multihash, bytes ?? encodeCID(version, code10, multihash.bytes));
    } else if (value2[cidSymbol] === true) {
      const { version, multihash, code: code10 } = value2;
      const digest4 = decode21(multihash);
      return _CID.create(version, code10, digest4);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version, code10, digest4) {
    if (typeof code10 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest4.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version) {
      case 0: {
        if (code10 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new _CID(version, code10, digest4, digest4.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID(version, code10, digest4.bytes);
        return new _CID(version, code10, digest4, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest4) {
    return _CID.create(0, DAG_PB_CODE, digest4);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code10, digest4) {
    return _CID.create(1, code10, digest4);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest4 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest4) : _CID.createV1(specs.codec, digest4);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length6] = decode20(initialBytes.subarray(offset));
      offset += length6;
      return i;
    };
    let version = next();
    let codec = DAG_PB_CODE;
    if (version === 18) {
      version = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${version}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base5) {
    const [prefix, bytes] = parseCIDtoBytes(source, base5);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes(source, base5) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base5 ?? base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base5 ?? base58btc;
      return [base58btc.prefix, decoder.decode(source)];
    }
    case base32.prefix: {
      const decoder = base5 ?? base32;
      return [base32.prefix, decoder.decode(source)];
    }
    case base36.prefix: {
      const decoder = base5 ?? base36;
      return [base36.prefix, decoder.decode(source)];
    }
    default: {
      if (base5 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base5.decode(source)];
    }
  }
}
function toStringV0(bytes, cache4, base5) {
  const { prefix } = base5;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base5.name} encoding`);
  }
  const cid = cache4.get(prefix);
  if (cid == null) {
    const cid2 = base5.encode(bytes).slice(1);
    cache4.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV1(bytes, cache4, base5) {
  const { prefix } = base5;
  const cid = cache4.get(prefix);
  if (cid == null) {
    const cid2 = base5.encode(bytes);
    cache4.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
function encodeCID(version, code10, multihash) {
  const codeOffset = encodingLength3(version);
  const hashOffset = codeOffset + encodingLength3(code10);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version, bytes, 0);
  encodeTo(code10, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol = /* @__PURE__ */ Symbol.for("@ipld/js-cid/CID");

// node_modules/.pnpm/@ipld+dag-pb@4.1.5/node_modules/@ipld/dag-pb/src/pb-decode.js
init_buffer_polyfill();
var textDecoder = new TextDecoder();
function decodeVarint(bytes, offset) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes[offset++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [v, offset];
}
function decodeBytes(bytes, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [bytes.subarray(offset, postOffset), postOffset];
}
function decodeKey(bytes, index) {
  let wire;
  [wire, index] = decodeVarint(bytes, index);
  return [wire & 7, wire >> 3, index];
}
function decodeLink(bytes) {
  const link = {};
  const l = bytes.length;
  let index = 0;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes, index);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      [link.Hash, index] = decodeBytes(bytes, index);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index] = decodeBytes(bytes, index);
      link.Name = textDecoder.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      [link.Tsize, index] = decodeVarint(bytes, index);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode(bytes) {
  const l = bytes.length;
  let index = 0;
  let links = void 0;
  let linksBeforeData = false;
  let data = void 0;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes, index);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      [data, index] = decodeBytes(bytes, index);
      if (links) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links) {
        links = [];
      }
      let byts;
      [byts, index] = decodeBytes(bytes, index);
      links.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links || [];
  return node;
}

// node_modules/.pnpm/@ipld+dag-pb@4.1.5/node_modules/@ipld/dag-pb/src/pb-encode.js
init_buffer_polyfill();
var textEncoder = new TextEncoder();
var maxInt32 = 2 ** 32;
var maxUInt32 = 2 ** 31;
function encodeLink(link, bytes) {
  let i = bytes.length;
  if (typeof link.Tsize === "number") {
    if (link.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i = encodeVarint(bytes, i, link.Tsize) - 1;
    bytes[i] = 24;
  }
  if (typeof link.Name === "string") {
    const nameBytes = textEncoder.encode(link.Name);
    i -= nameBytes.length;
    bytes.set(nameBytes, i);
    i = encodeVarint(bytes, i, nameBytes.length) - 1;
    bytes[i] = 18;
  }
  if (link.Hash) {
    i -= link.Hash.length;
    bytes.set(link.Hash, i);
    i = encodeVarint(bytes, i, link.Hash.length) - 1;
    bytes[i] = 10;
  }
  return bytes.length - i;
}
function encodeNode(node) {
  const size = sizeNode(node);
  const bytes = new Uint8Array(size);
  let i = size;
  if (node.Data) {
    i -= node.Data.length;
    bytes.set(node.Data, i);
    i = encodeVarint(bytes, i, node.Data.length) - 1;
    bytes[i] = 10;
  }
  if (node.Links) {
    for (let index = node.Links.length - 1; index >= 0; index--) {
      const size2 = encodeLink(node.Links[index], bytes.subarray(0, i));
      i -= size2;
      i = encodeVarint(bytes, i, size2) - 1;
      bytes[i] = 18;
    }
  }
  return bytes;
}
function sizeLink(link) {
  let n2 = 0;
  if (link.Hash) {
    const l = link.Hash.length;
    n2 += 1 + l + sov(l);
  }
  if (typeof link.Name === "string") {
    const l = textEncoder.encode(link.Name).length;
    n2 += 1 + l + sov(l);
  }
  if (typeof link.Tsize === "number") {
    n2 += 1 + sov(link.Tsize);
  }
  return n2;
}
function sizeNode(node) {
  let n2 = 0;
  if (node.Data) {
    const l = node.Data.length;
    n2 += 1 + l + sov(l);
  }
  if (node.Links) {
    for (const link of node.Links) {
      const l = sizeLink(link);
      n2 += 1 + l + sov(l);
    }
  }
  return n2;
}
function encodeVarint(bytes, offset, v) {
  offset -= sov(v);
  const base5 = offset;
  while (v >= maxUInt32) {
    bytes[offset++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes[offset++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes[offset] = v;
  return base5;
}
function sov(x) {
  if (x % 2 === 0) {
    x++;
  }
  return Math.floor((len64(x) + 6) / 7);
}
function len64(x) {
  let n2 = 0;
  if (x >= maxInt32) {
    x = Math.floor(x / maxInt32);
    n2 = 32;
  }
  if (x >= 1 << 16) {
    x >>>= 16;
    n2 += 16;
  }
  if (x >= 1 << 8) {
    x >>>= 8;
    n2 += 8;
  }
  return n2 + len8tab[x];
}
var len8tab = [
  0,
  1,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8
];

// node_modules/.pnpm/@ipld+dag-pb@4.1.5/node_modules/@ipld/dag-pb/src/util.js
init_buffer_polyfill();
var pbNodeProperties = ["Data", "Links"];
var pbLinkProperties = ["Hash", "Name", "Tsize"];
var textEncoder2 = new TextEncoder();
function linkComparator(a, b) {
  if (a === b) {
    return 0;
  }
  const abuf = a.Name ? textEncoder2.encode(a.Name) : [];
  const bbuf = b.Name ? textEncoder2.encode(b.Name) : [];
  let x = abuf.length;
  let y = bbuf.length;
  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (abuf[i] !== bbuf[i]) {
      x = abuf[i];
      y = bbuf[i];
      break;
    }
  }
  return x < y ? -1 : y < x ? 1 : 0;
}
function hasOnlyProperties(node, properties) {
  return !Object.keys(node).some((p) => !properties.includes(p));
}
function asLink(link) {
  if (typeof link.asCID === "object") {
    const Hash2 = CID.asCID(link);
    if (!Hash2) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash: Hash2 };
  }
  if (typeof link !== "object" || Array.isArray(link)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link.Hash) {
    let cid = CID.asCID(link.Hash);
    try {
      if (!cid) {
        if (typeof link.Hash === "string") {
          cid = CID.parse(link.Hash);
        } else if (link.Hash instanceof Uint8Array) {
          cid = CID.decode(link.Hash);
        }
      }
    } catch (e) {
      throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link.Name === "string") {
    pbl.Name = link.Name;
  }
  if (typeof link.Tsize === "number") {
    pbl.Tsize = link.Tsize;
  }
  return pbl;
}
function prepare(node) {
  if (node instanceof Uint8Array || typeof node === "string") {
    node = { Data: node };
  }
  if (typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node.Data !== void 0) {
    if (typeof node.Data === "string") {
      pbn.Data = textEncoder2.encode(node.Data);
    } else if (node.Data instanceof Uint8Array) {
      pbn.Data = node.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node.Links !== void 0) {
    if (Array.isArray(node.Links)) {
      pbn.Links = node.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate(node) {
  if (!node || typeof node !== "object" || Array.isArray(node) || node instanceof Uint8Array || node["/"] && node["/"] === node.bytes) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be bytes)");
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be a list)");
  }
  for (let i = 0; i < node.Links.length; i++) {
    const link = node.Links[i];
    if (!link || typeof link !== "object" || Array.isArray(link) || link instanceof Uint8Array || link["/"] && link["/"] === link.bytes) {
      throw new TypeError("Invalid DAG-PB form (bad link)");
    }
    if (!hasOnlyProperties(link, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link)");
    }
    if (link.Hash === void 0) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link.Hash == null || !link.Hash["/"] || link.Hash["/"] !== link.Hash.bytes) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link.Name !== void 0 && typeof link.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link.Tsize !== void 0) {
      if (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0) {
        throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
      }
      if (link.Tsize < 0) {
        throw new TypeError("Invalid DAG-PB form (link Tsize cannot be negative)");
      }
    }
    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function createNode(data, links = []) {
  return prepare({ Data: data, Links: links });
}
function createLink(name10, size, cid) {
  return asLink({ Hash: cid, Name: name10, Tsize: size });
}
function toByteView(buf2) {
  if (buf2 instanceof ArrayBuffer) {
    return new Uint8Array(buf2, 0, buf2.byteLength);
  }
  return buf2;
}

// node_modules/.pnpm/@ipld+dag-pb@4.1.5/node_modules/@ipld/dag-pb/src/index.js
var name = "dag-pb";
var code = 112;
function encode22(node) {
  validate(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map((l) => {
      const link = {};
      if (l.Hash) {
        link.Hash = l.Hash.bytes;
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return encodeNode(pbn);
}
function decode22(bytes) {
  const buf2 = toByteView(bytes);
  const pbn = decodeNode(buf2);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l) => {
      const link = {};
      try {
        link.Hash = CID.decode(l.Hash);
      } catch {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  return node;
}

// node_modules/.pnpm/@ipld+dag-cbor@9.2.5/node_modules/@ipld/dag-cbor/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  code: () => code2,
  decode: () => decode24,
  decodeOptions: () => decodeOptions,
  encode: () => encode24,
  encodeOptions: () => encodeOptions,
  name: () => name2,
  toByteView: () => toByteView2
});
init_buffer_polyfill();

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/cborg.js
init_buffer_polyfill();

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/encode.js
init_buffer_polyfill();

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/is.js
init_buffer_polyfill();
var typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is2(value2) {
  if (value2 === null) {
    return "null";
  }
  if (value2 === void 0) {
    return "undefined";
  }
  if (value2 === true || value2 === false) {
    return "boolean";
  }
  const typeOf2 = typeof value2;
  if (typeofs.includes(typeOf2)) {
    return typeOf2;
  }
  if (typeOf2 === "function") {
    return "Function";
  }
  if (Array.isArray(value2)) {
    return "Array";
  }
  if (isBuffer(value2)) {
    return "Buffer";
  }
  const objectType = getObjectType(value2);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer(value2) {
  return value2 && value2.constructor && value2.constructor.isBuffer && value2.constructor.isBuffer.call(null, value2);
}
function getObjectType(value2) {
  const objectTypeName = Object.prototype.toString.call(value2).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/token.js
init_buffer_polyfill();
var Type = class {
  /**
   * @param {number} major
   * @param {string} name
   * @param {boolean} terminal
   */
  constructor(major, name10, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name10;
    this.terminal = terminal;
  }
  /* c8 ignore next 3 */
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  /**
   * @param {Type} typ
   * @returns {number}
   */
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
var Token = class {
  /**
   * @param {Type} type
   * @param {any} [value]
   * @param {number} [encodedLength]
   */
  constructor(type, value2, encodedLength) {
    this.type = type;
    this.value = value2;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  /* c8 ignore next 3 */
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/bl.js
init_buffer_polyfill();

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/byte-utils.js
init_buffer_polyfill();
var useBuffer = globalThis.process && // @ts-ignore
!globalThis.process.browser && // @ts-ignore
globalThis.Buffer && // @ts-ignore
typeof globalThis.Buffer.isBuffer === "function";
var textDecoder2 = new TextDecoder();
var textEncoder3 = new TextEncoder();
function isBuffer2(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
var toString2 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes, start, end) => {
    return end - start > 64 ? (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(bytes.subarray(start, end)).toString("utf8")
    ) : utf8Slice(bytes, start, end);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes, start, end) => {
    return end - start > 64 ? textDecoder2.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);
  }
);
var fromString2 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string} string
   */
  (string5) => {
    return string5.length > 64 ? (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(string5)
    ) : utf8ToBytes2(string5);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string} string
   */
  (string5) => {
    return string5.length > 64 ? textEncoder3.encode(string5) : utf8ToBytes2(string5);
  }
);
var fromArray = (arr) => {
  return Uint8Array.from(arr);
};
var slice = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes, start, end) => {
    if (isBuffer2(bytes)) {
      return new Uint8Array(bytes.subarray(start, end));
    }
    return bytes.slice(start, end);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes, start, end) => {
    return bytes.slice(start, end);
  }
);
var concat3 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array[]} chunks
   * @param {number} length
   * @returns {Uint8Array}
   */
  (chunks, length6) => {
    chunks = chunks.map((c) => c instanceof Uint8Array ? c : (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(c)
    ));
    return asU8A(globalThis.Buffer.concat(chunks, length6));
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array[]} chunks
   * @param {number} length
   * @returns {Uint8Array}
   */
  (chunks, length6) => {
    const out = new Uint8Array(length6);
    let off = 0;
    for (let b of chunks) {
      if (off + b.length > out.length) {
        b = b.subarray(0, out.length - off);
      }
      out.set(b, off);
      off += b.length;
    }
    return out;
  }
);
var alloc = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {number} size
   * @returns {Uint8Array}
   */
  (size) => {
    return globalThis.Buffer.allocUnsafe(size);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {number} size
   * @returns {Uint8Array}
   */
  (size) => {
    return new Uint8Array(size);
  }
);
function compare3(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes2(str) {
  const out = [];
  let p = 0;
  for (let i = 0; i < str.length; i++) {
    let c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return out;
}
function utf8Slice(buf2, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/bl.js
var defaultChunkSize = 256;
var Bl = class {
  /**
   * @param {number} [chunkSize]
   */
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  /**
   * @param {Uint8Array|number[]} bytes
   */
  push(bytes) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes.length < 64 && bytes.length < this.chunkSize) {
        topChunk = alloc(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes, 0);
      } else {
        this.chunks.push(bytes);
        this.maxCursor += bytes.length;
      }
    }
    this.cursor += bytes.length;
  }
  /**
   * @param {boolean} [reset]
   * @returns {Uint8Array}
   */
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat3(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/common.js
init_buffer_polyfill();
var decodeErrPrefix = "CBOR decode error:";
var encodeErrPrefix = "CBOR encode error:";
var uintMinorPrefixBytes = [];
uintMinorPrefixBytes[23] = 1;
uintMinorPrefixBytes[24] = 2;
uintMinorPrefixBytes[25] = 3;
uintMinorPrefixBytes[26] = 5;
uintMinorPrefixBytes[27] = 9;
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/jump.js
init_buffer_polyfill();

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/0uint.js
init_buffer_polyfill();
var uintBoundaries = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value2 = data[offset];
  if (options.strict === true && value2 < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value2;
}
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value2 = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value2 < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value2;
}
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value2 = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value2 < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value2;
}
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value2 = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value2 < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value2 <= Number.MAX_SAFE_INTEGER) {
    return Number(value2);
  }
  if (options.allowBigInt === true) {
    return value2;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([major | 24, nuint]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([major | 25, nuint >>> 8, nuint & 255]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi & 255;
      hi = hi >> 8;
      set[3] = hi & 255;
      hi = hi >> 8;
      set[2] = hi & 255;
      hi = hi >> 8;
      set[1] = hi & 255;
      buf2.push(set);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : (
    /* c8 ignore next */
    0
  );
};

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/1negint.js
init_buffer_polyfill();
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
var neg1b = BigInt(-1);
var pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value2 = -1 - int;
    if (value2 >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value2, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf2, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned);
}
encodeNegint.encodedSize = function encodedSize3(token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : (
    /* c8 ignore next */
    0
  );
};

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/2bytes.js
init_buffer_polyfill();
function toToken(data, pos, prefix, length6) {
  assertEnoughData(data, pos, prefix + length6);
  const buf2 = slice(data, pos + prefix, pos + prefix + length6);
  return new Token(Type.bytes, buf2, prefix + length6);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString2(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf2, token) {
  const bytes = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes.length);
  buf2.push(bytes);
}
encodeBytes.encodedSize = function encodedSize4(token) {
  const bytes = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes.length) + bytes.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare3(b1, b2);
}

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/3string.js
init_buffer_polyfill();
function toToken2(data, pos, prefix, length6, options) {
  const totLength = prefix + length6;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString2(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options);
}
var encodeString = encodeBytes;

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/4array.js
init_buffer_polyfill();
function toToken3(_data, _pos, prefix, length6) {
  return new Token(Type.array, length6, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/5map.js
init_buffer_polyfill();
function toToken4(_data, _pos, prefix, length6) {
  return new Token(Type.map, length6, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/6tag.js
init_buffer_polyfill();
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/7float.js
init_buffer_polyfill();
var MINOR_FALSE = 20;
var MINOR_TRUE = 21;
var MINOR_NULL = 22;
var MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value2, bytes, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value2)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value2 === Infinity || value2 === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value2, bytes);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf2, token, options) {
  const float = token.value;
  if (float === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token, options) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
};
var buffer = new ArrayBuffer(9);
var dataView = new DataView(buffer, 1);
var ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | /* sign bit */
        1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
var jump = [];
for (let i = 0; i <= 23; i++) {
  jump[i] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i = 32; i <= 55; i++) {
  jump[i] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i = 64; i <= 87; i++) {
  jump[i] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i = 96; i <= 119; i++) {
  jump[i] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i = 128; i <= 151; i++) {
  jump[i] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i = 160; i <= 183; i++) {
  jump[i] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i = 192; i <= 215; i++) {
  jump[i] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i = 224; i <= 243; i++) {
  jump[i] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
var quick = [];
for (let i = 0; i < 24; i++) {
  quick[i] = new Token(Type.uint, i, 1);
}
for (let i = -1; i >= -24; i--) {
  quick[31 - i] = new Token(Type.negint, i, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/encode.js
var defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
var rfc8949EncodeOptions = Object.freeze({
  float64: true,
  mapSorter: rfc8949MapSorter,
  quickEncodeToken
});
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
var cborEncoders = makeCborEncoders();
var buf = new Bl();
var Ref = class _Ref {
  /**
   * @param {object|any[]} obj
   * @param {Reference|undefined} parent
   */
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  /**
   * @param {object|any[]} obj
   * @returns {boolean}
   */
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  /**
   * @param {Reference|undefined} stack
   * @param {object|any[]} obj
   * @returns {Reference}
   */
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new _Ref(obj, stack);
  }
};
var simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
var typeEncoders = {
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  /**
   * @param {any} _obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  /**
   * @param {any} _obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} options
   * @param {Reference} [refStack]
   * @returns {TokenOrNestedTokens}
   */
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [simpleTokens.emptyArray, new Token(Type.break)];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const e of obj) {
      entries[i++] = objectToTokens(e, options, refStack);
    }
    if (options.addBreakTokens) {
      return [new Token(Type.array, obj.length), entries, new Token(Type.break)];
    }
    return [new Token(Type.array, obj.length), entries];
  },
  /**
   * @param {any} obj
   * @param {string} typ
   * @param {EncodeOptions} options
   * @param {Reference} [refStack]
   * @returns {TokenOrNestedTokens}
   */
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length6 = isMap ? obj.size : keys.length;
    if (!length6) {
      if (options.addBreakTokens === true) {
        return [simpleTokens.emptyMap, new Token(Type.break)];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const key of keys) {
      entries[i++] = [
        objectToTokens(key, options, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [new Token(Type.map, length6), entries, new Token(Type.break)];
    }
    return [new Token(Type.map, length6), entries];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is2(obj);
  const customTypeEncoder = options && options.typeEncoders && /** @type {OptionalTypeEncoder} */
  options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function rfc8949MapSorter(e1, e2) {
  if (e1[0] instanceof Token && e2[0] instanceof Token) {
    const t1 = (
      /** @type {TokenEx} */
      e1[0]
    );
    const t2 = (
      /** @type {TokenEx} */
      e2[0]
    );
    if (!t1._keyBytes) {
      t1._keyBytes = encodeRfc8949(t1.value);
    }
    if (!t2._keyBytes) {
      t2._keyBytes = encodeRfc8949(t2.value);
    }
    return compare3(t1._keyBytes, t2._keyBytes);
  }
  throw new Error("rfc8949MapSorter: complex key types are not supported yet");
}
function encodeRfc8949(data) {
  return encodeCustom(data, cborEncoders, rfc8949EncodeOptions);
}
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder = encoders[tokens.type.major];
    if (encoder.encodedSize) {
      const size = encoder.encodedSize(tokens, options);
      const buf2 = new Bl(size);
      encoder(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode23(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/decode.js
init_buffer_polyfill();
var defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser = class {
  /**
   * @param {Uint8Array} data
   * @param {DecodeOptions} options
   */
  constructor(data, options = {}) {
    this._pos = 0;
    this.data = data;
    this.options = options;
  }
  pos() {
    return this._pos;
  }
  done() {
    return this._pos >= this.data.length;
  }
  next() {
    const byt = this.data[this._pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this._pos, minor, this.options);
    }
    this._pos += token.encodedLength;
    return token;
  }
};
var DONE = /* @__PURE__ */ Symbol.for("DONE");
var BREAK = /* @__PURE__ */ Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value2 = tokensToObject(tokeniser, options);
    if (value2 === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value2 === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value2;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value2 = tokensToObject(tokeniser, options);
    if (value2 === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value2);
    } else {
      obj[key] = value2;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decodeFirst(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  return [decoded, data.subarray(tokeniser.pos())];
}
function decode23(data, options) {
  const [decoded, remainder] = decodeFirst(data, options);
  if (remainder.length > 0) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}

// node_modules/.pnpm/@ipld+dag-cbor@9.2.5/node_modules/@ipld/dag-cbor/src/index.js
var CID_CBOR_TAG = 42;
function toByteView2(buf2) {
  if (buf2 instanceof ArrayBuffer) {
    return new Uint8Array(buf2, 0, buf2.byteLength);
  }
  return buf2;
}
function cidEncoder(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes = new Uint8Array(cid.bytes.byteLength + 1);
  bytes.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num2) {
  if (Number.isNaN(num2)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num2 === Infinity || num2 === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
function mapEncoder(map2) {
  for (const key of map2.keys()) {
    if (typeof key !== "string" || key.length === 0) {
      throw new Error("Non-string Map keys are not supported by the IPLD Data Model and cannot be encoded");
    }
  }
  return null;
}
var _encodeOptions = {
  float64: true,
  typeEncoders: {
    Map: mapEncoder,
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
var encodeOptions = {
  ..._encodeOptions,
  typeEncoders: {
    ..._encodeOptions.typeEncoders
  }
};
function cidDecoder(bytes) {
  if (bytes[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes.subarray(1));
}
var _decodeOptions = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  // this will lead to BigInt for ints outside of
  // safe-integer range, which may surprise users
  strict: true,
  useMaps: false,
  rejectDuplicateMapKeys: true,
  /** @type {import('cborg').TagDecoder[]} */
  tags: []
};
_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
var decodeOptions = {
  ..._decodeOptions,
  tags: _decodeOptions.tags.slice()
};
var name2 = "dag-cbor";
var code2 = 113;
var encode24 = (node) => encode23(node, _encodeOptions);
var decode24 = (data) => decode23(toByteView2(data), _decodeOptions);

// node_modules/.pnpm/@ipld+dag-json@10.2.5/node_modules/@ipld/dag-json/src/index.js
var src_exports3 = {};
__export(src_exports3, {
  code: () => code3,
  decode: () => decode26,
  encode: () => encode26,
  format: () => format2,
  name: () => name3,
  parse: () => parse3,
  stringify: () => format2
});
init_buffer_polyfill();

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/json/json.js
init_buffer_polyfill();

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/json/encode.js
init_buffer_polyfill();
var JSONEncoder = class extends Array {
  constructor() {
    super();
    this.inRecursive = [];
  }
  /**
   * @param {Bl} buf
   */
  prefix(buf2) {
    const recurs = this.inRecursive[this.inRecursive.length - 1];
    if (recurs) {
      if (recurs.type === Type.array) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          buf2.push([44]);
        }
      }
      if (recurs.type === Type.map) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          if (recurs.elements % 2 === 1) {
            buf2.push([44]);
          } else {
            buf2.push([58]);
          }
        }
      }
    }
  }
  /**
   * @param {Bl} buf
   * @param {Token} token
   */
  [Type.uint.major](buf2, token) {
    this.prefix(buf2);
    const is3 = String(token.value);
    const isa = [];
    for (let i = 0; i < is3.length; i++) {
      isa[i] = is3.charCodeAt(i);
    }
    buf2.push(isa);
  }
  /**
   * @param {Bl} buf
   * @param {Token} token
   */
  [Type.negint.major](buf2, token) {
    this[Type.uint.major](buf2, token);
  }
  /**
   * @param {Bl} _buf
   * @param {Token} _token
   */
  [Type.bytes.major](_buf, _token) {
    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);
  }
  /**
   * @param {Bl} buf
   * @param {Token} token
   */
  [Type.string.major](buf2, token) {
    this.prefix(buf2);
    const byts = fromString2(JSON.stringify(token.value));
    buf2.push(byts.length > 32 ? asU8A(byts) : byts);
  }
  /**
   * @param {Bl} buf
   * @param {Token} _token
   */
  [Type.array.major](buf2, _token) {
    this.prefix(buf2);
    this.inRecursive.push({ type: Type.array, elements: 0 });
    buf2.push([91]);
  }
  /**
   * @param {Bl} buf
   * @param {Token} _token
   */
  [Type.map.major](buf2, _token) {
    this.prefix(buf2);
    this.inRecursive.push({ type: Type.map, elements: 0 });
    buf2.push([123]);
  }
  /**
   * @param {Bl} _buf
   * @param {Token} _token
   */
  [Type.tag.major](_buf, _token) {
  }
  /**
   * @param {Bl} buf
   * @param {Token} token
   */
  [Type.float.major](buf2, token) {
    if (token.type.name === "break") {
      const recurs = this.inRecursive.pop();
      if (recurs) {
        if (recurs.type === Type.array) {
          buf2.push([93]);
        } else if (recurs.type === Type.map) {
          buf2.push([125]);
        } else {
          throw new Error("Unexpected recursive type; this should not happen!");
        }
        return;
      }
      throw new Error("Unexpected break; this should not happen!");
    }
    if (token.value === void 0) {
      throw new Error(`${encodeErrPrefix} unsupported type: undefined`);
    }
    this.prefix(buf2);
    if (token.type.name === "true") {
      buf2.push([116, 114, 117, 101]);
      return;
    } else if (token.type.name === "false") {
      buf2.push([102, 97, 108, 115, 101]);
      return;
    } else if (token.type.name === "null") {
      buf2.push([110, 117, 108, 108]);
      return;
    }
    const is3 = String(token.value);
    const isa = [];
    let dp = false;
    for (let i = 0; i < is3.length; i++) {
      isa[i] = is3.charCodeAt(i);
      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {
        dp = true;
      }
    }
    if (!dp) {
      isa.push(46);
      isa.push(48);
    }
    buf2.push(isa);
  }
};
function mapSorter2(e1, e2) {
  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {
    throw new Error(`${encodeErrPrefix} complex map keys are not supported`);
  }
  const keyToken1 = e1[0];
  const keyToken2 = e2[0];
  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {
    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);
  }
  if (keyToken1 < keyToken2) {
    return -1;
  }
  if (keyToken1 > keyToken2) {
    return 1;
  }
  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`);
}
var defaultEncodeOptions2 = { addBreakTokens: true, mapSorter: mapSorter2 };
function encode25(data, options) {
  options = Object.assign({}, defaultEncodeOptions2, options);
  return encodeCustom(data, new JSONEncoder(), options);
}

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/json/decode.js
init_buffer_polyfill();
var Tokenizer = class {
  /**
   * @param {Uint8Array} data
   * @param {DecodeOptions} options
   */
  constructor(data, options = {}) {
    this._pos = 0;
    this.data = data;
    this.options = options;
    this.modeStack = ["value"];
    this.lastToken = "";
  }
  pos() {
    return this._pos;
  }
  /**
   * @returns {boolean}
   */
  done() {
    return this._pos >= this.data.length;
  }
  /**
   * @returns {number}
   */
  ch() {
    return this.data[this._pos];
  }
  /**
   * @returns {string}
   */
  currentMode() {
    return this.modeStack[this.modeStack.length - 1];
  }
  skipWhitespace() {
    let c = this.ch();
    while (c === 32 || c === 9 || c === 13 || c === 10) {
      c = this.data[++this._pos];
    }
  }
  /**
   * @param {number[]} str
   */
  expect(str) {
    if (this.data.length - this._pos < str.length) {
      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this._pos}`);
    }
    for (let i = 0; i < str.length; i++) {
      if (this.data[this._pos++] !== str[i]) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...str)}'`);
      }
    }
  }
  parseNumber() {
    const startPos = this._pos;
    let negative = false;
    let float = false;
    const swallow = (chars) => {
      while (!this.done()) {
        const ch = this.ch();
        if (chars.includes(ch)) {
          this._pos++;
        } else {
          break;
        }
      }
    };
    if (this.ch() === 45) {
      negative = true;
      this._pos++;
    }
    if (this.ch() === 48) {
      this._pos++;
      if (this.ch() === 46) {
        this._pos++;
        float = true;
      } else {
        return new Token(Type.uint, 0, this._pos - startPos);
      }
    }
    swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
    if (negative && this._pos === startPos + 1) {
      throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`);
    }
    if (!this.done() && this.ch() === 46) {
      if (float) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`);
      }
      float = true;
      this._pos++;
      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
    }
    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
      float = true;
      this._pos++;
      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
        this._pos++;
      }
      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
    }
    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this._pos));
    const num2 = parseFloat(numStr);
    if (float) {
      return new Token(Type.float, num2, this._pos - startPos);
    }
    if (this.options.allowBigInt !== true || Number.isSafeInteger(num2)) {
      return new Token(num2 >= 0 ? Type.uint : Type.negint, num2, this._pos - startPos);
    }
    return new Token(num2 >= 0 ? Type.uint : Type.negint, BigInt(numStr), this._pos - startPos);
  }
  /**
   * @returns {Token}
   */
  parseString() {
    if (this.ch() !== 34) {
      throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}; this shouldn't happen`);
    }
    this._pos++;
    for (let i = this._pos, l = 0; i < this.data.length && l < 65536; i++, l++) {
      const ch = this.data[i];
      if (ch === 92 || ch < 32 || ch >= 128) {
        break;
      }
      if (ch === 34) {
        const str = String.fromCharCode.apply(null, this.data.subarray(this._pos, i));
        this._pos = i + 1;
        return new Token(Type.string, str, l);
      }
    }
    const startPos = this._pos;
    const chars = [];
    const readu4 = () => {
      if (this._pos + 4 >= this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this._pos}`);
      }
      let u4 = 0;
      for (let i = 0; i < 4; i++) {
        let ch = this.ch();
        if (ch >= 48 && ch <= 57) {
          ch -= 48;
        } else if (ch >= 97 && ch <= 102) {
          ch = ch - 97 + 10;
        } else if (ch >= 65 && ch <= 70) {
          ch = ch - 65 + 10;
        } else {
          throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this._pos}`);
        }
        u4 = u4 * 16 + ch;
        this._pos++;
      }
      return u4;
    };
    const readUtf8Char = () => {
      const firstByte = this.ch();
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (this._pos + bytesPerSequence > this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this._pos}`);
      }
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        /* c8 ignore next 6 */
        // this case is dealt with by the caller function
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = this.data[this._pos + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = this.data[this._pos + 1];
          thirdByte = this.data[this._pos + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = this.data[this._pos + 1];
          thirdByte = this.data[this._pos + 2];
          fourthByte = this.data[this._pos + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        chars.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      chars.push(codePoint);
      this._pos += bytesPerSequence;
    };
    while (!this.done()) {
      const ch = this.ch();
      let ch1;
      switch (ch) {
        case 92:
          this._pos++;
          if (this.done()) {
            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this._pos}`);
          }
          ch1 = this.ch();
          this._pos++;
          switch (ch1) {
            case 34:
            // '"'
            case 39:
            // '\''
            case 92:
            // '\'
            case 47:
              chars.push(ch1);
              break;
            case 98:
              chars.push(8);
              break;
            case 116:
              chars.push(9);
              break;
            case 110:
              chars.push(10);
              break;
            case 102:
              chars.push(12);
              break;
            case 114:
              chars.push(13);
              break;
            case 117:
              chars.push(readu4());
              break;
            default:
              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this._pos}`);
          }
          break;
        case 34:
          this._pos++;
          return new Token(Type.string, decodeCodePointsArray(chars), this._pos - startPos);
        default:
          if (ch < 32) {
            throw new Error(`${decodeErrPrefix} invalid control character at position ${this._pos}`);
          } else if (ch < 128) {
            chars.push(ch);
            this._pos++;
          } else {
            readUtf8Char();
          }
      }
    }
    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this._pos}`);
  }
  /**
   * @returns {Token}
   */
  parseValue() {
    switch (this.ch()) {
      case 123:
        this.modeStack.push("obj-start");
        this._pos++;
        return new Token(Type.map, Infinity, 1);
      case 91:
        this.modeStack.push("array-start");
        this._pos++;
        return new Token(Type.array, Infinity, 1);
      case 34: {
        return this.parseString();
      }
      case 110:
        this.expect([110, 117, 108, 108]);
        return new Token(Type.null, null, 4);
      case 102:
        this.expect([102, 97, 108, 115, 101]);
        return new Token(Type.false, false, 5);
      case 116:
        this.expect([116, 114, 117, 101]);
        return new Token(Type.true, true, 4);
      case 45:
      // '-'
      case 48:
      // '0'
      case 49:
      // '1'
      case 50:
      // '2'
      case 51:
      // '3'
      case 52:
      // '4'
      case 53:
      // '5'
      case 54:
      // '6'
      case 55:
      // '7'
      case 56:
      // '8'
      case 57:
        return this.parseNumber();
      default:
        throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}`);
    }
  }
  /**
   * @returns {Token}
   */
  next() {
    this.skipWhitespace();
    switch (this.currentMode()) {
      case "value":
        this.modeStack.pop();
        return this.parseValue();
      case "array-value": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this._pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this._pos++;
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "array-start": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this._pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      // @ts-ignore
      case "obj-key":
        if (this.ch() === 125) {
          this.modeStack.pop();
          this._pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this._pos++;
        this.skipWhitespace();
      case "obj-start": {
        this.modeStack.pop();
        if (this.ch() === 125) {
          this._pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        const token = this.parseString();
        this.skipWhitespace();
        if (this.ch() !== 58) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
        }
        this._pos++;
        this.modeStack.push("obj-value");
        return token;
      }
      case "obj-value": {
        this.modeStack.pop();
        this.modeStack.push("obj-key");
        this.skipWhitespace();
        return this.parseValue();
      }
      /* c8 ignore next 2 */
      default:
        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this._pos}; this shouldn't happen`);
    }
  }
};
function decode25(data, options) {
  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options);
  return decode23(data, options);
}

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/index.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/hashes/hasher.js
init_buffer_polyfill();
var DEFAULT_MIN_DIGEST_LENGTH = 20;
function from2({ name: name10, code: code10, encode: encode42, minDigestLength, maxDigestLength }) {
  return new Hasher(name10, code10, encode42, minDigestLength, maxDigestLength);
}
var Hasher = class {
  constructor(name10, code10, encode42, minDigestLength, maxDigestLength) {
    __publicField(this, "name");
    __publicField(this, "code");
    __publicField(this, "encode");
    __publicField(this, "minDigestLength");
    __publicField(this, "maxDigestLength");
    this.name = name10;
    this.code = code10;
    this.encode = encode42;
    this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH;
    this.maxDigestLength = maxDigestLength;
  }
  digest(input, options) {
    if (options?.truncate != null) {
      if (options.truncate < this.minDigestLength) {
        throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);
      }
      if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {
        throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`);
      }
    }
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      if (result instanceof Uint8Array) {
        return createDigest(result, this.code, options?.truncate);
      }
      return result.then((digest4) => createDigest(digest4, this.code, options?.truncate));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
function createDigest(digest4, code10, truncate) {
  if (truncate != null && truncate !== digest4.byteLength) {
    if (truncate > digest4.byteLength) {
      throw new Error(`Invalid truncate option, must be less than or equal to ${digest4.byteLength}`);
    }
    digest4 = digest4.subarray(0, truncate);
  }
  return create(code10, digest4);
}

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/interface.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/interface.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/hashes/interface.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/codecs/interface.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/block/interface.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
init_buffer_polyfill();
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/.pnpm/@ipld+dag-json@10.2.5/node_modules/@ipld/dag-json/src/index.js
function toByteView3(buf2) {
  if (buf2 instanceof ArrayBuffer) {
    return new Uint8Array(buf2, 0, buf2.byteLength);
  }
  return buf2;
}
function cidEncoder2(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const cidString = cid.toString();
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    // key
    new Token(Type.string, cidString, cidString.length),
    // value
    new Token(Type.break, void 0, 1)
  ];
}
function bytesEncoder(bytes) {
  const bytesString = base64.encode(bytes).slice(1);
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    // key
    new Token(Type.map, Infinity, 1),
    // value
    new Token(Type.string, "bytes", 5),
    // inner key
    new Token(Type.string, bytesString, bytesString.length),
    // inner value
    new Token(Type.break, void 0, 1),
    new Token(Type.break, void 0, 1)
  ];
}
function taBytesEncoder(obj) {
  return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
}
function abBytesEncoder(ab) {
  return bytesEncoder(new Uint8Array(ab));
}
function undefinedEncoder2() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder2(num2) {
  if (Number.isNaN(num2)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num2 === Infinity || num2 === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions2 = {
  typeEncoders: {
    Object: cidEncoder2,
    Buffer: bytesEncoder,
    Uint8Array: bytesEncoder,
    Int8Array: taBytesEncoder,
    Uint16Array: taBytesEncoder,
    Int16Array: taBytesEncoder,
    Uint32Array: taBytesEncoder,
    Int32Array: taBytesEncoder,
    Float32Array: taBytesEncoder,
    Float64Array: taBytesEncoder,
    Uint8ClampedArray: taBytesEncoder,
    BigInt64Array: taBytesEncoder,
    BigUint64Array: taBytesEncoder,
    DataView: taBytesEncoder,
    ArrayBuffer: abBytesEncoder,
    undefined: undefinedEncoder2,
    number: numberEncoder2
  }
};
var DagJsonTokenizer = class extends Tokenizer {
  /**
   * @param {Uint8Array} data
   * @param {object} [options]
   */
  constructor(data, options) {
    super(data, options);
    this.tokenBuffer = [];
  }
  /**
   * @returns {boolean}
   */
  done() {
    return this.tokenBuffer.length === 0 && super.done();
  }
  /**
   * @returns {Token}
   */
  _next() {
    if (this.tokenBuffer.length > 0) {
      return this.tokenBuffer.pop();
    }
    return super.next();
  }
  /**
   * Implements rules outlined in https://github.com/ipld/specs/pull/356
   *
   * @returns {Token}
   */
  next() {
    const token = this._next();
    if (token.type === Type.map) {
      const keyToken = this._next();
      if (keyToken.type === Type.string && keyToken.value === "/") {
        const valueToken = this._next();
        if (valueToken.type === Type.string) {
          const breakToken = this._next();
          if (breakToken.type !== Type.break) {
            throw new Error("Invalid encoded CID form");
          }
          this.tokenBuffer.push(valueToken);
          return new Token(Type.tag, 42, 0);
        }
        if (valueToken.type === Type.map) {
          const innerKeyToken = this._next();
          if (innerKeyToken.type === Type.string && innerKeyToken.value === "bytes") {
            const innerValueToken = this._next();
            if (innerValueToken.type === Type.string) {
              for (let i = 0; i < 2; i++) {
                const breakToken = this._next();
                if (breakToken.type !== Type.break) {
                  throw new Error("Invalid encoded Bytes form");
                }
              }
              const bytes = base64.decode(`m${innerValueToken.value}`);
              return new Token(Type.bytes, bytes, innerValueToken.value.length);
            }
            this.tokenBuffer.push(innerValueToken);
          }
          this.tokenBuffer.push(innerKeyToken);
        }
        this.tokenBuffer.push(valueToken);
      }
      this.tokenBuffer.push(keyToken);
    }
    return token;
  }
};
var decodeOptions2 = {
  allowIndefinite: false,
  allowUndefined: false,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  // this will lead to BigInt for ints outside of
  // safe-integer range, which may surprise users
  strict: true,
  useMaps: false,
  rejectDuplicateMapKeys: true,
  /** @type {import('cborg').TagDecoder[]} */
  tags: []
};
decodeOptions2.tags[42] = CID.parse;
var name3 = "dag-json";
var code3 = 297;
var encode26 = (node) => encode25(node, encodeOptions2);
var decode26 = (data) => {
  const buf2 = toByteView3(data);
  const options = Object.assign(decodeOptions2, { tokenizer: new DagJsonTokenizer(buf2, decodeOptions2) });
  return decode25(buf2, options);
};
var format2 = (node) => utf8Decoder.decode(encode26(node));
var utf8Decoder = new TextDecoder();
var parse3 = (data) => decode26(utf8Encoder.encode(data));
var utf8Encoder = new TextEncoder();

// node_modules/.pnpm/dag-jose@4.0.0/node_modules/dag-jose/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  code: () => code4,
  decode: () => decode33,
  encode: () => encode31,
  name: () => name4,
  toGeneral: () => toGeneral
});
init_buffer_polyfill();

// node_modules/.pnpm/dag-jose@4.0.0/node_modules/dag-jose/lib/signing.js
init_buffer_polyfill();

// node_modules/.pnpm/dag-jose@4.0.0/node_modules/dag-jose/lib/utils.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base64.js
var base64_exports2 = {};
__export(base64_exports2, {
  base64: () => base642,
  base64pad: () => base64pad2,
  base64url: () => base64url2,
  base64urlpad: () => base64urlpad2
});
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/vendor/base-x.js
init_buffer_polyfill();
function base3(ALPHABET2, name10) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET2.length; i++) {
    var x = ALPHABET2.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode42(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length6 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length6) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length6 = i2;
      pbegin++;
    }
    var it2 = size - length6;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length6 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length6) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length6 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length6;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode44(string5) {
    var buffer2 = decodeUnsafe(string5);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name10} character`);
  }
  return {
    encode: encode42,
    decodeUnsafe,
    decode: decode44
  };
}
var src2 = base3;
var _brrp__multiformats_scope_baseX2 = src2;
var base_x_default2 = _brrp__multiformats_scope_baseX2;

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bytes.js
init_buffer_polyfill();
var empty2 = new Uint8Array(0);
var equals3 = (aa, bb) => {
  if (aa === bb) return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce2 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") return o;
  if (o instanceof ArrayBuffer) return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString3 = (str) => new TextEncoder().encode(str);
var toString3 = (b) => new TextDecoder().decode(b);

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/interface.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base.js
var Encoder2 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name10, prefix, baseEncode) {
    this.name = name10;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder2 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name10, prefix, baseDecode) {
    this.name = name10;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or2(this, decoder);
  }
};
var ComposedDecoder2 = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders3) {
    this.decoders = decoders3;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or2(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or2 = (left, right) => new ComposedDecoder2(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec2 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name10, prefix, baseEncode, baseDecode) {
    this.name = name10;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder2(name10, prefix, baseEncode);
    this.decoder = new Decoder2(name10, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from3 = ({ name: name10, prefix, encode: encode42, decode: decode44 }) => new Codec2(name10, prefix, encode42, decode44);
var baseX2 = ({ prefix, name: name10, alphabet: alphabet5 }) => {
  const { encode: encode42, decode: decode44 } = base_x_default2(alphabet5, name10);
  return from3({
    prefix,
    name: name10,
    encode: encode42,
    /**
     * @param {string} text
     */
    decode: (text) => coerce2(decode44(text))
  });
};
var decode27 = (string5, alphabet5, bitsPerChar, name10) => {
  const codes2 = {};
  for (let i = 0; i < alphabet5.length; ++i) {
    codes2[alphabet5[i]] = i;
  }
  let end = string5.length;
  while (string5[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value2 = codes2[string5[i]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name10} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode27 = (data, alphabet5, bitsPerChar) => {
  const pad = alphabet5[alphabet5.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet5[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet5[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46482 = ({ name: name10, prefix, bitsPerChar, alphabet: alphabet5 }) => {
  return from3({
    prefix,
    name: name10,
    encode(input) {
      return encode27(input, alphabet5, bitsPerChar);
    },
    decode(input) {
      return decode27(input, alphabet5, bitsPerChar, name10);
    }
  });
};

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base64.js
var base642 = rfc46482({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad2 = rfc46482({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url2 = rfc46482({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad2 = rfc46482({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/.pnpm/dag-jose@4.0.0/node_modules/dag-jose/lib/utils.js
function toBase64url(b) {
  return base64url2.encode(b).slice(1);
}
function fromBase64url(s) {
  return base64url2.decode(`u${s}`);
}

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/cid.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/varint.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/vendor/varint.js
init_buffer_polyfill();
var encode_12 = encode28;
var MSB2 = 128;
var REST2 = 127;
var MSBALL2 = ~REST2;
var INT2 = Math.pow(2, 31);
function encode28(num2, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num2 >= INT2) {
    out[offset++] = num2 & 255 | MSB2;
    num2 /= 128;
  }
  while (num2 & MSBALL2) {
    out[offset++] = num2 & 255 | MSB2;
    num2 >>>= 7;
  }
  out[offset] = num2 | 0;
  encode28.bytes = offset - oldOffset + 1;
  return out;
}
var decode28 = read2;
var MSB$12 = 128;
var REST$12 = 127;
function read2(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$12);
  read2.bytes = counter - offset;
  return res;
}
var N12 = Math.pow(2, 7);
var N22 = Math.pow(2, 14);
var N32 = Math.pow(2, 21);
var N42 = Math.pow(2, 28);
var N52 = Math.pow(2, 35);
var N62 = Math.pow(2, 42);
var N72 = Math.pow(2, 49);
var N82 = Math.pow(2, 56);
var N92 = Math.pow(2, 63);
var length4 = function(value2) {
  return value2 < N12 ? 1 : value2 < N22 ? 2 : value2 < N32 ? 3 : value2 < N42 ? 4 : value2 < N52 ? 5 : value2 < N62 ? 6 : value2 < N72 ? 7 : value2 < N82 ? 8 : value2 < N92 ? 9 : 10;
};
var varint2 = {
  encode: encode_12,
  decode: decode28,
  encodingLength: length4
};
var _brrp_varint2 = varint2;
var varint_default2 = _brrp_varint2;

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/varint.js
var decode29 = (data, offset = 0) => {
  const code10 = varint_default2.decode(data, offset);
  return [code10, varint_default2.decode.bytes];
};
var encodeTo2 = (int, target, offset = 0) => {
  varint_default2.encode(int, target, offset);
  return target;
};
var encodingLength4 = (int) => {
  return varint_default2.encodingLength(int);
};

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/digest.js
init_buffer_polyfill();
var create2 = (code10, digest4) => {
  const size = digest4.byteLength;
  const sizeOffset = encodingLength4(code10);
  const digestOffset = sizeOffset + encodingLength4(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo2(code10, bytes, 0);
  encodeTo2(size, bytes, sizeOffset);
  bytes.set(digest4, digestOffset);
  return new Digest2(code10, size, digest4, bytes);
};
var decode30 = (multihash) => {
  const bytes = coerce2(multihash);
  const [code10, sizeOffset] = decode29(bytes);
  const [size, digestOffset] = decode29(bytes.subarray(sizeOffset));
  const digest4 = bytes.subarray(sizeOffset + digestOffset);
  if (digest4.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest2(code10, size, digest4, bytes);
};
var equals4 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals3(a.bytes, data.bytes);
  }
};
var Digest2 = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code10, size, digest4, bytes) {
    this.code = code10;
    this.size = size;
    this.digest = digest4;
    this.bytes = bytes;
  }
};

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base58.js
var base58_exports2 = {};
__export(base58_exports2, {
  base58btc: () => base58btc2,
  base58flickr: () => base58flickr2
});
init_buffer_polyfill();
var base58btc2 = baseX2({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr2 = baseX2({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base32.js
var base32_exports2 = {};
__export(base32_exports2, {
  base32: () => base322,
  base32hex: () => base32hex2,
  base32hexpad: () => base32hexpad2,
  base32hexpadupper: () => base32hexpadupper2,
  base32hexupper: () => base32hexupper2,
  base32pad: () => base32pad2,
  base32padupper: () => base32padupper2,
  base32upper: () => base32upper2,
  base32z: () => base32z2
});
init_buffer_polyfill();
var base322 = rfc46482({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper2 = rfc46482({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad2 = rfc46482({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper2 = rfc46482({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex2 = rfc46482({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper2 = rfc46482({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad2 = rfc46482({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper2 = rfc46482({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z2 = rfc46482({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/link/interface.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/cid.js
var format3 = (link, base5) => {
  const { bytes, version } = link;
  switch (version) {
    case 0:
      return toStringV02(
        bytes,
        baseCache2(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base5 || base58btc2.encoder
      );
    default:
      return toStringV12(
        bytes,
        baseCache2(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base5 || base322.encoder
      );
  }
};
var cache2 = /* @__PURE__ */ new WeakMap();
var baseCache2 = (cid) => {
  const baseCache4 = cache2.get(cid);
  if (baseCache4 == null) {
    const baseCache5 = /* @__PURE__ */ new Map();
    cache2.set(cid, baseCache5);
    return baseCache5;
  }
  return baseCache4;
};
var CID2 = class _CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version, code10, multihash, bytes) {
    this.code = code10;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code10, multihash } = this;
        if (code10 !== DAG_PB_CODE2) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE2) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code10, digest: digest4 } = this.multihash;
        const multihash = create2(code10, digest4);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals4(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base5) {
    return format3(this, base5);
  }
  toJSON() {
    return { "/": format3(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = (
      /** @type {any} */
      input
    );
    if (value2 instanceof _CID) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version, code: code10, multihash, bytes } = value2;
      return new _CID(
        version,
        code10,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes || encodeCID2(version, code10, multihash.bytes)
      );
    } else if (value2[cidSymbol2] === true) {
      const { version, multihash, code: code10 } = value2;
      const digest4 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode30(multihash)
      );
      return _CID.create(version, code10, digest4);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version, code10, digest4) {
    if (typeof code10 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest4.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version) {
      case 0: {
        if (code10 !== DAG_PB_CODE2) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`
          );
        } else {
          return new _CID(version, code10, digest4, digest4.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID2(version, code10, digest4.bytes);
        return new _CID(version, code10, digest4, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest4) {
    return _CID.create(0, DAG_PB_CODE2, digest4);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code10, digest4) {
    return _CID.create(1, code10, digest4);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce2(
      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest4 = new Digest2(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest4
    ) : _CID.createV1(specs.codec, digest4);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length6] = decode29(initialBytes.subarray(offset));
      offset += length6;
      return i;
    };
    let version = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE2
    );
    if (
      /** @type {number} */
      version === 18
    ) {
      version = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${version}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base5) {
    const [prefix, bytes] = parseCIDtoBytes2(source, base5);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache2(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes2 = (source, base5) => {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base5 || base58btc2;
      return [
        /** @type {Prefix} */
        base58btc2.prefix,
        decoder.decode(`${base58btc2.prefix}${source}`)
      ];
    }
    case base58btc2.prefix: {
      const decoder = base5 || base58btc2;
      return [
        /** @type {Prefix} */
        base58btc2.prefix,
        decoder.decode(source)
      ];
    }
    case base322.prefix: {
      const decoder = base5 || base322;
      return [
        /** @type {Prefix} */
        base322.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base5 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base5.decode(source)
      ];
    }
  }
};
var toStringV02 = (bytes, cache4, base5) => {
  const { prefix } = base5;
  if (prefix !== base58btc2.prefix) {
    throw Error(`Cannot string encode V0 in ${base5.name} encoding`);
  }
  const cid = cache4.get(prefix);
  if (cid == null) {
    const cid2 = base5.encode(bytes).slice(1);
    cache4.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV12 = (bytes, cache4, base5) => {
  const { prefix } = base5;
  const cid = cache4.get(prefix);
  if (cid == null) {
    const cid2 = base5.encode(bytes);
    cache4.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE2 = 112;
var SHA_256_CODE2 = 18;
var encodeCID2 = (version, code10, multihash) => {
  const codeOffset = encodingLength4(version);
  const hashOffset = codeOffset + encodingLength4(code10);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo2(version, bytes, 0);
  encodeTo2(code10, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol2 = /* @__PURE__ */ Symbol.for("@ipld/js-cid/CID");

// node_modules/.pnpm/dag-jose@4.0.0/node_modules/dag-jose/lib/signing.js
function fromSplit(split2) {
  const [protectedHeader, payload, signature2] = split2;
  return {
    payload,
    signatures: [{ protected: protectedHeader, signature: signature2 }],
    link: CID2.decode(fromBase64url(payload))
  };
}
function encodeSignature(signature2) {
  const encoded = {
    signature: fromBase64url(signature2.signature)
  };
  if (signature2.header)
    encoded.header = signature2.header;
  if (signature2.protected)
    encoded.protected = fromBase64url(signature2.protected);
  return encoded;
}
function encode29(jws) {
  const payload = fromBase64url(jws.payload);
  try {
    CID2.decode(payload);
  } catch (e) {
    throw new Error("Not a valid DagJWS");
  }
  return {
    payload,
    signatures: jws.signatures.map(encodeSignature)
  };
}
function decodeSignature(encoded) {
  const sign2 = {
    signature: toBase64url(encoded.signature)
  };
  if (encoded.header)
    sign2.header = encoded.header;
  if (encoded.protected)
    sign2.protected = toBase64url(encoded.protected);
  return sign2;
}
function decode31(encoded) {
  const decoded = {
    payload: toBase64url(encoded.payload),
    signatures: encoded.signatures.map(decodeSignature)
  };
  decoded.link = CID2.decode(new Uint8Array(encoded.payload));
  return decoded;
}

// node_modules/.pnpm/dag-jose@4.0.0/node_modules/dag-jose/lib/encryption.js
init_buffer_polyfill();
function fromSplit2(split2) {
  const [protectedHeader, encrypted_key, iv, ciphertext, tag] = split2;
  const jwe = {
    ciphertext,
    iv,
    protected: protectedHeader,
    tag
  };
  if (encrypted_key)
    jwe.recipients = [{ encrypted_key }];
  return jwe;
}
function encodeRecipient(recipient) {
  const encRec = {};
  if (recipient.encrypted_key)
    encRec.encrypted_key = fromBase64url(recipient.encrypted_key);
  if (recipient.header)
    encRec.header = recipient.header;
  return encRec;
}
function encode30(jwe) {
  const encJwe = {
    ciphertext: fromBase64url(jwe.ciphertext),
    protected: fromBase64url(jwe.protected),
    iv: fromBase64url(jwe.iv),
    tag: fromBase64url(jwe.tag)
  };
  if (jwe.aad)
    encJwe.aad = fromBase64url(jwe.aad);
  if (jwe.recipients)
    encJwe.recipients = jwe.recipients.map(encodeRecipient);
  if (jwe.unprotected)
    encJwe.unprotected = jwe.unprotected;
  return encJwe;
}
function decodeRecipient(encoded) {
  const recipient = {};
  if (encoded.encrypted_key)
    recipient.encrypted_key = toBase64url(encoded.encrypted_key);
  if (encoded.header)
    recipient.header = encoded.header;
  return recipient;
}
function decode32(encoded) {
  const jwe = {
    ciphertext: toBase64url(encoded.ciphertext),
    protected: toBase64url(encoded.protected),
    iv: toBase64url(encoded.iv),
    tag: toBase64url(encoded.tag)
  };
  if (encoded.aad)
    jwe.aad = toBase64url(encoded.aad);
  if (encoded.recipients)
    jwe.recipients = encoded.recipients.map(decodeRecipient);
  if (encoded.unprotected)
    jwe.unprotected = encoded.unprotected;
  return jwe;
}

// node_modules/.pnpm/dag-jose@4.0.0/node_modules/dag-jose/lib/index.js
var name4 = "dag-jose";
var code4 = 133;
function isDagJWS(jose) {
  return "payload" in jose && typeof jose.payload === "string" && "signatures" in jose && Array.isArray(jose.signatures);
}
function isEncodedJWS(jose) {
  return "payload" in jose && jose.payload instanceof Uint8Array && "signatures" in jose && Array.isArray(jose.signatures);
}
function isEncodedJWE(jose) {
  return "ciphertext" in jose && jose.ciphertext instanceof Uint8Array && "iv" in jose && jose.iv instanceof Uint8Array && "protected" in jose && jose.protected instanceof Uint8Array && "tag" in jose && jose.tag instanceof Uint8Array;
}
function isDagJWE(jose) {
  return "ciphertext" in jose && typeof jose.ciphertext === "string" && "iv" in jose && typeof jose.iv === "string" && "protected" in jose && typeof jose.protected === "string" && "tag" in jose && typeof jose.tag === "string";
}
function toGeneral(jose) {
  if (typeof jose === "string") {
    const split2 = jose.split(".");
    if (split2.length === 3) {
      return fromSplit(split2);
    } else if (split2.length === 5) {
      return fromSplit2(split2);
    }
    throw new Error("Not a valid JOSE string");
  }
  if (isDagJWS(jose) || isDagJWE(jose)) {
    return jose;
  }
  throw new Error("Not a valid unencoded JOSE object");
}
function encode31(obj) {
  if (typeof obj === "string") {
    obj = toGeneral(obj);
  }
  let encodedJose;
  if (isDagJWS(obj)) {
    encodedJose = encode29(obj);
  } else if (isDagJWE(obj)) {
    encodedJose = encode30(obj);
  } else {
    throw new Error("Not a valid JOSE object");
  }
  return new Uint8Array(encode24(encodedJose));
}
function decode33(data) {
  let encoded;
  try {
    encoded = decode24(data);
  } catch (e) {
    throw new Error("Not a valid DAG-JOSE object");
  }
  if (isEncodedJWS(encoded)) {
    return decode31(encoded);
  } else if (isEncodedJWE(encoded)) {
    return decode32(encoded);
  } else {
    throw new Error("Not a valid DAG-JOSE object");
  }
}

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
init_buffer_polyfill();
var code5 = 0;
var name5 = "identity";
var encode32 = coerce2;
var digest = (input) => create2(code5, encode32(input));
var identity = { code: code5, name: name5, encode: encode32, digest };

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/basics.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
init_buffer_polyfill();
var identity2 = from3({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString3(buf2),
  decode: (str) => fromString3(str)
});

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base22
});
init_buffer_polyfill();
var base22 = rfc46482({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
init_buffer_polyfill();
var base8 = rfc46482({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
init_buffer_polyfill();
var base10 = baseX2({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
init_buffer_polyfill();
var base16 = rfc46482({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc46482({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base36.js
var base36_exports2 = {};
__export(base36_exports2, {
  base36: () => base362,
  base36upper: () => base36upper2
});
init_buffer_polyfill();
var base362 = baseX2({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper2 = baseX2({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
init_buffer_polyfill();
var alphabet2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars = (
  /** @type {string[]} */
  alphabet2.reduce(
    (p, c, i) => {
      p[i] = c;
      return p;
    },
    /** @type {string[]} */
    []
  )
);
var alphabetCharsToBytes = (
  /** @type {number[]} */
  alphabet2.reduce(
    (p, c, i) => {
      p[
        /** @type {number} */
        c.codePointAt(0)
      ] = i;
      return p;
    },
    /** @type {number[]} */
    []
  )
);
function encode33(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode34(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[
      /** @type {number} */
      char.codePointAt(0)
    ];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from3({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode33,
  decode: decode34
});

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha2564,
  sha512: () => sha5123
});
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/hasher.js
init_buffer_polyfill();
var from4 = ({ name: name10, code: code10, encode: encode42 }) => new Hasher2(name10, code10, encode42);
var Hasher2 = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name10, code10, encode42) {
    this.name = name10;
    this.code = code10;
    this.encode = encode42;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create2(this.code, result) : result.then((digest4) => create2(this.code, digest4));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/sha2-browser.js
var sha = (name10) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name10, data))
);
var sha2564 = from4({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
var sha5123 = from4({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/codecs/raw.js
var raw_exports = {};
__export(raw_exports, {
  code: () => code6,
  decode: () => decode35,
  encode: () => encode34,
  name: () => name6
});
init_buffer_polyfill();
var name6 = "raw";
var code6 = 85;
var encode34 = (node) => coerce2(node);
var decode35 = (data) => coerce2(data);

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/codecs/json.js
var json_exports2 = {};
__export(json_exports2, {
  code: () => code7,
  decode: () => decode36,
  encode: () => encode35,
  name: () => name7
});
init_buffer_polyfill();
var textEncoder4 = new TextEncoder();
var textDecoder3 = new TextDecoder();
var name7 = "json";
var code7 = 512;
var encode35 = (node) => textEncoder4.encode(JSON.stringify(node));
var decode36 = (data) => JSON.parse(textDecoder3.decode(data));

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/index.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/interface.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/basics.js
var bases = { ...identity_exports2, ...base2_exports, ...base8_exports, ...base10_exports, ...base16_exports, ...base32_exports2, ...base36_exports2, ...base58_exports2, ...base64_exports2, ...base256emoji_exports };
var hashes = { ...sha2_browser_exports, ...identity_exports };
var codecs = { raw: raw_exports, json: json_exports2 };

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/bitswap/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/bitswap/wantlist.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/lib/configure.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/lib/core.js
init_buffer_polyfill();

// node_modules/.pnpm/@multiformats+multiaddr@11.6.1/node_modules/@multiformats/multiaddr/dist/src/index.js
init_buffer_polyfill();

// node_modules/.pnpm/@multiformats+multiaddr@11.6.1/node_modules/@multiformats/multiaddr/dist/src/codec.js
init_buffer_polyfill();

// node_modules/.pnpm/@multiformats+multiaddr@11.6.1/node_modules/@multiformats/multiaddr/dist/src/convert.js
init_buffer_polyfill();

// node_modules/.pnpm/@multiformats+multiaddr@11.6.1/node_modules/@multiformats/multiaddr/dist/src/ip.js
init_buffer_polyfill();

// node_modules/.pnpm/@chainsafe+is-ip@2.1.0/node_modules/@chainsafe/is-ip/lib/is-ip.js
init_buffer_polyfill();

// node_modules/.pnpm/@chainsafe+is-ip@2.1.0/node_modules/@chainsafe/is-ip/lib/parse.js
init_buffer_polyfill();

// node_modules/.pnpm/@chainsafe+is-ip@2.1.0/node_modules/@chainsafe/is-ip/lib/parser.js
init_buffer_polyfill();
var Parser = class {
  constructor() {
    __publicField(this, "index", 0);
    __publicField(this, "input", "");
  }
  new(input) {
    this.index = 0;
    this.input = input;
    return this;
  }
  /** Run a parser, and restore the pre-parse state if it fails. */
  readAtomically(fn) {
    const index = this.index;
    const result = fn();
    if (result === void 0) {
      this.index = index;
    }
    return result;
  }
  /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */
  parseWith(fn) {
    const result = fn();
    if (this.index !== this.input.length) {
      return void 0;
    }
    return result;
  }
  /** Peek the next character from the input */
  peekChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index];
  }
  /** Read the next character from the input */
  readChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index++];
  }
  /** Read the next character from the input if it matches the target. */
  readGivenChar(target) {
    return this.readAtomically(() => {
      const char = this.readChar();
      if (char !== target) {
        return void 0;
      }
      return char;
    });
  }
  /**
   * Helper for reading separators in an indexed loop. Reads the separator
   * character iff index > 0, then runs the parser. When used in a loop,
   * the separator character will only be read on index > 0 (see
   * readIPv4Addr for an example)
   */
  readSeparator(sep, index, inner) {
    return this.readAtomically(() => {
      if (index > 0) {
        if (this.readGivenChar(sep) === void 0) {
          return void 0;
        }
      }
      return inner();
    });
  }
  /**
   * Read a number off the front of the input in the given radix, stopping
   * at the first non-digit character or eof. Fails if the number has more
   * digits than max_digits or if there is no number.
   */
  readNumber(radix2, maxDigits, allowZeroPrefix, maxBytes) {
    return this.readAtomically(() => {
      let result = 0;
      let digitCount = 0;
      const leadingChar = this.peekChar();
      if (leadingChar === void 0) {
        return void 0;
      }
      const hasLeadingZero = leadingChar === "0";
      const maxValue4 = 2 ** (8 * maxBytes) - 1;
      while (true) {
        const digit = this.readAtomically(() => {
          const char = this.readChar();
          if (char === void 0) {
            return void 0;
          }
          const num2 = Number.parseInt(char, radix2);
          if (Number.isNaN(num2)) {
            return void 0;
          }
          return num2;
        });
        if (digit === void 0) {
          break;
        }
        result *= radix2;
        result += digit;
        if (result > maxValue4) {
          return void 0;
        }
        digitCount += 1;
        if (maxDigits !== void 0) {
          if (digitCount > maxDigits) {
            return void 0;
          }
        }
      }
      if (digitCount === 0) {
        return void 0;
      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
        return void 0;
      } else {
        return result;
      }
    });
  }
  /** Read an IPv4 address. */
  readIPv4Addr() {
    return this.readAtomically(() => {
      const out = new Uint8Array(4);
      for (let i = 0; i < out.length; i++) {
        const ix = this.readSeparator(".", i, () => this.readNumber(10, 3, false, 1));
        if (ix === void 0) {
          return void 0;
        }
        out[i] = ix;
      }
      return out;
    });
  }
  /** Read an IPv6 Address. */
  readIPv6Addr() {
    const readGroups = (groups) => {
      for (let i = 0; i < groups.length / 2; i++) {
        const ix = i * 2;
        if (i < groups.length - 3) {
          const ipv4 = this.readSeparator(":", i, () => this.readIPv4Addr());
          if (ipv4 !== void 0) {
            groups[ix] = ipv4[0];
            groups[ix + 1] = ipv4[1];
            groups[ix + 2] = ipv4[2];
            groups[ix + 3] = ipv4[3];
            return [ix + 4, true];
          }
        }
        const group = this.readSeparator(":", i, () => this.readNumber(16, 4, true, 2));
        if (group === void 0) {
          return [ix, false];
        }
        groups[ix] = group >> 8;
        groups[ix + 1] = group & 255;
      }
      return [groups.length, false];
    };
    return this.readAtomically(() => {
      const head = new Uint8Array(16);
      const [headSize, headIp4] = readGroups(head);
      if (headSize === 16) {
        return head;
      }
      if (headIp4) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      const tail = new Uint8Array(14);
      const limit = 16 - (headSize + 2);
      const [tailSize] = readGroups(tail.subarray(0, limit));
      head.set(tail.subarray(0, tailSize), 16 - tailSize);
      return head;
    });
  }
  /** Read an IP Address, either IPv4 or IPv6. */
  readIPAddr() {
    return this.readIPv4Addr() ?? this.readIPv6Addr();
  }
};

// node_modules/.pnpm/@chainsafe+is-ip@2.1.0/node_modules/@chainsafe/is-ip/lib/parse.js
var MAX_IPV6_LENGTH = 45;
var MAX_IPV4_LENGTH = 15;
var parser = new Parser();
function parseIPv4(input) {
  if (input.length > MAX_IPV4_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv4Addr());
}
function parseIPv6(input) {
  if (input.includes("%")) {
    input = input.split("%")[0];
  }
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv6Addr());
}
function parseIP(input, mapIPv4ToIPv6 = false) {
  if (input.includes("%")) {
    input = input.split("%")[0];
  }
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  const addr = parser.new(input).parseWith(() => parser.readIPAddr());
  if (!addr) {
    return void 0;
  }
  if (mapIPv4ToIPv6 && addr.length === 4) {
    return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, addr[0], addr[1], addr[2], addr[3]]);
  }
  return addr;
}

// node_modules/.pnpm/@chainsafe+is-ip@2.1.0/node_modules/@chainsafe/is-ip/lib/is-ip.js
function isIPv4(input) {
  return Boolean(parseIPv4(input));
}
function isIPv6(input) {
  return Boolean(parseIPv6(input));
}
function isIP(input) {
  return Boolean(parseIP(input));
}

// node_modules/.pnpm/uint8arrays@4.0.10/node_modules/uint8arrays/dist/src/to-string.js
init_buffer_polyfill();

// node_modules/.pnpm/uint8arrays@4.0.10/node_modules/uint8arrays/dist/src/util/bases.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/basics.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base10.js
var base10_exports2 = {};
__export(base10_exports2, {
  base10: () => base102
});
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/vendor/base-x.js
init_buffer_polyfill();
function base4(ALPHABET2, name10) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET2.length; i++) {
    var x = ALPHABET2.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode42(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length6 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length6) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length6 = i2;
      pbegin++;
    }
    var it2 = size - length6;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length6 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length6) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length6 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length6;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode44(string5) {
    var buffer2 = decodeUnsafe(string5);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name10} character`);
  }
  return {
    encode: encode42,
    decodeUnsafe,
    decode: decode44
  };
}
var src3 = base4;
var _brrp__multiformats_scope_baseX3 = src3;
var base_x_default3 = _brrp__multiformats_scope_baseX3;

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bytes.js
init_buffer_polyfill();
var empty3 = new Uint8Array(0);
var equals5 = (aa, bb) => {
  if (aa === bb) return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce3 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") return o;
  if (o instanceof ArrayBuffer) return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString4 = (str) => new TextEncoder().encode(str);
var toString4 = (b) => new TextDecoder().decode(b);

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/interface.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base.js
var Encoder3 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name10, prefix, baseEncode) {
    this.name = name10;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder3 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name10, prefix, baseDecode) {
    this.name = name10;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or3(this, decoder);
  }
};
var ComposedDecoder3 = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders3) {
    this.decoders = decoders3;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or3(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or3 = (left, right) => new ComposedDecoder3(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec3 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name10, prefix, baseEncode, baseDecode) {
    this.name = name10;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder3(name10, prefix, baseEncode);
    this.decoder = new Decoder3(name10, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from5 = ({ name: name10, prefix, encode: encode42, decode: decode44 }) => new Codec3(name10, prefix, encode42, decode44);
var baseX3 = ({ prefix, name: name10, alphabet: alphabet5 }) => {
  const { encode: encode42, decode: decode44 } = base_x_default3(alphabet5, name10);
  return from5({
    prefix,
    name: name10,
    encode: encode42,
    /**
     * @param {string} text
     */
    decode: (text) => coerce3(decode44(text))
  });
};
var decode37 = (string5, alphabet5, bitsPerChar, name10) => {
  const codes2 = {};
  for (let i = 0; i < alphabet5.length; ++i) {
    codes2[alphabet5[i]] = i;
  }
  let end = string5.length;
  while (string5[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value2 = codes2[string5[i]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name10} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode36 = (data, alphabet5, bitsPerChar) => {
  const pad = alphabet5[alphabet5.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet5[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet5[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46483 = ({ name: name10, prefix, bitsPerChar, alphabet: alphabet5 }) => {
  return from5({
    prefix,
    name: name10,
    encode(input) {
      return encode36(input, alphabet5, bitsPerChar);
    },
    decode(input) {
      return decode37(input, alphabet5, bitsPerChar, name10);
    }
  });
};

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base10.js
var base102 = baseX3({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base16.js
var base16_exports2 = {};
__export(base16_exports2, {
  base16: () => base162,
  base16upper: () => base16upper2
});
init_buffer_polyfill();
var base162 = rfc46483({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper2 = rfc46483({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base2.js
var base2_exports2 = {};
__export(base2_exports2, {
  base2: () => base23
});
init_buffer_polyfill();
var base23 = rfc46483({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports2 = {};
__export(base256emoji_exports2, {
  base256emoji: () => base256emoji2
});
init_buffer_polyfill();
var alphabet3 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars2 = (
  /** @type {string[]} */
  alphabet3.reduce(
    (p, c, i) => {
      p[i] = c;
      return p;
    },
    /** @type {string[]} */
    []
  )
);
var alphabetCharsToBytes2 = (
  /** @type {number[]} */
  alphabet3.reduce(
    (p, c, i) => {
      p[
        /** @type {number} */
        c.codePointAt(0)
      ] = i;
      return p;
    },
    /** @type {number[]} */
    []
  )
);
function encode37(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars2[c];
    return p;
  }, "");
}
function decode38(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes2[
      /** @type {number} */
      char.codePointAt(0)
    ];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji2 = from5({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode37,
  decode: decode38
});

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base32.js
var base32_exports3 = {};
__export(base32_exports3, {
  base32: () => base323,
  base32hex: () => base32hex3,
  base32hexpad: () => base32hexpad3,
  base32hexpadupper: () => base32hexpadupper3,
  base32hexupper: () => base32hexupper3,
  base32pad: () => base32pad3,
  base32padupper: () => base32padupper3,
  base32upper: () => base32upper3,
  base32z: () => base32z3
});
init_buffer_polyfill();
var base323 = rfc46483({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper3 = rfc46483({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad3 = rfc46483({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper3 = rfc46483({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex3 = rfc46483({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper3 = rfc46483({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad3 = rfc46483({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper3 = rfc46483({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z3 = rfc46483({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base36.js
var base36_exports3 = {};
__export(base36_exports3, {
  base36: () => base363,
  base36upper: () => base36upper3
});
init_buffer_polyfill();
var base363 = baseX3({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper3 = baseX3({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base58.js
var base58_exports3 = {};
__export(base58_exports3, {
  base58btc: () => base58btc3,
  base58flickr: () => base58flickr3
});
init_buffer_polyfill();
var base58btc3 = baseX3({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr3 = baseX3({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base64.js
var base64_exports3 = {};
__export(base64_exports3, {
  base64: () => base643,
  base64pad: () => base64pad3,
  base64url: () => base64url3,
  base64urlpad: () => base64urlpad3
});
init_buffer_polyfill();
var base643 = rfc46483({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad3 = rfc46483({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url3 = rfc46483({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad3 = rfc46483({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base8.js
var base8_exports2 = {};
__export(base8_exports2, {
  base8: () => base82
});
init_buffer_polyfill();
var base82 = rfc46483({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/identity.js
var identity_exports3 = {};
__export(identity_exports3, {
  identity: () => identity3
});
init_buffer_polyfill();
var identity3 = from5({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString4(buf2),
  decode: (str) => fromString4(str)
});

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/codecs/json.js
init_buffer_polyfill();
var textEncoder5 = new TextEncoder();
var textDecoder4 = new TextDecoder();

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/codecs/raw.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/hashes/identity.js
var identity_exports4 = {};
__export(identity_exports4, {
  identity: () => identity4
});
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/hashes/digest.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/varint.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/vendor/varint.js
init_buffer_polyfill();
var encode_13 = encode38;
var MSB3 = 128;
var REST3 = 127;
var MSBALL3 = ~REST3;
var INT3 = Math.pow(2, 31);
function encode38(num2, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num2 >= INT3) {
    out[offset++] = num2 & 255 | MSB3;
    num2 /= 128;
  }
  while (num2 & MSBALL3) {
    out[offset++] = num2 & 255 | MSB3;
    num2 >>>= 7;
  }
  out[offset] = num2 | 0;
  encode38.bytes = offset - oldOffset + 1;
  return out;
}
var decode39 = read3;
var MSB$13 = 128;
var REST$13 = 127;
function read3(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read3.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$13) << shift : (b & REST$13) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$13);
  read3.bytes = counter - offset;
  return res;
}
var N13 = Math.pow(2, 7);
var N23 = Math.pow(2, 14);
var N33 = Math.pow(2, 21);
var N43 = Math.pow(2, 28);
var N53 = Math.pow(2, 35);
var N63 = Math.pow(2, 42);
var N73 = Math.pow(2, 49);
var N83 = Math.pow(2, 56);
var N93 = Math.pow(2, 63);
var length5 = function(value2) {
  return value2 < N13 ? 1 : value2 < N23 ? 2 : value2 < N33 ? 3 : value2 < N43 ? 4 : value2 < N53 ? 5 : value2 < N63 ? 6 : value2 < N73 ? 7 : value2 < N83 ? 8 : value2 < N93 ? 9 : 10;
};
var varint3 = {
  encode: encode_13,
  decode: decode39,
  encodingLength: length5
};
var _brrp_varint3 = varint3;
var varint_default3 = _brrp_varint3;

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/varint.js
var decode40 = (data, offset = 0) => {
  const code10 = varint_default3.decode(data, offset);
  return [code10, varint_default3.decode.bytes];
};
var encodeTo3 = (int, target, offset = 0) => {
  varint_default3.encode(int, target, offset);
  return target;
};
var encodingLength5 = (int) => {
  return varint_default3.encodingLength(int);
};

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/hashes/digest.js
var create3 = (code10, digest4) => {
  const size = digest4.byteLength;
  const sizeOffset = encodingLength5(code10);
  const digestOffset = sizeOffset + encodingLength5(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo3(code10, bytes, 0);
  encodeTo3(size, bytes, sizeOffset);
  bytes.set(digest4, digestOffset);
  return new Digest3(code10, size, digest4, bytes);
};
var decode41 = (multihash) => {
  const bytes = coerce3(multihash);
  const [code10, sizeOffset] = decode40(bytes);
  const [size, digestOffset] = decode40(bytes.subarray(sizeOffset));
  const digest4 = bytes.subarray(sizeOffset + digestOffset);
  if (digest4.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest3(code10, size, digest4, bytes);
};
var equals6 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals5(a.bytes, data.bytes);
  }
};
var Digest3 = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code10, size, digest4, bytes) {
    this.code = code10;
    this.size = size;
    this.digest = digest4;
    this.bytes = bytes;
  }
};

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/hashes/identity.js
var code8 = 0;
var name8 = "identity";
var encode39 = coerce3;
var digest2 = (input) => create3(code8, encode39(input));
var identity4 = { code: code8, name: name8, encode: encode39, digest: digest2 };

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports2 = {};
__export(sha2_browser_exports2, {
  sha256: () => sha2565,
  sha512: () => sha5124
});
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/hashes/hasher.js
init_buffer_polyfill();
var from6 = ({ name: name10, code: code10, encode: encode42 }) => new Hasher3(name10, code10, encode42);
var Hasher3 = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name10, code10, encode42) {
    this.name = name10;
    this.code = code10;
    this.encode = encode42;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create3(this.code, result) : result.then((digest4) => create3(this.code, digest4));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2 = (name10) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name10, data))
);
var sha2565 = from6({
  name: "sha2-256",
  code: 18,
  encode: sha2("SHA-256")
});
var sha5124 = from6({
  name: "sha2-512",
  code: 19,
  encode: sha2("SHA-512")
});

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/index.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/cid.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/link/interface.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/cid.js
var format4 = (link, base5) => {
  const { bytes, version } = link;
  switch (version) {
    case 0:
      return toStringV03(
        bytes,
        baseCache3(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base5 || base58btc3.encoder
      );
    default:
      return toStringV13(
        bytes,
        baseCache3(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base5 || base323.encoder
      );
  }
};
var cache3 = /* @__PURE__ */ new WeakMap();
var baseCache3 = (cid) => {
  const baseCache4 = cache3.get(cid);
  if (baseCache4 == null) {
    const baseCache5 = /* @__PURE__ */ new Map();
    cache3.set(cid, baseCache5);
    return baseCache5;
  }
  return baseCache4;
};
var CID3 = class _CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   */
  constructor(version, code10, multihash, bytes) {
    this.code = code10;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code10, multihash } = this;
        if (code10 !== DAG_PB_CODE3) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE3) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code10, digest: digest4 } = this.multihash;
        const multihash = create3(code10, digest4);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals6(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base5) {
    return format4(this, base5);
  }
  /**
   * @returns {API.LinkJSON<this>}
   */
  toJSON() {
    return { "/": format4(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = (
      /** @type {any} */
      input
    );
    if (value2 instanceof _CID) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version, code: code10, multihash, bytes } = value2;
      return new _CID(
        version,
        code10,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes || encodeCID3(version, code10, multihash.bytes)
      );
    } else if (value2[cidSymbol3] === true) {
      const { version, multihash, code: code10 } = value2;
      const digest4 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode41(multihash)
      );
      return _CID.create(version, code10, digest4);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version, code10, digest4) {
    if (typeof code10 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest4.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version) {
      case 0: {
        if (code10 !== DAG_PB_CODE3) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE3}) block encoding`
          );
        } else {
          return new _CID(version, code10, digest4, digest4.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID3(version, code10, digest4.bytes);
        return new _CID(version, code10, digest4, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest4) {
    return _CID.create(0, DAG_PB_CODE3, digest4);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code10, digest4) {
    return _CID.create(1, code10, digest4);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce3(
      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest4 = new Digest3(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest4
    ) : _CID.createV1(specs.codec, digest4);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length6] = decode40(initialBytes.subarray(offset));
      offset += length6;
      return i;
    };
    let version = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE3
    );
    if (
      /** @type {number} */
      version === 18
    ) {
      version = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${version}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base5) {
    const [prefix, bytes] = parseCIDtoBytes3(source, base5);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache3(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes3 = (source, base5) => {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base5 || base58btc3;
      return [
        /** @type {Prefix} */
        base58btc3.prefix,
        decoder.decode(`${base58btc3.prefix}${source}`)
      ];
    }
    case base58btc3.prefix: {
      const decoder = base5 || base58btc3;
      return [
        /** @type {Prefix} */
        base58btc3.prefix,
        decoder.decode(source)
      ];
    }
    case base323.prefix: {
      const decoder = base5 || base323;
      return [
        /** @type {Prefix} */
        base323.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base5 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base5.decode(source)
      ];
    }
  }
};
var toStringV03 = (bytes, cache4, base5) => {
  const { prefix } = base5;
  if (prefix !== base58btc3.prefix) {
    throw Error(`Cannot string encode V0 in ${base5.name} encoding`);
  }
  const cid = cache4.get(prefix);
  if (cid == null) {
    const cid2 = base5.encode(bytes).slice(1);
    cache4.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV13 = (bytes, cache4, base5) => {
  const { prefix } = base5;
  const cid = cache4.get(prefix);
  if (cid == null) {
    const cid2 = base5.encode(bytes);
    cache4.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE3 = 112;
var SHA_256_CODE3 = 18;
var encodeCID3 = (version, code10, multihash) => {
  const codeOffset = encodingLength5(version);
  const hashOffset = codeOffset + encodingLength5(code10);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo3(version, bytes, 0);
  encodeTo3(code10, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol3 = /* @__PURE__ */ Symbol.for("@ipld/js-cid/CID");

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/interface.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/basics.js
var bases2 = { ...identity_exports3, ...base2_exports2, ...base8_exports2, ...base10_exports2, ...base16_exports2, ...base32_exports3, ...base36_exports3, ...base58_exports3, ...base64_exports3, ...base256emoji_exports2 };
var hashes2 = { ...sha2_browser_exports2, ...identity_exports4 };

// node_modules/.pnpm/uint8arrays@4.0.10/node_modules/uint8arrays/dist/src/alloc.js
init_buffer_polyfill();

// node_modules/.pnpm/uint8arrays@4.0.10/node_modules/uint8arrays/dist/src/util/as-uint8array.js
init_buffer_polyfill();
function asUint8Array(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/.pnpm/uint8arrays@4.0.10/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/.pnpm/uint8arrays@4.0.10/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec(name10, prefix, encode42, decode44) {
  return {
    name: name10,
    prefix,
    encoder: {
      name: name10,
      prefix,
      encode: encode42
    },
    decoder: {
      decode: decode44
    }
  };
}
var string3 = createCodec("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf2) => {
  let string5 = "a";
  for (let i = 0; i < buf2.length; i++) {
    string5 += String.fromCharCode(buf2[i]);
  }
  return string5;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe(str.length);
  for (let i = 0; i < str.length; i++) {
    buf2[i] = str.charCodeAt(i);
  }
  return buf2;
});
var BASES = {
  utf8: string3,
  "utf-8": string3,
  hex: bases2.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases2
};
var bases_default = BASES;

// node_modules/.pnpm/uint8arrays@4.0.10/node_modules/uint8arrays/dist/src/to-string.js
function toString5(array2, encoding = "utf8") {
  const base5 = bases_default[encoding];
  if (base5 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array2.buffer, array2.byteOffset, array2.byteLength).toString("utf8");
  }
  return base5.encoder.encode(array2).substring(1);
}

// node_modules/.pnpm/@multiformats+multiaddr@11.6.1/node_modules/@multiformats/multiaddr/dist/src/ip.js
var isV4 = isIPv4;
var isV6 = isIPv6;
var toBytes2 = function(ip) {
  let offset = 0;
  ip = ip.toString().trim();
  if (isV4(ip)) {
    const bytes = new Uint8Array(offset + 4);
    ip.split(/\./g).forEach((byte) => {
      bytes[offset++] = parseInt(byte, 10) & 255;
    });
    return bytes;
  }
  if (isV6(ip)) {
    const sections = ip.split(":", 8);
    let i;
    for (i = 0; i < sections.length; i++) {
      const isv4 = isV4(sections[i]);
      let v4Buffer;
      if (isv4) {
        v4Buffer = toBytes2(sections[i]);
        sections[i] = toString5(v4Buffer.slice(0, 2), "base16");
      }
      if (v4Buffer != null && ++i < 8) {
        sections.splice(i, 0, toString5(v4Buffer.slice(2, 4), "base16"));
      }
    }
    if (sections[0] === "") {
      while (sections.length < 8)
        sections.unshift("0");
    } else if (sections[sections.length - 1] === "") {
      while (sections.length < 8)
        sections.push("0");
    } else if (sections.length < 8) {
      for (i = 0; i < sections.length && sections[i] !== ""; i++)
        ;
      const argv = [i, 1];
      for (i = 9 - sections.length; i > 0; i--) {
        argv.push("0");
      }
      sections.splice.apply(sections, argv);
    }
    const bytes = new Uint8Array(offset + 16);
    for (i = 0; i < sections.length; i++) {
      const word = parseInt(sections[i], 16);
      bytes[offset++] = word >> 8 & 255;
      bytes[offset++] = word & 255;
    }
    return bytes;
  }
  throw new Error("invalid ip address");
};
var toString6 = function(buf2, offset = 0, length6) {
  offset = ~~offset;
  length6 = length6 ?? buf2.length - offset;
  const view = new DataView(buf2.buffer);
  if (length6 === 4) {
    const result = [];
    for (let i = 0; i < length6; i++) {
      result.push(buf2[offset + i]);
    }
    return result.join(".");
  }
  if (length6 === 16) {
    const result = [];
    for (let i = 0; i < length6; i += 2) {
      result.push(view.getUint16(offset + i).toString(16));
    }
    return result.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
  }
  return "";
};

// node_modules/.pnpm/@multiformats+multiaddr@11.6.1/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js
init_buffer_polyfill();
var V = -1;
var names = {};
var codes = {};
var table = [
  [4, 32, "ip4"],
  [6, 16, "tcp"],
  [33, 16, "dccp"],
  [41, 128, "ip6"],
  [42, V, "ip6zone"],
  [43, 8, "ipcidr"],
  [53, V, "dns", true],
  [54, V, "dns4", true],
  [55, V, "dns6", true],
  [56, V, "dnsaddr", true],
  [132, 16, "sctp"],
  [273, 16, "udp"],
  [275, 0, "p2p-webrtc-star"],
  [276, 0, "p2p-webrtc-direct"],
  [277, 0, "p2p-stardust"],
  [280, 0, "webrtc"],
  [281, 0, "webrtc-w3c"],
  [290, 0, "p2p-circuit"],
  [301, 0, "udt"],
  [302, 0, "utp"],
  [400, V, "unix", false, true],
  // `ipfs` is added before `p2p` for legacy support.
  // All text representations will default to `p2p`, but `ipfs` will
  // still be supported
  [421, V, "ipfs"],
  // `p2p` is the preferred name for 421, and is now the default
  [421, V, "p2p"],
  [443, 0, "https"],
  [444, 96, "onion"],
  [445, 296, "onion3"],
  [446, V, "garlic64"],
  [448, 0, "tls"],
  [449, V, "sni"],
  [460, 0, "quic"],
  [461, 0, "quic-v1"],
  [465, 0, "webtransport"],
  [466, V, "certhash"],
  [477, 0, "ws"],
  [478, 0, "wss"],
  [479, 0, "p2p-websocket-star"],
  [480, 0, "http"],
  [777, V, "memory"]
];
table.forEach((row) => {
  const proto = createProtocol(...row);
  codes[proto.code] = proto;
  names[proto.name] = proto;
});
function createProtocol(code10, size, name10, resolvable, path) {
  return {
    code: code10,
    size,
    name: name10,
    resolvable: Boolean(resolvable),
    path: Boolean(path)
  };
}
function getProtocol(proto) {
  if (typeof proto === "number") {
    if (codes[proto] != null) {
      return codes[proto];
    }
    throw new Error(`no protocol with code: ${proto}`);
  } else if (typeof proto === "string") {
    if (names[proto] != null) {
      return names[proto];
    }
    throw new Error(`no protocol with name: ${proto}`);
  }
  throw new Error(`invalid protocol id type: ${typeof proto}`);
}

// node_modules/.pnpm/@multiformats+multiaddr@11.6.1/node_modules/@multiformats/multiaddr/dist/src/convert.js
var import_varint4 = __toESM(require_varint(), 1);

// node_modules/.pnpm/uint8arrays@4.0.10/node_modules/uint8arrays/dist/src/from-string.js
init_buffer_polyfill();
function fromString5(string5, encoding = "utf8") {
  const base5 = bases_default[encoding];
  if (base5 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string5, "utf-8"));
  }
  return base5.decoder.decode(`${base5.prefix}${string5}`);
}

// node_modules/.pnpm/uint8arrays@4.0.10/node_modules/uint8arrays/dist/src/concat.js
init_buffer_polyfill();
function concat4(arrays, length6) {
  if (length6 == null) {
    length6 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length6);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output);
}

// node_modules/.pnpm/@multiformats+multiaddr@11.6.1/node_modules/@multiformats/multiaddr/dist/src/convert.js
function convertToString(proto, buf2) {
  const protocol = getProtocol(proto);
  switch (protocol.code) {
    case 4:
    // ipv4
    case 41:
      return bytes2ip(buf2);
    case 42:
      return bytes2str(buf2);
    case 6:
    // tcp
    case 273:
    // udp
    case 33:
    // dccp
    case 132:
      return bytes2port(buf2).toString();
    case 53:
    // dns
    case 54:
    // dns4
    case 55:
    // dns6
    case 56:
    // dnsaddr
    case 400:
    // unix
    case 449:
    // sni
    case 777:
      return bytes2str(buf2);
    case 421:
      return bytes2mh(buf2);
    case 444:
      return bytes2onion(buf2);
    case 445:
      return bytes2onion(buf2);
    case 466:
      return bytes2mb(buf2);
    default:
      return toString5(buf2, "base16");
  }
}
function convertToBytes(proto, str) {
  const protocol = getProtocol(proto);
  switch (protocol.code) {
    case 4:
      return ip2bytes(str);
    case 41:
      return ip2bytes(str);
    case 42:
      return str2bytes(str);
    case 6:
    // tcp
    case 273:
    // udp
    case 33:
    // dccp
    case 132:
      return port2bytes(parseInt(str, 10));
    case 53:
    // dns
    case 54:
    // dns4
    case 55:
    // dns6
    case 56:
    // dnsaddr
    case 400:
    // unix
    case 449:
    // sni
    case 777:
      return str2bytes(str);
    case 421:
      return mh2bytes(str);
    case 444:
      return onion2bytes(str);
    case 445:
      return onion32bytes(str);
    case 466:
      return mb2bytes(str);
    default:
      return fromString5(str, "base16");
  }
}
var decoders = Object.values(bases).map((c) => c.decoder);
var anybaseDecoder = (function() {
  let acc = decoders[0].or(decoders[1]);
  decoders.slice(2).forEach((d) => acc = acc.or(d));
  return acc;
})();
function ip2bytes(ipString) {
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return toBytes2(ipString);
}
function bytes2ip(ipBuff) {
  const ipString = toString6(ipBuff, 0, ipBuff.length);
  if (ipString == null) {
    throw new Error("ipBuff is required");
  }
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return ipString;
}
function port2bytes(port) {
  const buf2 = new ArrayBuffer(2);
  const view = new DataView(buf2);
  view.setUint16(0, port);
  return new Uint8Array(buf2);
}
function bytes2port(buf2) {
  const view = new DataView(buf2.buffer);
  return view.getUint16(buf2.byteOffset);
}
function str2bytes(str) {
  const buf2 = fromString5(str);
  const size = Uint8Array.from(import_varint4.default.encode(buf2.length));
  return concat4([size, buf2], size.length + buf2.length);
}
function bytes2str(buf2) {
  const size = import_varint4.default.decode(buf2);
  buf2 = buf2.slice(import_varint4.default.decode.bytes);
  if (buf2.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString5(buf2);
}
function mh2bytes(hash) {
  let mh;
  if (hash[0] === "Q" || hash[0] === "1") {
    mh = decode30(base58btc2.decode(`z${hash}`)).bytes;
  } else {
    mh = CID2.parse(hash).multihash.bytes;
  }
  const size = Uint8Array.from(import_varint4.default.encode(mh.length));
  return concat4([size, mh], size.length + mh.length);
}
function mb2bytes(mbstr) {
  const mb = anybaseDecoder.decode(mbstr);
  const size = Uint8Array.from(import_varint4.default.encode(mb.length));
  return concat4([size, mb], size.length + mb.length);
}
function bytes2mb(buf2) {
  const size = import_varint4.default.decode(buf2);
  const hash = buf2.slice(import_varint4.default.decode.bytes);
  if (hash.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return "u" + toString5(hash, "base64url");
}
function bytes2mh(buf2) {
  const size = import_varint4.default.decode(buf2);
  const address = buf2.slice(import_varint4.default.decode.bytes);
  if (address.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString5(address, "base58btc");
}
function onion2bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf2 = base322.decode("b" + addr[0]);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat4([buf2, portBuf], buf2.length + portBuf.length);
}
function onion32bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf2 = base322.decode(`b${addr[0]}`);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat4([buf2, portBuf], buf2.length + portBuf.length);
}
function bytes2onion(buf2) {
  const addrBytes = buf2.slice(0, buf2.length - 2);
  const portBytes = buf2.slice(buf2.length - 2);
  const addr = toString5(addrBytes, "base32");
  const port = bytes2port(portBytes);
  return `${addr}:${port}`;
}

// node_modules/.pnpm/@multiformats+multiaddr@11.6.1/node_modules/@multiformats/multiaddr/dist/src/codec.js
var import_varint5 = __toESM(require_varint(), 1);
function stringToStringTuples(str) {
  const tuples = [];
  const parts = str.split("/").slice(1);
  if (parts.length === 1 && parts[0] === "") {
    return [];
  }
  for (let p = 0; p < parts.length; p++) {
    const part = parts[p];
    const proto = getProtocol(part);
    if (proto.size === 0) {
      tuples.push([part]);
      continue;
    }
    p++;
    if (p >= parts.length) {
      throw ParseError("invalid address: " + str);
    }
    if (proto.path === true) {
      tuples.push([
        part,
        // should we need to check each path part to see if it's a proto?
        // This would allow for other protocols to be added after a unix path,
        // however it would have issues if the path had a protocol name in the path
        cleanPath(parts.slice(p).join("/"))
      ]);
      break;
    }
    tuples.push([part, parts[p]]);
  }
  return tuples;
}
function stringTuplesToString(tuples) {
  const parts = [];
  tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    parts.push(proto.name);
    if (tup.length > 1 && tup[1] != null) {
      parts.push(tup[1]);
    }
    return null;
  });
  return cleanPath(parts.join("/"));
}
function stringTuplesToTuples(tuples) {
  return tuples.map((tup) => {
    if (!Array.isArray(tup)) {
      tup = [tup];
    }
    const proto = protoFromTuple(tup);
    if (tup.length > 1) {
      return [proto.code, convertToBytes(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToStringTuples(tuples) {
  return tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    if (tup[1] != null) {
      return [proto.code, convertToString(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToBytes(tuples) {
  return fromBytes(concat4(tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    let buf2 = Uint8Array.from(import_varint5.default.encode(proto.code));
    if (tup.length > 1 && tup[1] != null) {
      buf2 = concat4([buf2, tup[1]]);
    }
    return buf2;
  })));
}
function sizeForAddr(p, addr) {
  if (p.size > 0) {
    return p.size / 8;
  } else if (p.size === 0) {
    return 0;
  } else {
    const size = import_varint5.default.decode(addr);
    return size + (import_varint5.default.decode.bytes ?? 0);
  }
}
function bytesToTuples(buf2) {
  const tuples = [];
  let i = 0;
  while (i < buf2.length) {
    const code10 = import_varint5.default.decode(buf2, i);
    const n2 = import_varint5.default.decode.bytes ?? 0;
    const p = getProtocol(code10);
    const size = sizeForAddr(p, buf2.slice(i + n2));
    if (size === 0) {
      tuples.push([code10]);
      i += n2;
      continue;
    }
    const addr = buf2.slice(i + n2, i + n2 + size);
    i += size + n2;
    if (i > buf2.length) {
      throw ParseError("Invalid address Uint8Array: " + toString5(buf2, "base16"));
    }
    tuples.push([code10, addr]);
  }
  return tuples;
}
function bytesToString(buf2) {
  const a = bytesToTuples(buf2);
  const b = tuplesToStringTuples(a);
  return stringTuplesToString(b);
}
function stringToBytes(str) {
  str = cleanPath(str);
  const a = stringToStringTuples(str);
  const b = stringTuplesToTuples(a);
  return tuplesToBytes(b);
}
function fromString6(str) {
  return stringToBytes(str);
}
function fromBytes(buf2) {
  const err = validateBytes(buf2);
  if (err != null) {
    throw err;
  }
  return Uint8Array.from(buf2);
}
function validateBytes(buf2) {
  try {
    bytesToTuples(buf2);
  } catch (err) {
    return err;
  }
}
function cleanPath(str) {
  return "/" + str.trim().split("/").filter((a) => a).join("/");
}
function ParseError(str) {
  return new Error("Error parsing address: " + str);
}
function protoFromTuple(tup) {
  const proto = getProtocol(tup[0]);
  return proto;
}

// node_modules/.pnpm/@multiformats+multiaddr@11.6.1/node_modules/@multiformats/multiaddr/dist/src/index.js
var import_varint6 = __toESM(require_varint(), 1);
var import_err_code = __toESM(require_err_code(), 1);

// node_modules/.pnpm/uint8arrays@4.0.10/node_modules/uint8arrays/dist/src/equals.js
init_buffer_polyfill();
function equals7(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/.pnpm/@multiformats+multiaddr@11.6.1/node_modules/@multiformats/multiaddr/dist/src/index.js
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var _DefaultMultiaddr_string;
var _DefaultMultiaddr_tuples;
var _DefaultMultiaddr_stringTuples;
var _a2;
var inspect = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var DNS_CODES = [
  getProtocol("dns").code,
  getProtocol("dns4").code,
  getProtocol("dns6").code,
  getProtocol("dnsaddr").code
];
var resolvers = /* @__PURE__ */ new Map();
var symbol = /* @__PURE__ */ Symbol.for("@multiformats/js-multiaddr/multiaddr");
function isMultiaddr(value2) {
  return Boolean(value2?.[symbol]);
}
var DefaultMultiaddr = class _DefaultMultiaddr {
  constructor(addr) {
    _DefaultMultiaddr_string.set(this, void 0);
    _DefaultMultiaddr_tuples.set(this, void 0);
    _DefaultMultiaddr_stringTuples.set(this, void 0);
    this[_a2] = true;
    if (addr == null) {
      addr = "";
    }
    if (addr instanceof Uint8Array) {
      this.bytes = fromBytes(addr);
    } else if (typeof addr === "string") {
      if (addr.length > 0 && addr.charAt(0) !== "/") {
        throw new Error(`multiaddr "${addr}" must start with a "/"`);
      }
      this.bytes = fromString6(addr);
    } else if (isMultiaddr(addr)) {
      this.bytes = fromBytes(addr.bytes);
    } else {
      throw new Error("addr must be a string, Buffer, or another Multiaddr");
    }
  }
  toString() {
    if (__classPrivateFieldGet(this, _DefaultMultiaddr_string, "f") == null) {
      __classPrivateFieldSet(this, _DefaultMultiaddr_string, bytesToString(this.bytes), "f");
    }
    return __classPrivateFieldGet(this, _DefaultMultiaddr_string, "f");
  }
  toJSON() {
    return this.toString();
  }
  toOptions() {
    let family;
    let transport;
    let host;
    let port;
    let zone = "";
    const tcp = getProtocol("tcp");
    const udp = getProtocol("udp");
    const ip4 = getProtocol("ip4");
    const ip6 = getProtocol("ip6");
    const dns6 = getProtocol("dns6");
    const ip6zone = getProtocol("ip6zone");
    for (const [code10, value2] of this.stringTuples()) {
      if (code10 === ip6zone.code) {
        zone = `%${value2 ?? ""}`;
      }
      if (DNS_CODES.includes(code10)) {
        transport = tcp.name;
        port = 443;
        host = `${value2 ?? ""}${zone}`;
        family = code10 === dns6.code ? 6 : 4;
      }
      if (code10 === tcp.code || code10 === udp.code) {
        transport = getProtocol(code10).name;
        port = parseInt(value2 ?? "");
      }
      if (code10 === ip4.code || code10 === ip6.code) {
        transport = getProtocol(code10).name;
        host = `${value2 ?? ""}${zone}`;
        family = code10 === ip6.code ? 6 : 4;
      }
    }
    if (family == null || transport == null || host == null || port == null) {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
    }
    const opts = {
      family,
      host,
      transport,
      port
    };
    return opts;
  }
  protos() {
    return this.protoCodes().map((code10) => Object.assign({}, getProtocol(code10)));
  }
  protoCodes() {
    const codes2 = [];
    const buf2 = this.bytes;
    let i = 0;
    while (i < buf2.length) {
      const code10 = import_varint6.default.decode(buf2, i);
      const n2 = import_varint6.default.decode.bytes ?? 0;
      const p = getProtocol(code10);
      const size = sizeForAddr(p, buf2.slice(i + n2));
      i += size + n2;
      codes2.push(code10);
    }
    return codes2;
  }
  protoNames() {
    return this.protos().map((proto) => proto.name);
  }
  tuples() {
    if (__classPrivateFieldGet(this, _DefaultMultiaddr_tuples, "f") == null) {
      __classPrivateFieldSet(this, _DefaultMultiaddr_tuples, bytesToTuples(this.bytes), "f");
    }
    return __classPrivateFieldGet(this, _DefaultMultiaddr_tuples, "f");
  }
  stringTuples() {
    if (__classPrivateFieldGet(this, _DefaultMultiaddr_stringTuples, "f") == null) {
      __classPrivateFieldSet(this, _DefaultMultiaddr_stringTuples, tuplesToStringTuples(this.tuples()), "f");
    }
    return __classPrivateFieldGet(this, _DefaultMultiaddr_stringTuples, "f");
  }
  encapsulate(addr) {
    addr = new _DefaultMultiaddr(addr);
    return new _DefaultMultiaddr(this.toString() + addr.toString());
  }
  decapsulate(addr) {
    const addrString = addr.toString();
    const s = this.toString();
    const i = s.lastIndexOf(addrString);
    if (i < 0) {
      throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
    }
    return new _DefaultMultiaddr(s.slice(0, i));
  }
  decapsulateCode(code10) {
    const tuples = this.tuples();
    for (let i = tuples.length - 1; i >= 0; i--) {
      if (tuples[i][0] === code10) {
        return new _DefaultMultiaddr(tuplesToBytes(tuples.slice(0, i)));
      }
    }
    return this;
  }
  getPeerId() {
    try {
      const tuples = this.stringTuples().filter((tuple2) => {
        if (tuple2[0] === names.ipfs.code) {
          return true;
        }
        return false;
      });
      const tuple = tuples.pop();
      if (tuple?.[1] != null) {
        const peerIdStr = tuple[1];
        if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
          return toString5(base58btc2.decode(`z${peerIdStr}`), "base58btc");
        }
        return toString5(CID2.parse(peerIdStr).multihash.bytes, "base58btc");
      }
      return null;
    } catch (e) {
      return null;
    }
  }
  getPath() {
    let path = null;
    try {
      path = this.stringTuples().filter((tuple) => {
        const proto = getProtocol(tuple[0]);
        if (proto.path === true) {
          return true;
        }
        return false;
      })[0][1];
      if (path == null) {
        path = null;
      }
    } catch {
      path = null;
    }
    return path;
  }
  equals(addr) {
    return equals7(this.bytes, addr.bytes);
  }
  async resolve(options) {
    const resolvableProto = this.protos().find((p) => p.resolvable);
    if (resolvableProto == null) {
      return [this];
    }
    const resolver = resolvers.get(resolvableProto.name);
    if (resolver == null) {
      throw (0, import_err_code.default)(new Error(`no available resolver for ${resolvableProto.name}`), "ERR_NO_AVAILABLE_RESOLVER");
    }
    const addresses = await resolver(this, options);
    return addresses.map((a) => new _DefaultMultiaddr(a));
  }
  nodeAddress() {
    const options = this.toOptions();
    if (options.transport !== "tcp" && options.transport !== "udp") {
      throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
    }
    return {
      family: options.family,
      address: options.host,
      port: options.port
    };
  }
  isThinWaistAddress(addr) {
    const protos = (addr ?? this).protos();
    if (protos.length !== 2) {
      return false;
    }
    if (protos[0].code !== 4 && protos[0].code !== 41) {
      return false;
    }
    if (protos[1].code !== 6 && protos[1].code !== 273) {
      return false;
    }
    return true;
  }
  /**
   * Returns Multiaddr as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { multiaddr } from '@multiformats/multiaddr'
   *
   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
   * ```
   */
  [(_DefaultMultiaddr_string = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_tuples = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_stringTuples = /* @__PURE__ */ new WeakMap(), _a2 = symbol, inspect)]() {
    return `Multiaddr(${bytesToString(this.bytes)})`;
  }
};
function multiaddr(addr) {
  return new DefaultMultiaddr(addr);
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/lib/core.js
var import_env = __toESM(require_env(), 1);

// node_modules/.pnpm/parse-duration@1.1.2/node_modules/parse-duration/index.mjs
init_buffer_polyfill();
var durationRE = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig;
parse4.year = parse4.yr = parse4.y = 6e4 * 60 * 24 * 365.25;
parse4.month = parse4.b = 6e4 * 60 * 24 * (365.25 / 12);
parse4.week = parse4.wk = parse4.w = 6e4 * 60 * 24 * 7;
parse4.day = parse4.d = 6e4 * 60 * 24;
parse4.hour = parse4.hr = parse4.h = 6e4 * 60;
parse4.minute = parse4.min = parse4.m = 6e4;
parse4.second = parse4.sec = parse4.s = 1e3;
parse4.millisecond = parse4.millisec = parse4.ms = 1;
parse4["\xB5s"] = parse4["\u03BCs"] = parse4.us = parse4.microsecond = 1 / 1e3;
parse4.nanosecond = parse4.ns = 1 / 1e6;
function parse4(str = "", format5 = "ms") {
  var result = null, prevUnits;
  str = (str + "").replace(/(\d)[,_](\d)/g, "$1$2");
  str.replace(durationRE, function(_, n2, units) {
    if (!units) {
      if (prevUnits) {
        for (var u in parse4) if (parse4[u] < prevUnits) {
          units = u;
          break;
        }
      } else units = format5;
    } else units = units.toLowerCase();
    if (Object.prototype.hasOwnProperty.call(parse4, units)) {
      units = parse4[units];
    } else if (Object.prototype.hasOwnProperty.call(parse4, units.replace(/s$/, ""))) {
      units = parse4[units.replace(/s$/, "")];
    } else {
      units = null;
    }
    if (units) result = (result || 0) + Math.abs(parseFloat(n2, 10)) * units, prevUnits = units;
  });
  return result && result / (parse4[format5] || 1) * (str[0] === "-" ? -1 : 1);
}
var parse_duration_default = parse4;

// node_modules/.pnpm/@libp2p+logger@2.1.1/node_modules/@libp2p/logger/dist/src/index.js
init_buffer_polyfill();
var import_debug = __toESM(require_browser14(), 1);
import_debug.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc2.baseEncode(v);
};
import_debug.default.formatters.t = (v) => {
  return v == null ? "undefined" : base322.baseEncode(v);
};
import_debug.default.formatters.m = (v) => {
  return v == null ? "undefined" : base642.baseEncode(v);
};
import_debug.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger(namespace) {
  const logger2 = () => {
  };
  logger2.enabled = false;
  logger2.color = "";
  logger2.diff = 0;
  logger2.log = () => {
  };
  logger2.namespace = namespace;
  logger2.destroy = () => true;
  logger2.extend = () => logger2;
  return logger2;
}
function logger(name10) {
  let trace = createDisabledLogger(`${name10}:trace`);
  if (import_debug.default.enabled(`${name10}:trace`) && import_debug.default.names.map((r) => r.toString()).find((n2) => n2.includes(":trace")) != null) {
    trace = (0, import_debug.default)(`${name10}:trace`);
  }
  return Object.assign((0, import_debug.default)(name10), {
    error: (0, import_debug.default)(`${name10}:error`),
    trace
  });
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/lib/core.js
var import_http = __toESM(require_http(), 1);

// node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.mjs
init_buffer_polyfill();
var import_index3 = __toESM(require_merge_options(), 1);
var merge_options_default = import_index3.default;

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/to-url-string.js
init_buffer_polyfill();

// node_modules/.pnpm/@multiformats+multiaddr-to-uri@9.0.8/node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js
init_buffer_polyfill();

// node_modules/.pnpm/@multiformats+multiaddr@12.5.1/node_modules/@multiformats/multiaddr/dist/src/index.js
init_buffer_polyfill();

// node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/to-string.js
init_buffer_polyfill();

// node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/util/bases.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/basics.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports3 = {};
__export(base10_exports3, {
  base10: () => base103
});
init_buffer_polyfill();
var base103 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports3 = {};
__export(base16_exports3, {
  base16: () => base163,
  base16upper: () => base16upper3
});
init_buffer_polyfill();
var base163 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper3 = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports3 = {};
__export(base2_exports3, {
  base2: () => base24
});
init_buffer_polyfill();
var base24 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports3 = {};
__export(base256emoji_exports3, {
  base256emoji: () => base256emoji3
});
init_buffer_polyfill();
var alphabet4 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars3 = alphabet4.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes3 = alphabet4.reduce((p, c, i) => {
  const codePoint = c.codePointAt(0);
  if (codePoint == null) {
    throw new Error(`Invalid character: ${c}`);
  }
  p[codePoint] = i;
  return p;
}, []);
function encode40(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars3[c];
    return p;
  }, "");
}
function decode42(str) {
  const byts = [];
  for (const char of str) {
    const codePoint = char.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${char}`);
    }
    const byt = alphabetCharsToBytes3[codePoint];
    if (byt == null) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji3 = from({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode40,
  decode: decode42
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports3 = {};
__export(base8_exports3, {
  base8: () => base83
});
init_buffer_polyfill();
var base83 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports5 = {};
__export(identity_exports5, {
  identity: () => identity5
});
init_buffer_polyfill();
var identity5 = from({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString(buf2),
  decode: (str) => fromString(str)
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/codecs/json.js
init_buffer_polyfill();
var textEncoder6 = new TextEncoder();
var textDecoder5 = new TextDecoder();

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/codecs/raw.js
init_buffer_polyfill();

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports6 = {};
__export(identity_exports6, {
  identity: () => identity6
});
init_buffer_polyfill();
var code9 = 0;
var name9 = "identity";
var encode41 = coerce;
function digest3(input, options) {
  if (options?.truncate != null && options.truncate !== input.byteLength) {
    if (options.truncate < 0 || options.truncate > input.byteLength) {
      throw new Error(`Invalid truncate option, must be less than or equal to ${input.byteLength}`);
    }
    input = input.subarray(0, options.truncate);
  }
  return create(code9, encode41(input));
}
var identity6 = { code: code9, name: name9, encode: encode41, digest: digest3 };

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports3 = {};
__export(sha2_browser_exports3, {
  sha256: () => sha2566,
  sha512: () => sha5125
});
init_buffer_polyfill();
function sha3(name10) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name10, data));
}
var sha2566 = from2({
  name: "sha2-256",
  code: 18,
  encode: sha3("SHA-256")
});
var sha5125 = from2({
  name: "sha2-512",
  code: 19,
  encode: sha3("SHA-512")
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/basics.js
var bases3 = { ...identity_exports5, ...base2_exports3, ...base8_exports3, ...base10_exports3, ...base16_exports3, ...base32_exports, ...base36_exports, ...base58_exports, ...base64_exports, ...base256emoji_exports3 };
var hashes3 = { ...sha2_browser_exports3, ...identity_exports6 };

// node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/alloc.js
init_buffer_polyfill();
function allocUnsafe2(size = 0) {
  return new Uint8Array(size);
}

// node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec2(name10, prefix, encode42, decode44) {
  return {
    name: name10,
    prefix,
    encoder: {
      name: name10,
      prefix,
      encode: encode42
    },
    decoder: {
      decode: decode44
    }
  };
}
var string4 = createCodec2("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii2 = createCodec2("ascii", "a", (buf2) => {
  let string5 = "a";
  for (let i = 0; i < buf2.length; i++) {
    string5 += String.fromCharCode(buf2[i]);
  }
  return string5;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe2(str.length);
  for (let i = 0; i < str.length; i++) {
    buf2[i] = str.charCodeAt(i);
  }
  return buf2;
});
var BASES2 = {
  utf8: string4,
  "utf-8": string4,
  hex: bases3.base16,
  latin1: ascii2,
  ascii: ascii2,
  binary: ascii2,
  ...bases3
};
var bases_default2 = BASES2;

// node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/to-string.js
function toString7(array2, encoding = "utf8") {
  const base5 = bases_default2[encoding];
  if (base5 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base5.encoder.encode(array2).substring(1);
}

// node_modules/.pnpm/@multiformats+multiaddr@12.5.1/node_modules/@multiformats/multiaddr/dist/src/errors.js
init_buffer_polyfill();
var InvalidMultiaddrError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMultiaddrError");
  }
};
__publicField(InvalidMultiaddrError, "name", "InvalidMultiaddrError");
var ValidationError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "ValidationError");
  }
};
__publicField(ValidationError, "name", "ValidationError");
var InvalidParametersError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidParametersError");
  }
};
__publicField(InvalidParametersError, "name", "InvalidParametersError");
var UnknownProtocolError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnknownProtocolError");
  }
};
__publicField(UnknownProtocolError, "name", "UnknownProtocolError");

// node_modules/.pnpm/@multiformats+multiaddr@12.5.1/node_modules/@multiformats/multiaddr/dist/src/multiaddr.js
init_buffer_polyfill();

// node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/equals.js
init_buffer_polyfill();
function equals8(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/from-string.js
init_buffer_polyfill();
function fromString7(string5, encoding = "utf8") {
  const base5 = bases_default2[encoding];
  if (base5 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base5.decoder.decode(`${base5.prefix}${string5}`);
}

// node_modules/.pnpm/@multiformats+multiaddr@12.5.1/node_modules/@multiformats/multiaddr/dist/src/components.js
init_buffer_polyfill();

// node_modules/.pnpm/uint8-varint@2.0.4/node_modules/uint8-varint/dist/src/index.js
init_buffer_polyfill();
var N14 = Math.pow(2, 7);
var N24 = Math.pow(2, 14);
var N34 = Math.pow(2, 21);
var N44 = Math.pow(2, 28);
var N54 = Math.pow(2, 35);
var N64 = Math.pow(2, 42);
var N74 = Math.pow(2, 49);
var MSB4 = 128;
var REST4 = 127;
function encodingLength6(value2) {
  if (value2 < N14) {
    return 1;
  }
  if (value2 < N24) {
    return 2;
  }
  if (value2 < N34) {
    return 3;
  }
  if (value2 < N44) {
    return 4;
  }
  if (value2 < N54) {
    return 5;
  }
  if (value2 < N64) {
    return 6;
  }
  if (value2 < N74) {
    return 7;
  }
  if (Number.MAX_SAFE_INTEGER != null && value2 > Number.MAX_SAFE_INTEGER) {
    throw new RangeError("Could not encode varint");
  }
  return 8;
}
function encodeUint8Array(value2, buf2, offset = 0) {
  switch (encodingLength6(value2)) {
    case 8: {
      buf2[offset++] = value2 & 255 | MSB4;
      value2 /= 128;
    }
    case 7: {
      buf2[offset++] = value2 & 255 | MSB4;
      value2 /= 128;
    }
    case 6: {
      buf2[offset++] = value2 & 255 | MSB4;
      value2 /= 128;
    }
    case 5: {
      buf2[offset++] = value2 & 255 | MSB4;
      value2 /= 128;
    }
    case 4: {
      buf2[offset++] = value2 & 255 | MSB4;
      value2 >>>= 7;
    }
    case 3: {
      buf2[offset++] = value2 & 255 | MSB4;
      value2 >>>= 7;
    }
    case 2: {
      buf2[offset++] = value2 & 255 | MSB4;
      value2 >>>= 7;
    }
    case 1: {
      buf2[offset++] = value2 & 255;
      value2 >>>= 7;
      break;
    }
    default:
      throw new Error("unreachable");
  }
  return buf2;
}
function decodeUint8Array(buf2, offset) {
  let b = buf2[offset];
  let res = 0;
  res += b & REST4;
  if (b < MSB4) {
    return res;
  }
  b = buf2[offset + 1];
  res += (b & REST4) << 7;
  if (b < MSB4) {
    return res;
  }
  b = buf2[offset + 2];
  res += (b & REST4) << 14;
  if (b < MSB4) {
    return res;
  }
  b = buf2[offset + 3];
  res += (b & REST4) << 21;
  if (b < MSB4) {
    return res;
  }
  b = buf2[offset + 4];
  res += (b & REST4) * N44;
  if (b < MSB4) {
    return res;
  }
  b = buf2[offset + 5];
  res += (b & REST4) * N54;
  if (b < MSB4) {
    return res;
  }
  b = buf2[offset + 6];
  res += (b & REST4) * N64;
  if (b < MSB4) {
    return res;
  }
  b = buf2[offset + 7];
  res += (b & REST4) * N74;
  if (b < MSB4) {
    return res;
  }
  throw new RangeError("Could not decode varint");
}
function decodeUint8ArrayList(buf2, offset) {
  let b = buf2.get(offset);
  let res = 0;
  res += b & REST4;
  if (b < MSB4) {
    return res;
  }
  b = buf2.get(offset + 1);
  res += (b & REST4) << 7;
  if (b < MSB4) {
    return res;
  }
  b = buf2.get(offset + 2);
  res += (b & REST4) << 14;
  if (b < MSB4) {
    return res;
  }
  b = buf2.get(offset + 3);
  res += (b & REST4) << 21;
  if (b < MSB4) {
    return res;
  }
  b = buf2.get(offset + 4);
  res += (b & REST4) * N44;
  if (b < MSB4) {
    return res;
  }
  b = buf2.get(offset + 5);
  res += (b & REST4) * N54;
  if (b < MSB4) {
    return res;
  }
  b = buf2.get(offset + 6);
  res += (b & REST4) * N64;
  if (b < MSB4) {
    return res;
  }
  b = buf2.get(offset + 7);
  res += (b & REST4) * N74;
  if (b < MSB4) {
    return res;
  }
  throw new RangeError("Could not decode varint");
}
function decode43(buf2, offset = 0) {
  if (buf2 instanceof Uint8Array) {
    return decodeUint8Array(buf2, offset);
  } else {
    return decodeUint8ArrayList(buf2, offset);
  }
}

// node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/concat.js
init_buffer_polyfill();

// node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/util/as-uint8array.js
init_buffer_polyfill();
function asUint8Array2(buf2) {
  return buf2;
}

// node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/concat.js
function concat5(arrays, length6) {
  if (length6 == null) {
    length6 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe2(length6);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array2(output);
}

// node_modules/.pnpm/@multiformats+multiaddr@12.5.1/node_modules/@multiformats/multiaddr/dist/src/registry.js
init_buffer_polyfill();

// node_modules/.pnpm/@multiformats+multiaddr@12.5.1/node_modules/@multiformats/multiaddr/dist/src/constants.js
init_buffer_polyfill();
var CODE_IP4 = 4;
var CODE_TCP = 6;
var CODE_UDP = 273;
var CODE_DCCP = 33;
var CODE_IP6 = 41;
var CODE_IP6ZONE = 42;
var CODE_IPCIDR = 43;
var CODE_DNS = 53;
var CODE_DNS4 = 54;
var CODE_DNS6 = 55;
var CODE_DNSADDR = 56;
var CODE_SCTP = 132;
var CODE_UDT = 301;
var CODE_UTP = 302;
var CODE_UNIX = 400;
var CODE_P2P = 421;
var CODE_ONION = 444;
var CODE_ONION3 = 445;
var CODE_GARLIC64 = 446;
var CODE_GARLIC32 = 447;
var CODE_TLS = 448;
var CODE_SNI = 449;
var CODE_NOISE = 454;
var CODE_QUIC = 460;
var CODE_QUIC_V1 = 461;
var CODE_WEBTRANSPORT = 465;
var CODE_CERTHASH = 466;
var CODE_HTTP = 480;
var CODE_HTTP_PATH = 481;
var CODE_HTTPS = 443;
var CODE_WS = 477;
var CODE_WSS = 478;
var CODE_P2P_WEBSOCKET_STAR = 479;
var CODE_P2P_STARDUST = 277;
var CODE_P2P_WEBRTC_STAR = 275;
var CODE_P2P_WEBRTC_DIRECT = 276;
var CODE_WEBRTC_DIRECT = 280;
var CODE_WEBRTC = 281;
var CODE_P2P_CIRCUIT = 290;
var CODE_MEMORY = 777;

// node_modules/.pnpm/@multiformats+multiaddr@12.5.1/node_modules/@multiformats/multiaddr/dist/src/utils.js
init_buffer_polyfill();
function bytesToString2(base5) {
  return (buf2) => {
    return toString7(buf2, base5);
  };
}
function stringToBytes2(base5) {
  return (buf2) => {
    return fromString7(buf2, base5);
  };
}
function bytes2port2(buf2) {
  const view = new DataView(buf2.buffer);
  return view.getUint16(buf2.byteOffset).toString();
}
function port2bytes2(port) {
  const buf2 = new ArrayBuffer(2);
  const view = new DataView(buf2);
  view.setUint16(0, typeof port === "string" ? parseInt(port) : port);
  return new Uint8Array(buf2);
}
function onion2bytes2(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf2 = fromString7(addr[0], "base32");
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes2(port);
  return concat5([buf2, portBuf], buf2.length + portBuf.length);
}
function onion32bytes2(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf2 = base32.decode(`b${addr[0]}`);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes2(port);
  return concat5([buf2, portBuf], buf2.length + portBuf.length);
}
function bytes2onion2(buf2) {
  const addrBytes = buf2.subarray(0, buf2.length - 2);
  const portBytes = buf2.subarray(buf2.length - 2);
  const addr = toString7(addrBytes, "base32");
  const port = bytes2port2(portBytes);
  return `${addr}:${port}`;
}
var ip4ToBytes = function(ip) {
  ip = ip.toString().trim();
  const bytes = new Uint8Array(4);
  ip.split(/\./g).forEach((byte, index) => {
    const value2 = parseInt(byte, 10);
    if (isNaN(value2) || value2 < 0 || value2 > 255) {
      throw new InvalidMultiaddrError("Invalid byte value in IP address");
    }
    bytes[index] = value2;
  });
  return bytes;
};
var ip6ToBytes = function(ip) {
  let offset = 0;
  ip = ip.toString().trim();
  const sections = ip.split(":", 8);
  let i;
  for (i = 0; i < sections.length; i++) {
    const isv4 = isIPv4(sections[i]);
    let v4Buffer;
    if (isv4) {
      v4Buffer = ip4ToBytes(sections[i]);
      sections[i] = toString7(v4Buffer.subarray(0, 2), "base16");
    }
    if (v4Buffer != null && ++i < 8) {
      sections.splice(i, 0, toString7(v4Buffer.subarray(2, 4), "base16"));
    }
  }
  if (sections[0] === "") {
    while (sections.length < 8) {
      sections.unshift("0");
    }
  } else if (sections[sections.length - 1] === "") {
    while (sections.length < 8) {
      sections.push("0");
    }
  } else if (sections.length < 8) {
    for (i = 0; i < sections.length && sections[i] !== ""; i++) {
    }
    const argv = [i, 1];
    for (i = 9 - sections.length; i > 0; i--) {
      argv.push("0");
    }
    sections.splice.apply(sections, argv);
  }
  const bytes = new Uint8Array(offset + 16);
  for (i = 0; i < sections.length; i++) {
    if (sections[i] === "") {
      sections[i] = "0";
    }
    const word = parseInt(sections[i], 16);
    if (isNaN(word) || word < 0 || word > 65535) {
      throw new InvalidMultiaddrError("Invalid byte value in IP address");
    }
    bytes[offset++] = word >> 8 & 255;
    bytes[offset++] = word & 255;
  }
  return bytes;
};
var ip4ToString = function(buf2) {
  if (buf2.byteLength !== 4) {
    throw new InvalidMultiaddrError("IPv4 address was incorrect length");
  }
  const result = [];
  for (let i = 0; i < buf2.byteLength; i++) {
    result.push(buf2[i]);
  }
  return result.join(".");
};
var ip6ToString = function(buf2) {
  if (buf2.byteLength !== 16) {
    throw new InvalidMultiaddrError("IPv6 address was incorrect length");
  }
  const result = [];
  for (let i = 0; i < buf2.byteLength; i += 2) {
    const byte1 = buf2[i];
    const byte2 = buf2[i + 1];
    const tuple = `${byte1.toString(16).padStart(2, "0")}${byte2.toString(16).padStart(2, "0")}`;
    result.push(tuple);
  }
  const ip = result.join(":");
  try {
    const url = new URL(`http://[${ip}]`);
    return url.hostname.substring(1, url.hostname.length - 1);
  } catch {
    throw new InvalidMultiaddrError(`Invalid IPv6 address "${ip}"`);
  }
};
function ip6StringToValue(str) {
  try {
    const url = new URL(`http://[${str}]`);
    return url.hostname.substring(1, url.hostname.length - 1);
  } catch {
    throw new InvalidMultiaddrError(`Invalid IPv6 address "${str}"`);
  }
}
var decoders2 = Object.values(bases3).map((c) => c.decoder);
var anybaseDecoder2 = (function() {
  let acc = decoders2[0].or(decoders2[1]);
  decoders2.slice(2).forEach((d) => acc = acc.or(d));
  return acc;
})();
function mb2bytes2(mbstr) {
  return anybaseDecoder2.decode(mbstr);
}
function bytes2mb2(base5) {
  return (buf2) => {
    return base5.encoder.encode(buf2);
  };
}

// node_modules/.pnpm/@multiformats+multiaddr@12.5.1/node_modules/@multiformats/multiaddr/dist/src/validation.js
init_buffer_polyfill();
function integer3(value2) {
  const int = parseInt(value2);
  if (int.toString() !== value2) {
    throw new ValidationError("Value must be an integer");
  }
}
function positive(value2) {
  if (value2 < 0) {
    throw new ValidationError("Value must be a positive integer, or zero");
  }
}
function maxValue3(max) {
  return (value2) => {
    if (value2 > max) {
      throw new ValidationError(`Value must be smaller than or equal to ${max}`);
    }
  };
}
function validate2(...funcs) {
  return (value2) => {
    for (const fn of funcs) {
      fn(value2);
    }
  };
}
var validatePort = validate2(integer3, positive, maxValue3(65535));

// node_modules/.pnpm/@multiformats+multiaddr@12.5.1/node_modules/@multiformats/multiaddr/dist/src/registry.js
var V2 = -1;
var Registry = class {
  constructor() {
    __publicField(this, "protocolsByCode", /* @__PURE__ */ new Map());
    __publicField(this, "protocolsByName", /* @__PURE__ */ new Map());
  }
  getProtocol(key) {
    let codec;
    if (typeof key === "string") {
      codec = this.protocolsByName.get(key);
    } else {
      codec = this.protocolsByCode.get(key);
    }
    if (codec == null) {
      throw new UnknownProtocolError(`Protocol ${key} was unknown`);
    }
    return codec;
  }
  addProtocol(codec) {
    this.protocolsByCode.set(codec.code, codec);
    this.protocolsByName.set(codec.name, codec);
    codec.aliases?.forEach((alias) => {
      this.protocolsByName.set(alias, codec);
    });
  }
  removeProtocol(code10) {
    const codec = this.protocolsByCode.get(code10);
    if (codec == null) {
      return;
    }
    this.protocolsByCode.delete(codec.code);
    this.protocolsByName.delete(codec.name);
    codec.aliases?.forEach((alias) => {
      this.protocolsByName.delete(alias);
    });
  }
};
var registry = new Registry();
var codecs2 = [{
  code: CODE_IP4,
  name: "ip4",
  size: 32,
  valueToBytes: ip4ToBytes,
  bytesToValue: ip4ToString,
  validate: (value2) => {
    if (!isIPv4(value2)) {
      throw new ValidationError(`Invalid IPv4 address "${value2}"`);
    }
  }
}, {
  code: CODE_TCP,
  name: "tcp",
  size: 16,
  valueToBytes: port2bytes2,
  bytesToValue: bytes2port2,
  validate: validatePort
}, {
  code: CODE_UDP,
  name: "udp",
  size: 16,
  valueToBytes: port2bytes2,
  bytesToValue: bytes2port2,
  validate: validatePort
}, {
  code: CODE_DCCP,
  name: "dccp",
  size: 16,
  valueToBytes: port2bytes2,
  bytesToValue: bytes2port2,
  validate: validatePort
}, {
  code: CODE_IP6,
  name: "ip6",
  size: 128,
  valueToBytes: ip6ToBytes,
  bytesToValue: ip6ToString,
  stringToValue: ip6StringToValue,
  validate: (value2) => {
    if (!isIPv6(value2)) {
      throw new ValidationError(`Invalid IPv6 address "${value2}"`);
    }
  }
}, {
  code: CODE_IP6ZONE,
  name: "ip6zone",
  size: V2
}, {
  code: CODE_IPCIDR,
  name: "ipcidr",
  size: 8,
  bytesToValue: bytesToString2("base10"),
  valueToBytes: stringToBytes2("base10")
}, {
  code: CODE_DNS,
  name: "dns",
  size: V2,
  resolvable: true
}, {
  code: CODE_DNS4,
  name: "dns4",
  size: V2,
  resolvable: true
}, {
  code: CODE_DNS6,
  name: "dns6",
  size: V2,
  resolvable: true
}, {
  code: CODE_DNSADDR,
  name: "dnsaddr",
  size: V2,
  resolvable: true
}, {
  code: CODE_SCTP,
  name: "sctp",
  size: 16,
  valueToBytes: port2bytes2,
  bytesToValue: bytes2port2,
  validate: validatePort
}, {
  code: CODE_UDT,
  name: "udt"
}, {
  code: CODE_UTP,
  name: "utp"
}, {
  code: CODE_UNIX,
  name: "unix",
  size: V2,
  path: true,
  stringToValue: (str) => decodeURIComponent(str),
  valueToString: (val) => encodeURIComponent(val)
}, {
  code: CODE_P2P,
  name: "p2p",
  aliases: ["ipfs"],
  size: V2,
  bytesToValue: bytesToString2("base58btc"),
  valueToBytes: (val) => {
    if (val.startsWith("Q") || val.startsWith("1")) {
      return stringToBytes2("base58btc")(val);
    }
    return CID.parse(val).multihash.bytes;
  }
}, {
  code: CODE_ONION,
  name: "onion",
  size: 96,
  bytesToValue: bytes2onion2,
  valueToBytes: onion2bytes2
}, {
  code: CODE_ONION3,
  name: "onion3",
  size: 296,
  bytesToValue: bytes2onion2,
  valueToBytes: onion32bytes2
}, {
  code: CODE_GARLIC64,
  name: "garlic64",
  size: V2
}, {
  code: CODE_GARLIC32,
  name: "garlic32",
  size: V2
}, {
  code: CODE_TLS,
  name: "tls"
}, {
  code: CODE_SNI,
  name: "sni",
  size: V2
}, {
  code: CODE_NOISE,
  name: "noise"
}, {
  code: CODE_QUIC,
  name: "quic"
}, {
  code: CODE_QUIC_V1,
  name: "quic-v1"
}, {
  code: CODE_WEBTRANSPORT,
  name: "webtransport"
}, {
  code: CODE_CERTHASH,
  name: "certhash",
  size: V2,
  bytesToValue: bytes2mb2(base64url),
  valueToBytes: mb2bytes2
}, {
  code: CODE_HTTP,
  name: "http"
}, {
  code: CODE_HTTP_PATH,
  name: "http-path",
  size: V2,
  stringToValue: (str) => `/${decodeURIComponent(str)}`,
  valueToString: (val) => encodeURIComponent(val.substring(1))
}, {
  code: CODE_HTTPS,
  name: "https"
}, {
  code: CODE_WS,
  name: "ws"
}, {
  code: CODE_WSS,
  name: "wss"
}, {
  code: CODE_P2P_WEBSOCKET_STAR,
  name: "p2p-websocket-star"
}, {
  code: CODE_P2P_STARDUST,
  name: "p2p-stardust"
}, {
  code: CODE_P2P_WEBRTC_STAR,
  name: "p2p-webrtc-star"
}, {
  code: CODE_P2P_WEBRTC_DIRECT,
  name: "p2p-webrtc-direct"
}, {
  code: CODE_WEBRTC_DIRECT,
  name: "webrtc-direct"
}, {
  code: CODE_WEBRTC,
  name: "webrtc"
}, {
  code: CODE_P2P_CIRCUIT,
  name: "p2p-circuit"
}, {
  code: CODE_MEMORY,
  name: "memory",
  size: V2
}];
codecs2.forEach((codec) => {
  registry.addProtocol(codec);
});

// node_modules/.pnpm/@multiformats+multiaddr@12.5.1/node_modules/@multiformats/multiaddr/dist/src/components.js
function bytesToComponents(bytes) {
  const components = [];
  let i = 0;
  while (i < bytes.length) {
    const code10 = decode43(bytes, i);
    const codec = registry.getProtocol(code10);
    const codeLength = encodingLength6(code10);
    const size = sizeForAddr2(codec, bytes, i + codeLength);
    let sizeLength = 0;
    if (size > 0 && codec.size === V2) {
      sizeLength = encodingLength6(size);
    }
    const componentLength = codeLength + sizeLength + size;
    const component = {
      code: code10,
      name: codec.name,
      bytes: bytes.subarray(i, i + componentLength)
    };
    if (size > 0) {
      const valueOffset = i + codeLength + sizeLength;
      const valueBytes = bytes.subarray(valueOffset, valueOffset + size);
      component.value = codec.bytesToValue?.(valueBytes) ?? toString7(valueBytes);
    }
    components.push(component);
    i += componentLength;
  }
  return components;
}
function componentsToBytes(components) {
  let length6 = 0;
  const bytes = [];
  for (const component of components) {
    if (component.bytes == null) {
      const codec = registry.getProtocol(component.code);
      const codecLength = encodingLength6(component.code);
      let valueBytes;
      let valueLength = 0;
      let valueLengthLength = 0;
      if (component.value != null) {
        valueBytes = codec.valueToBytes?.(component.value) ?? fromString7(component.value);
        valueLength = valueBytes.byteLength;
        if (codec.size === V2) {
          valueLengthLength = encodingLength6(valueLength);
        }
      }
      const bytes2 = new Uint8Array(codecLength + valueLengthLength + valueLength);
      let offset = 0;
      encodeUint8Array(component.code, bytes2, offset);
      offset += codecLength;
      if (valueBytes != null) {
        if (codec.size === V2) {
          encodeUint8Array(valueLength, bytes2, offset);
          offset += valueLengthLength;
        }
        bytes2.set(valueBytes, offset);
      }
      component.bytes = bytes2;
    }
    bytes.push(component.bytes);
    length6 += component.bytes.byteLength;
  }
  return concat5(bytes, length6);
}
function stringToComponents(string5) {
  if (string5.charAt(0) !== "/") {
    throw new InvalidMultiaddrError('String multiaddr must start with "/"');
  }
  const components = [];
  let collecting = "protocol";
  let value2 = "";
  let protocol = "";
  for (let i = 1; i < string5.length; i++) {
    const char = string5.charAt(i);
    if (char !== "/") {
      if (collecting === "protocol") {
        protocol += string5.charAt(i);
      } else {
        value2 += string5.charAt(i);
      }
    }
    const ended = i === string5.length - 1;
    if (char === "/" || ended) {
      const codec = registry.getProtocol(protocol);
      if (collecting === "protocol") {
        if (codec.size == null || codec.size === 0) {
          components.push({
            code: codec.code,
            name: codec.name
          });
          value2 = "";
          protocol = "";
          collecting = "protocol";
          continue;
        } else if (ended) {
          throw new InvalidMultiaddrError(`Component ${protocol} was missing value`);
        }
        collecting = "value";
      } else if (collecting === "value") {
        const component = {
          code: codec.code,
          name: codec.name
        };
        if (codec.size != null && codec.size !== 0) {
          if (value2 === "") {
            throw new InvalidMultiaddrError(`Component ${protocol} was missing value`);
          }
          component.value = codec.stringToValue?.(value2) ?? value2;
        }
        components.push(component);
        value2 = "";
        protocol = "";
        collecting = "protocol";
      }
    }
  }
  if (protocol !== "" && value2 !== "") {
    throw new InvalidMultiaddrError("Incomplete multiaddr");
  }
  return components;
}
function componentsToString(components) {
  return `/${components.flatMap((component) => {
    if (component.value == null) {
      return component.name;
    }
    const codec = registry.getProtocol(component.code);
    if (codec == null) {
      throw new InvalidMultiaddrError(`Unknown protocol code ${component.code}`);
    }
    return [
      component.name,
      codec.valueToString?.(component.value) ?? component.value
    ];
  }).join("/")}`;
}
function sizeForAddr2(codec, bytes, offset) {
  if (codec.size == null || codec.size === 0) {
    return 0;
  }
  if (codec.size > 0) {
    return codec.size / 8;
  }
  return decode43(bytes, offset);
}

// node_modules/.pnpm/@multiformats+multiaddr@12.5.1/node_modules/@multiformats/multiaddr/dist/src/multiaddr.js
var inspect2 = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var symbol2 = /* @__PURE__ */ Symbol.for("@multiformats/multiaddr");
var DNS_CODES2 = [
  CODE_DNS,
  CODE_DNS4,
  CODE_DNS6,
  CODE_DNSADDR
];
var NoAvailableResolverError = class extends Error {
  constructor(message = "No available resolver") {
    super(message);
    this.name = "NoAvailableResolverError";
  }
};
function toComponents(addr) {
  if (addr == null) {
    addr = "/";
  }
  if (isMultiaddr2(addr)) {
    return addr.getComponents();
  }
  if (addr instanceof Uint8Array) {
    return bytesToComponents(addr);
  }
  if (typeof addr === "string") {
    addr = addr.replace(/\/(\/)+/, "/").replace(/(\/)+$/, "");
    if (addr === "") {
      addr = "/";
    }
    return stringToComponents(addr);
  }
  if (Array.isArray(addr)) {
    return addr;
  }
  throw new InvalidMultiaddrError("Must be a string, Uint8Array, Component[], or another Multiaddr");
}
var _a3, _components, _string, _bytes;
var _Multiaddr = class _Multiaddr {
  constructor(addr = "/", options = {}) {
    __publicField(this, _a3, true);
    __privateAdd(this, _components);
    // cache string representation
    __privateAdd(this, _string);
    // cache byte representation
    __privateAdd(this, _bytes);
    __privateSet(this, _components, toComponents(addr));
    if (options.validate !== false) {
      validate3(this);
    }
  }
  get bytes() {
    if (__privateGet(this, _bytes) == null) {
      __privateSet(this, _bytes, componentsToBytes(__privateGet(this, _components)));
    }
    return __privateGet(this, _bytes);
  }
  toString() {
    if (__privateGet(this, _string) == null) {
      __privateSet(this, _string, componentsToString(__privateGet(this, _components)));
    }
    return __privateGet(this, _string);
  }
  toJSON() {
    return this.toString();
  }
  toOptions() {
    let family;
    let transport;
    let host;
    let port;
    let zone = "";
    for (const { code: code10, name: name10, value: value2 } of __privateGet(this, _components)) {
      if (code10 === CODE_IP6ZONE) {
        zone = `%${value2 ?? ""}`;
      }
      if (DNS_CODES2.includes(code10)) {
        transport = "tcp";
        port = 443;
        host = `${value2 ?? ""}${zone}`;
        family = code10 === CODE_DNS6 ? 6 : 4;
      }
      if (code10 === CODE_TCP || code10 === CODE_UDP) {
        transport = name10 === "tcp" ? "tcp" : "udp";
        port = parseInt(value2 ?? "");
      }
      if (code10 === CODE_IP4 || code10 === CODE_IP6) {
        transport = "tcp";
        host = `${value2 ?? ""}${zone}`;
        family = code10 === CODE_IP6 ? 6 : 4;
      }
    }
    if (family == null || transport == null || host == null || port == null) {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
    }
    const opts = {
      family,
      host,
      transport,
      port
    };
    return opts;
  }
  getComponents() {
    return [
      ...__privateGet(this, _components)
    ];
  }
  protos() {
    return __privateGet(this, _components).map(({ code: code10, value: value2 }) => {
      const codec = registry.getProtocol(code10);
      return {
        code: code10,
        size: codec.size ?? 0,
        name: codec.name,
        resolvable: Boolean(codec.resolvable),
        path: Boolean(codec.path)
      };
    });
  }
  protoCodes() {
    return __privateGet(this, _components).map(({ code: code10 }) => code10);
  }
  protoNames() {
    return __privateGet(this, _components).map(({ name: name10 }) => name10);
  }
  tuples() {
    return __privateGet(this, _components).map(({ code: code10, value: value2 }) => {
      if (value2 == null) {
        return [code10];
      }
      const codec = registry.getProtocol(code10);
      const output = [code10];
      if (value2 != null) {
        output.push(codec.valueToBytes?.(value2) ?? fromString7(value2));
      }
      return output;
    });
  }
  stringTuples() {
    return __privateGet(this, _components).map(({ code: code10, value: value2 }) => {
      if (value2 == null) {
        return [code10];
      }
      return [code10, value2];
    });
  }
  encapsulate(addr) {
    const ma = new _Multiaddr(addr);
    return new _Multiaddr([
      ...__privateGet(this, _components),
      ...ma.getComponents()
    ], {
      validate: false
    });
  }
  decapsulate(addr) {
    const addrString = addr.toString();
    const s = this.toString();
    const i = s.lastIndexOf(addrString);
    if (i < 0) {
      throw new InvalidParametersError(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
    }
    return new _Multiaddr(s.slice(0, i), {
      validate: false
    });
  }
  decapsulateCode(code10) {
    let index;
    for (let i = __privateGet(this, _components).length - 1; i > -1; i--) {
      if (__privateGet(this, _components)[i].code === code10) {
        index = i;
        break;
      }
    }
    return new _Multiaddr(__privateGet(this, _components).slice(0, index), {
      validate: false
    });
  }
  getPeerId() {
    try {
      let tuples = [];
      __privateGet(this, _components).forEach(({ code: code10, value: value2 }) => {
        if (code10 === CODE_P2P) {
          tuples.push([code10, value2]);
        }
        if (code10 === CODE_P2P_CIRCUIT) {
          tuples = [];
        }
      });
      const tuple = tuples.pop();
      if (tuple?.[1] != null) {
        const peerIdStr = tuple[1];
        if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
          return toString7(base58btc.decode(`z${peerIdStr}`), "base58btc");
        }
        return toString7(CID.parse(peerIdStr).multihash.bytes, "base58btc");
      }
      return null;
    } catch (e) {
      return null;
    }
  }
  getPath() {
    for (const component of __privateGet(this, _components)) {
      const codec = registry.getProtocol(component.code);
      if (!codec.path) {
        continue;
      }
      return component.value ?? null;
    }
    return null;
  }
  equals(addr) {
    return equals8(this.bytes, addr.bytes);
  }
  async resolve(options) {
    const resolvableProto = this.protos().find((p) => p.resolvable);
    if (resolvableProto == null) {
      return [this];
    }
    const resolver = resolvers2.get(resolvableProto.name);
    if (resolver == null) {
      throw new NoAvailableResolverError(`no available resolver for ${resolvableProto.name}`);
    }
    const result = await resolver(this, options);
    return result.map((str) => multiaddr2(str));
  }
  nodeAddress() {
    const options = this.toOptions();
    if (options.transport !== "tcp" && options.transport !== "udp") {
      throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
    }
    return {
      family: options.family,
      address: options.host,
      port: options.port
    };
  }
  isThinWaistAddress() {
    if (__privateGet(this, _components).length !== 2) {
      return false;
    }
    if (__privateGet(this, _components)[0].code !== CODE_IP4 && __privateGet(this, _components)[0].code !== CODE_IP6) {
      return false;
    }
    if (__privateGet(this, _components)[1].code !== CODE_TCP && __privateGet(this, _components)[1].code !== CODE_UDP) {
      return false;
    }
    return true;
  }
  /**
   * Returns Multiaddr as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { multiaddr } from '@multiformats/multiaddr'
   *
   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
   * ```
   */
  [(_a3 = symbol2, inspect2)]() {
    return `Multiaddr(${this.toString()})`;
  }
};
_components = new WeakMap();
_string = new WeakMap();
_bytes = new WeakMap();
var Multiaddr = _Multiaddr;
function validate3(addr) {
  addr.getComponents().forEach((component) => {
    const codec = registry.getProtocol(component.code);
    if (component.value == null) {
      return;
    }
    codec.validate?.(component.value);
  });
}

// node_modules/.pnpm/@multiformats+multiaddr@12.5.1/node_modules/@multiformats/multiaddr/dist/src/filter/multiaddr-filter.js
init_buffer_polyfill();

// node_modules/.pnpm/@multiformats+multiaddr@12.5.1/node_modules/@multiformats/multiaddr/dist/src/convert.js
init_buffer_polyfill();

// node_modules/.pnpm/@chainsafe+netmask@2.0.0/node_modules/@chainsafe/netmask/dist/src/index.js
init_buffer_polyfill();

// node_modules/.pnpm/@chainsafe+netmask@2.0.0/node_modules/@chainsafe/netmask/dist/src/ipnet.js
init_buffer_polyfill();

// node_modules/.pnpm/@chainsafe+netmask@2.0.0/node_modules/@chainsafe/netmask/dist/src/cidr.js
init_buffer_polyfill();

// node_modules/.pnpm/@chainsafe+netmask@2.0.0/node_modules/@chainsafe/netmask/dist/src/ip.js
init_buffer_polyfill();

// node_modules/.pnpm/@chainsafe+netmask@2.0.0/node_modules/@chainsafe/netmask/dist/src/util.js
init_buffer_polyfill();

// node_modules/.pnpm/@chainsafe+netmask@2.0.0/node_modules/@chainsafe/netmask/dist/src/ip.js
var maxIPv6Octet = parseInt("0xFFFF", 16);
var ipv4Prefix = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  255,
  255
]);

// node_modules/.pnpm/@multiformats+multiaddr@12.5.1/node_modules/@multiformats/multiaddr/dist/src/index.js
var resolvers2 = /* @__PURE__ */ new Map();
function isMultiaddr2(value2) {
  return Boolean(value2?.[symbol2]);
}
function multiaddr2(addr) {
  return new Multiaddr(addr);
}
function protocols(proto) {
  const codec = registry.getProtocol(proto);
  return {
    code: codec.code,
    size: codec.size ?? 0,
    name: codec.name,
    resolvable: Boolean(codec.resolvable),
    path: Boolean(codec.path)
  };
}

// node_modules/.pnpm/@multiformats+multiaddr-to-uri@9.0.8/node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js
function extractSNI(ma) {
  let sniProtoCode;
  try {
    sniProtoCode = protocols("sni").code;
  } catch (e) {
    return null;
  }
  for (const [proto, value2] of ma) {
    if (proto === sniProtoCode && value2 !== void 0) {
      return value2;
    }
  }
  return null;
}
function hasTLS(ma) {
  return ma.some(([proto, _]) => proto === protocols("tls").code);
}
function interpretNext(headProtoCode, headProtoVal, restMa) {
  const interpreter = interpreters[protocols(headProtoCode).name];
  if (interpreter === void 0) {
    throw new Error(`Can't interpret protocol ${protocols(headProtoCode).name}`);
  }
  const restVal = interpreter(headProtoVal, restMa);
  if (headProtoCode === protocols("ip6").code) {
    return `[${restVal}]`;
  }
  return restVal;
}
var interpreters = {
  ip4: (value2, restMa) => value2,
  ip6: (value2, restMa) => {
    if (restMa.length === 0) {
      return value2;
    }
    return `[${value2}]`;
  },
  tcp: (value2, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `tcp://${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}:${value2}`;
  },
  udp: (value2, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `udp://${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}:${value2}`;
  },
  dnsaddr: (value2, restMa) => value2,
  dns4: (value2, restMa) => value2,
  dns6: (value2, restMa) => value2,
  dns: (value2, restMa) => value2,
  ipfs: (value2, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/ipfs/${value2}`;
  },
  p2p: (value2, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p/${value2}`;
  },
  http: (value2, restMa) => {
    const maHasTLS = hasTLS(restMa);
    const sni = extractSNI(restMa);
    if (maHasTLS && sni !== null) {
      return `https://${sni}`;
    }
    const protocol = maHasTLS ? "https://" : "http://";
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  tls: (value2, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
  },
  sni: (value2, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
  },
  https: (value2, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `https://${baseVal}`;
  },
  ws: (value2, restMa) => {
    const maHasTLS = hasTLS(restMa);
    const sni = extractSNI(restMa);
    if (maHasTLS && sni !== null) {
      return `wss://${sni}`;
    }
    const protocol = maHasTLS ? "wss://" : "ws://";
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  wss: (value2, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `wss://${baseVal}`;
  },
  "p2p-websocket-star": (value2, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-websocket-star`;
  },
  "p2p-webrtc-star": (value2, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-webrtc-star`;
  },
  "p2p-webrtc-direct": (value2, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-webrtc-direct`;
  }
};
function multiaddrToUri(input, opts) {
  const ma = multiaddr2(input);
  const parts = ma.stringTuples();
  const head = parts.pop();
  if (head === void 0) {
    throw new Error("Unexpected end of multiaddr");
  }
  const protocol = protocols(head[0]);
  const interpreter = interpreters[protocol.name];
  if (interpreter == null) {
    throw new Error(`No interpreter found for ${protocol.name}`);
  }
  let uri = interpreter(head[1] ?? "", parts);
  if (opts?.assumeHttp !== false && head[0] === protocols("tcp").code) {
    uri = uri.replace("tcp://", "http://");
    if (head[1] === "443" || head[1] === "80") {
      if (head[1] === "443") {
        uri = uri.replace("http://", "https://");
      }
      uri = uri.substring(0, uri.lastIndexOf(":"));
    }
  }
  return uri;
}

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/to-url-string.js
function toUrlString(url) {
  try {
    url = multiaddrToUri(multiaddr(url));
  } catch (err) {
  }
  url = url.toString();
  return url;
}

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/agent.browser.js
init_buffer_polyfill();
var agent_browser_default = () => {
};

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/lib/core.js
var log = logger("ipfs-http-client:lib:error-handler");
var merge = merge_options_default.bind({ ignoreUndefined: true });
var DEFAULT_PROTOCOL = import_env.isBrowser || import_env.isWebWorker ? location.protocol : "http";
var DEFAULT_HOST = import_env.isBrowser || import_env.isWebWorker ? location.hostname : "localhost";
var DEFAULT_PORT = import_env.isBrowser || import_env.isWebWorker ? location.port : "5001";
var normalizeOptions = (options = {}) => {
  let url;
  let opts = {};
  let agent;
  if (typeof options === "string" || isMultiaddr(options)) {
    url = new URL(toUrlString(options));
  } else if (options instanceof URL) {
    url = options;
  } else if (typeof options.url === "string" || isMultiaddr(options.url)) {
    url = new URL(toUrlString(options.url));
    opts = options;
  } else if (options.url instanceof URL) {
    url = options.url;
    opts = options;
  } else {
    opts = options || {};
    const protocol = (opts.protocol || DEFAULT_PROTOCOL).replace(":", "");
    const host = (opts.host || DEFAULT_HOST).split(":")[0];
    const port = opts.port || DEFAULT_PORT;
    url = new URL(`${protocol}://${host}:${port}`);
  }
  if (opts.apiPath) {
    url.pathname = opts.apiPath;
  } else if (url.pathname === "/" || url.pathname === void 0) {
    url.pathname = "api/v0";
  }
  if (import_env.isNode) {
    const Agent = agent_browser_default(url);
    agent = opts.agent || new Agent({
      keepAlive: true,
      // Similar to browsers which limit connections to six per host
      maxSockets: 6
    });
  }
  return {
    ...opts,
    host: url.host,
    protocol: url.protocol.replace(":", ""),
    port: Number(url.port),
    apiPath: url.pathname,
    url,
    agent
  };
};
var errorHandler = async (response) => {
  let msg;
  try {
    if ((response.headers.get("Content-Type") || "").startsWith("application/json")) {
      const data = await response.json();
      log(data);
      msg = data.Message || data.message;
    } else {
      msg = await response.text();
    }
  } catch (err) {
    log("Failed to parse error response", err);
    msg = err.message;
  }
  let error = new import_http.default.HTTPError(response);
  if (msg) {
    if (msg.includes("deadline has elapsed")) {
      error = new import_http.default.TimeoutError();
    }
    if (msg && msg.includes("context deadline exceeded")) {
      error = new import_http.default.TimeoutError();
    }
  }
  if (msg && msg.includes("request timed out")) {
    error = new import_http.default.TimeoutError();
  }
  if (msg) {
    error.message = msg;
  }
  throw error;
};
var KEBAB_REGEX = /[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g;
var kebabCase = (str) => {
  return str.replace(KEBAB_REGEX, function(match) {
    return "-" + match.toLowerCase();
  });
};
var parseTimeout = (value2) => {
  return typeof value2 === "string" ? parse_duration_default(value2) : value2;
};
var Client = class extends import_http.default {
  /**
   * @param {Options|URL|Multiaddr|string} [options]
   */
  constructor(options = {}) {
    const opts = normalizeOptions(options);
    super({
      timeout: parseTimeout(opts.timeout || 0) || void 0,
      headers: opts.headers,
      base: `${opts.url}`,
      handleError: errorHandler,
      transformSearchParams: (search) => {
        const out = new URLSearchParams();
        for (const [key, value2] of search) {
          if (value2 !== "undefined" && value2 !== "null" && key !== "signal") {
            out.append(kebabCase(key), value2);
          }
          if (key === "timeout" && !isNaN(value2)) {
            out.append(kebabCase(key), value2);
          }
        }
        return out;
      },
      // @ts-expect-error this can be a https agent or a http agent
      agent: opts.agent
    });
    delete this.get;
    delete this.put;
    delete this.delete;
    delete this.options;
    const fetch2 = this.fetch;
    this.fetch = (resource, options2 = {}) => {
      if (typeof resource === "string" && !resource.startsWith("/")) {
        resource = `${opts.url}/${resource}`;
      }
      return fetch2.call(this, resource, merge(options2, {
        method: "POST"
      }));
    };
  }
};
var HTTPError = import_http.default.HTTPError;

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/lib/configure.js
var configure = (fn) => {
  return (options) => {
    return fn(new Client(options), options);
  };
};

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/lib/to-url-search-params.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/lib/mode-to-string.js
init_buffer_polyfill();
function modeToString(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/lib/parse-mtime.js
init_buffer_polyfill();
var import_err_code2 = __toESM(require_err_code(), 1);
function parseMtime(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code2.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/lib/to-url-search-params.js
function toUrlSearchParams({ arg, searchParams, hashAlg, mtime, mode, ...options } = {}) {
  if (searchParams) {
    options = {
      ...options,
      ...searchParams
    };
  }
  if (hashAlg) {
    options.hash = hashAlg;
  }
  if (mtime != null) {
    mtime = parseMtime(mtime);
    options.mtime = mtime.secs;
    options.mtimeNsecs = mtime.nsecs;
  }
  if (mode != null) {
    options.mode = modeToString(mode);
  }
  if (options.timeout && !isNaN(options.timeout)) {
    options.timeout = `${options.timeout}ms`;
  }
  if (arg === void 0 || arg === null) {
    arg = [];
  } else if (!Array.isArray(arg)) {
    arg = [arg];
  }
  const urlSearchParams = new URLSearchParams(options);
  arg.forEach((arg2) => urlSearchParams.append("arg", arg2));
  return urlSearchParams;
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/bitswap/wantlist.js
var createWantlist = configure((api) => {
  async function wantlist(options = {}) {
    const res = await (await api.post("bitswap/wantlist", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return (res.Keys || []).map((k) => CID2.parse(k["/"]));
  }
  return wantlist;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/bitswap/wantlist-for-peer.js
init_buffer_polyfill();
var createWantlistForPeer = configure((api) => {
  async function wantlistForPeer(peerId, options = {}) {
    const res = await (await api.post("bitswap/wantlist", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        peer: peerId.toString()
      }),
      headers: options.headers
    })).json();
    return (res.Keys || []).map((k) => CID2.parse(k["/"]));
  }
  return wantlistForPeer;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/bitswap/stat.js
init_buffer_polyfill();

// node_modules/.pnpm/@libp2p+peer-id@2.0.4/node_modules/@libp2p/peer-id/dist/src/index.js
init_buffer_polyfill();

// node_modules/.pnpm/@libp2p+interface-peer-id@2.0.2/node_modules/@libp2p/interface-peer-id/dist/src/index.js
init_buffer_polyfill();
var symbol3 = /* @__PURE__ */ Symbol.for("@libp2p/peer-id");

// node_modules/.pnpm/@libp2p+interfaces@3.3.2/node_modules/@libp2p/interfaces/dist/src/errors.js
init_buffer_polyfill();

// node_modules/.pnpm/@libp2p+peer-id@2.0.4/node_modules/@libp2p/peer-id/dist/src/index.js
var inspect3 = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var baseDecoder = Object.values(bases).map((codec) => codec.decoder).reduce((acc, curr) => acc.or(curr), bases.identity.decoder);
var LIBP2P_KEY_CODE = 114;
var MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;
var MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;
var _a4;
var PeerIdImpl = class {
  constructor(init) {
    __publicField(this, "type");
    __publicField(this, "multihash");
    __publicField(this, "privateKey");
    __publicField(this, "publicKey");
    __publicField(this, "string");
    __publicField(this, _a4, true);
    this.type = init.type;
    this.multihash = init.multihash;
    this.privateKey = init.privateKey;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  toString() {
    if (this.string == null) {
      this.string = base58btc2.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID2.createV1(LIBP2P_KEY_CODE, this.multihash);
  }
  toBytes() {
    return this.multihash.bytes;
  }
  /**
   * Returns Multiaddr as a JSON string
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(id) {
    if (id instanceof Uint8Array) {
      return equals7(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return peerIdFromString(id).equals(this);
    } else if (id?.multihash?.bytes != null) {
      return equals7(this.multihash.bytes, id.multihash.bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [(_a4 = symbol3, inspect3)]() {
    return `PeerId(${this.toString()})`;
  }
};
var RSAPeerIdImpl = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "RSA" });
    __publicField(this, "type", "RSA");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var Ed25519PeerIdImpl = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "Ed25519" });
    __publicField(this, "type", "Ed25519");
    __publicField(this, "publicKey");
    this.publicKey = init.multihash.digest;
  }
};
var Secp256k1PeerIdImpl = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "secp256k1" });
    __publicField(this, "type", "secp256k1");
    __publicField(this, "publicKey");
    this.publicKey = init.multihash.digest;
  }
};
function peerIdFromString(str, decoder) {
  decoder = decoder ?? baseDecoder;
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    const multihash = decode30(base58btc2.decode(`z${str}`));
    if (str.startsWith("12D")) {
      return new Ed25519PeerIdImpl({ multihash });
    } else if (str.startsWith("16U")) {
      return new Secp256k1PeerIdImpl({ multihash });
    } else {
      return new RSAPeerIdImpl({ multihash });
    }
  }
  return peerIdFromBytes(baseDecoder.decode(str));
}
function peerIdFromBytes(buf2) {
  try {
    const multihash = decode30(buf2);
    if (multihash.code === identity.code) {
      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
        return new Ed25519PeerIdImpl({ multihash });
      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
        return new Secp256k1PeerIdImpl({ multihash });
      }
    }
    if (multihash.code === sha2564.code) {
      return new RSAPeerIdImpl({ multihash });
    }
  } catch {
    return peerIdFromCID(CID2.decode(buf2));
  }
  throw new Error("Supplied PeerID CID is invalid");
}
function peerIdFromCID(cid) {
  if (cid == null || cid.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE) {
    throw new Error("Supplied PeerID CID is invalid");
  }
  const multihash = cid.multihash;
  if (multihash.code === sha2564.code) {
    return new RSAPeerIdImpl({ multihash: cid.multihash });
  } else if (multihash.code === identity.code) {
    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
      return new Ed25519PeerIdImpl({ multihash: cid.multihash });
    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
      return new Secp256k1PeerIdImpl({ multihash: cid.multihash });
    }
  }
  throw new Error("Supplied PeerID CID is invalid");
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/bitswap/stat.js
var createStat = configure((api) => {
  async function stat(options = {}) {
    const res = await api.post("bitswap/stat", {
      searchParams: toUrlSearchParams(options),
      signal: options.signal,
      headers: options.headers
    });
    return toCoreInterface(await res.json());
  }
  return stat;
});
function toCoreInterface(res) {
  return {
    provideBufLen: res.ProvideBufLen,
    wantlist: (res.Wantlist || []).map((k) => CID2.parse(k["/"])),
    peers: (res.Peers || []).map((str) => peerIdFromString(str)),
    blocksReceived: BigInt(res.BlocksReceived),
    dataReceived: BigInt(res.DataReceived),
    blocksSent: BigInt(res.BlocksSent),
    dataSent: BigInt(res.DataSent),
    dupBlksReceived: BigInt(res.DupBlksReceived),
    dupDataReceived: BigInt(res.DupDataReceived)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/bitswap/unwant.js
init_buffer_polyfill();
var createUnwant = configure((api) => {
  async function unwant(cid, options = {}) {
    const res = await api.post("bitswap/unwant", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    return res.json();
  }
  return unwant;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/bitswap/index.js
function createBitswap(config) {
  return {
    wantlist: createWantlist(config),
    wantlistForPeer: createWantlistForPeer(config),
    unwant: createUnwant(config),
    stat: createStat(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/block/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/block/get.js
init_buffer_polyfill();
var createGet = configure((api) => {
  async function get(cid, options = {}) {
    const res = await api.post("block/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    return new Uint8Array(await res.arrayBuffer());
  }
  return get;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/block/put.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/multipart-request.browser.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/files/normalise-input-multiple.browser.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/files/normalise-content.browser.js
init_buffer_polyfill();
var import_err_code3 = __toESM(require_err_code(), 1);

// node_modules/.pnpm/it-peekable@2.0.1/node_modules/it-peekable/dist/src/index.js
init_buffer_polyfill();
function peekableIterator(iterable) {
  const [iterator, symbol4] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value2) => {
      queue.push(value2);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol4]() {
      return this;
    }
  };
}

// node_modules/.pnpm/browser-readablestream-to-it@2.0.10/node_modules/browser-readablestream-to-it/dist/src/index.js
init_buffer_polyfill();
async function* browserReadableStreamToIt(stream, options = {}) {
  const reader = stream.getReader();
  try {
    while (true) {
      const result = await reader.read();
      if (result.done) {
        return;
      }
      yield result.value;
    }
  } finally {
    if (options.preventCancel !== true) {
      await reader.cancel();
    }
    reader.releaseLock();
  }
}

// node_modules/.pnpm/it-all@2.0.1/node_modules/it-all/dist/src/index.js
init_buffer_polyfill();
async function all(source) {
  const arr = [];
  for await (const entry of source) {
    arr.push(entry);
  }
  return arr;
}

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/files/utils.js
init_buffer_polyfill();
function isBytes4(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob(obj) {
  return obj.constructor && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isFileObject(obj) {
  return typeof obj === "object" && (obj.path || obj.content);
}
var isReadableStream = (value2) => value2 && typeof value2.getReader === "function";

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/files/normalise-content.browser.js
async function normaliseContent(input) {
  if (isBytes4(input)) {
    return new Blob([input]);
  }
  if (typeof input === "string" || input instanceof String) {
    return new Blob([input.toString()]);
  }
  if (isBlob(input)) {
    return input;
  }
  if (isReadableStream(input)) {
    input = browserReadableStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = peekableIterator(input);
    const { value: value2, done } = await peekable.peek();
    if (done) {
      return itToBlob(peekable);
    }
    peekable.push(value2);
    if (Number.isInteger(value2)) {
      return new Blob([Uint8Array.from(await all(peekable))]);
    }
    if (isBytes4(value2) || typeof value2 === "string" || value2 instanceof String) {
      return itToBlob(peekable);
    }
  }
  throw (0, import_err_code3.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
async function itToBlob(stream) {
  const parts = [];
  for await (const chunk of stream) {
    parts.push(chunk);
  }
  return new Blob(parts);
}

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/files/normalise-candidate-multiple.js
init_buffer_polyfill();
var import_err_code5 = __toESM(require_err_code(), 1);

// node_modules/.pnpm/it-map@2.0.1/node_modules/it-map/dist/src/index.js
init_buffer_polyfill();
async function* map(source, func) {
  for await (const val of source) {
    yield func(val);
  }
}

// node_modules/.pnpm/ipfs-unixfs@9.0.1/node_modules/ipfs-unixfs/src/index.js
init_buffer_polyfill();
var import_err_code4 = __toESM(require_err_code(), 1);

// node_modules/.pnpm/ipfs-unixfs@9.0.1/node_modules/ipfs-unixfs/src/unixfs.js
init_buffer_polyfill();
var import_minimal = __toESM(require_minimal2(), 1);
var $Reader = import_minimal.default.Reader;
var $Writer = import_minimal.default.Writer;
var $util = import_minimal.default.util;
var $root = import_minimal.default.roots["ipfs-unixfs"] || (import_minimal.default.roots["ipfs-unixfs"] = {});
var Data = $root.Data = (() => {
  function Data2(p) {
    this.blocksizes = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Data2.prototype.Type = 0;
  Data2.prototype.Data = $util.newBuffer([]);
  Data2.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.blocksizes = $util.emptyArray;
  Data2.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.mode = 0;
  Data2.prototype.mtime = null;
  Data2.encode = function encode42(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int32(m.Type);
    if (m.Data != null && Object.hasOwnProperty.call(m, "Data"))
      w.uint32(18).bytes(m.Data);
    if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize"))
      w.uint32(24).uint64(m.filesize);
    if (m.blocksizes != null && m.blocksizes.length) {
      for (var i = 0; i < m.blocksizes.length; ++i)
        w.uint32(32).uint64(m.blocksizes[i]);
    }
    if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType"))
      w.uint32(40).uint64(m.hashType);
    if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
      w.uint32(48).uint64(m.fanout);
    if (m.mode != null && Object.hasOwnProperty.call(m, "mode"))
      w.uint32(56).uint32(m.mode);
    if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime"))
      $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
    return w;
  };
  Data2.decode = function decode44(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.Data();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Type = r.int32();
          break;
        case 2:
          m.Data = r.bytes();
          break;
        case 3:
          m.filesize = r.uint64();
          break;
        case 4:
          if (!(m.blocksizes && m.blocksizes.length))
            m.blocksizes = [];
          if ((t & 7) === 2) {
            var c2 = r.uint32() + r.pos;
            while (r.pos < c2)
              m.blocksizes.push(r.uint64());
          } else
            m.blocksizes.push(r.uint64());
          break;
        case 5:
          m.hashType = r.uint64();
          break;
        case 6:
          m.fanout = r.uint64();
          break;
        case 7:
          m.mode = r.uint32();
          break;
        case 8:
          m.mtime = $root.UnixTime.decode(r, r.uint32());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Type"))
      throw $util.ProtocolError("missing required 'Type'", { instance: m });
    return m;
  };
  Data2.fromObject = function fromObject(d) {
    if (d instanceof $root.Data)
      return d;
    var m = new $root.Data();
    switch (d.Type) {
      case "Raw":
      case 0:
        m.Type = 0;
        break;
      case "Directory":
      case 1:
        m.Type = 1;
        break;
      case "File":
      case 2:
        m.Type = 2;
        break;
      case "Metadata":
      case 3:
        m.Type = 3;
        break;
      case "Symlink":
      case 4:
        m.Type = 4;
        break;
      case "HAMTShard":
      case 5:
        m.Type = 5;
        break;
    }
    if (d.Data != null) {
      if (typeof d.Data === "string")
        $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
      else if (d.Data.length)
        m.Data = d.Data;
    }
    if (d.filesize != null) {
      if ($util.Long)
        (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;
      else if (typeof d.filesize === "string")
        m.filesize = parseInt(d.filesize, 10);
      else if (typeof d.filesize === "number")
        m.filesize = d.filesize;
      else if (typeof d.filesize === "object")
        m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
    }
    if (d.blocksizes) {
      if (!Array.isArray(d.blocksizes))
        throw TypeError(".Data.blocksizes: array expected");
      m.blocksizes = [];
      for (var i = 0; i < d.blocksizes.length; ++i) {
        if ($util.Long)
          (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;
        else if (typeof d.blocksizes[i] === "string")
          m.blocksizes[i] = parseInt(d.blocksizes[i], 10);
        else if (typeof d.blocksizes[i] === "number")
          m.blocksizes[i] = d.blocksizes[i];
        else if (typeof d.blocksizes[i] === "object")
          m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);
      }
    }
    if (d.hashType != null) {
      if ($util.Long)
        (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;
      else if (typeof d.hashType === "string")
        m.hashType = parseInt(d.hashType, 10);
      else if (typeof d.hashType === "number")
        m.hashType = d.hashType;
      else if (typeof d.hashType === "object")
        m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
    }
    if (d.fanout != null) {
      if ($util.Long)
        (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;
      else if (typeof d.fanout === "string")
        m.fanout = parseInt(d.fanout, 10);
      else if (typeof d.fanout === "number")
        m.fanout = d.fanout;
      else if (typeof d.fanout === "object")
        m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
    }
    if (d.mode != null) {
      m.mode = d.mode >>> 0;
    }
    if (d.mtime != null) {
      if (typeof d.mtime !== "object")
        throw TypeError(".Data.mtime: object expected");
      m.mtime = $root.UnixTime.fromObject(d.mtime);
    }
    return m;
  };
  Data2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.blocksizes = [];
    }
    if (o.defaults) {
      d.Type = o.enums === String ? "Raw" : 0;
      if (o.bytes === String)
        d.Data = "";
      else {
        d.Data = [];
        if (o.bytes !== Array)
          d.Data = $util.newBuffer(d.Data);
      }
      if ($util.Long) {
        var n2 = new $util.Long(0, 0, true);
        d.filesize = o.longs === String ? n2.toString() : o.longs === Number ? n2.toNumber() : n2;
      } else
        d.filesize = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n2 = new $util.Long(0, 0, true);
        d.hashType = o.longs === String ? n2.toString() : o.longs === Number ? n2.toNumber() : n2;
      } else
        d.hashType = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n2 = new $util.Long(0, 0, true);
        d.fanout = o.longs === String ? n2.toString() : o.longs === Number ? n2.toNumber() : n2;
      } else
        d.fanout = o.longs === String ? "0" : 0;
      d.mode = 0;
      d.mtime = null;
    }
    if (m.Type != null && m.hasOwnProperty("Type")) {
      d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
    }
    if (m.Data != null && m.hasOwnProperty("Data")) {
      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
    }
    if (m.filesize != null && m.hasOwnProperty("filesize")) {
      if (typeof m.filesize === "number")
        d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
      else
        d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
    }
    if (m.blocksizes && m.blocksizes.length) {
      d.blocksizes = [];
      for (var j = 0; j < m.blocksizes.length; ++j) {
        if (typeof m.blocksizes[j] === "number")
          d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
        else
          d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
      }
    }
    if (m.hashType != null && m.hasOwnProperty("hashType")) {
      if (typeof m.hashType === "number")
        d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
      else
        d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
    }
    if (m.fanout != null && m.hasOwnProperty("fanout")) {
      if (typeof m.fanout === "number")
        d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
      else
        d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
    }
    if (m.mode != null && m.hasOwnProperty("mode")) {
      d.mode = m.mode;
    }
    if (m.mtime != null && m.hasOwnProperty("mtime")) {
      d.mtime = $root.UnixTime.toObject(m.mtime, o);
    }
    return d;
  };
  Data2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  Data2.DataType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Raw"] = 0;
    values[valuesById[1] = "Directory"] = 1;
    values[valuesById[2] = "File"] = 2;
    values[valuesById[3] = "Metadata"] = 3;
    values[valuesById[4] = "Symlink"] = 4;
    values[valuesById[5] = "HAMTShard"] = 5;
    return values;
  })();
  return Data2;
})();
var UnixTime = $root.UnixTime = (() => {
  function UnixTime2(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  UnixTime2.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
  UnixTime2.prototype.FractionalNanoseconds = 0;
  UnixTime2.encode = function encode42(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int64(m.Seconds);
    if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds"))
      w.uint32(21).fixed32(m.FractionalNanoseconds);
    return w;
  };
  UnixTime2.decode = function decode44(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.UnixTime();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Seconds = r.int64();
          break;
        case 2:
          m.FractionalNanoseconds = r.fixed32();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Seconds"))
      throw $util.ProtocolError("missing required 'Seconds'", { instance: m });
    return m;
  };
  UnixTime2.fromObject = function fromObject(d) {
    if (d instanceof $root.UnixTime)
      return d;
    var m = new $root.UnixTime();
    if (d.Seconds != null) {
      if ($util.Long)
        (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;
      else if (typeof d.Seconds === "string")
        m.Seconds = parseInt(d.Seconds, 10);
      else if (typeof d.Seconds === "number")
        m.Seconds = d.Seconds;
      else if (typeof d.Seconds === "object")
        m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
    }
    if (d.FractionalNanoseconds != null) {
      m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
    }
    return m;
  };
  UnixTime2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if ($util.Long) {
        var n2 = new $util.Long(0, 0, false);
        d.Seconds = o.longs === String ? n2.toString() : o.longs === Number ? n2.toNumber() : n2;
      } else
        d.Seconds = o.longs === String ? "0" : 0;
      d.FractionalNanoseconds = 0;
    }
    if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
      if (typeof m.Seconds === "number")
        d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
      else
        d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
    }
    if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
      d.FractionalNanoseconds = m.FractionalNanoseconds;
    }
    return d;
  };
  UnixTime2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  return UnixTime2;
})();
var Metadata = $root.Metadata = (() => {
  function Metadata2(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Metadata2.prototype.MimeType = "";
  Metadata2.encode = function encode42(m, w) {
    if (!w)
      w = $Writer.create();
    if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType"))
      w.uint32(10).string(m.MimeType);
    return w;
  };
  Metadata2.decode = function decode44(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.Metadata();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.MimeType = r.string();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Metadata2.fromObject = function fromObject(d) {
    if (d instanceof $root.Metadata)
      return d;
    var m = new $root.Metadata();
    if (d.MimeType != null) {
      m.MimeType = String(d.MimeType);
    }
    return m;
  };
  Metadata2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      d.MimeType = "";
    }
    if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
      d.MimeType = m.MimeType;
    }
    return d;
  };
  Metadata2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  return Metadata2;
})();

// node_modules/.pnpm/ipfs-unixfs@9.0.1/node_modules/ipfs-unixfs/src/index.js
var DEFAULT_FILE_MODE = parseInt("0644", 8);
var DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
function parseMode(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "number") {
    return mode & 4095;
  }
  mode = mode.toString();
  if (mode.substring(0, 1) === "0") {
    return parseInt(mode, 8) & 4095;
  }
  return parseInt(mode, 10) & 4095;
}
function parseMtime2(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code4.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/files/normalise-candidate-multiple.js
async function* normaliseCandidateMultiple(input, normaliseContent3) {
  if (typeof input === "string" || input instanceof String || isBytes4(input) || isBlob(input) || input._readableState) {
    throw (0, import_err_code5.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isReadableStream(input)) {
    input = browserReadableStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = peekableIterator(input);
    const { value: value2, done } = await peekable.peek();
    if (done) {
      yield* [];
      return;
    }
    peekable.push(value2);
    if (Number.isInteger(value2)) {
      throw (0, import_err_code5.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
    }
    if (value2._readableState) {
      yield* map(peekable, (value3) => toFileObject({ content: value3 }, normaliseContent3));
      return;
    }
    if (isBytes4(value2)) {
      yield toFileObject({ content: peekable }, normaliseContent3);
      return;
    }
    if (isFileObject(value2) || value2[Symbol.iterator] || value2[Symbol.asyncIterator] || isReadableStream(value2) || isBlob(value2)) {
      yield* map(peekable, (value3) => toFileObject(value3, normaliseContent3));
      return;
    }
  }
  if (isFileObject(input)) {
    throw (0, import_err_code5.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  throw (0, import_err_code5.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject(input, normaliseContent3) {
  const { path, mode, mtime, content } = input;
  const file = {
    path: path || "",
    mode: parseMode(mode),
    mtime: parseMtime2(mtime)
  };
  if (content) {
    file.content = await normaliseContent3(content);
  } else if (!path) {
    file.content = await normaliseContent3(input);
  }
  return file;
}

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/files/normalise-input-multiple.browser.js
function normaliseInput(input) {
  return normaliseCandidateMultiple(input, normaliseContent, true);
}

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/mode-to-string.js
init_buffer_polyfill();
function modeToString2(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/multipart-request.browser.js
async function multipartRequest(source, abortController, headers = {}) {
  const parts = [];
  const formData = new FormData();
  let index = 0;
  let total = 0;
  for await (const { content, path, mode, mtime } of normaliseInput(source)) {
    let fileSuffix = "";
    const type = content ? "file" : "dir";
    if (index > 0) {
      fileSuffix = `-${index}`;
    }
    let fieldName = type + fileSuffix;
    const qs = [];
    if (mode !== null && mode !== void 0) {
      qs.push(`mode=${modeToString2(mode)}`);
    }
    if (mtime != null) {
      const { secs, nsecs } = mtime;
      qs.push(`mtime=${secs}`);
      if (nsecs != null) {
        qs.push(`mtime-nsecs=${nsecs}`);
      }
    }
    if (qs.length) {
      fieldName = `${fieldName}?${qs.join("&")}`;
    }
    if (content) {
      formData.set(fieldName, content, path != null ? encodeURIComponent(path) : void 0);
      const end = total + content.size;
      parts.push({ name: path, start: total, end });
      total = end;
    } else if (path != null) {
      formData.set(fieldName, new File([""], encodeURIComponent(path), { type: "application/x-directory" }));
    } else {
      throw new Error("path or content or both must be set");
    }
    index++;
  }
  return {
    total,
    parts,
    headers,
    body: formData
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/lib/abort-signal.js
init_buffer_polyfill();
var import_any_signal = __toESM(require_any_signal(), 1);
function filter(signals) {
  return signals.filter(Boolean);
}
function abortSignal(...signals) {
  return (0, import_any_signal.anySignal)(filter(signals));
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/block/put.js
var createPut = configure((api) => {
  async function put(data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    let res;
    try {
      const response = await api.post("block/put", {
        signal,
        searchParams: toUrlSearchParams(options),
        ...await multipartRequest([data], controller, options.headers)
      });
      res = await response.json();
    } catch (err) {
      if (options.format === "dag-pb") {
        return put(data, { ...options, format: "protobuf" });
      } else if (options.format === "dag-cbor") {
        return put(data, { ...options, format: "cbor" });
      }
      throw err;
    }
    return CID2.parse(res.Key);
  }
  return put;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/block/rm.js
init_buffer_polyfill();
var createRm = configure((api) => {
  async function* rm(cid, options = {}) {
    if (!Array.isArray(cid)) {
      cid = [cid];
    }
    const res = await api.post("block/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.map((cid2) => cid2.toString()),
        "stream-channels": true,
        ...options
      }),
      headers: options.headers
    });
    for await (const removed of res.ndjson()) {
      yield toCoreInterface2(removed);
    }
  }
  return rm;
});
function toCoreInterface2(removed) {
  const out = {
    cid: CID2.parse(removed.Hash)
  };
  if (removed.Error) {
    out.error = new Error(removed.Error);
  }
  return out;
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/block/stat.js
init_buffer_polyfill();
var createStat2 = configure((api) => {
  async function stat(cid, options = {}) {
    const res = await api.post("block/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return { cid: CID2.parse(data.Key), size: data.Size };
  }
  return stat;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/block/index.js
function createBlock(config) {
  return {
    get: createGet(config),
    put: createPut(config),
    rm: createRm(config),
    stat: createStat2(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/bootstrap/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/bootstrap/add.js
init_buffer_polyfill();
var createAdd = configure((api) => {
  async function add2(addr, options = {}) {
    const res = await api.post("bootstrap/add", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return add2;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/bootstrap/clear.js
init_buffer_polyfill();
var createClear = configure((api) => {
  async function clear(options = {}) {
    const res = await api.post("bootstrap/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        all: true
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return clear;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/bootstrap/list.js
init_buffer_polyfill();
var createList = configure((api) => {
  async function list(options = {}) {
    const res = await api.post("bootstrap/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return list;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/bootstrap/reset.js
init_buffer_polyfill();
var createReset = configure((api) => {
  async function reset(options = {}) {
    const res = await api.post("bootstrap/add", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        default: true
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return reset;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/bootstrap/rm.js
init_buffer_polyfill();
var createRm2 = configure((api) => {
  async function rm(addr, options = {}) {
    const res = await api.post("bootstrap/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return rm;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/bootstrap/index.js
function createBootstrap(config) {
  return {
    add: createAdd(config),
    clear: createClear(config),
    list: createList(config),
    reset: createReset(config),
    rm: createRm2(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/config/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/config/profiles/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/config/profiles/apply.js
init_buffer_polyfill();
var createApply = configure((api) => {
  async function apply(profile, options = {}) {
    const res = await api.post("config/profile/apply", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: profile,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      original: data.OldCfg,
      updated: data.NewCfg
    };
  }
  return apply;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/config/profiles/list.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/lib/object-to-camel.js
init_buffer_polyfill();
function objectToCamel(obj) {
  if (obj == null) {
    return obj;
  }
  const caps = /^[A-Z]+$/;
  const output = {};
  return Object.keys(obj).reduce((camelObj, k) => {
    if (caps.test(k)) {
      camelObj[k.toLowerCase()] = obj[k];
    } else if (caps.test(k[0])) {
      camelObj[k[0].toLowerCase() + k.slice(1)] = obj[k];
    } else {
      camelObj[k] = obj[k];
    }
    return camelObj;
  }, output);
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/config/profiles/list.js
var createList2 = configure((api) => {
  async function list(options = {}) {
    const res = await api.post("config/profile/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.map((profile) => objectToCamel(profile));
  }
  return list;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/config/profiles/index.js
function createProfiles(config) {
  return {
    apply: createApply(config),
    list: createList2(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/config/get.js
init_buffer_polyfill();
var createGet2 = configure((api) => {
  const get = async (key, options = {}) => {
    if (!key) {
      throw new Error("key argument is required");
    }
    const res = await api.post("config", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: key,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data.Value;
  };
  return get;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/config/get-all.js
init_buffer_polyfill();
var createGetAll = configure((api) => {
  const getAll = async (options = {}) => {
    const res = await api.post("config/show", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data;
  };
  return getAll;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/config/replace.js
init_buffer_polyfill();
var createReplace = configure((api) => {
  const replace = async (config, options = {}) => {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("config/replace", {
      signal,
      searchParams: toUrlSearchParams(options),
      ...await multipartRequest([fromString5(JSON.stringify(config))], controller, options.headers)
    });
    await res.text();
  };
  return replace;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/config/set.js
init_buffer_polyfill();
var createSet = configure((api) => {
  const set = async (key, value2, options = {}) => {
    if (typeof key !== "string") {
      throw new Error("Invalid key type");
    }
    const params = {
      ...options,
      ...encodeParam(key, value2)
    };
    const res = await api.post("config", {
      signal: options.signal,
      searchParams: toUrlSearchParams(params),
      headers: options.headers
    });
    await res.text();
  };
  return set;
});
var encodeParam = (key, value2) => {
  switch (typeof value2) {
    case "boolean":
      return { arg: [key, value2.toString()], bool: true };
    case "string":
      return { arg: [key, value2] };
    default:
      return { arg: [key, JSON.stringify(value2)], json: true };
  }
};

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/config/index.js
function createConfig(config) {
  return {
    getAll: createGetAll(config),
    get: createGet2(config),
    set: createSet(config),
    replace: createReplace(config),
    profiles: createProfiles(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dag/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dag/export.js
init_buffer_polyfill();
var createExport = configure((api) => {
  async function* dagExport(root, options = {}) {
    const res = await api.post("dag/export", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: root.toString()
      }),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return dagExport;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dag/get.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/lib/resolve.js
init_buffer_polyfill();
var import_err_code6 = __toESM(require_err_code(), 1);
async function* resolve(cid, path, codecs3, getBlock, options) {
  const load = async (cid2) => {
    const codec = await codecs3.getCodec(cid2.code);
    const block = await getBlock(cid2, options);
    return codec.decode(block);
  };
  const parts = path.split("/").filter(Boolean);
  let value2 = await load(cid);
  let lastCid = cid;
  while (parts.length) {
    const key = parts.shift();
    if (!key) {
      throw (0, import_err_code6.default)(new Error(`Could not resolve path "${path}"`), "ERR_INVALID_PATH");
    }
    if (Object.prototype.hasOwnProperty.call(value2, key)) {
      value2 = value2[key];
      yield {
        value: value2,
        remainderPath: parts.join("/")
      };
    } else {
      throw (0, import_err_code6.default)(new Error(`no link named "${key}" under ${lastCid}`), "ERR_NO_LINK");
    }
    const cid2 = CID2.asCID(value2);
    if (cid2) {
      lastCid = cid2;
      value2 = await load(value2);
    }
  }
  yield {
    value: value2,
    remainderPath: ""
  };
}

// node_modules/.pnpm/it-first@2.0.1/node_modules/it-first/dist/src/index.js
init_buffer_polyfill();
async function first(source) {
  for await (const entry of source) {
    return entry;
  }
  return void 0;
}

// node_modules/.pnpm/it-last@2.0.1/node_modules/it-last/dist/src/index.js
init_buffer_polyfill();
async function last(source) {
  let res;
  for await (const entry of source) {
    res = entry;
  }
  return res;
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dag/get.js
var import_err_code7 = __toESM(require_err_code(), 1);
var createGet3 = (codecs3, options) => {
  const fn = configure((api, opts) => {
    const getBlock = createGet(opts);
    const get = async (cid, options2 = {}) => {
      if (options2.path) {
        const entry = options2.localResolve ? await first(resolve(cid, options2.path, codecs3, getBlock, options2)) : await last(resolve(cid, options2.path, codecs3, getBlock, options2));
        const result = entry;
        if (!result) {
          throw (0, import_err_code7.default)(new Error("Not found"), "ERR_NOT_FOUND");
        }
        return result;
      }
      const codec = await codecs3.getCodec(cid.code);
      const block = await getBlock(cid, options2);
      const node = codec.decode(block);
      return {
        value: node,
        remainderPath: ""
      };
    };
    return get;
  });
  return fn(options);
};

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dag/import.js
init_buffer_polyfill();
var createImport = configure((api) => {
  async function* dagImport(source, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const { headers, body } = await multipartRequest(source, controller, options.headers);
    const res = await api.post("dag/import", {
      signal,
      headers,
      body,
      searchParams: toUrlSearchParams({ "pin-roots": options.pinRoots })
    });
    for await (const { Root } of res.ndjson()) {
      if (Root !== void 0) {
        const { Cid: { "/": Cid }, PinErrorMsg } = Root;
        yield {
          root: {
            cid: CID2.parse(Cid),
            pinErrorMsg: PinErrorMsg
          }
        };
      }
    }
  }
  return dagImport;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dag/put.js
init_buffer_polyfill();
var createPut2 = (codecs3, options) => {
  const fn = configure((api) => {
    const put = async (dagNode, options2 = {}) => {
      const settings = {
        storeCodec: "dag-cbor",
        hashAlg: "sha2-256",
        ...options2
      };
      let serialized;
      if (settings.inputCodec) {
        if (!(dagNode instanceof Uint8Array)) {
          throw new Error("Can only inputCodec on raw bytes that can be decoded");
        }
        serialized = dagNode;
      } else {
        const storeCodec = await codecs3.getCodec(settings.storeCodec);
        serialized = storeCodec.encode(dagNode);
        settings.inputCodec = settings.storeCodec;
      }
      const controller = new AbortController();
      const signal = abortSignal(controller.signal, settings.signal);
      const res = await api.post("dag/put", {
        timeout: settings.timeout,
        signal,
        searchParams: toUrlSearchParams(settings),
        ...await multipartRequest([serialized], controller, settings.headers)
      });
      const data = await res.json();
      return CID2.parse(data.Cid["/"]);
    };
    return put;
  });
  return fn(options);
};

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dag/resolve.js
init_buffer_polyfill();
var createResolve = configure((api) => {
  const resolve2 = async (ipfsPath, options = {}) => {
    const res = await api.post("dag/resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${ipfsPath}${options.path ? `/${options.path}`.replace(/\/[/]+/g, "/") : ""}`,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return { cid: CID2.parse(data.Cid["/"]), remainderPath: data.RemPath };
  };
  return resolve2;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dag/index.js
function createDag(codecs3, config) {
  return {
    export: createExport(config),
    get: createGet3(codecs3, config),
    import: createImport(config),
    put: createPut2(codecs3, config),
    resolve: createResolve(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dht/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dht/find-peer.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dht/map-event.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dht/response-types.js
init_buffer_polyfill();
var SendingQuery = 0;
var PeerResponse = 1;
var FinalPeer = 2;
var QueryError = 3;
var Provider = 4;
var Value = 5;
var AddingPeer = 6;
var DialingPeer = 7;

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dht/map-event.js
var mapEvent = (event) => {
  if (event.Type === SendingQuery) {
    return {
      name: "SENDING_QUERY",
      type: event.Type
    };
  }
  if (event.Type === PeerResponse) {
    return {
      from: peerIdFromString(event.ID),
      name: "PEER_RESPONSE",
      type: event.Type,
      // TODO: how to infer this from the go-ipfs response
      messageType: 0,
      // TODO: how to infer this from the go-ipfs response
      messageName: "PUT_VALUE",
      closer: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] })),
      providers: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] }))
      // TODO: how to infer this from the go-ipfs response
      // record: ???
    };
  }
  if (event.Type === FinalPeer) {
    let peer = {
      // @ts-expect-error go-ipfs does not return this
      id: event.ID ?? peerIdFromString(event.ID),
      /** @type {Multiaddr[]} */
      multiaddrs: [],
      protocols: []
    };
    if (event.Responses && event.Responses.length) {
      peer = {
        id: peerIdFromString(event.Responses[0].ID),
        multiaddrs: event.Responses[0].Addrs.map((addr) => multiaddr(addr)),
        protocols: []
      };
    }
    return {
      name: "FINAL_PEER",
      type: event.Type,
      peer
    };
  }
  if (event.Type === QueryError) {
    return {
      name: "QUERY_ERROR",
      type: event.Type,
      error: new Error(event.Extra)
    };
  }
  if (event.Type === Provider) {
    return {
      name: "PROVIDER",
      type: event.Type,
      providers: event.Responses.map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] }))
    };
  }
  if (event.Type === Value) {
    return {
      name: "VALUE",
      type: event.Type,
      value: fromString5(event.Extra, "base64pad")
    };
  }
  if (event.Type === AddingPeer) {
    const peers = event.Responses.map(({ ID }) => peerIdFromString(ID));
    if (!peers.length) {
      throw new Error("No peer found");
    }
    return {
      name: "ADDING_PEER",
      type: event.Type,
      peer: peers[0]
    };
  }
  if (event.Type === DialingPeer) {
    return {
      name: "DIALING_PEER",
      type: event.Type,
      peer: peerIdFromString(event.ID)
    };
  }
  throw new Error("Unknown DHT event type");
};

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dht/find-peer.js
var createFindPeer = configure((api) => {
  async function* findPeer(peerId, options = {}) {
    const res = await api.post("dht/findpeer", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: peerId,
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return findPeer;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dht/find-provs.js
init_buffer_polyfill();
var createFindProvs = configure((api) => {
  async function* findProvs(cid, options = {}) {
    const res = await api.post("dht/findprovs", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return findProvs;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dht/get.js
init_buffer_polyfill();
var createGet4 = configure((api) => {
  async function* get(key, options = {}) {
    const res = await api.post("dht/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        // arg: base36.encode(key),
        arg: key instanceof Uint8Array ? toString5(key) : key.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return get;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dht/provide.js
init_buffer_polyfill();
var createProvide = configure((api) => {
  async function* provide(cids, options = { recursive: false }) {
    const cidArr = Array.isArray(cids) ? cids : [cids];
    const res = await api.post("dht/provide", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cidArr.map((cid) => cid.toString()),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return provide;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dht/put.js
init_buffer_polyfill();
var createPut3 = configure((api) => {
  async function* put(key, value2, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("dht/put", {
      signal,
      searchParams: toUrlSearchParams({
        arg: key instanceof Uint8Array ? toString5(key) : key.toString(),
        ...options
      }),
      ...await multipartRequest([value2], controller, options.headers)
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return put;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dht/query.js
init_buffer_polyfill();
var createQuery = configure((api) => {
  async function* query(peerId, options = {}) {
    const res = await api.post("dht/query", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: peerId.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return query;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dht/index.js
function createDht(config) {
  return {
    findPeer: createFindPeer(config),
    findProvs: createFindProvs(config),
    get: createGet4(config),
    provide: createProvide(config),
    put: createPut3(config),
    query: createQuery(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/diag/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/diag/cmds.js
init_buffer_polyfill();
var createCmds = configure((api) => {
  async function cmds(options = {}) {
    const res = await api.post("diag/cmds", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return cmds;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/diag/net.js
init_buffer_polyfill();
var createNet = configure((api) => {
  async function net(options = {}) {
    const res = await api.post("diag/net", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return net;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/diag/sys.js
init_buffer_polyfill();
var createSys = configure((api) => {
  async function sys(options = {}) {
    const res = await api.post("diag/sys", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return sys;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/diag/index.js
function createDiag(config) {
  return {
    cmds: createCmds(config),
    net: createNet(config),
    sys: createSys(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/files/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/files/chmod.js
init_buffer_polyfill();
var createChmod = configure((api) => {
  async function chmod(path, mode, options = {}) {
    const res = await api.post("files/chmod", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        mode,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return chmod;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/files/cp.js
init_buffer_polyfill();
var createCp = configure((api) => {
  async function cp(sources, destination, options = {}) {
    const sourceArr = Array.isArray(sources) ? sources : [sources];
    const res = await api.post("files/cp", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: sourceArr.concat(destination).map((src4) => CID2.asCID(src4) ? `/ipfs/${src4}` : src4),
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return cp;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/files/flush.js
init_buffer_polyfill();
var createFlush = configure((api) => {
  async function flush(path, options = {}) {
    if (!path || typeof path !== "string") {
      throw new Error("ipfs.files.flush requires a path");
    }
    const res = await api.post("files/flush", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return CID2.parse(data.Cid);
  }
  return flush;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/files/ls.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/lib/object-to-camel-with-metadata.js
init_buffer_polyfill();
function objectToCamelWithMetadata(entry) {
  const file = objectToCamel(entry);
  if (Object.prototype.hasOwnProperty.call(file, "mode")) {
    file.mode = parseInt(file.mode, 8);
  }
  if (Object.prototype.hasOwnProperty.call(file, "mtime")) {
    file.mtime = {
      secs: file.mtime,
      nsecs: file.mtimeNsecs || 0
    };
    delete file.mtimeNsecs;
  }
  return file;
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/files/ls.js
var createLs = configure((api) => {
  async function* ls(path, options = {}) {
    if (!path) {
      throw new Error("ipfs.files.ls requires a path");
    }
    const res = await api.post("files/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: CID2.asCID(path) ? `/ipfs/${path}` : path,
        // default long to true, diverges from go-ipfs where its false by default
        long: true,
        ...options,
        stream: true
      }),
      headers: options.headers
    });
    for await (const result of res.ndjson()) {
      if ("Entries" in result) {
        for (const entry of result.Entries || []) {
          yield toCoreInterface3(objectToCamelWithMetadata(entry));
        }
      } else {
        yield toCoreInterface3(objectToCamelWithMetadata(result));
      }
    }
  }
  return ls;
});
function toCoreInterface3(entry) {
  if (entry.hash) {
    entry.cid = CID2.parse(entry.hash);
  }
  delete entry.hash;
  entry.type = entry.type === 1 ? "directory" : "file";
  return entry;
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/files/mkdir.js
init_buffer_polyfill();
var createMkdir = configure((api) => {
  async function mkdir(path, options = {}) {
    const res = await api.post("files/mkdir", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return mkdir;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/files/mv.js
init_buffer_polyfill();
var createMv = configure((api) => {
  async function mv(sources, destination, options = {}) {
    if (!Array.isArray(sources)) {
      sources = [sources];
    }
    const res = await api.post("files/mv", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: sources.concat(destination),
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return mv;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/files/read.js
init_buffer_polyfill();
var import_source = __toESM(require_source(), 1);
var createRead = configure((api) => {
  async function* read4(path, options = {}) {
    const res = await api.post("files/read", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        count: options.length,
        ...options
      }),
      headers: options.headers
    });
    yield* (0, import_source.default)(res.body);
  }
  return read4;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/files/rm.js
init_buffer_polyfill();
var import_http2 = __toESM(require_http(), 1);
var createRm3 = configure((api) => {
  async function rm(path, options = {}) {
    const res = await api.post("files/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    const body = await res.text();
    if (body !== "") {
      const error = new import_http2.default.HTTPError(res);
      error.message = body;
      throw error;
    }
  }
  return rm;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/files/stat.js
init_buffer_polyfill();
var createStat3 = configure((api) => {
  async function stat(path, options = {}) {
    const res = await api.post("files/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    data.WithLocality = data.WithLocality || false;
    return toCoreInterface4(objectToCamelWithMetadata(data));
  }
  return stat;
});
function toCoreInterface4(entry) {
  entry.cid = CID2.parse(entry.hash);
  delete entry.hash;
  return entry;
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/files/touch.js
init_buffer_polyfill();
var createTouch = configure((api) => {
  async function touch(path, options = {}) {
    const res = await api.post("files/touch", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return touch;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/files/write.js
init_buffer_polyfill();
var createWrite = configure((api) => {
  async function write(path, input, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("files/write", {
      signal,
      searchParams: toUrlSearchParams({
        arg: path,
        streamChannels: true,
        count: options.length,
        ...options
      }),
      ...await multipartRequest([{
        content: input,
        path: "arg",
        mode: modeToString(options.mode),
        mtime: parseMtime(options.mtime)
      }], controller, options.headers)
    });
    await res.text();
  }
  return write;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/files/index.js
function createFiles(config) {
  return {
    chmod: createChmod(config),
    cp: createCp(config),
    flush: createFlush(config),
    ls: createLs(config),
    mkdir: createMkdir(config),
    mv: createMv(config),
    read: createRead(config),
    rm: createRm3(config),
    stat: createStat3(config),
    touch: createTouch(config),
    write: createWrite(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/key/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/key/export.js
init_buffer_polyfill();
var import_err_code8 = __toESM(require_err_code(), 1);
var createExport2 = configure((api) => {
  const exportKey = async (name10, password, options = {}) => {
    throw (0, import_err_code8.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return exportKey;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/key/gen.js
init_buffer_polyfill();
var createGen = configure((api) => {
  async function gen(name10, options) {
    const opts = options ?? { type: "Ed25519" };
    const res = await api.post("key/gen", {
      signal: opts.signal,
      searchParams: toUrlSearchParams({
        arg: name10,
        ...opts
      }),
      headers: opts.headers
    });
    const data = await res.json();
    return objectToCamel(data);
  }
  return gen;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/key/import.js
init_buffer_polyfill();
var createImport2 = configure((api) => {
  async function importKey(name10, pem, password, options = {}) {
    const res = await api.post("key/import", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name10,
        pem,
        password,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data);
  }
  return importKey;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/key/info.js
init_buffer_polyfill();
var import_err_code9 = __toESM(require_err_code(), 1);
var createInfo = configure((api) => {
  const info = async (name10, options = {}) => {
    throw (0, import_err_code9.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return info;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/key/list.js
init_buffer_polyfill();
var createList3 = configure((api) => {
  async function list(options = {}) {
    const res = await api.post("key/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return (data.Keys || []).map((k) => objectToCamel(k));
  }
  return list;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/key/rename.js
init_buffer_polyfill();
var createRename = configure((api) => {
  async function rename(oldName, newName, options = {}) {
    const res = await api.post("key/rename", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          oldName,
          newName
        ],
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return rename;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/key/rm.js
init_buffer_polyfill();
var createRm4 = configure((api) => {
  async function rm(name10, options = {}) {
    const res = await api.post("key/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name10,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data.Keys[0]);
  }
  return rm;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/key/index.js
function createKey(config) {
  return {
    export: createExport2(config),
    gen: createGen(config),
    import: createImport2(config),
    info: createInfo(config),
    list: createList3(config),
    rename: createRename(config),
    rm: createRm4(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/log/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/log/level.js
init_buffer_polyfill();
var createLevel = configure((api) => {
  async function level(subsystem, level2, options = {}) {
    const res = await api.post("log/level", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          subsystem,
          level2
        ],
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return level;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/log/ls.js
init_buffer_polyfill();
var createLs2 = configure((api) => {
  async function ls(options = {}) {
    const res = await api.post("log/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.Strings;
  }
  return ls;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/log/tail.js
init_buffer_polyfill();
var createTail = configure((api) => {
  async function* tail(options = {}) {
    const res = await api.post("log/tail", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    yield* res.ndjson();
  }
  return tail;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/log/index.js
function createLog(config) {
  return {
    level: createLevel(config),
    ls: createLs2(config),
    tail: createTail(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/name/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/name/publish.js
init_buffer_polyfill();
var createPublish = configure((api) => {
  async function publish(path, options = {}) {
    const res = await api.post("name/publish", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${path}`,
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return publish;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/name/resolve.js
init_buffer_polyfill();
var createResolve2 = configure((api) => {
  async function* resolve2(path, options = {}) {
    const res = await api.post("name/resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        stream: true,
        ...options
      }),
      headers: options.headers
    });
    for await (const result of res.ndjson()) {
      yield result.Path;
    }
  }
  return resolve2;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/name/pubsub/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/name/pubsub/cancel.js
init_buffer_polyfill();
var createCancel = configure((api) => {
  async function cancel(name10, options = {}) {
    const res = await api.post("name/pubsub/cancel", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name10,
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return cancel;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/name/pubsub/state.js
init_buffer_polyfill();
var createState = configure((api) => {
  async function state(options = {}) {
    const res = await api.post("name/pubsub/state", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return state;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/name/pubsub/subs.js
init_buffer_polyfill();
var createSubs = configure((api) => {
  async function subs(options = {}) {
    const res = await api.post("name/pubsub/subs", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.Strings || [];
  }
  return subs;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/name/pubsub/index.js
function createPubsub(config) {
  return {
    cancel: createCancel(config),
    state: createState(config),
    subs: createSubs(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/name/index.js
function createName(config) {
  return {
    publish: createPublish(config),
    resolve: createResolve2(config),
    pubsub: createPubsub(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/object/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/object/data.js
init_buffer_polyfill();
var createData = configure((api) => {
  async function data(cid, options = {}) {
    const res = await api.post("object/data", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID2.decode(cid) : cid}`,
        ...options
      }),
      headers: options.headers
    });
    const data2 = await res.arrayBuffer();
    return new Uint8Array(data2, 0, data2.byteLength);
  }
  return data;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/object/get.js
init_buffer_polyfill();
var createGet5 = configure((api) => {
  async function get(cid, options = {}) {
    const res = await api.post("object/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID2.decode(cid) : cid}`,
        dataEncoding: "base64",
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      Data: fromString5(data.Data, "base64pad"),
      Links: (data.Links || []).map((link) => ({
        Name: link.Name,
        Hash: CID2.parse(link.Hash),
        Tsize: link.Size
      }))
    };
  }
  return get;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/object/links.js
init_buffer_polyfill();
var createLinks = configure((api) => {
  async function links(cid, options = {}) {
    const res = await api.post("object/links", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID2.decode(cid) : cid}`,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return (data.Links || []).map((l) => ({
      Name: l.Name,
      Tsize: l.Size,
      Hash: CID2.parse(l.Hash)
    }));
  }
  return links;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/object/new.js
init_buffer_polyfill();
var createNew = configure((api) => {
  async function newObject(options = {}) {
    const res = await api.post("object/new", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: options.template,
        ...options
      }),
      headers: options.headers
    });
    const { Hash: Hash2 } = await res.json();
    return CID2.parse(Hash2);
  }
  return newObject;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/object/put.js
init_buffer_polyfill();
var createPut4 = (codecs3, options) => {
  const fn = configure((api) => {
    const dagPut = createPut2(codecs3, options);
    async function put(obj, options2 = {}) {
      return dagPut(obj, {
        ...options2,
        storeCodec: "dag-pb",
        hashAlg: "sha2-256",
        version: 1
      });
    }
    return put;
  });
  return fn(options);
};

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/object/stat.js
init_buffer_polyfill();
var createStat4 = configure((api) => {
  async function stat(cid, options = {}) {
    const res = await api.post("object/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid}`,
        ...options
      }),
      headers: options.headers
    });
    const output = await res.json();
    return {
      ...output,
      Hash: CID2.parse(output.Hash)
    };
  }
  return stat;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/object/patch/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/object/patch/add-link.js
init_buffer_polyfill();
var createAddLink = configure((api) => {
  async function addLink(cid, dLink, options = {}) {
    const res = await api.post("object/patch/add-link", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`,
          // @ts-expect-error loose types
          dLink.Name || dLink.name || "",
          // @ts-expect-error loose types
          (dLink.Hash || dLink.cid || "").toString() || null
        ],
        ...options
      }),
      headers: options.headers
    });
    const { Hash: Hash2 } = await res.json();
    return CID2.parse(Hash2);
  }
  return addLink;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/object/patch/append-data.js
init_buffer_polyfill();
var createAppendData = configure((api) => {
  async function appendData(cid, data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("object/patch/append-data", {
      signal,
      searchParams: toUrlSearchParams({
        arg: `${cid}`,
        ...options
      }),
      ...await multipartRequest([data], controller, options.headers)
    });
    const { Hash: Hash2 } = await res.json();
    return CID2.parse(Hash2);
  }
  return appendData;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/object/patch/rm-link.js
init_buffer_polyfill();
var createRmLink = configure((api) => {
  async function rmLink(cid, dLink, options = {}) {
    const res = await api.post("object/patch/rm-link", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`,
          // @ts-expect-error loose types
          dLink.Name || dLink.name || null
        ],
        ...options
      }),
      headers: options.headers
    });
    const { Hash: Hash2 } = await res.json();
    return CID2.parse(Hash2);
  }
  return rmLink;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/object/patch/set-data.js
init_buffer_polyfill();
var createSetData = configure((api) => {
  async function setData(cid, data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("object/patch/set-data", {
      signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`
        ],
        ...options
      }),
      ...await multipartRequest([data], controller, options.headers)
    });
    const { Hash: Hash2 } = await res.json();
    return CID2.parse(Hash2);
  }
  return setData;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/object/patch/index.js
function createPatch(config) {
  return {
    addLink: createAddLink(config),
    appendData: createAppendData(config),
    rmLink: createRmLink(config),
    setData: createSetData(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/object/index.js
function createObject(codecs3, config) {
  return {
    data: createData(config),
    get: createGet5(config),
    links: createLinks(config),
    new: createNew(config),
    put: createPut4(codecs3, config),
    stat: createStat4(config),
    patch: createPatch(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/add-all.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/pins/normalise-input.js
init_buffer_polyfill();
var import_err_code10 = __toESM(require_err_code(), 1);
function isIterable(thing) {
  return Symbol.iterator in thing;
}
function isAsyncIterable(thing) {
  return Symbol.asyncIterator in thing;
}
function isCID(thing) {
  return CID2.asCID(thing) != null;
}
async function* normaliseInput2(input) {
  if (input === null || input === void 0) {
    throw (0, import_err_code10.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  const cid = CID2.asCID(input);
  if (cid) {
    yield toPin({ cid });
    return;
  }
  if (input instanceof String || typeof input === "string") {
    yield toPin({ path: input });
    return;
  }
  if (input.cid != null || input.path != null) {
    return yield toPin(input);
  }
  if (isIterable(input)) {
    const iterator = input[Symbol.iterator]();
    const first2 = iterator.next();
    if (first2.done) {
      return iterator;
    }
    if (isCID(first2.value)) {
      yield toPin({ cid: first2.value });
      for (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first2.value instanceof String || typeof first2.value === "string") {
      yield toPin({ path: first2.value });
      for (const path of iterator) {
        yield toPin({ path });
      }
      return;
    }
    if (first2.value.cid != null || first2.value.path != null) {
      yield toPin(first2.value);
      for (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code10.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  }
  if (isAsyncIterable(input)) {
    const iterator = input[Symbol.asyncIterator]();
    const first2 = await iterator.next();
    if (first2.done) return iterator;
    if (isCID(first2.value)) {
      yield toPin({ cid: first2.value });
      for await (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first2.value instanceof String || typeof first2.value === "string") {
      yield toPin({ path: first2.value });
      for await (const path of iterator) {
        yield toPin({ path });
      }
      return;
    }
    if (first2.value.cid != null || first2.value.path != null) {
      yield toPin(first2.value);
      for await (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code10.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  }
  throw (0, import_err_code10.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
function toPin(input) {
  const path = input.cid || `${input.path}`;
  if (!path) {
    throw (0, import_err_code10.default)(new Error("Unexpected input: Please path either a CID or an IPFS path"), "ERR_UNEXPECTED_INPUT");
  }
  const pin = {
    path,
    recursive: input.recursive !== false
  };
  if (input.metadata != null) {
    pin.metadata = input.metadata;
  }
  return pin;
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/add-all.js
var createAddAll = configure((api) => {
  async function* addAll(source, options = {}) {
    for await (const { path, recursive, metadata } of normaliseInput2(source)) {
      const res = await api.post("pin/add", {
        signal: options.signal,
        searchParams: toUrlSearchParams({
          ...options,
          arg: path,
          recursive,
          metadata: metadata ? JSON.stringify(metadata) : void 0,
          stream: true
        }),
        headers: options.headers
      });
      for await (const pin of res.ndjson()) {
        if (pin.Pins) {
          for (const cid of pin.Pins) {
            yield CID2.parse(cid);
          }
          continue;
        }
        yield CID2.parse(pin);
      }
    }
  }
  return addAll;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/add.js
init_buffer_polyfill();
function createAdd2(config) {
  const all2 = createAddAll(config);
  return configure(() => {
    async function add2(path, options = {}) {
      return last(all2([{
        path,
        ...options
      }], options));
    }
    return add2;
  })(config);
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/ls.js
init_buffer_polyfill();
function toPin2(type, cid, metadata) {
  const pin = {
    type,
    cid: CID2.parse(cid)
  };
  if (metadata) {
    pin.metadata = metadata;
  }
  return pin;
}
var createLs3 = configure((api) => {
  async function* ls(options = {}) {
    let paths = [];
    if (options.paths) {
      paths = Array.isArray(options.paths) ? options.paths : [options.paths];
    }
    const res = await api.post("pin/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        arg: paths.map((path) => `${path}`),
        stream: true
      }),
      headers: options.headers
    });
    for await (const pin of res.ndjson()) {
      if (pin.Keys) {
        for (const cid of Object.keys(pin.Keys)) {
          yield toPin2(pin.Keys[cid].Type, cid, pin.Keys[cid].Metadata);
        }
        return;
      }
      yield toPin2(pin.Type, pin.Cid, pin.Metadata);
    }
  }
  return ls;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/rm-all.js
init_buffer_polyfill();
var createRmAll = configure((api) => {
  async function* rmAll(source, options = {}) {
    for await (const { path, recursive } of normaliseInput2(source)) {
      const searchParams = new URLSearchParams(options.searchParams);
      searchParams.append("arg", `${path}`);
      if (recursive != null) searchParams.set("recursive", String(recursive));
      const res = await api.post("pin/rm", {
        signal: options.signal,
        headers: options.headers,
        searchParams: toUrlSearchParams({
          ...options,
          arg: `${path}`,
          recursive
        })
      });
      for await (const pin of res.ndjson()) {
        if (pin.Pins) {
          yield* pin.Pins.map((cid) => CID2.parse(cid));
          continue;
        }
        yield CID2.parse(pin);
      }
    }
  }
  return rmAll;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/rm.js
init_buffer_polyfill();
var createRm5 = (config) => {
  const all2 = createRmAll(config);
  return configure(() => {
    async function rm(path, options = {}) {
      return last(all2([{
        path,
        ...options
      }], options));
    }
    return rm;
  })(config);
};

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/remote/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/remote/add.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/remote/utils.js
init_buffer_polyfill();
var decodePin = ({ Name: name10, Status: status, Cid: cid }) => {
  return {
    cid: CID2.parse(cid),
    name: name10,
    status
  };
};
var encodeService = (service) => {
  if (typeof service === "string" && service !== "") {
    return service;
  } else {
    throw new TypeError("service name must be passed");
  }
};
var encodeCID4 = (cid) => {
  if (CID2.asCID(cid)) {
    return cid.toString();
  } else {
    throw new TypeError(`CID instance expected instead of ${typeof cid}`);
  }
};
var encodeQuery = ({ service, cid, name: name10, status, all: all2 }) => {
  const query = toUrlSearchParams({
    service: encodeService(service),
    name: name10,
    force: all2 ? true : void 0
  });
  if (cid) {
    for (const value2 of cid) {
      query.append("cid", encodeCID4(value2));
    }
  }
  if (status) {
    for (const value2 of status) {
      query.append("status", value2);
    }
  }
  return query;
};
var encodeAddParams = ({ cid, service, background, name: name10, origins }) => {
  const params = toUrlSearchParams({
    arg: encodeCID4(cid),
    service: encodeService(service),
    name: name10,
    background: background ? true : void 0
  });
  if (origins) {
    for (const origin of origins) {
      params.append("origin", origin.toString());
    }
  }
  return params;
};

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/remote/add.js
function createAdd3(client2) {
  async function add2(cid, { timeout, signal, headers, ...query }) {
    const response = await client2.post("pin/remote/add", {
      timeout,
      signal,
      headers,
      searchParams: encodeAddParams({ cid, ...query })
    });
    return decodePin(await response.json());
  }
  return add2;
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/remote/ls.js
init_buffer_polyfill();
function createLs4(client2) {
  async function* ls({ timeout, signal, headers, ...query }) {
    const response = await client2.post("pin/remote/ls", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery(query)
    });
    for await (const pin of response.ndjson()) {
      yield decodePin(pin);
    }
  }
  return ls;
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/remote/rm.js
init_buffer_polyfill();
function createRm6(client2) {
  async function rm({ timeout, signal, headers, ...query }) {
    await client2.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: false
      })
    });
  }
  return rm;
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/remote/rm-all.js
init_buffer_polyfill();
function createRmAll2(client2) {
  async function rmAll({ timeout, signal, headers, ...query }) {
    await client2.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: true
      })
    });
  }
  return rmAll;
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/remote/service/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/remote/service/add.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/remote/service/utils.js
init_buffer_polyfill();
function encodeEndpoint(url) {
  const href = String(url);
  if (href === "undefined") {
    throw Error("endpoint is required");
  }
  return href[href.length - 1] === "/" ? href.slice(0, -1) : href;
}
function decodeRemoteService(json) {
  return {
    service: json.Service,
    endpoint: new URL(json.ApiEndpoint),
    ...json.Stat && { stat: decodeStat(json.Stat) }
  };
}
function decodeStat(json) {
  switch (json.Status) {
    case "valid": {
      const { Pinning, Pinned, Queued, Failed } = json.PinCount;
      return {
        status: "valid",
        pinCount: {
          queued: Queued,
          pinning: Pinning,
          pinned: Pinned,
          failed: Failed
        }
      };
    }
    case "invalid": {
      return { status: "invalid" };
    }
    default: {
      return { status: json.Status };
    }
  }
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/remote/service/add.js
function createAdd4(client2) {
  async function add2(name10, options) {
    const { endpoint, key, headers, timeout, signal } = options;
    await client2.post("pin/remote/service/add", {
      timeout,
      signal,
      searchParams: toUrlSearchParams({
        arg: [name10, encodeEndpoint(endpoint), key]
      }),
      headers
    });
  }
  return add2;
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/remote/service/ls.js
init_buffer_polyfill();
function createLs5(client2) {
  async function ls(options = {}) {
    const { stat, headers, timeout, signal } = options;
    const response = await client2.post("pin/remote/service/ls", {
      timeout,
      signal,
      headers,
      searchParams: stat === true ? toUrlSearchParams({ stat }) : void 0
    });
    const { RemoteServices } = await response.json();
    return RemoteServices.map(decodeRemoteService);
  }
  return ls;
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/remote/service/rm.js
init_buffer_polyfill();
function createRm7(client2) {
  async function rm(name10, options = {}) {
    await client2.post("pin/remote/service/rm", {
      signal: options.signal,
      headers: options.headers,
      searchParams: toUrlSearchParams({
        arg: name10
      })
    });
  }
  return rm;
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/remote/service/index.js
function createService(config) {
  const client2 = new Client(config);
  return {
    add: createAdd4(client2),
    ls: createLs5(client2),
    rm: createRm7(client2)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/remote/index.js
function createRemote(config) {
  const client2 = new Client(config);
  return {
    add: createAdd3(client2),
    ls: createLs4(client2),
    rm: createRm6(client2),
    rmAll: createRmAll2(client2),
    service: createService(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pin/index.js
function createPin(config) {
  return {
    addAll: createAddAll(config),
    add: createAdd2(config),
    ls: createLs3(config),
    rmAll: createRmAll(config),
    rm: createRm5(config),
    remote: createRemote(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pubsub/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pubsub/ls.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/lib/http-rpc-wire-format.js
init_buffer_polyfill();
var rpcArrayToTextArray = (strings) => {
  if (Array.isArray(strings)) {
    return strings.map(rpcToText);
  }
  return strings;
};
var rpcToText = (mb) => toString5(rpcToBytes(mb));
var rpcToBytes = (mb) => base64url2.decode(mb);
var rpcToBigInt = (mb) => BigInt(`0x${toString5(base64url2.decode(mb), "base16")}`);
var textToUrlSafeRpc = (text) => base64url2.encode(fromString5(text));

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pubsub/ls.js
var createLs6 = configure((api) => {
  async function ls(options = {}) {
    const { Strings } = await (await api.post("pubsub/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return rpcArrayToTextArray(Strings) || [];
  }
  return ls;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pubsub/peers.js
init_buffer_polyfill();
var createPeers = configure((api) => {
  async function peers(topic, options = {}) {
    const res = await api.post("pubsub/peers", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: textToUrlSafeRpc(topic),
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return peers;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pubsub/publish.js
init_buffer_polyfill();
var createPublish2 = configure((api) => {
  async function publish(topic, data, options = {}) {
    const searchParams = toUrlSearchParams({
      arg: textToUrlSafeRpc(topic),
      ...options
    });
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("pubsub/pub", {
      signal,
      searchParams,
      ...await multipartRequest([data], controller, options.headers)
    });
    await res.text();
  }
  return publish;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pubsub/subscribe.js
init_buffer_polyfill();
var log2 = logger("ipfs-http-client:pubsub:subscribe");
var createSubscribe = (options, subsTracker) => {
  return configure((api) => {
    async function subscribe(topic, handler, options2 = {}) {
      options2.signal = subsTracker.subscribe(topic, handler, options2.signal);
      let done;
      let fail;
      const result = new Promise((resolve2, reject) => {
        done = resolve2;
        fail = reject;
      });
      const ffWorkaround = setTimeout(() => done(), 1e3);
      api.post("pubsub/sub", {
        signal: options2.signal,
        searchParams: toUrlSearchParams({
          arg: textToUrlSafeRpc(topic),
          ...options2
        }),
        headers: options2.headers
      }).catch((err) => {
        subsTracker.unsubscribe(topic, handler);
        fail(err);
      }).then((response) => {
        clearTimeout(ffWorkaround);
        if (!response) {
          return;
        }
        readMessages(response, {
          onMessage: (message) => {
            if (!handler) {
              return;
            }
            if (typeof handler === "function") {
              handler(message);
              return;
            }
            if (typeof handler.handleEvent === "function") {
              handler.handleEvent(message);
            }
          },
          onEnd: () => subsTracker.unsubscribe(topic, handler),
          onError: options2.onError
        });
        done();
      });
      return result;
    }
    return subscribe;
  })(options);
};
async function readMessages(response, { onMessage, onEnd, onError }) {
  onError = onError || log2;
  try {
    for await (const msg of response.ndjson()) {
      try {
        if (!msg.from) {
          continue;
        }
        if (msg.from != null && msg.seqno != null) {
          onMessage({
            type: "signed",
            from: peerIdFromString(msg.from),
            data: rpcToBytes(msg.data),
            sequenceNumber: rpcToBigInt(msg.seqno),
            topic: rpcToText(msg.topicIDs[0]),
            key: rpcToBytes(msg.key ?? "u"),
            signature: rpcToBytes(msg.signature ?? "u")
          });
        } else {
          onMessage({
            type: "unsigned",
            data: rpcToBytes(msg.data),
            topic: rpcToText(msg.topicIDs[0])
          });
        }
      } catch (err) {
        err.message = `Failed to parse pubsub message: ${err.message}`;
        onError(err, false, msg);
      }
    }
  } catch (err) {
    if (!isAbortError(err)) {
      onError(err, true);
    }
  } finally {
    onEnd();
  }
}
var isAbortError = (error) => {
  switch (error.type) {
    case "aborted":
      return true;
    // It is `abort` in Electron instead of `aborted`
    case "abort":
      return true;
    default:
      return error.name === "AbortError";
  }
};

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pubsub/unsubscribe.js
init_buffer_polyfill();
var createUnsubscribe = (options, subsTracker) => {
  async function unsubscribe(topic, handler) {
    subsTracker.unsubscribe(topic, handler);
  }
  return unsubscribe;
};

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pubsub/subscription-tracker.js
init_buffer_polyfill();
var SubscriptionTracker = class {
  constructor() {
    this._subs = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} topic
   * @param {MessageHandlerFn} handler
   * @param {AbortSignal} [signal]
   */
  subscribe(topic, handler, signal) {
    const topicSubs = this._subs.get(topic) || [];
    if (topicSubs.find((s) => s.handler === handler)) {
      throw new Error(`Already subscribed to ${topic} with this handler`);
    }
    const controller = new AbortController();
    this._subs.set(topic, [{ handler, controller }].concat(topicSubs));
    if (signal) {
      signal.addEventListener("abort", () => this.unsubscribe(topic, handler));
    }
    return controller.signal;
  }
  /**
   * @param {string} topic
   * @param {MessageHandlerFn} [handler]
   */
  unsubscribe(topic, handler) {
    const subs = this._subs.get(topic) || [];
    let unsubs;
    if (handler) {
      this._subs.set(topic, subs.filter((s) => s.handler !== handler));
      unsubs = subs.filter((s) => s.handler === handler);
    } else {
      this._subs.set(topic, []);
      unsubs = subs;
    }
    if (!(this._subs.get(topic) || []).length) {
      this._subs.delete(topic);
    }
    unsubs.forEach((s) => s.controller.abort());
  }
};

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/pubsub/index.js
function createPubsub2(config) {
  const subscriptionTracker = new SubscriptionTracker();
  return {
    ls: createLs6(config),
    peers: createPeers(config),
    publish: createPublish2(config),
    subscribe: createSubscribe(config, subscriptionTracker),
    unsubscribe: createUnsubscribe(config, subscriptionTracker)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/refs/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/refs/local.js
init_buffer_polyfill();
var createLocal = configure((api) => {
  async function* refsLocal(options = {}) {
    const res = await api.post("refs/local", {
      signal: options.signal,
      transform: objectToCamel,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    yield* res.ndjson();
  }
  return refsLocal;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/refs/index.js
var createRefs = configure((api, opts) => {
  const refs = async function* (args, options = {}) {
    const argsArr = Array.isArray(args) ? args : [args];
    const res = await api.post("refs", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: argsArr.map((arg) => `${arg instanceof Uint8Array ? CID2.decode(arg) : arg}`),
        ...options
      }),
      headers: options.headers,
      transform: objectToCamel
    });
    yield* res.ndjson();
  };
  return Object.assign(refs, {
    local: createLocal(opts)
  });
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/repo/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/repo/gc.js
init_buffer_polyfill();
var createGc = configure((api) => {
  async function* gc(options = {}) {
    const res = await api.post("repo/gc", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers,
      transform: (res2) => {
        return {
          err: res2.Error ? new Error(res2.Error) : null,
          cid: (res2.Key || {})["/"] ? CID2.parse(res2.Key["/"]) : null
        };
      }
    });
    yield* res.ndjson();
  }
  return gc;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/repo/stat.js
init_buffer_polyfill();
var createStat5 = configure((api) => {
  async function stat(options = {}) {
    const res = await api.post("repo/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return {
      numObjects: BigInt(data.NumObjects),
      repoSize: BigInt(data.RepoSize),
      repoPath: data.RepoPath,
      version: data.Version,
      storageMax: BigInt(data.StorageMax)
    };
  }
  return stat;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/repo/version.js
init_buffer_polyfill();
var createVersion = configure((api) => {
  async function version(options = {}) {
    const res = await (await api.post("repo/version", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return res.Version;
  }
  return version;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/repo/index.js
function createRepo(config) {
  return {
    gc: createGc(config),
    stat: createStat5(config),
    version: createVersion(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/stats/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/stats/bw.js
init_buffer_polyfill();
var createBw = configure((api) => {
  async function* bw(options = {}) {
    const res = await api.post("stats/bw", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers,
      transform: (stats) => ({
        totalIn: BigInt(stats.TotalIn),
        totalOut: BigInt(stats.TotalOut),
        rateIn: parseFloat(stats.RateIn),
        rateOut: parseFloat(stats.RateOut)
      })
    });
    yield* res.ndjson();
  }
  return bw;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/stats/index.js
function createStats(config) {
  return {
    bitswap: createStat(config),
    repo: createStat5(config),
    bw: createBw(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/swarm/index.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/swarm/addrs.js
init_buffer_polyfill();
var createAddrs = configure((api) => {
  async function addrs(options = {}) {
    const res = await api.post("swarm/addrs", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Addrs } = await res.json();
    return Object.keys(Addrs).map((id) => ({
      id: peerIdFromString(id),
      addrs: (Addrs[id] || []).map((a) => multiaddr(a))
    }));
  }
  return addrs;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/swarm/connect.js
init_buffer_polyfill();
var createConnect = configure((api) => {
  async function connect(addr, options = {}) {
    const res = await api.post("swarm/connect", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return connect;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/swarm/disconnect.js
init_buffer_polyfill();
var createDisconnect = configure((api) => {
  async function disconnect(addr, options = {}) {
    const res = await api.post("swarm/disconnect", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return disconnect;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/swarm/local-addrs.js
init_buffer_polyfill();
var createLocalAddrs = configure((api) => {
  async function localAddrs(options = {}) {
    const res = await api.post("swarm/addrs/local", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return (Strings || []).map((a) => multiaddr(a));
  }
  return localAddrs;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/swarm/peers.js
init_buffer_polyfill();
var createPeers2 = configure((api) => {
  async function peers(options = {}) {
    const res = await api.post("swarm/peers", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return (Peers || []).map((peer) => {
      return {
        addr: multiaddr(peer.Addr),
        peer: peerIdFromString(peer.Peer),
        muxer: peer.Muxer,
        latency: peer.Latency,
        streams: peer.Streams,
        direction: peer.Direction == null ? void 0 : peer.Direction === 0 ? "inbound" : "outbound"
      };
    });
  }
  return peers;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/swarm/index.js
function createSwarm(config) {
  return {
    addrs: createAddrs(config),
    connect: createConnect(config),
    disconnect: createDisconnect(config),
    localAddrs: createLocalAddrs(config),
    peers: createPeers2(config)
  };
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/add.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/add-all.js
init_buffer_polyfill();
var createAddAll2 = configure((api) => {
  async function* addAll(source, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const { headers, body, total, parts } = await multipartRequest(source, controller, options.headers);
    const [progressFn, onUploadProgress] = typeof options.progress === "function" ? createProgressHandler(total, parts, options.progress) : [void 0, void 0];
    const res = await api.post("add", {
      searchParams: toUrlSearchParams({
        "stream-channels": true,
        ...options,
        progress: Boolean(progressFn)
      }),
      onUploadProgress,
      signal,
      headers,
      body
    });
    for await (let file of res.ndjson()) {
      file = objectToCamel(file);
      if (file.hash !== void 0) {
        yield toCoreInterface5(file);
      } else if (progressFn) {
        progressFn(file.bytes || 0, file.name);
      }
    }
  }
  return addAll;
});
var createProgressHandler = (total, parts, progress) => parts ? [void 0, createOnUploadProgress(total, parts, progress)] : [progress, void 0];
var createOnUploadProgress = (size, parts, progress) => {
  let index = 0;
  const count = parts.length;
  return ({ loaded, total }) => {
    const position = Math.floor(loaded / total * size);
    while (index < count) {
      const { start, end, name: name10 } = parts[index];
      if (position < end) {
        progress(position - start, name10);
        break;
      } else {
        progress(end - start, name10);
        index += 1;
      }
    }
  };
};
function toCoreInterface5({ name: name10, hash, size, mode, mtime, mtimeNsecs }) {
  const output = {
    path: name10,
    cid: CID2.parse(hash),
    size: parseInt(size)
  };
  if (mode != null) {
    output.mode = parseInt(mode, 8);
  }
  if (mtime != null) {
    output.mtime = {
      secs: mtime,
      nsecs: mtimeNsecs || 0
    };
  }
  return output;
}

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/files/normalise-input-single.js
init_buffer_polyfill();

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/files/normalise-content.js
init_buffer_polyfill();
var import_err_code11 = __toESM(require_err_code(), 1);

// node_modules/.pnpm/blob-to-it@2.0.10/node_modules/blob-to-it/dist/src/index.js
init_buffer_polyfill();
function blobToIt(blob) {
  if (typeof blob.stream === "function") {
    return browserReadableStreamToIt(blob.stream());
  }
  return browserReadableStreamToIt(new Response(blob).body);
}

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/files/normalise-content.js
async function* toAsyncIterable(thing) {
  yield thing;
}
async function normaliseContent2(input) {
  if (isBytes4(input)) {
    return toAsyncIterable(toBytes3(input));
  }
  if (typeof input === "string" || input instanceof String) {
    return toAsyncIterable(toBytes3(input.toString()));
  }
  if (isBlob(input)) {
    return blobToIt(input);
  }
  if (isReadableStream(input)) {
    input = browserReadableStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = peekableIterator(input);
    const { value: value2, done } = await peekable.peek();
    if (done) {
      return toAsyncIterable(new Uint8Array(0));
    }
    peekable.push(value2);
    if (Number.isInteger(value2)) {
      return toAsyncIterable(Uint8Array.from(await all(peekable)));
    }
    if (isBytes4(value2) || typeof value2 === "string" || value2 instanceof String) {
      return map(peekable, toBytes3);
    }
  }
  throw (0, import_err_code11.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
function toBytes3(chunk) {
  if (chunk instanceof Uint8Array) {
    return chunk;
  }
  if (ArrayBuffer.isView(chunk)) {
    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  }
  if (chunk instanceof ArrayBuffer) {
    return new Uint8Array(chunk);
  }
  if (Array.isArray(chunk)) {
    return Uint8Array.from(chunk);
  }
  return fromString5(chunk.toString());
}

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/files/normalise-candidate-single.js
init_buffer_polyfill();
var import_err_code12 = __toESM(require_err_code(), 1);
async function* normaliseCandidateSingle(input, normaliseContent3) {
  if (input === null || input === void 0) {
    throw (0, import_err_code12.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  if (typeof input === "string" || input instanceof String) {
    yield toFileObject2(input.toString(), normaliseContent3);
    return;
  }
  if (isBytes4(input) || isBlob(input)) {
    yield toFileObject2(input, normaliseContent3);
    return;
  }
  if (isReadableStream(input)) {
    input = browserReadableStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = peekableIterator(input);
    const { value: value2, done } = await peekable.peek();
    if (done) {
      yield { content: [] };
      return;
    }
    peekable.push(value2);
    if (Number.isInteger(value2) || isBytes4(value2) || typeof value2 === "string" || value2 instanceof String) {
      yield toFileObject2(peekable, normaliseContent3);
      return;
    }
    throw (0, import_err_code12.default)(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isFileObject(input)) {
    yield toFileObject2(input, normaliseContent3);
    return;
  }
  throw (0, import_err_code12.default)(new Error('Unexpected input: cannot convert "' + typeof input + '" into ImportCandidate'), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject2(input, normaliseContent3) {
  const { path, mode, mtime, content } = input;
  const file = {
    path: path || "",
    mode: parseMode(mode),
    mtime: parseMtime2(mtime)
  };
  if (content) {
    file.content = await normaliseContent3(content);
  } else if (!path) {
    file.content = await normaliseContent3(input);
  }
  return file;
}

// node_modules/.pnpm/ipfs-core-utils@0.18.1_encoding@0.1.13/node_modules/ipfs-core-utils/src/files/normalise-input-single.js
function normaliseInput3(input) {
  return normaliseCandidateSingle(input, normaliseContent2);
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/add.js
function createAdd5(options) {
  const all2 = createAddAll2(options);
  return configure(() => {
    async function add2(input, options2 = {}) {
      return await last(all2(normaliseInput3(input), options2));
    }
    return add2;
  })(options);
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/cat.js
init_buffer_polyfill();
var createCat = configure((api) => {
  async function* cat(path, options = {}) {
    const res = await api.post("cat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path.toString(),
        ...options
      }),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return cat;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/commands.js
init_buffer_polyfill();
var createCommands = configure((api) => {
  const commands = async (options = {}) => {
    const res = await api.post("commands", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  };
  return commands;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/dns.js
init_buffer_polyfill();
var createDns = configure((api) => {
  const dns = async (domain, options = {}) => {
    const res = await api.post("dns", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: domain,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data.Path;
  };
  return dns;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/get-endpoint-config.js
init_buffer_polyfill();
var createGetEndpointConfig = configure((api) => {
  return () => {
    const url = new URL(api.opts.base || "");
    return {
      host: url.hostname,
      port: url.port,
      protocol: url.protocol,
      pathname: url.pathname,
      "api-path": url.pathname
    };
  };
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/get.js
init_buffer_polyfill();
var createGet6 = configure((api) => {
  async function* get(path, options = {}) {
    const opts = {
      arg: `${path instanceof Uint8Array ? CID2.decode(path) : path}`,
      ...options
    };
    if (opts.compressionLevel) {
      opts["compression-level"] = opts.compressionLevel;
      delete opts.compressionLevel;
    }
    const res = await api.post("get", {
      signal: options.signal,
      searchParams: toUrlSearchParams(opts),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return get;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/id.js
init_buffer_polyfill();
var createId = configure((api) => {
  async function id(options = {}) {
    const res = await api.post("id", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: options.peerId ? options.peerId.toString() : void 0,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    const output = {
      ...objectToCamel(data)
    };
    output.id = peerIdFromString(output.id);
    if (output.addresses) {
      output.addresses = output.addresses.map((ma) => multiaddr(ma));
    }
    return output;
  }
  return id;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/is-online.js
init_buffer_polyfill();
var createIsOnline = (options) => {
  const id = createId(options);
  async function isOnline(options2 = {}) {
    const res = await id(options2);
    return Boolean(res && res.addresses && res.addresses.length);
  }
  return isOnline;
};

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/ls.js
init_buffer_polyfill();
var createLs7 = configure((api, opts) => {
  async function* ls(path, options = {}) {
    const pathStr = `${path instanceof Uint8Array ? CID2.decode(path) : path}`;
    async function mapLink(link) {
      let hash = link.Hash;
      if (hash.includes("/")) {
        const ipfsPath = hash.startsWith("/ipfs/") ? hash : `/ipfs/${hash}`;
        const stats = await createStat3(opts)(ipfsPath);
        hash = stats.cid;
      } else {
        hash = CID2.parse(hash);
      }
      const entry = {
        name: link.Name,
        path: pathStr + (link.Name ? `/${link.Name}` : ""),
        size: link.Size,
        cid: hash,
        type: typeOf(link)
      };
      if (link.Mode) {
        entry.mode = parseInt(link.Mode, 8);
      }
      if (link.Mtime !== void 0 && link.Mtime !== null) {
        entry.mtime = {
          secs: link.Mtime
        };
        if (link.MtimeNsecs !== void 0 && link.MtimeNsecs !== null) {
          entry.mtime.nsecs = link.MtimeNsecs;
        }
      }
      return entry;
    }
    const res = await api.post("ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: pathStr,
        ...options
      }),
      headers: options.headers
    });
    for await (let result of res.ndjson()) {
      result = result.Objects;
      if (!result) {
        throw new Error("expected .Objects in results");
      }
      result = result[0];
      if (!result) {
        throw new Error("expected one array in results.Objects");
      }
      const links = result.Links;
      if (!Array.isArray(links)) {
        throw new Error("expected one array in results.Objects[0].Links");
      }
      if (!links.length) {
        yield mapLink(result);
        return;
      }
      yield* links.map(mapLink);
    }
  }
  return ls;
});
function typeOf(link) {
  switch (link.Type) {
    case 1:
    case 5:
      return "dir";
    case 2:
      return "file";
    default:
      return "file";
  }
}

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/mount.js
init_buffer_polyfill();
var createMount = configure((api) => {
  async function mount(options = {}) {
    const res = await api.post("dns", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return mount;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/ping.js
init_buffer_polyfill();
var createPing = configure((api) => {
  async function* ping(peerId, options = {}) {
    const res = await api.post("ping", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${peerId}`,
        ...options
      }),
      headers: options.headers,
      transform: objectToCamel
    });
    yield* res.ndjson();
  }
  return ping;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/resolve.js
init_buffer_polyfill();
var createResolve3 = configure((api) => {
  async function resolve2(path, options = {}) {
    const res = await api.post("resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    const { Path } = await res.json();
    return Path;
  }
  return resolve2;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/start.js
init_buffer_polyfill();
var import_err_code13 = __toESM(require_err_code(), 1);
var createStart = configure((api) => {
  const start = async (options = {}) => {
    throw (0, import_err_code13.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return start;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/stop.js
init_buffer_polyfill();
var createStop = configure((api) => {
  async function stop(options = {}) {
    const res = await api.post("shutdown", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    await res.text();
  }
  return stop;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/version.js
init_buffer_polyfill();
var createVersion2 = configure((api) => {
  async function version(options = {}) {
    const res = await api.post("version", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return {
      ...objectToCamel(await res.json()),
      "ipfs-http-client": "1.0.0"
    };
  }
  return version;
});

// node_modules/.pnpm/ipfs-http-client@60.0.1_encoding@0.1.13/node_modules/ipfs-http-client/src/index.js
var import_glob_source = __toESM(require_glob_source(), 1);
var import_url_source = __toESM(require_url_source(), 1);
function create4(options = {}) {
  const id = {
    name: identity.name,
    code: identity.code,
    encode: (id2) => id2,
    decode: (id2) => id2
  };
  const multibaseCodecs = Object.values(bases);
  (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach((base5) => multibaseCodecs.push(base5));
  const multibases = new Multibases({
    bases: multibaseCodecs,
    loadBase: options.ipld && options.ipld.loadBase
  });
  const blockCodecs = Object.values(codecs);
  [src_exports, src_exports2, src_exports3, lib_exports, id].concat(options.ipld && options.ipld.codecs || []).forEach((codec) => blockCodecs.push(codec));
  const multicodecs = new Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const multihashHashers = Object.values(hashes);
  (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach((hasher) => multihashHashers.push(hasher));
  const multihashes = new Multihashes({
    hashers: multihashHashers,
    loadHasher: options.ipld && options.ipld.loadHasher
  });
  const client2 = {
    add: createAdd5(options),
    addAll: createAddAll2(options),
    bitswap: createBitswap(options),
    block: createBlock(options),
    bootstrap: createBootstrap(options),
    cat: createCat(options),
    commands: createCommands(options),
    config: createConfig(options),
    dag: createDag(multicodecs, options),
    dht: createDht(options),
    diag: createDiag(options),
    dns: createDns(options),
    files: createFiles(options),
    get: createGet6(options),
    getEndpointConfig: createGetEndpointConfig(options),
    id: createId(options),
    isOnline: createIsOnline(options),
    key: createKey(options),
    log: createLog(options),
    ls: createLs7(options),
    mount: createMount(options),
    name: createName(options),
    object: createObject(multicodecs, options),
    pin: createPin(options),
    ping: createPing(options),
    pubsub: createPubsub2(options),
    refs: createRefs(options),
    repo: createRepo(options),
    resolve: createResolve3(options),
    start: createStart(options),
    stats: createStats(options),
    stop: createStop(options),
    swarm: createSwarm(options),
    version: createVersion2(options),
    bases: multibases,
    codecs: multicodecs,
    hashers: multihashes
  };
  return client2;
}

// src/services/ipfs.ts
var import_buffer4 = __toESM(require_buffer());
var client = create4();
var ipfsCache = /* @__PURE__ */ new Map();
async function uploadToIPFS(data) {
  const { cid } = await client.add(data);
  return cid;
}
async function downloadFromIPFS(cid) {
  if (ipfsCache.has(cid)) {
    return ipfsCache.get(cid);
  }
  const response = await fetch(`https://ipfs.io/ipfs/${cid}`);
  if (!response.ok) {
    throw new Error(
      `Failed to fetch from IPFS gateway: ${response.statusText}`
    );
  }
  const arrayBuffer = await response.arrayBuffer();
  const buffer2 = import_buffer4.Buffer.from(arrayBuffer);
  ipfsCache.set(cid, buffer2);
  return buffer2;
}

// src/core/unified-balance-service.ts
init_buffer_polyfill();
var UnifiedBalanceService = class {
  constructor(l1Client2, l2Client2, sidechainClient2) {
    this.l1Client = l1Client2;
    this.l2Client = l2Client2;
    this.sidechainClient = sidechainClient2;
  }
  /**
   *  Bolt: Fetch balances across all layers in parallel to minimize UI latency.
   * This approach avoids sequential network requests, reducing the total time to
   * display a consolidated view of the user's wealth.
   */
  async getUnifiedBalance(account, asset) {
    const [l1Balance, l2Balance, sidechainBalance] = await Promise.all([
      this.l1Client.getBalance(account.address, asset),
      this.l2Client.getBalance(account),
      this.sidechainClient.getBalance(account, asset)
    ]);
    const toSats = (val, decimals = 8) => {
      if (!val.includes(".")) {
        if (BigInt(val) > 100000000n) return BigInt(val);
        return BigInt(val) * BigInt(10 ** decimals);
      }
      const [intPart, fragPart] = val.split(".");
      const paddedFrag = fragPart.padEnd(decimals, "0").slice(0, decimals);
      return BigInt(intPart) * BigInt(10 ** decimals) + BigInt(paddedFrag);
    };
    const total = toSats(l1Balance.amount.value) + toSats(l2Balance.amount.value) + toSats(sidechainBalance.amount.value);
    return {
      l1: l1Balance,
      l2: l2Balance,
      sidechain: sidechainBalance,
      total
    };
  }
};

// src/adapters/mock-blockchain-client.ts
init_buffer_polyfill();
var MockBlockchainClient = class {
  async getBalance(address, asset) {
    return {
      asset,
      amount: { asset, value: "1.23" }
    };
  }
  async getTransaction(transactionID) {
    const mockAsset = { symbol: "BTC", name: "Bitcoin", decimals: 8 };
    return {
      id: transactionID,
      from: "mock-from-address",
      to: "mock-to-address",
      asset: mockAsset,
      amount: { asset: mockAsset, value: "0.1" },
      fee: { asset: mockAsset, value: "0.0001" },
      timestamp: Date.now(),
      psbt: "cHNidP8BAg=="
      // Add the required psbt property
    };
  }
  async broadcastTransaction(_signedTransaction) {
    return "mock-transaction-id";
  }
  async getRawTransaction(_transactionID) {
    return "01000000000000000000";
  }
  async getFeeEstimates() {
    return {
      slow: 1,
      medium: 2,
      fast: 3
    };
  }
  async getUTXOs(_address) {
    return [
      {
        txid: "mock-txid-1",
        vout: 0,
        value: BigInt(1e5)
      },
      {
        txid: "mock-txid-2",
        vout: 1,
        value: BigInt(2e5)
      }
    ];
  }
  async getTransactionHistory(_address) {
    const mockAsset = { symbol: "BTC", name: "Bitcoin", decimals: 8 };
    return [
      {
        id: "mock-txid-1",
        from: "mock-from-address-1",
        to: "mock-to-address-1",
        asset: mockAsset,
        amount: { asset: mockAsset, value: "0.1" },
        fee: { asset: mockAsset, value: "0.0001" },
        timestamp: Date.now(),
        psbt: "cHNidP8BAg=="
      },
      {
        id: "mock-txid-2",
        from: "mock-from-address-2",
        to: "mock-to-address-2",
        asset: mockAsset,
        amount: { asset: mockAsset, value: "0.2" },
        fee: { asset: mockAsset, value: "0.0002" },
        timestamp: Date.now(),
        psbt: "cHNidP8BAg=="
      }
    ];
  }
};

// src/adapters/mock-lightning-client.ts
init_buffer_polyfill();
var MockLightningClient = class {
  constructor() {
    this.invoices = /* @__PURE__ */ new Map();
  }
  async createInvoice(account, amount, description) {
    const paymentHash = Math.random().toString(16).substring(2);
    const invoice = {
      id: `ln-inv-${paymentHash}`,
      paymentHash,
      serialized: `lnbc${amount.value}n1...mock...`,
      amount,
      description,
      expiry: 3600,
      timestamp: Date.now()
    };
    this.invoices.set(paymentHash, invoice);
    return invoice;
  }
  async payInvoice(account, invoice) {
    return `ln-pay-${Math.random().toString(16).substring(2)}`;
  }
  async getInvoiceStatus(paymentHash) {
    return "paid";
  }
  async getBalance(account) {
    return {
      asset: { symbol: "BTC", name: "Bitcoin", decimals: 8 },
      amount: {
        asset: { symbol: "BTC", name: "Bitcoin", decimals: 8 },
        value: "0.1"
      }
    };
  }
};

// src/adapters/liquid-client.ts
init_buffer_polyfill();
var liquid = __toESM(require_src6());
var LiquidBlockchainClient = class {
  constructor(network = liquid.networks.liquid) {
    this.network = network;
  }
  async issueAsset(account, name10, symbol4, amount) {
    const mockAssetId = "6f0279e9ed041c3d710a9f57d0c02928416460c4b722ae3457a11eec381c526d";
    return {
      name: name10,
      symbol: symbol4,
      decimals: 8,
      assetId: mockAssetId,
      isConfidential: true
    };
  }
  async transferAsset(account, destinationAddress, asset, amount) {
    const pset = new liquid.Pset();
    const txid = pset.getHash().toString("hex");
    return `liquid-tx-${txid}`;
  }
  async getBalance(account, asset) {
    return {
      asset,
      amount: { asset, value: "1250000" }
      // Mocked balance for the review
    };
  }
};

// src/core/domain.ts
init_buffer_polyfill();
initEccLib(ecc_exports);
var Account = class {
  constructor(id, name10, node, network = networks_exports.bitcoin, addressType = "P2WPKH" /* NativeSegWit */) {
    this.id = id;
    this.name = name10;
    this.node = node;
    this.network = network;
    this.addressType = addressType;
  }
  get address() {
    if (!this._address) {
      let result;
      switch (this.addressType) {
        case "P2PKH" /* Legacy */:
          result = payments_exports.p2pkh({
            pubkey: this.node.publicKey,
            network: this.network
          });
          break;
        case "P2WPKH" /* NativeSegWit */:
          result = payments_exports.p2wpkh({
            pubkey: this.node.publicKey,
            network: this.network
          });
          break;
        case "P2TR" /* Taproot */: {
          const internalPubkey = import_buffer.Buffer.from(this.node.publicKey.slice(1, 33));
          result = payments_exports.p2tr({
            internalPubkey,
            network: this.network
          });
          break;
        }
        default:
          throw new Error(`Unsupported address type: ${this.addressType}`);
      }
      if (!result || !result.address) {
        throw new Error(`Could not generate ${this.addressType} address`);
      }
      this._address = result.address;
    }
    return this._address;
  }
  get privateKey() {
    if (!this._privateKey) {
      if (!this.node.privateKey) {
        throw new Error("Could not derive private key");
      }
      this._privateKey = this.node.toWIF();
    }
    return this._privateKey;
  }
  get publicKey() {
    if (!this._publicKey) {
      this._publicKey = import_buffer.Buffer.from(this.node.publicKey).toString("hex");
    }
    return this._publicKey;
  }
  getSigner() {
    return this.node;
  }
};

// src/ui/app.ts
var secureStorage = new SecureStorageService();
var l1Client = new MockBlockchainClient();
var l2Client = new MockLightningClient();
var sidechainClient = new LiquidBlockchainClient();
var balanceService = new UnifiedBalanceService(
  l1Client,
  l2Client,
  sidechainClient
);
function setupMnemonicToggle(spanId, buttonId, mnemonic) {
  const span = document.getElementById(spanId);
  const button = document.getElementById(buttonId);
  if (span && button) {
    let visible = false;
    const mask = "\u2022\u2022\u2022\u2022 \u2022\u2022\u2022\u2022 \u2022\u2022\u2022\u2022 \u2022\u2022\u2022\u2022 \u2022\u2022\u2022\u2022 \u2022\u2022\u2022\u2022";
    span.innerText = mask;
    button.addEventListener("click", () => {
      visible = !visible;
      span.innerText = visible ? mnemonic : mask;
      button.innerText = visible ? "\u{1F648}" : "\u{1F441}\uFE0F";
      button.setAttribute(
        "aria-label",
        visible ? "Hide mnemonic" : "Show mnemonic"
      );
    });
  }
}
function setupCopyButton(buttonId, textToCopy) {
  const button = document.getElementById(buttonId);
  if (button) {
    const originalLabel = button.getAttribute("aria-label") || "";
    const originalText = button.innerText;
    let timeoutId = null;
    button.addEventListener("click", () => {
      if (timeoutId) clearTimeout(timeoutId);
      navigator.clipboard.writeText(textToCopy).then(() => {
        button.innerText = "\u2705";
        button.setAttribute("aria-label", "Copied!");
        timeoutId = setTimeout(() => {
          button.innerText = originalText;
          button.setAttribute("aria-label", originalLabel);
          timeoutId = null;
        }, 2e3);
      }).catch((err) => {
        console.error(`Failed to copy ${buttonId}: `, err);
        button.innerText = "\u274C";
        button.setAttribute("aria-label", "Failed to copy");
        timeoutId = setTimeout(() => {
          button.innerText = originalText;
          button.setAttribute("aria-label", originalLabel);
          timeoutId = null;
        }, 2e3);
      });
    });
  }
}
document.getElementById("pinInput")?.addEventListener("keypress", (e) => {
  if (e.key === "Enter") {
    e.target.blur();
    document.getElementById("createWallet")?.click();
  }
});
document.getElementById("cidInput")?.addEventListener("keypress", (e) => {
  const loadWalletButton2 = document.getElementById(
    "loadWallet"
  );
  if (e.key === "Enter" && loadWalletButton2 && !loadWalletButton2.disabled) {
    e.target.blur();
    loadWalletButton2.click();
  }
});
document.getElementById("createWallet")?.addEventListener("click", async () => {
  const walletInfo = document.getElementById("walletInfo");
  const pinInput = document.getElementById("pinInput");
  const pin = pinInput?.value || "1234";
  const addressTypeSelect = document.getElementById("addressType");
  const addressType = addressTypeSelect?.value || "P2WPKH";
  if (walletInfo && walletInfo.innerHTML.trim() !== "" && !confirm(
    "Are you sure you want to create a new wallet? This will replace the current one shown. Make sure you have backed up your mnemonic!"
  )) {
    return;
  }
  const createWalletButton = document.getElementById(
    "createWallet"
  );
  createWalletButton.disabled = true;
  createWalletButton.innerText = "Creating...";
  try {
    const { wallet, mnemonic } = await createWallet(secureStorage, pin);
    let path = "m/84'/0'/0'/0";
    if (addressType === "P2TR") path = "m/86'/0'/0'/0";
    if (addressType === "P2PKH") path = "m/44'/0'/0'/0";
    const address = await wallet.getAddress(0, pin, path, addressType);
    if (walletInfo) {
      walletInfo.innerHTML = `
        <div class="wallet-section">
          <h3>Security</h3>
          <p>
            <strong>Mnemonic:</strong>
            <span id="mnemonic-value"></span>
            <button id="toggleMnemonic" title="Show/Hide mnemonic" aria-label="Show mnemonic">\u{1F441}\uFE0F</button>
            <button id="copyMnemonic" title="Copy mnemonic to clipboard" aria-label="Copy mnemonic to clipboard">\u{1F4CB}</button>
          </p>
        </div>
        <div class="wallet-section">
          <h3>L1 - Bitcoin</h3>
          <p><strong>Address:</strong> ${address} <button id="copyAddress" title="Copy address to clipboard" aria-label="Copy address to clipboard">\u{1F4CB}</button></p>
        </div>
        <div id="unified-balance" class="wallet-section">
          <h3>Unified Balance</h3>
          <p>Loading balances across all layers...</p>
        </div>
        <p id="ipfs-status"><strong>IPFS CID:</strong> Uploading...</p>
      `;
    }
    const btcAsset = { symbol: "BTC", name: "Bitcoin", decimals: 8 };
    const tempAccount = new Account("temp", "Temp", null, void 0, addressType);
    Object.defineProperty(tempAccount, "address", { get: () => address });
    balanceService.getUnifiedBalance(tempAccount, btcAsset).then((balances) => {
      const balanceDiv = document.getElementById("unified-balance");
      if (balanceDiv) {
        balanceDiv.innerHTML = `
          <h3>Unified Balance</h3>
          <ul>
            <li><strong>Layer 1:</strong> ${balances.l1.amount.value} BTC</li>
            <li><strong>Lightning (L2):</strong> ${balances.l2.amount.value} BTC</li>
            <li><strong>Liquid (Sidechain):</strong> ${Number(balances.sidechain.amount.value) / 1e8} L-BTC</li>
          </ul>
          <p><strong>Total Wealth:</strong> ${Number(balances.total) / 1e8} BTC equivalent</p>
        `;
      }
    }).catch((err) => {
      console.error("Failed to fetch unified balance:", err);
    });
    setupMnemonicToggle("mnemonic-value", "toggleMnemonic", mnemonic);
    setupCopyButton("copyMnemonic", mnemonic);
    setupCopyButton("copyAddress", address);
    try {
      const walletData = {
        encryptedMnemonic: wallet.getEncryptedMnemonic(),
        address
      };
      const walletJson = JSON.stringify(walletData);
      const cid = await uploadToIPFS(walletJson);
      const cidStr = cid.toString();
      const ipfsStatus = document.getElementById("ipfs-status");
      if (ipfsStatus) {
        ipfsStatus.innerHTML = `
          <strong>IPFS CID:</strong> ${cidStr}
          <button id="copyCID" title="Copy CID to clipboard" aria-label="Copy CID to clipboard">\u{1F4CB}</button>
        `;
      }
      setupCopyButton("copyCID", cidStr);
    } catch (err) {
      console.error("IPFS upload failed:", err);
      const ipfsStatus = document.getElementById("ipfs-status");
      if (ipfsStatus) {
        ipfsStatus.innerHTML = `<strong>IPFS CID:</strong> Upload failed. (No local IPFS node found)`;
      }
    }
  } catch (err) {
    console.error("Wallet creation failed:", err);
  } finally {
    createWalletButton.disabled = false;
    createWalletButton.innerText = "Create New Wallet";
  }
});
var cidInput = document.getElementById("cidInput");
var loadWalletButton = document.getElementById(
  "loadWallet"
);
if (cidInput && loadWalletButton) {
  cidInput.addEventListener("input", () => {
    loadWalletButton.disabled = cidInput.value.trim() === "";
  });
}
document.getElementById("loadWallet")?.addEventListener("click", async () => {
  if (!loadWalletButton || !cidInput) return;
  loadWalletButton.disabled = true;
  loadWalletButton.innerText = "Loading...";
  cidInput.disabled = true;
  const cid = cidInput.value.trim();
  const pinInput = document.getElementById("pinInput");
  const pin = pinInput?.value || "1234";
  const walletInfo = document.getElementById("walletInfo");
  if (walletInfo) {
    walletInfo.innerHTML = "<p>Loading wallet from IPFS...</p>";
  }
  try {
    const walletJson = await downloadFromIPFS(cid);
    const loadedData = JSON.parse(walletJson.toString());
    const mnemonic = await secureStorage.decrypt(loadedData.encryptedMnemonic, pin);
    if (walletInfo) {
      walletInfo.innerHTML = `
        <p>
          <strong>Mnemonic (Decrypted):</strong>
          <span id="loaded-mnemonic-value"></span>
          <button id="toggleLoadedMnemonic" title="Show/Hide mnemonic" aria-label="Show mnemonic">\u{1F441}\uFE0F</button>
          <button id="copyLoadedMnemonic" title="Copy mnemonic to clipboard" aria-label="Copy mnemonic to clipboard">\u{1F4CB}</button>
        </p>
        <p><strong>Original Address:</strong> ${loadedData.address}</p>
      `;
      setupMnemonicToggle("loaded-mnemonic-value", "toggleLoadedMnemonic", mnemonic);
      setupCopyButton("copyLoadedMnemonic", mnemonic);
    }
  } catch (err) {
    console.error("Failed to load wallet:", err);
    if (walletInfo) {
      walletInfo.innerHTML = `<p>Failed to load or decrypt wallet. Please check CID and PIN.</p>`;
    }
  } finally {
    loadWalletButton.disabled = false;
    loadWalletButton.innerText = "Load Wallet from IPFS";
    cidInput.disabled = false;
  }
});
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@noble/hashes/utils.js:
@noble/hashes/esm/utils.js:
@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/weierstrass.js:
@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
